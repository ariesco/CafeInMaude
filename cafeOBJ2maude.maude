load predefined_core.maude

fmod GOAL is
 pr META-LEVEL .

 sort Goal .
 *** Id
 *** Sentence
 *** Is it the current one?
 *** Is it proven?
 op [_,_,_,_,_] : NatList Qid EquationSet Bool Bool -> Goal [ctor] .

 op noGoal : -> Goal [ctor] .
 op _+_ : Goal Goal -> Goal [ctor assoc id: noGoal] .

 sort ProofTree ProofTreeList .
 subsort ProofTree < ProofTreeList .

 op mtPT : -> ProofTree [ctor] .
 op __ : ProofTreeList ProofTreeList -> ProofTreeList [ctor assoc id: mtPT] .

 op |_,_,_,_| : Module Goal ProofTreeList Nat -> ProofTree [ctor] .

 var  M : Module .
 var  G : Goal .
 var  P : ProofTree .
 vars PrL PrL' : ProofTreeList .
 vars N N' : Nat .
 vars NL NL' : NatList .
 var  Q : Qid .
 var  EqS : EquationSet .
 vars CURR PRV : Bool .
 vars SR SR' : SearchRes .
 var  PO : ProofOrder .

 op getEq : Goal -> EquationSet .
 eq getEq([NL, Q, EqS, CURR, PRV]) = EqS .

 op getId : Goal -> NatList .
 eq getId([NL, Q, EqS, CURR, PRV]) = NL .

 op isProven : Goal -> Bool .
 eq isProven([NL, Q, EqS, CURR, PRV]) = PRV .

 op size : ProofTree -> Nat .
 eq size(mtPT) = 0 .
 eq size(| M, G, PrL, N |) = N .

 op size* : ProofTreeList -> Nat .
 eq size*(mtPT) = 0 .
 eq size*(| M, G, PrL, N | PrL') = N + size*(PrL') .

 sort SearchRes .
 subsort NatList < SearchRes .

 op allProven : -> SearchRes [ctor] .

 op minSR : SearchRes SearchRes -> SearchRes [comm assoc] .
 eq minSR(allProven, SR) = SR .
 eq minSR(N NL, N' NL') = if N < N'
                          then N NL
                          else N' NL'
                          fi .
 eq minSR(NL, nil) = NL .

 sort ProofOrder .
 subsort NatList < ProofOrder .
 op finished : -> ProofOrder [ctor] .
 op _y_ : ProofOrder ProofOrder -> ProofOrder [ctor assoc id: finished] .

 op pop : ProofOrder -> ProofOrder .
 eq pop(finished) = finished .
 eq pop(NL y PO) = PO .

 op fst : ProofOrder ~> NatList .
 eq fst(NL y PO) = NL .

 op getGoal : ProofTree NatList ~> Equation .
 eq getGoal(| M, G, PrL, N |, nil) = getEq(G) .
 ceq getGoal(| M, G, PrL, N |, s(N') NL) = getGoal(P, NL)
  if P := getNth(PrL, N') .

 op getNth : ProofTreeList Nat ~> ProofTree .
 ceq getNth(P PrL, 0) = P
  if P =/= mtPT .
 ceq getNth(P PrL, s(N)) = getNth(PrL, N)
  if P =/= mtPT .

 op getMod : ProofTree NatList ~> Module .
 eq getMod(| M, G, PrL, N |, nil) = M .
 ceq getMod(| M, G, PrL, N |, s(N') NL) = getMod(P, NL)
  if P := getNth(PrL, N') .
endfm

fmod MACROS is
 pr META-LEVEL .

 sorts Macro Macros MacroLabel .
 subsort Macro < Macros .

 ops cvss cvvs cvsv cevss cevs cesv cesvs : -> MacroLabel [ctor] .

 op #_,_-_# : Module Qid Equation -> Macro [ctor] .
 op #_,_-_# : Module Qid Term -> Macro [ctor] .
 op #_,_-_._# : Module Qid Term MacroLabel -> Macro [ctor] .

 op mtMacros : -> Macros [ctor] .
 op __ : Macros Macros -> Macros [ctor assoc comm id: mtMacros] .
endfm

fmod SCORE-INFO-MAP is
 pr META-LEVEL .

 sorts ScoreInfo ScoreInfoSet .
 subsort ScoreInfo < ScoreInfoSet .

 *** Flat module
 *** Top module
 *** Reduced terms
 op $_,_,_$ : Module Module TermList -> ScoreInfo [ctor] .

 op noScoreInfo : -> ScoreInfoSet [ctor] .
 op __ : ScoreInfoSet ScoreInfoSet -> ScoreInfoSet [ctor assoc comm id: noScoreInfo] .

 sort ScoreInfoMap .

 op mtSIM : -> ScoreInfoMap [ctor] .
 op _:_ : Qid ScoreInfoSet -> ScoreInfoMap [ctor] .
 op __ : ScoreInfoMap ScoreInfoMap -> ScoreInfoMap [ctor assoc comm id: mtSIM] .

 var  SIM : ScoreInfoMap .
 var  Q : Qid .
 var  SI : ScoreInfo .
 var  SIS : ScoreInfoSet .
 vars M M' : Module .
 var  TL : TermList .

 op addSIM : ScoreInfoMap Qid ScoreInfo -> ScoreInfoMap .
 eq addSIM((Q : SIS) SIM, Q, SI) = (Q : SIS SI) SIM .
 eq addSIM(SIM, Q, SI) = (Q : SI) SIM .

 op completeTermList : ScoreInfoSet -> TermList .
 eq completeTermList(noScoreInfo) = empty .
 eq completeTermList($ M, M', TL $ SIS) = TL, completeTermList(SIS) .

 op _[_] : ScoreInfoMap Qid -> ScoreInfoSet .
 eq ((Q : SIS) SIM)[Q] = SIS .
 eq SIM[Q] = noScoreInfo [owise] .

 op allReductions : ScoreInfoSet -> TermList .
 eq allReductions(noScoreInfo) = empty .
 eq allReductions($ M, M', TL $ SIS) = TL, allReductions(SIS) .
endfm

***(%

We present in this section the main modules required for dealing with CafeOBJ
specifications~\cite{cafe-report}. First, we will see how to define the syntax,
and how to parse the terms to obtain the Maude modules~\cite{maude-book}. Then,
we will show how to pretty print these terms and how to create new commands and
rules and will be added in addition to the ones already defined in Full Maude.

{\codesize
\begin{comment}
%)

******************************************************
***predefined modules
******************************************************
***for HS

fmod COMPONENTS is
  sorts AComp OComp State .
  subsort AComp OComp < State .

  op empty-state : -> State .
  op __ : State State -> State [assoc comm id: empty-state format(o nt o)] .
endfm

*****************************************************
***for translation
*****************************************************

***(%
\end{comment}
}

\subsection{Syntax\label{subsec:syntax}}

The module \verb"CafeBUBBLES" defines the sorts \verb"@CafeBubble@" for bubbles (that is,
terms that can take any form, like the lefthand side of an equation), \verb"@CafeBubble@"
for tokens (like sorts), and \verb"@NeCafeTokenList@" for nonempty lists of tokens:

{\codesize
\begin{verbatim}
%)

fmod CafeBUBBLES is
  including QID-LIST .

  sorts @CafeBubble@ @CafeToken@ @NeCafeTokenList@ .

  op CafeBubble : QidList -> @CafeBubble@ [special (id-hook Bubble (1 -1 ( ))
                            op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                            op-hook qidSymbol (<Qids> : ~> Qid))] .

  op CafeToken : Qid -> @CafeToken@ [special (id-hook Bubble (1 1)
                            op-hook qidSymbol (<Qids> : ~> Qid)
                            id-hook Exclude(. [] < { } ( )))] .

  op neCafeTokenList : QidList -> @NeCafeTokenList@ [special (id-hook Bubble (1 -1)
                            op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                            op-hook qidSymbol (<Qids> : ~> Qid)
                            id-hook Exclude(. { } ))] .
endfm

***(%
\end{verbatim}
}

The module \verb"Cafe-ATTRIBUTES" defines the possible attributes that can be used
in operators and equations:

{\codesize
\begin{verbatim}
%)

fmod Cafe-ATTRIBUTES is
  pr CafeBUBBLES .

***(%
\end{verbatim}
}

It defines the sorts \verb"@CafeAttr@" for a single attribute and
\verb"@CafeAttrList@" for lists of attributes:

{\codesize
\begin{verbatim}
%)

  sorts @CafeAttr@ @CafeAttrList@ .
  subsorts @CafeAttr@ < @CafeAttrList@ .

***(%
\end{verbatim}
}

The attributes are defined following the CafeOBJ syntax. The unary attributes
are all defined in the same way, the identity attributes require take a bubble as
argument, while the precedence attribute takes a token:

{\codesize
\begin{verbatim}
%)

  op __ : @CafeAttrList@ @CafeAttrList@ -> @CafeAttrList@ [ctor assoc] .
  ops assoc associative l-assoc r-assoc comm commutative constr nonexec :nonexec
      idem idempotent owise : -> @CafeAttr@ [ctor] .
***  TODO: Remove if not required
***  op id:`(_`) : @CafeBubble@ -> @CafeAttr@ [ctor] .
  op id:_ : @CafeBubble@ -> @CafeAttr@ [ctor] .
***  TODO: Remove if not required
***  op idr:`(_`) : @CafeBubble@ -> @CafeAttr@ [ctor] .
  op idr:_ : @CafeBubble@ -> @CafeAttr@ [ctor] .
  op prec:_ : @CafeToken@ -> @CafeAttr@ [ctor] .

***(%
\end{verbatim}
}

Although the \verb"metadata" attribute is not currently available for CafeOBJ
specifications, it might be useful, so we support it by defining the appropriate
operator. However, it can also be defined in a comment, as explained
in~\cite{cafeOBJ2maudeUG}:

{\codesize
\begin{verbatim}
%)

  op metadata_ : @CafeToken@ -> @CafeAttr@ [ctor] .
endfm

***(%
\end{verbatim}
}

The syntax must also include the commands that we want to use for CafeOBJ specifications.
These commands are defined in the \verb"TRANSLATION-COMMANDS" module, which imports the
\verb"COMMANDS" module from Full Maude. To add new commands the user must define them
here and then specify their behavior in the module \texttt{CAFE2MAUDE-DATABASE-HANDLING}
described in Section~\ref{subsec:cafe:commands}:

{\codesize
\begin{verbatim}
%)

fmod TRANSLATION-COMMANDS is
  inc COMMANDS .

***(%
\end{verbatim}
}

We have defined three commands:
\begin{itemize}
\item
The first one will force the translation to be done without using the modifications
presented in~\cite{cafeOBJ2maudeUG}, that drop some requirements from the importations
modes and on the usage of theories to allow a wider range of CafeOBJ specifications to
be translated:

{\codesize
\begin{verbatim}
%)

  op strict`translation`on`. : -> @Command@ .

***(%
\end{verbatim}
}

\item
Analogously, the second one will allow these modifications:

{\codesize
\begin{verbatim}
%)

  op strict`translation`off`. : -> @Command@ .

***(%
\end{verbatim}
}

\item
The third one will require a CafeOBJ module to be shown:

{\codesize
\begin{verbatim}
%)

  op original`CafeOBJ`module_. : @Token@ -> @Command@ .
endfm

***(%
\end{verbatim}
}

\end{itemize}

The module \verb"CafeMETA-SIGN" defines the syntax for CafeOBJ modules:

{\codesize
\begin{verbatim}
%)

fmod CafeMETA-SIGN is
  including FULL-MAUDE-SIGN .
  including Cafe-ATTRIBUTES .

***(%
\end{verbatim}
}

It first defines all the required sorts, and the subsort relations between them:

{\codesize
\begin{verbatim}
%)

  sorts @CafeMODULE@ @OpenCloseEnv@ @HiddenSortDecl@ @VisibleSortDecl@ @CafeOpDecl@
        @CafeImportDecl@ @CafeType@ @CafeTypeList@ @CafeSortList@ @CafeSort@
        @BehaviorEquationDecl@ @CafeDeclList@ @CafeEqDecl@ @CafeVarDecl@
        @CafeSubSortRel@ @CafeLDeclList@ @OpenCloseDeclList@ @CafeModExp@ @CafeParameter@
        @CafeParameters@ @CafeInterface@ @CafeViewDecl@ @CafeViewDeclList@ @CafeTransDecl@
        @CafeViewId@ @CafeViewIdList@ @ExecutionDecl@ @ReqProvDecl@
        @CafeInductiveComm@ .

  subsort @CafeToken@ < @CafeSort@ < @CafeType@ .

***(%
  ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  subsort @CafeSort@ < @CafeSortList@ .
  subsort @CafeType@ < @CafeTypeList@ .
  subsorts @CafeImportDecl@ @CafeVarDecl@ @CafeEqDecl@ @VisibleSortDecl@ @CafeOpDecl@
           @CafeTransDecl@ @ExecutionDecl@ @CafeInductiveComm@
           < @CafeLDeclList@ < @OpenCloseDeclList@  .
  subsorts @HiddenSortDecl@ @BehaviorEquationDecl@ @CafeLDeclList@
           < @CafeDeclList@ .
  subsort @ModExp@ < @CafeModExp@ . *** !!!!
  subsort @ModExp@ < @CafeViewId@ .
  subsort @CafeViewId@ < @CafeViewIdList@ .
  *** !!!! subsort @CafeToken@ < @CafeModExp@ .
  subsort @CafeParameter@ < @CafeParameters@ .
  subsort @CafeToken@  < @CafeInterface@ .
  subsort @CafeViewDecl@ < @CafeViewDeclList@ .

  subsort @CafeMODULE@ @OpenCloseEnv@ @ReqProvDecl@ < @Input@ .

  op __ : @CafeDeclList@ @CafeDeclList@ -> @CafeDeclList@ [assoc prec 10] .
  op __ : @CafeLDeclList@ @CafeLDeclList@ -> @CafeLDeclList@ [assoc prec 10] .
  op __ : @CafeTypeList@ @CafeTypeList@ -> @CafeTypeList@ [assoc prec 10] .
  op _,_ : @CafeParameters@ @CafeParameters@ -> @CafeParameters@ [assoc prec 45] .
  op none : -> @CafeViewDeclList@ [ctor] .
  op __ : @CafeViewDeclList@ @CafeViewDeclList@ -> @CafeViewDeclList@ [assoc id: none] .

  op _::_ : @CafeToken@ @CafeModExp@ -> @CafeParameter@ [prec 5 gather (e &)] .

  op _`(_`) : @CafeToken@ @CafeParameters@ -> @CafeInterface@ .
  op _`[_`] : @CafeToken@ @CafeToken@ -> @CafeInterface@ .
  op _`{_|_`} : @CafeToken@ @CafeParameters@ @CafeToken@ -> @CafeInterface@ .

***(%
\end{comment}
}

Then it defines the syntax of every possible construction in CafeOBJ. For example,
we can define the syntax for:
\begin{itemize}
\item
Hidden sorts, which receive a token and create a \verb"@HiddenSortDecl@":

{\codesize
\begin{verbatim}
%)

  op *`[_`]* : @CafeToken@ -> @HiddenSortDecl@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  *** cafe module expressions !!!!
  *** op _+_ : @CafeModExp@ @CafeModExp@ -> @CafeModExp@ [ctor assoc prec 42] .
  op _`(_`) : @CafeModExp@ @CafeViewId@ -> @CafeModExp@ [ctor prec 40] .
  op _*`{_`} : @CafeModExp@ @CafeViewDeclList@ -> @CafeModExp@ [ctor prec 43] .

***(%
\end{comment}
}

\item
View identifiers, which can be either:
\begin{itemize}
\item
On the fly view declarations, receiving a module expression and a declaration
list:

{\codesize
\begin{verbatim}
%)

  op view`to_`{_`} : @CafeModExp@ @CafeViewDeclList@ -> @CafeViewId@ [ctor] .

***(%
\end{verbatim}
}

\item
The abbreviated version of the previous declaration, which does not require the
\verb"view to" keywords:

{\codesize
\begin{verbatim}
%)

  op _`{_`} : @CafeModExp@ @CafeViewDeclList@
              -> @CafeViewId@ [ctor prec 15] .

***(%
\end{verbatim}
}

\item
A view identifier assigned to a specific module expression:

{\codesize
\begin{verbatim}
%)

  op _<=_ : @CafeModExp@ @CafeViewId@
            -> @CafeViewId@ [ctor prec 20] .

***(%
\end{verbatim}
}

\item
Finally, lists of view identifiers are created by using the operator \verb"_,_".
Note that this operator is the one with the lower precedence, since it must not
interfer with the previous declarations:

{\codesize
\begin{verbatim}
%)

  op _,_ : @CafeViewIdList@ @CafeViewIdList@
           -> @CafeViewIdList@ [ctor assoc prec 25] .

***(%
\end{verbatim}
}

\end{itemize}

\item
Importations, including all the possible variants:

{\codesize
\begin{verbatim}
%)

  op protecting`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op pr`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op extending`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op ex`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op including`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op inc`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op using`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op us`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .

***(%
\end{verbatim}
}

\item
Sort and subsort declarations:

{\codesize
\begin{verbatim}
%)

  op `[_`] : @CafeSortList@ -> @VisibleSortDecl@ [ctor prec 5] .
  op `[_`] : @CafeSubSortRel@ -> @VisibleSortDecl@ [ctor prec 5] .

***(%
\end{verbatim}
}

\item
Subsort relations:

{\codesize
\begin{verbatim}
%)

  op _<_ : @CafeSortList@ @CafeSortList@ -> @CafeSubSortRel@ [ctor] .
  op _<_ : @CafeSortList@ @CafeSubSortRel@ -> @CafeSubSortRel@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  op var_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeVarDecl@ [ctor] .
  op vars_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeVarDecl@ [ctor] .

***(%
\end{comment}
}

\item
Equations. Note that the label or the possible attributes are not included
into the operator definition. Instead, we will deal with the bubble defining
the lefthand side to check whether there is a label. Similarly, we will
analyze the last bubble looking for attributes, such as \verb"nonexec":

{\codesize
\begin{verbatim}
%)

  op eq_=_. : @CafeBubble@ @CafeBubble@ -> @CafeEqDecl@ [ctor] .
  op ceq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ -> @CafeEqDecl@ [ctor] .
  op cq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ -> @CafeEqDecl@ [ctor] .

***(%
\end{verbatim}
}

\item
Transitions. Analogously to the case above, we do not declare explicitly the label
or the attributes of the transitions:

{\codesize
\begin{verbatim}
%)

  op trans_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op trns_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op ctrans_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                      -> @CafeTransDecl@ [ctor] .
  op ctrns_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                     -> @CafeTransDecl@ [ctor] .
  op btrans_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op btrns_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op bctrans_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                       -> @CafeTransDecl@ [ctor] .
  op bctrns_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                      -> @CafeTransDecl@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  *** Operator definitions
  op op_:`->_`{_`}. : @CafeToken@ @CafeType@ @CafeAttrList@ -> @CafeOpDecl@ [ctor] .
  op op_:_->_`{_`}. : @CafeToken@ @CafeTypeList@ @CafeSort@ @CafeAttrList@
                      -> @CafeOpDecl@ [ctor] .
  op op_:`->_. : @CafeToken@ @CafeType@ -> @CafeOpDecl@ [ctor] .
  op op_:_->_. : @CafeToken@ @CafeTypeList@ @CafeType@ -> @CafeOpDecl@ [ctor] .
  op ops_:`->_`{_`}. : @NeCafeTokenList@ @CafeType@ @CafeAttrList@ -> @CafeOpDecl@ [ctor] .
  op ops_:_->_`{_`}. : @NeCafeTokenList@ @CafeTypeList@ @CafeType@ @CafeAttrList@
                       -> @CafeOpDecl@ [ctor] .
  op ops_:`->_. : @NeCafeTokenList@ @CafeType@ -> @CafeOpDecl@ [ctor] .
  op ops_:_->_. : @NeCafeTokenList@ @CafeTypeList@ @CafeType@  -> @CafeOpDecl@ [ctor] .

***(%
\end{comment}
}

\item
Predicates. In this case the sorts for the definition are more specific than in the
cases above (where we just used bubbles), so we distinguish whether attributes are
declared or not:

{\codesize
\begin{verbatim}
%)

  op pred_:_`{_`}. : @CafeToken@ @CafeTypeList@ @CafeAttrList@
                     -> @CafeOpDecl@ [ctor] .
  op pred_:_. : @CafeToken@ @CafeTypeList@ -> @CafeOpDecl@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ***observer declaration
  op bop_:_->_. : @CafeToken@ @CafeTypeList@ @CafeSort@  -> @CafeOpDecl@ [ctor] .
  op bops_:_->_. : @NeCafeTokenList@ @CafeTypeList@ @CafeSort@ -> @CafeOpDecl@ [ctor] .
  op bop_:_->_`{_`}. : @CafeToken@ @CafeTypeList@ @CafeSort@ @CafeAttrList@
                       -> @CafeOpDecl@ [ctor] .
  op bops_:_->_`{_`}. : @NeCafeTokenList@ @CafeTypeList@ @CafeType@ @CafeAttrList@
                        -> @CafeOpDecl@ [ctor] .
  op beq_=_. : @CafeBubble@ @CafeBubble@ -> @CafeEqDecl@ [ctor] .
  op bceq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ ->
                   @BehaviorEquationDecl@ [ctor] .
  op bcq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ ->
                  @BehaviorEquationDecl@ [ctor] .

  *** View declarations
  op vvar_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeViewDecl@ [ctor] .
  op vvars_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeViewDecl@ [ctor] .
  op sort_->_. : @CafeToken@ @CafeToken@ -> @CafeViewDecl@ [ctor] .
  op hsort_->_. : @CafeToken@ @CafeToken@ -> @CafeViewDecl@ [ctor] .
  op op_->_. : @CafeBubble@ @CafeBubble@ -> @CafeViewDecl@ [ctor] .
  op bop_->_. : @CafeBubble@ @CafeBubble@ -> @CafeViewDecl@ [ctor] .

  *** Reduction declarations
  op reduce_. : @CafeBubble@ -> @ExecutionDecl@ [ctor] .
  op red_. : @CafeBubble@ -> @ExecutionDecl@ [ctor] .
  op exec_. : @CafeBubble@ -> @ExecutionDecl@ [ctor] .

  *** Requires and provides
  op require_ : @NeCafeTokenList@ -> @ReqProvDecl@ [ctor] .
  op provide_ : @NeCafeTokenList@ -> @ReqProvDecl@ [ctor] .

  *** Commands for induction
  op :goal{_} : @CafeLDeclList@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:ctf{_} : @CafeToken@ @CafeEqDecl@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:ctf[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:cvss[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:cvvs[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:cvsv[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:cevss[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:cevs[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:cesv[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:cesvs[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .

  ***(
  :cs-vss: case splitting value (eq1) and seq seq (eq2)
  :cs-vvs: case splitting value (eq1) and value seq (eq2)
  :cs-vsv: case splitting value (eq1) and seq value (eq2)
  :cs-evss: case splitting empty (eq1), value (eq2), and seq seq (eq3).
  :cs-evs: case splitting empty (eq1) and value seq (eq2).
  :cs-esv: case splitting empty (eq1) and seq value (eq2).
  :cs-esvs: case splitting empty (eq1) and seq value seq (eq2).
  )

  op :ind`on(_) : @CafeToken@ -> @CafeInductiveComm@ [ctor] .
  op :apply(_) : @NeCafeTokenList@ -> @CafeInductiveComm@ [ctor] .
  op :imp[_]. : @CafeToken@ -> @CafeInductiveComm@ [ctor] .
  op :imp[_]by{_} : @CafeToken@ @NeCafeTokenList@ -> @CafeInductiveComm@ [ctor] .
  op :sel(_) : @CafeToken@ -> @CafeInductiveComm@ [ctor] .
  op :postpone`. : -> @CafeInductiveComm@ [ctor] .
  op :show`proof : -> @CafeInductiveComm@ [ctor] .
  op :desc`proof : -> @CafeInductiveComm@ [ctor] .
  op :desc`. : -> @CafeInductiveComm@ [ctor] .

  op :id(_) : @CafeToken@ -> @CafeInductiveComm@ [ctor] .
  op :proof(_) : @CafeToken@ -> @CafeInductiveComm@ [ctor] .

***(%
\end{comment}
}

\item
Module and view declarations. Note that they do not have the exact syntax used
by CafeOBJ. This distinction is obtained after a pre-processing stage that makes sure
that there is no clash with the Maude syntax for modules and views:

{\codesize
\begin{verbatim}
%)

  op cmod*_`{_`} : @CafeInterface@ @CafeDeclList@ -> @CafeMODULE@ [ctor] .
  op cmod!_`{_`} : @CafeInterface@ @CafeLDeclList@ -> @CafeMODULE@ [ctor] .
  op cview_from_to_`{_`} : @CafeToken@ @CafeModExp@ @CafeModExp@
                           @CafeViewDeclList@ -> @CafeMODULE@ [ctor] .
  op cview_from_to_`{`} : @CafeToken@ @CafeModExp@ @CafeModExp@ -> @CafeMODULE@ [ctor] .

***(%
\end{verbatim}
}

\item
Open-close environment. This block is composed by a module expression and a list of
declarations, possibly including reduction commands. Note that we have introduced an
extra dot to ease the parsing; this dot will be added during the preprocessing stage,
so the user is not required to type it:

{\codesize
\begin{verbatim}
%)

  op copen_._close : @CafeModExp@ @OpenCloseDeclList@ -> @OpenCloseEnv@ [ctor] .
endfm

***(%
\end{verbatim}
}

\end{itemize}

The module \verb"META-CAFE2MAUDE-SIGNATURE" contains the metapresented signature
required by CafeOBJ, which extends the one for Full Maude:

{\codesize
\begin{verbatim}
%)

fmod META-CAFE2MAUDE-SIGNATURE is
 including META-FULL-MAUDE-SIGN .

 op CafeGRAMMAR : -> FModule .
 eq CafeGRAMMAR = addImports((including 'CafeMETA-SIGN .)
                             (including 'TRANSLATION-COMMANDS .), GRAMMAR ) .
endfm

***(%
\end{verbatim}
}

The modules \verb"CafeSIGN" and \verb"OPERATOR-Cafe", just describe auxiliary functions
for dealing with CafeOBJ modules, like functions for adding new sorts, equations, or
transitions, or for obtaining these values.

{\codesize
\begin{comment}
%)

fmod CafeSIGN is
  including EXT-SORT .

  sorts HiddenSortDecl CafeDecl CafeDeclSet BehaviorEquation CafeEquation CafeEquationSet
        CafeOpDecl CafeOpDeclSet CafeModExp .

  subsort BehaviorEquation CafeEquation < CafeEquationSet .
  subsort CafeOpDecl < CafeOpDeclSet .
  subsort CafeDecl < CafeDeclSet .
  sort CafeModule .

  op *`[_`]* : SortSet -> HiddenSortDecl .
  op (bop_:_->_) : Qid TypeList Type -> CafeDecl [ctor format(g o g o g o o )] .
  op (bops_:_->_) : QidList TypeList Type -> CafeDecl [ctor format(g o g o g o o )] .
  op none : -> CafeDeclSet [ctor] .
  op __ : CafeDeclSet CafeDeclSet -> CafeDeclSet [ctor assoc comm id: none format(d ni d)] .
  op none : -> CafeEquationSet [ctor] .
  op __ : CafeEquationSet CafeEquationSet -> CafeEquationSet [ctor assoc comm id: none format(d ni d)] .
  op none : -> CafeOpDeclSet [ctor] .
  op __ : CafeOpDeclSet CafeOpDeclSet -> CafeOpDeclSet [ctor assoc comm id: none format(d ni d)] .

  op op_:_->_ : Qid TypeList Type -> CafeOpDecl [ctor format(g o g o g o o )] .
  op eq_=_. : Term Term -> CafeEquation [ctor format(g o g o g o )] .
  op ceq_=_if_. : Term Term EqCondition -> CafeEquation [ctor format(g o g o g o o o )] .
  op bceq_=_if_. : Term Term EqCondition -> BehaviorEquation [ctor format(g o g o g o o o)] .
  op pr`(_`) : ModuleExpression -> Import [ctor] .
  op ex`(_`) : ModuleExpression -> Import [ctor] .
  op inc`(_`) : ModuleExpression -> Import [ctor] .
  op us`(_`) : ModuleExpression -> Import [ctor] .
  op none : -> HiddenSortDecl [ctor] .
  op cmod*_`{_____`} : Header ImportList HiddenSortDecl CafeOpDeclSet CafeDeclSet
                       CafeEquationSet -> CafeModule
                       [ctor gather(& & & & & &) format(d d s n++i ni d d ni n--i d)] .
  op emptyCafeModule : -> CafeModule .
endfm

fmod OPERATOR-Cafe is
  including CafeSIGN .
  including UNIT .

  sorts Bop2op Bop2opList DoubleResultPair TypeConstants TypeConstantsList
        Combine4TupleResult RuleConditionPair MetaTermTriple MetaTermTripleSet .
  subsorts Bop2op < Bop2opList .
  subsorts TypeConstants < TypeConstantsList .
  subsorts MetaTermTriple < MetaTermTripleSet .

  op `[_;_`] : CafeDecl OpDecl -> Bop2op [ctor format (o o r o o o)] .
  op nil : -> Bop2opList [ctor] .
  op __ : Bop2opList Bop2opList -> Bop2opList [assoc comm id: nil ctor prec 121 gather (e E)] .
  op <_;_> : Bop2opList SModule -> DoubleResultPair [ctor] .
  op getBOP2OP : [Bop2opList] [Qid] -> [Bop2op] .
  op getBOP : Bop2op -> Qid .
  op getOP : Bop2op -> Qid .
  op getObvdType : Bop2op -> Type .
  op getTransitions : CafeDeclSet -> CafeDeclSet .
  op getHiddenSortDecl : CafeModule -> HiddenSortDecl .
  op getCafeDeclSet : CafeModule -> CafeDeclSet .
  op getSort : HiddenSortDecl -> Sort .
  op getName : CafeModule -> Header .
  op getImports : CafeModule -> ImportList .
  op getSorts : CafeModule -> SortSet .
  op getEqs : CafeModule -> CafeEquationSet .
  op getPars : CafeModule -> ParameterDeclList .
  op getOps : CafeModule -> CafeOpDeclSet .
  op getInitialState : CafeModule -> Constant .
  op getConditionOps : CafeModule -> QidList .
  op getConditionOpsAux : CafeOpDeclSet Type -> QidList .
  op setHiddenSortDecl : CafeModule HiddenSortDecl -> CafeModule .
  op setCafeDeclSet : CafeModule CafeDeclSet -> CafeModule .
  op setName : CafeModule Header -> CafeModule .
  op setImports : CafeModule ImportList -> CafeModule .
  op setOps : CafeModule CafeOpDeclSet -> CafeModule .
  op setEqs : CafeModule CafeEquationSet -> CafeModule .
  op setPars : CafeModule ParameterDeclList -> CafeModule .
  op setSubsorts : CafeModule SubsortDeclSet -> CafeModule .
  op setSorts : CafeModule SortSet -> CafeModule .
  op addHiddenSortDecl : HiddenSortDecl CafeModule -> CafeModule .
  op addCafeDeclSet : CafeDeclSet CafeModule -> CafeModule .
  op addImports : ImportList CafeModule -> CafeModule .
  op addEqs : CafeEquationSet CafeModule -> CafeModule .
  op addSorts : SortSet CafeModule -> CafeModule .
  op addOps : CafeOpDeclSet CafeModule -> CafeModule .
  op empty : CafeModule -> CafeModule .

  vars H H' : Header .
  vars IL IL' : ImportList .
  vars HSD HSD' : HiddenSortDecl .
  vars CafeOPDS CafeOPDS' : CafeOpDeclSet .
  vars OPDS OPDS' : OpDeclSet .
  vars CafeDS CafeDS' : CafeDeclSet .
  vars EqS EqS' EqCS : EquationSet .
  vars CafeEqS CafeEqS' : CafeEquationSet .
  var SS : SortSet .
  vars S HS : Sort .
  var RIS? : [RuleSet] .
  vars U CafeM : CafeModule .
  vars U' U'' M : Module .
  var ME' : ModuleExpression .
  var PDL : ParameterDeclList .
  var MAS : MembAxSet .
  var SSDS : SubsortDeclSet .
  var FM : FModule .
  vars OPS QL CS CS' : QidList .
  vars TCL TCL' : TypeConstantsList .
  var GTL : GroundTermList .
  vars TL TL' TL'' : TermList .
  vars T T' T'' T3 OT BV SV OT' BV' SV' : Term .
  vars Attr AttrS AttrS' : AttrSet .
  vars V V' : Variable .
  vars EqC EqC' : EqCondition .
  var CON : Constant .
  var RlC : Condition .
  var Rl : Rule .
  var RlS : RuleSet .
  var RP : ResultPair .
  var Eq : Equation .
  vars MTTS MTTS' : MetaTermTripleSet .
  var BOP2OP : Bop2op .
  vars MTT MTT' : MetaTermTriple .
  vars Ty Ty' Ty'' : Type .
  vars TyL TyL' : TypeList .
  vars OP OP' OP'' C C'   : Qid .
  var BOPL : Bop2opList .

  op nil : -> TypeConstants .
  op __ : TypeConstantsList TypeConstantsList -> TypeConstantsList [assoc comm id: nil] .
  op `[_;_`] : Type QidList -> TypeConstants [ctor format (o o r o o o)] .
  op add2TypeConstants : Qid TypeConstants -> TypeConstants .
  op getConstants : Type TypeConstantsList -> QidList .
  op <_;_;_> : TermList TermList AttrSet -> Combine4TupleResult .
  op <_;_> : EqCondition RuleSet -> RuleConditionPair .
  op none : -> RuleConditionPair .
  op getVariables : Term -> TermList .
  op getVariables : TermList -> TermList .
  op getVariables : Equation -> TermList .
  op getVariables : EqCondition -> TermList .
  op combineVariables : TermList TermList -> TermList .
  op inVars : Variable TermList -> Bool .
  op substitute : Qid Variable Equation -> Equation .
  op substitute : Qid Variable Term -> Term .
  op substitute : Qid Variable TermList -> TermList .
  op substitute : Qid Variable EqCondition -> EqCondition .
  op getEquations : Constant EquationSet -> EquationSet .
  op getEquations : Term EquationSet -> EquationSet .
  op contains : Term Constant -> Bool .
  op contains : TermList Constant -> Bool .
  op removeConditionEqs : EquationSet EquationSet -> EquationSet .
  op removeConditionEqC : EquationSet EqCondition -> EqCondition .
  op replaceConditionParts : EquationSet FModule -> EquationSet .

  op getConditionEqs : QidList EquationSet -> EquationSet .
  op combineRules : RuleConditionPair -> Rule .
  op combineLRA : RuleSet -> Combine4TupleResult .
  op replaceTerm : Term Term Term -> Term .
  op replaceTermList : TermList Term Term -> TermList .
  op replaceCondition : EqCondition Term Term -> EqCondition .
  op buildVar : Type TermList -> Qid .
  op buildVarAux : TermList -> Qid .
  op <_`,_`,_`,_> : Term Qid Term Term -> MetaTermTriple [ctor] .
  op empty : -> MetaTermTripleSet [ctor] .
  op __ : MetaTermTripleSet MetaTermTripleSet -> MetaTermTripleSet [assoc comm id: empty] .
  op getCafeTerm : MetaTermTriple -> Term .
  op getObsOP : MetaTermTriple -> Qid .
  op getObsVal : MetaTermTriple -> Term .
  op getSuccVal : MetaTermTriple -> Term .
  op hasCafeTerm : MetaTermTripleSet Term -> Bool .
  op getMTT : MetaTermTripleSet Term -> MetaTermTriple .
  op setCafeTerm : MetaTermTriple Term -> MetaTermTriple .
  op setObsOP : MetaTermTriple Qid -> MetaTermTriple .
  op setObsVal : MetaTermTriple Term -> MetaTermTriple .
  op setSuccVal : MetaTermTriple Term -> MetaTermTriple .
  op term2string : TermList -> String .
  op getConstantsList : Module TypeList -> TypeConstantsList .
  op getConstantsListAux1 : OpDeclSet TypeList -> TypeConstantsList .
  op getConstantsListAux2 : OpDeclSet Type -> TypeConstants .
  op add2TypeList : TypeList TypeList -> TypeList .
  op getNewCafeTerm : Bop2opList TermList Type MetaTermTripleSet -> TermList .
  op getNewCafeTermAux : Bop2opList Term MetaTermTripleSet -> TermList .
  op initialObsSuccValue : Term MetaTermTripleSet -> Term .
  op initialObsSuccValueAux : TermList MetaTermTripleSet -> TermList .
  op buildLHS : MetaTermTripleSet -> Term .
  op buildLHSAux : MetaTermTripleSet -> TermList .
  op buildRHS : MetaTermTripleSet -> Term .
  op buildRHSAux : MetaTermTripleSet -> TermList .
  op buildObsSuccValue : MetaTermTripleSet -> MetaTermTripleSet .
  op buildObsSuccValueAux : MetaTermTripleSet MetaTermTripleSet -> MetaTermTripleSet .
  op isSetExp : Type -> Bool .
  op isOccurs : Type TypeList -> Bool .

  eq getBOP2OP (([(bop OP : TyL -> Ty ) ; (op OP' : TyL' -> Ty' [Attr] .)] BOPL), OP) =
      [(bop OP : TyL -> Ty ) ; (op OP' : TyL' -> Ty' [Attr] .)] .
  eq getBOP ([(bop OP : TyL -> Ty ) ; (op OP' : TyL' -> Ty' [Attr] .)]) = OP .
  eq getOP ([(bop OP : TyL -> Ty ) ; (op OP' : TyL' -> Ty' [Attr] .)]) = OP' .
  eq getObvdType ([(bop OP : TyL -> Ty ) ; (op OP' : TyL' -> Ty' [Attr] .)]) = Ty .
  eq getBOP2OP (BOPL, OP) = nil [owise] .

  eq getConditionOps (CafeM) =
      getConditionOpsAux (getOps (CafeM), getSort (getHiddenSortDecl (CafeM))) .
  eq getConditionOpsAux ((op OP : S TyL -> 'Bool ) CafeOPDS, S) = OP getConditionOpsAux (CafeOPDS, S) .
  eq getConditionOpsAux (CafeOPDS, S) = nil [owise] .

  eq emptyCafeModule = cmod* nullHeader {nil none none none none} .
  eq getInitialState (cmod* H {IL * [S] * CafeOPDS CafeDS CafeEqS}) = qid ("init." + string (S)) .
  eq getSort ((* [S] *)) = S .
  eq getHiddenSortDecl (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = HSD .
  eq getCafeDeclSet (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = CafeDS .
  eq getName (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = H .
  eq getImports (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = IL .
  eq getSorts (cmod* H {IL * [SS] * CafeOPDS CafeDS CafeEqS}) = SS .
  eq getSorts (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = none [owise] .
  eq getOps (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = CafeOPDS .
  eq getEqs (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = CafeEqS .
  eq getPars (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = nil .
  eq getTransitions ((bop OP : Ty TyL -> Ty ) CafeDS) = (bop OP : Ty TyL -> Ty ) getTransitions (CafeDS) .
  eq getTransitions (none) = none .
  ceq getTransitions ((bop OP : Ty TyL -> Ty' ) CafeDS) = getTransitions (CafeDS) if Ty =/= Ty' .

  eq setHiddenSortDecl (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, HSD') = cmod* H {IL HSD' CafeOPDS CafeDS CafeEqS} .
  eq setName (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, ME') = cmod* ME' {IL HSD CafeOPDS CafeDS CafeEqS} .
  eq setCafeDeclSet (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, CafeDS') = cmod* H {IL HSD CafeOPDS CafeDS' CafeEqS} .
  eq setImports (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, IL') = cmod* H {IL' HSD CafeOPDS CafeDS CafeEqS} .
  eq setSorts (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, SS) =
                cmod* H {IL * [SS] * CafeOPDS CafeDS CafeEqS} .
  eq setOps (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, CafeOPDS') = cmod* H {IL HSD CafeOPDS' CafeDS CafeEqS} .
  eq setEqs (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, CafeEqS') = cmod* H {IL HSD CafeOPDS CafeDS CafeEqS'} .
  eq setPars (CafeM, PDL) = CafeM .

  eq empty (CafeM) = emptyCafeModule .
  eq setSubsorts (CafeM, SSDS) = CafeM .

  eq addHiddenSortDecl (HSD, CafeM) = setHiddenSortDecl (CafeM, HSD) .
  eq addCafeDeclSet (CafeDS, CafeM) = setCafeDeclSet (CafeM, (CafeDS getCafeDeclSet (CafeM))) .
  eq addEqs (CafeEqS, CafeM) = setEqs (CafeM, CafeEqS getEqs (CafeM)) .
  eq addImports (IL, CafeM) = setImports (CafeM, IL getImports (CafeM)) .
  eq addOps (CafeOPDS, CafeM) = setOps (CafeM, CafeOPDS getOps (CafeM)) .
  eq addSorts (SS, CafeM) = setSorts (CafeM, SS ; getSorts (CafeM)) .
  eq add2TypeConstants (OP, [Ty ; OPS]) = [Ty ; OP OPS] .

  eq getConstants (Ty, [Ty ; OPS] TCL) = OPS .
  eq getConstants (Ty, TCL) = nil [owise] .

  eq replaceCondition ((T = T'), T'', T3) = (replaceTerm (T, T'', T3) = replaceTerm (T', T'', T3)) .
  eq replaceCondition ((T : Ty), T', T'') = (replaceTerm (T, T', T'') : Ty) .
  eq replaceCondition ((T := T'), T'', T3) = (replaceTerm (T, T'', T3) := replaceTerm (T', T'', T3)) .
  eq replaceCondition ((EqC /\ EqC'), T, T') = (replaceCondition (EqC, T, T') /\ replaceCondition (EqC', T, T')) .
  eq replaceCondition (nil, T, T') = nil .

  eq buildVar (Ty, TL) = if TL =/= empty then qid (string (Ty) + string (buildVarAux (TL))) else qid (string (Ty) + "@") fi .
  ceq buildVarAux ((T, TL)) = qid (string (getName (T)) + string (buildVarAux (TL))) if TL =/= empty .
  eq buildVarAux (T) = getName (T) .
  eq buildVarAux (empty) = nil .

  eq replaceTerm (T, T, T'') = T'' .
  ceq replaceTerm (T, T', T'') = OP [replaceTermList (TL, T', T'')] if OP [TL] := T .
  eq replaceTerm (T, T', T'') = T [owise] .
  eq replaceTermList ((T, TL), T', T'') = (replaceTerm (T, T', T''), replaceTermList (TL, T', T'')) .
  eq replaceTermList (empty, T, T') = empty .

  ceq combineRules (< EqC ; RlS >) = if TL'' :: NeTermList then (crl '__ [TL] => '__ [TL'] if EqC [AttrS] .) else (crl TL => TL' if EqC [AttrS] .) fi
    if < TL ; TL' ; AttrS > := combineLRA (RlS) /\ (T, TL'') := TL .
  eq combineRules (none) = none .
  ceq combineLRA ((rl T => T' [AttrS] .) RlS) = < (T, TL) ; (T', TL') ; (AttrS AttrS') > if < TL ; TL' ; AttrS' > := combineLRA (RlS) .
  eq combineLRA (none) = < empty ; empty ; none > .

  ceq getConditionEqs (OP QL, EqS) = getConditionEqs (OP, EqS) getConditionEqs (QL, EqS) if QL =/= (nil) .TypeList .
  eq getConditionEqs (OP, (eq OP [TL] = T' [AttrS] .) EqS) = (eq OP [TL] = T' [AttrS] .) getConditionEqs (OP, EqS) .
  eq getConditionEqs (OP, none) = none .
  eq getConditionEqs (OP, EqS) = none [owise] .
  eq getConditionEqs (nil, EqS) = none .

  eq removeConditionEqs (EqCS, (ceq T = T' if EqC [AttrS] .) EqS) =
      (ceq T = T' if removeConditionEqC (EqCS, EqC) [AttrS] .) removeConditionEqs (EqCS, EqS) .
  eq removeConditionEqs (EqCS, none) = none .
  eq removeConditionEqs (EqCS, EqS) = EqS [owise] .
  eq removeConditionEqC (((eq T = T'' [AttrS] .) EqCS), (T = T')) = (T'' = T') .
  eq removeConditionEqC (((eq T = T'' [AttrS] .) EqCS), (T := T')) = (T'' := T') .
  eq removeConditionEqC (((eq T = T'' [AttrS] .) EqCS), (T : S)) = (T'' : S) .
  eq removeConditionEqC (EqCS, (EqC /\ EqC')) = removeConditionEqC (EqCS, EqC) /\ removeConditionEqC (EqCS, EqC) .
  eq removeConditionEqC (EqCS, EqC) = EqC [owise] .

  ceq replaceConditionParts (((ceq T = T' if T'' = 'true.Bool [AttrS] .) EqS), FM) =
    ((ceq T = T' if getTerm (RP) = 'true.Bool [AttrS] .) replaceConditionParts (EqS, FM))
   if RP := metaReduce (FM, T'') /\ RP :: ResultPair .
  eq replaceConditionParts (none, FM) = none .
  eq replaceConditionParts (EqS, FM) = EqS [owise] .

  eq contains (OP [TL], CON) = contains (TL, CON) .
  eq contains (CON, CON) = true .
  eq contains (T, CON) = false [owise] .
  ceq contains ((T, TL), CON) = contains (T, CON) or contains (TL, CON) if TL =/= (empty) .EmptyCommaList .
  eq contains (empty, CON) = false .

  eq getEquations (CON, (eq T = T' [AttrS] .) EqS) =
      if contains (T, CON) then ((eq T = T' [AttrS] .) getEquations (CON, EqS)) else getEquations (CON, EqS) fi .
  eq getEquations (CON, EqS) = none [owise] .

  eq substitute (C, V, (eq T = T' [AttrS] .)) = (eq substitute (C, V, T) = substitute (C, V, T') [AttrS] .) .
  eq substitute (C, V, (ceq T = T' if EqC [AttrS] .)) = (ceq substitute (C, V, T) = substitute (C, V, T') if substitute (C, V, EqC) [AttrS] .) .
  eq substitute (C, V, OP [TL]) = if TL :: GroundTermList then OP [TL] else OP [substitute (C, V, TL)] fi .
  eq substitute (C, V, T) = if T == V then qid (string (C) + "." + string (getType (V))) else T fi .
  eq substitute (C, V, (T, TL)) = (substitute (C, V, T), substitute (C, V, TL)) .
  eq substitute (C, V, empty) = empty .
  ceq substitute (C, V, (EqC /\ EqC')) =
    (substitute (C, V, EqC) /\ substitute (C, V, EqC'))
   if EqC' =/= (nil) .EqCondition and EqC =/= (nil).EqCondition .
  eq substitute (C, V, (T := T')) = (substitute (C, V, T) := substitute (C, V, T')) .
  eq substitute (C, V, (T = T')) = (substitute (C, V, T) = substitute (C, V, T')) .
  eq substitute (C, V, (T : S)) = (substitute (C, V, T) := S) .
  eq substitute (C, V, (nil) .EqCondition) = (nil) .EqCondition .

  ceq getVariables ((EqC /\ EqC')) =
    combineVariables (getVariables (EqC), getVariables (EqC'))
   if EqC' =/= (nil) .EqCondition and EqC =/= (nil).EqCondition .
  eq getVariables ((T := T')) = getVariables (T) .
  eq getVariables ((T = T')) = getVariables (T) .
  eq getVariables ((T : S)) = getVariables (T) .
  eq getVariables ((nil) .EqCondition) = empty .

  eq inVars (V, (V', TL)) = if V == V' then true else inVars (V, TL) fi .
  eq inVars (V, empty) = false .

  eq combineVariables ((V, TL), TL') =
      if inVars (V, TL') then combineVariables (TL, TL') else combineVariables (TL, (V, TL')) fi .
  eq combineVariables (empty, TL) = TL .

  eq getVariables (OP [TL]) = if TL :: GroundTermList then empty else getVariables (TL) fi .
  eq getVariables (T) = if T :: Variable then T else empty fi .
  eq getVariables ((T, TL)) = combineVariables (getVariables (T), getVariables (TL)) .
  eq getVariables (empty) = empty .
  eq getVariables (eq T = T' [AttrS] .) = getVariables (T) .
  eq getVariables (ceq T = T' if EqC [AttrS] .) = combineVariables (getVariables (T), getVariables (EqC)) .

  eq isOccurs (Ty, (Ty' TyL)) = if Ty == Ty' then true else isOccurs (Ty, TyL) fi .
  eq isOccurs (Ty, nil) = false .

  ceq add2TypeList ((Ty TyL), TyL') =
     if not isOccurs (Ty, TyL') then add2TypeList (TyL, (Ty TyL')) else add2TypeList (TyL, TyL') fi
    if TyL =/= nil .
  eq add2TypeList (Ty, TyL) = if not isOccurs (Ty, TyL) then (Ty TyL) else TyL fi .
  eq add2TypeList (nil, TyL) = TyL .

  eq isSetExp (Ty) = false [owise] .
  ceq isSetExp (Ty) = true if length (string (Ty)) > 3 and substr(string (Ty), sd (length (string (Ty)), 3), length (string (Ty))) == "Set" .

  eq getConstantsList (M, TyL) = getConstantsListAux1 (getOps(M), TyL) .
  eq getConstantsListAux1 (OPDS, Ty TyL) = (getConstantsListAux2 (OPDS, Ty)) getConstantsListAux1 (OPDS, TyL) .
  eq getConstantsListAux1 (OPDS, nil) = nil .
  ceq getConstantsListAux2 ((op OP : TyL' -> Ty [Attr] .) OPDS, Ty') =
    if Ty == Ty' and TyL' == nil then
     add2TypeConstants (OP, getConstantsListAux2(OPDS, Ty')) else getConstantsListAux2 (OPDS, Ty') fi
   if not isSetExp (Ty') .
  ceq getConstantsListAux2 ((op OP : TyL' -> Ty  [Attr] .) OPDS, Ty') =
    if Ty == Ty'' and TyL' == nil then
     add2TypeConstants (OP, getConstantsListAux2 (OPDS, Ty')) else
     getConstantsListAux2 (OPDS, Ty') fi
    if isSetExp (Ty') /\ Ty'' := qid (substr(string (Ty'), 0, sd (length (string (Ty')), 3))) .
  eq getConstantsListAux2 (none, Ty) = [Ty ; nil] .

  ceq term2string ((T, TL)) = string (getName (T)) + term2string (TL) if TL =/= empty /\ T :: Variable .
  eq term2string (empty) = "" .
  ceq term2string (T) = string (getName (T)) if T :: Variable .
  eq term2string ((T, TL)) = term2string (TL) [owise] .

  eq buildObsSuccValue (MTTS) = buildObsSuccValueAux (MTTS, empty) .
  eq buildObsSuccValueAux (empty, MTTS) = MTTS .
  eq buildObsSuccValueAux (MTT, MTTS) = (setSuccVal (MTT, initialObsSuccValue (getSuccVal (MTT), (MTT MTTS))) MTTS) .
  ceq buildObsSuccValueAux ((MTT MTTS), MTTS') =
    buildObsSuccValueAux (MTTS, (MTT' MTTS'))
    if MTTS =/= empty /\
     MTT' := setSuccVal (MTT, initialObsSuccValue (getSuccVal (MTT), (MTT MTTS MTTS'))) /\
     MTT' :: MetaTermTriple .
  eq buildObsSuccValueAux (MTTS, MTTS') = MTTS' [owise] .

  eq buildRHS (< OP [T, TL], OP', BV, SV >) = (OP' [TL, SV]) .
  ceq buildRHS (< OP [T, TL], OP', BV, SV > MTTS) = '__ [OP' [TL, SV], buildRHSAux (MTTS)] if MTTS =/= empty .
  eq buildRHSAux (MTT MTTS) = (buildRHS (MTT), buildRHSAux (MTTS)) .
  eq buildRHSAux (empty) = empty .

  eq buildLHS (< OP [T, TL], OP', BV, SV >) = (OP' [TL, BV]) .
  ceq buildLHS (< OP [T, TL], OP', BV, SV > MTTS) = '__ [OP' [TL, BV], buildLHSAux (MTTS)] if MTTS =/= empty .
  eq buildLHSAux (MTT MTTS) = (buildLHS (MTT), buildLHSAux (MTTS)) .
  eq buildLHSAux (empty) = empty .

  ceq initialObsSuccValue (T, MTTS) = getObsVal (MTT) if MTT := getMTT (MTTS, T) /\ MTT =/= empty .
  ceq initialObsSuccValue (OP [TL], MTTS) = (OP [initialObsSuccValueAux (TL, MTTS)]) if not hasCafeTerm (MTTS, OP [TL]) .
  eq initialObsSuccValue (T, MTTS) = T [owise] .
  eq initialObsSuccValueAux (empty, MTTS) = empty .
  eq initialObsSuccValueAux ((T, TL), MTTS) = (initialObsSuccValue (T, MTTS), initialObsSuccValueAux (TL, MTTS)) .

  eq getMTT ((< OT, OP, BV, SV > MTTS), OT) = < OT, OP, BV, SV > .
  eq getMTT (MTTS, OT) = empty [owise] .

  ceq getNewCafeTerm (BOPL, (T, TL), Ty, MTTS) =
    (getNewCafeTerm (BOPL, T, Ty, MTTS), getNewCafeTerm (BOPL, TL, Ty, MTTS)) if TL =/= empty .
  eq getNewCafeTerm (BOPL, empty, Ty, MTTS) = empty .
  ceq getNewCafeTerm (BOPL, OP [T, TL], Ty, MTTS) =
    getNewCafeTermAux (BOPL, OP [T, TL], MTTS) if (T :: Constant or T :: Variable) /\ getType (T) == Ty .
  ceq getNewCafeTermAux (BOPL, OP [T, TL], MTTS) = empty if hasCafeTerm (MTTS, OP [T, TL]) .
  ceq getNewCafeTermAux (BOPL, OP [T, TL], MTTS) =
    (OP [T, TL]) if not hasCafeTerm (MTTS, OP [T, TL]) /\ BOP2OP := getBOP2OP (BOPL, OP) /\ BOP2OP =/= nil .
  eq getNewCafeTermAux (BOPL, T, MTTS) = empty [owise] .
  ceq getNewCafeTerm (BOPL, T, Ty, MTTS) = empty if T :: Constant or T :: Variable .
  eq getNewCafeTerm (BOPL, OP [T, TL], Ty, MTTS) =
    (getNewCafeTerm (BOPL, T, Ty, MTTS), getNewCafeTerm (BOPL, TL, Ty, MTTS)) [owise] .

  eq getCafeTerm (< OT, OP, BV, SV >) = OT .
  eq getObsOP (< OT, OP, BV, SV >) = OP .
  eq getObsVal (< OT, OP, BV, SV >) = BV .
  eq getSuccVal (< OT, OP, BV, SV >) = SV .
  eq setCafeTerm (< OT, OP, BV, SV >, OT') = < OT', OP, BV, SV > .
  eq setObsOP (< OT, OP, BV, SV >, OP') = < OT, OP', BV, SV > .
  eq setObsVal (< OT, OP, BV, SV >, BV') = < OT, OP, BV', SV > .
  eq setSuccVal (< OT, OP, BV, SV >, SV') = < OT, OP, BV, SV' > .
  eq hasCafeTerm ((< OT, OP, BV, SV > MTTS), OT) = true .
  eq hasCafeTerm (MTTS, OT) = false [owise] .
endfm

***(%
\end{comment}
}

\subsection{Parsing\label{subsec:parsing}}

The module \verb"CafeDECL-PARSING" is in charge of parsing a term built following
the syntactical constructions presented above:

{\codesize
\begin{verbatim}
%)

view SortSet from TRIV to META-LEVEL is
 sort Elt to SortSet .
endv

fmod CafeDECL-PARSING is
  inc UNIT-DECL-PARSING .
  inc OPERATOR-Cafe .
  pr SCORE-INFO-MAP .
  pr MAP{Qid, Qid} * (sort Map{Qid, Qid} to SortMap,
                      op undefined to undefinedQQ) .
  pr MAP{Qid, SortSet} * (op _|->_ to _->_,
                          sort Map{Qid, SortSet} to TheorySortMap) .

***(%
\end{verbatim}
}

It defines the sort \verb"CafeParseResult" to return the result of the parsing process.
The is composed of:
\begin{itemize}
\item
A term of sort \verb"ParseDeclResult". This sort, defined in Full Maude, keeps
the module obtained thus far, another module still containing bubbles, and a set of
operator declarations standing for the declaration of variables on the fly.

\item
A list of quoted identifiers, that will propagate the errors found during the
parsing process.

\item
A database, that will be updated with the new module or view if the parsing is
successful.
\end{itemize}

{\codesize
\begin{verbatim}
%)

  sort CafeParseResult .
  op <_,_,_,_> : ParseDeclResult QidList SortSet Database -> CafeParseResult [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  vars T T' T'' T''' T3 T4 TV TS TOTF TOTF' TOTF'' : Term .
  vars S S' S'' : Term .
  vars TL TL' TL'' : TermList .
  var  CafeM : CafeModule .
  vars VDS VDS' : OpDeclSet .
  var  PDR : ParseDeclResult .
  vars F O QI Q Q' Q'' : Qid .
  var  H : Header .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RIS : RuleSet .
  var  IL : ImportList .
  vars SS SS' : SortSet .
  vars QIL' QIL QL QL' QL'' : QidList .
  vars PU U PU' U' M M' : Module .
  var  M? : Module .
  vars HS Srt Srt' : Sort .
  var  CafeDS : CafeDeclSet .
  var  CafeD  : CafeDecl .
  var  TyL : TypeList .
  vars Ty Ty' : Type .
  vars DB DB' DB'' : Database .
  var  RP : [ResultPair] .
  var  N : Nat .
  var  B : Bool .
  var  PDL : ParameterDeclList .
  var  ME : ModuleExpression .
  vars SM SM' VM VM' PSM PSM' : SortMap .
  var  HSM HSM' : TheorySortMap .
  var  V : Variable .
  var  C : Constant .
  vars St St' St'' St''' : String .
  var  TSM : TheorySortMap .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}

The function \verb"unfoldCafeOpDecl" ``unfolds'' the operator names defined in a
multiple definition by means of \verb"ops" or \verb"bops":
%)

  op unfoldCafeOpDecl : QidList TypeList Sort -> CafeOpDeclSet .
  eq unfoldCafeOpDecl((QI QIL), TyL, Ty) = (op QI : TyL -> Ty)
                                           unfoldCafeOpDecl(QIL, TyL, Ty) .
  eq unfoldCafeOpDecl(nil, TyL, Ty) = none .

  op unfoldCafe : QidList TypeList Sort -> CafeDeclSet .
  ceq unfoldCafe((QL QIL), TyL , Ty) = CafeD unfoldCafe(QIL, TyL, Ty)
   if CafeD := (bop QL : TyL -> Ty ) .
  eq unfoldCafe(nil, TyL, Ty) = none .

***(%
\end{comment}
}

{\codesize
\begin{comment}
%)

  ***parse imported expression
  op parseCafeDecl : Term CafeModule -> CafeModule .
  ceq parseCafeDecl('protecting`(_`)[T], CafeM) = addImports((protecting parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('pr`(_`)[T], CafeM) = addImports((protecting parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('extending`(_`)[T], CafeM) = addImports((extending parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('ex`(_`)[T], CafeM) = addImports((extending parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('including`(_`)[T], CafeM) = addImports((including parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('inc`(_`)[T], CafeM) = addImports((including parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('using`(_`)[T], CafeM) = addImports((including parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('us`(_`)[T], CafeM) = addImports((including parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .

***(%
\end{comment}
}

\begin{comment}

In the same way, the function \verb"parseCafeModExp" transforms the CafeOBJ syntax
for module expressions into Maude syntax. Note that the syntax for tokens is also
translated when required:

{\codesize
\begin{verbatim}
%)

  op parseCafeModExp : Term -> ModuleExpression .
  eq parseCafeModExp('CafeToken[T]) = 'token[T] .
  eq parseCafeModExp('token[T]) = 'token[T] .
  ceq parseCafeModExp('_`(_`)[T, T']) = '_`{_`}[T'', T''']
   if T'' := parseCafeModExp(T) /\
      T''' := parseCafeViewExp(T') .
  ceq parseCafeModExp('_*`{_`}[T, T']) = '_*`(_`)[T'', T''']
   if T'' := parseCafeModExp(T) /\
      T''' := parseCafeRen(T') .
  ceq parseCafeModExp('_+_[T, T']) = '_+_[T'', T''']
   if T'' := parseCafeModExp(T) /\
      T''' := parseCafeModExp(T') .

***(%
\end{verbatim}
}

\end{comment}

The function \verb"parseCafeRen" translates CafeOBJ renamings. Note that
the renaming for hidden sorts is translated as a renaming for standard sorts, since
there is no hidden sorts in Maude:

{\codesize
\begin{verbatim}
%)

  op parseCafeRen : Term -> Term .
  ceq parseCafeRen('__[T, T']) = '_`,_[T'', T3]
   if T'' := parseCafeRen(T) /\
      T3 := parseCafeRen(T') .
  ceq parseCafeRen('sort_->_.[T, T']) = 'sort_to_[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .
  ceq parseCafeRen('hsort_->_.[T, T']) = 'sort_to_[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .
  eq parseCafeRen('op_->_.['CafeBubble[T], 'CafeBubble[T']]) =
                                    'op_to_['token[T], 'token[T']] .
  eq parseCafeRen('bop_->_.['CafeBubble[T], 'CafeBubble[T']]) =
                                    'op_to_['token[T], 'token[T']] .
  eq parseCafeRen(T) = T [owise] .

***(%
\end{verbatim}
}

The function \verb"sort2sort" translates CafeOBJ tokens into Maude tokens
for sorts, while \verb"parseCafeViewExp" translates view tokens:

{\codesize
\begin{verbatim}
%)

  op sort2sort : Term -> Term .
  eq sort2sort('CafeToken[T]) = 'sortToken[T] .
  eq sort2sort(T) = T [owise] .

  op parseCafeViewExp : Term -> ViewExp .
  eq parseCafeViewExp('token[T]) = 'viewToken[T] .
  eq parseCafeViewExp(T) = T [owise] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  *** parse hiddensort and sort
  ceq parseCafeDecl('*`[_`]*[T], CafeM) = addHiddenSortDecl((*[ HS ]*), CafeM)
   if HS := parseHiddenSort(T) .
  eq parseCafeDecl('`[_`]['neCafeTokenList[T]], CafeM) = addSorts(parseSortSet(addSortToken(T)), CafeM) .
  eq parseCafeDecl('`[_`]['CafeToken[T]], CafeM) =
         addSorts(parseSortSet('sortToken[T]), CafeM) .
  eq  parseCafeDecl('op_:`->_`{_`}.['CafeToken[T], 'CafeToken[T'], T''],  CafeM) =
        addOps((op downQid(T) : nil -> parseType('sortToken[T'])), CafeM) .
  eq  parseCafeDecl('op_:`->_`{_`}.['__[TL], 'CafeToken[T'], T''],  CafeM) =
        addOps((op tokenList2token(TL) : nil -> parseType('sortToken[T'])), CafeM) .

  ***parse normal operators
  eq parseCafeDecl('op_:`->_.['CafeToken[T], 'CafeToken[T']], CafeM) =
          addOps((op downQid(T) : nil -> parseType(cafeType2maudeType(T')) ), CafeM) .

  eq parseCafeDecl('ops_:`->_.['neCafeTokenList[T], 'CafeToken[T']], CafeM) =
      addOps(unfoldCafeOpDecl(downTypes(T), nil, parseType('sortToken[T'])), CafeM) .

  ceq parseCafeDecl('op_:_->_.['CafeToken[T], T', 'CafeToken[T'']], CafeM ) =
       addOps((op downQid(T) : parseTypeList(T4) -> parseType('sortToken[T''])), CafeM)
   if T4 := addSortToken(T') .

  ceq parseCafeDecl('pred_:_.['CafeToken[T], T'], CafeM ) =
        addOps((op downQid(T) : parseTypeList(T4) -> 'Bool), CafeM)
   if T4 := addSortToken(T') .

  ceq parseCafeDecl('ops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], CafeM) =
        addOps(unfoldCafeOpDecl(downTypes(T), parseTypeList(T4), parseType('sortToken[T''])), CafeM)
   if T4 := addSortToken(T') .

  ***ceq parseCafeDecl('op_:_->_`{_`}.['CafeToken[T], T', 'CafeToken[T''], T'''], CafeM) =
  ***    addOps((op downQid(T) : parseTypeList(T4) -> parseType('sortToken[T''])
  ***    [parsePreAttrs(T''', size(parseTypeList(T4)))] .), CafeM) if T4 := addSortToken(T') .

  ***parse behavioral operations
  eq parseCafeDecl('bop_:_->_.['CafeToken[T], T', T''], CafeM) =
       parseCafeDecl('bops_:_->_.['neCafeTokenList[T], T', T''], CafeM) .
  eq parseCafeDecl('bop_:_->_`{_`}.['CafeToken[T], T', T'', T'''], CafeM) =
       parseCafeDecl('bops_:_->_.['neCafeTokenList[T], T', T''], CafeM) .
  ceq parseCafeDecl('bops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], CafeM) =
       addCafeDeclSet(unfoldCafe(downTypes(T), parseTypeList(T4), parseType('sortToken[T''])), CafeM)
   if T4 := addSortToken(T') .
  ceq parseCafeDecl('bops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''], CafeM) =
       addCafeDeclSet(unfoldCafe(downTypes(T), parseTypeList(T4), parseType('sortToken[T''])), CafeM)
   if T4 := addSortToken(T') .

  ***parse equations at meta-level
  eq parseCafeDecl('eq_=_.['CafeBubble[T], 'CafeBubble[T']], CafeM) = CafeM . ***addEqs((eq 'T = T' [none] .), CafeM) .
  eq parseCafeDecl('cq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], CafeM) = CafeM .
  eq parseCafeDecl('ceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], CafeM) = CafeM .
   *** addEqs((ceq T = T' if T'' = ''true.Bool [none] .), CafeM) .
   ***to be handled
  eq parseCafeDecl('bceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], CafeM) = CafeM .
  eq parseCafeDecl('bcq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], CafeM) = CafeM .

  eq parseCafeDecl('var_:_.['neCafeTokenList[T], T'], CafeM) = CafeM .
  eq parseCafeDecl('vars_:_.['neCafeTokenList[T], T'], CafeM) = CafeM .

  **************************************
  ***convert to Functional Module
  **************************************

***(%
\end{comment}
}

The function \verb"parseCafeDecl" uses the function \texttt{parseCafeModExp}
to parse de module expression. Once this expression is obtained it uses the
Full Maude function

{\codesize
\begin{verbatim}
%)

  op parseCafeDecl : Term Module Module OpDeclSet SortMap TheorySortMap Database
     -> CafeParseResult .
  ceq parseCafeDecl('protecting`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('protecting_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('pr`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('protecting_.[T'], PU, U, VDS) .

***(%
  ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('extending`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('extending_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('ex`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('extending_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('inc`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('including`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('using`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('us`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .

  op changeTheoryByModule : Term Bool Database -> Term .
  ceq changeTheoryByModule(Q[TL], B, DB) = Q[TL']
   if Q =/= 'token /\
      TL' := changeTheoryByModule*(TL, B, DB) .
  ceq changeTheoryByModule('token[T], B, DB) = T'
   if Q := downQid(T) /\
      Q' := qid(string(Q) + "-MODCAFE") /\
      T' := 'token[upTerm(Q')] /\
      not B /\
      M := getTopModule(Q, DB) /\
      isATheory(M) .
  eq changeTheoryByModule(T, B, DB) = T [owise] .

  op changeTheoryByModule* : TermList Bool Database -> TermList .
  eq changeTheoryByModule*(empty, B, DB) = empty .
  eq changeTheoryByModule*((T, TL), B, DB) = changeTheoryByModule(T, B, DB),
                                             changeTheoryByModule*(TL, B, DB) .

  op isATheory : [Module] -> Bool .
  eq isATheory(fth Q is IL sorts SS . SSDS OPDS MAS EqS endfth) = true .
  eq isATheory(th Q is IL sorts SS . SSDS OPDS MAS EqS RIS endth) = true .
  eq isATheory(emptyFTheory) = true .
  eq isATheory(emptySTheory) = true .
  eq isATheory(M?) = false [owise] .

***(%
\end{comment}
}

The function \verb"parseCafeModExp" returns a term of sort \verb"ParseResult".
This sort contains a database and, depending the context where it is applied,
a module expression, a view expression, or a list of terms:

{\codesize
\begin{verbatim}
%)

  sort ParseResult .
  op <_,_> : ModuleExpression Database -> ParseResult [ctor] .
  op <_,_> : ViewExp Database -> ParseResult [ctor] .
  op <_,_> : TermList Database -> ParseResult [ctor] .

***(%
\end{verbatim}
}

Parsing simple module expressions, summations, and expressions with renamings is
straightforward:

{\codesize
\begin{verbatim}
%)

  op parseCafeModExp : Term SortMap Database -> ParseResult .
  eq parseCafeModExp('CafeToken[T], PSM, DB) = < 'token[T], DB > .
  eq parseCafeModExp('token[T], PSM, DB) = < 'token[T], DB > .
  ceq parseCafeModExp('_+_[T, T'], PSM, DB) = < '_+_[T'', T'''], DB'' >
   if < T'', DB' > := parseCafeModExp(T, PSM, DB) /\
      < T''', DB'' > := parseCafeModExp(T', PSM, DB') .
  ceq parseCafeModExp('_*`{_`}[T, T'], PSM, DB) = < '_*`(_`)[T'', T'''], DB' >
   if < T'', DB' > := parseCafeModExp(T, PSM, DB) /\
      T''' := parseCafeRen(T') .

***(%
\end{verbatim}
}

Parsing a module expression involving view expression requires the database, because
we need the list of parameters to deal with on-the-fly view declarations:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeModExp('_`(_`)[T, T'], PSM, DB) = < '_`{_`}[T'', T'''], DB'' >
   if < T'', DB' > := parseCafeModExp(T, PSM, DB) /\
      M := getTopModule(parseModExp(T''), DB') /\
      PDL := getPDL(M) /\
      < T''', DB'' > := parseCafeViewExp(PDL, sortViewId(PDL, T'), PSM, DB') .

***(%
\end{verbatim}
}

Parsing a view identifier requires the parameter list of the module being instantiated,
the view identifier itself, and the database.

{\codesize
\begin{verbatim}
%)

  op parseCafeViewExp : ParameterDeclList Term SortMap Database -> ParseResult .
  ceq parseCafeViewExp(PDL, 'token[T], PSM, DB) = < 'viewToken[T], DB >
   if Q := downQid(T) /\
      isParamName(Q, PDL) .
  ceq parseCafeViewExp(PDL, 'token[T], PSM, DB) = < 'viewToken[T], DB >
   if Q := downQid(T) /\
      getView(Q, DB) :: View .
  ceq parseCafeViewExp(Q :: ME, 'token[T], PSM, DB) = < 'viewToken[T], DB' >
   if Q' := downQid(T) /\
      not getView(Q', DB) :: View /\
      M := getTopModule(ME, DB) /\
      M' := getTopModule(Q', DB) /\
      SS := getSorts(M) /\
      SS' := getSorts(M') /\
      Srt := removePredef(SS) /\
      Srt' := removePredef(SS') /\
      T' := 'sort_to_.['sortToken[upTerm(Srt)], 'sortToken[upTerm(Srt')]] /\
      TV := 'view_from_to_is_endv['token[T], 'token[upTerm(ME)], 'token[T], T'] /\
      DB' := procView(TV, DB) .
  ceq parseCafeViewExp(Q :: ME, 'token[T], PSM, DB) = < 'viewToken[T], DB' >
   if Q' := downQid(T) /\
      not getView(Q', DB) :: View /\
      M := getTopModule(ME, DB) /\
      SS := getSorts(M) /\
      Srt := removePredef(SS) /\
      (Q' |-> Srt', PSM') := PSM /\
      T' := 'sort_to_.['sortToken[upTerm(Srt)], 'sortToken[upTerm(Srt')]] /\
      TV := 'view_from_to_is_endv['token[T], 'token[upTerm(ME)], 'token[T], T'] /\
      DB' := procView(TV, DB) .
  *** The names of the sorts and ops are the same, so it is enough to use the module name.
  ceq parseCafeViewExp(Q :: ME, 'token[T], PSM, DB) = < 'viewToken[T''], DB' >
   if Q' := downQid(T) /\
      not getView(Q', DB) :: View /\
      M := getTopModule(Q', DB) /\
      M' := getTopModule(ME, DB) /\
      SS := getSorts(M') /\
      SS' := removePredef(SS) /\
      T'' := upTerm(newName(M, Q')) /\
      T' := createMapsForSorts(SS') /\
      TV := 'view_from_to_is_endv['token[T''], 'token[upTerm(ME)], 'token[T''], T'] /\
      DB' := procView(TV, DB) [owise] .
  eq parseCafeViewExp(PDL, '_<=_[T, T'], PSM, DB) = parseCafeViewExp(PDL, T', PSM, DB) .
  ceq parseCafeViewExp(PDL, '_`,_[TL], PSM, DB) = < '_`,_[TL'], DB' >
   if < TL', DB' > := parseCafeViewExp*(PDL, TL, PSM, DB) .

  op isParamName : Qid ParameterDeclList -> Bool .
  eq isParamName(Q, nil) = false .
  eq isParamName(Q, (Q' :: ME, PDL)) = if Q == Q'
                                       then true
                                       else isParamName(Q, PDL)
                                       fi .

  op newName : Module Qid -> Qid .
  eq newName(M, Q) = if M :: FTheory or M :: STheory
                     then qid(string(Q) + "-MODCAFE")
                     else Q
                     fi .

  op removePredef : SortSet -> SortSet .
  eq removePredef('Bool ; SS) = removePredef(SS) .
  eq removePredef('Nat ; SS) = removePredef(SS) .
  eq removePredef('NzNat ; SS) = removePredef(SS) .
  eq removePredef('Zero ; SS) = removePredef(SS) .
  eq removePredef(SS) = SS [owise] .

  op createMapsForSorts : SortSet ~> Term .
  eq createMapsForSorts(Srt) = 'sort_to_.['sortToken[upTerm(Srt)], 'sortToken[upTerm(Srt)]] .
  ceq createMapsForSorts(Srt ; SS) =
                     '__['sort_to_.['sortToken[upTerm(Srt)], 'sortToken[upTerm(Srt)]],
                         createMapsForSorts(SS)]
   if SS =/= none .

***(%
\end{verbatim}
}

When parsing views declared on the fly we create a new auxiliary view, add it to the
database, and return the new database and the name of the auxiliary view:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeViewExp(Q :: ME, 'view`to_`{_`}['token[T], T'], PSM, DB) =
                                                      < 'viewToken[upTerm(Q')], DB' >
   if Q'' := downQid(T) /\
      M := getTopModule(Q'', DB) /\
      Q' := getNewName(DB, 0) /\
      T'' := 'token[upTerm(Q')] /\
      T''' := 'token[upTerm(newName(M, Q''))] /\
      TV := 'view_from_to_is_endv[T'', 'token[upTerm(ME)], T''', maps2maps(T')] /\
      DB' := procView(TV, DB) .
  ceq parseCafeViewExp(Q :: ME, '_`{_`}['token[T], T'], PSM, DB) = < 'viewToken[upTerm(Q')], DB' >
   if Q'' := downQid(T) /\
      M := getTopModule(Q'', DB) /\
      Q' := getNewName(DB, 0) /\
      T'' := 'token[upTerm(Q')] /\
      T''' := 'token[upTerm(newName(M, Q''))] /\
      TV := 'view_from_to_is_endv[T'', 'token[upTerm(ME)], T''', maps2maps(T')] /\
      DB' := procView(TV, DB) .

***(%
\end{verbatim}
}

The auxiliary functions used thus far are defined as follows:
\begin{itemize}
\item
The function \verb"parseCafeViewExp*" traverses the terms in the list,
pairing them with the parameters from the module being instantiated:

{\codesize
\begin{verbatim}
%)

  op parseCafeViewExp* : ParameterDeclList TermList SortMap Database -> ParseResult .
  eq parseCafeViewExp*(PDL, empty, PSM, DB) = < empty, DB > .
  ceq parseCafeViewExp*((Q :: ME, PDL), (T, TL), PSM, DB) = < (T', TL'), DB'' >
   if < T', DB' > := parseCafeViewExp(Q :: ME, T, PSM, DB) /\
      < TL', DB'' > := parseCafeViewExp(PDL, TL, PSM, DB') .

***(%
\end{verbatim}
}

\item
The function \verb"maps2maps" transforms CafeOBJ mappings into Maude mappings.
This is achieved by first computing the mappings for sorts and variables,
removing the variable declarations, which are not allowed in Maude, and
then applying an auxiliary \verb"maps2maps" function with $3$ arguments:

{\codesize
\begin{verbatim}
%)

  op maps2maps : Term -> Term .
  ceq maps2maps(T) = maps2maps(T', SM, VM)
   if SM := getSortMap(T) /\
      VM := getVarMap(T) /\
      T' := removeVarDecls(T) .

***(%
\end{verbatim}
}

\item
The function \verb"getSortMap" traverses the mappings, transforming them into
Maude mappings:

{\codesize
\begin{verbatim}
%)

  op getSortMap : Term -> SortMap .
  ceq getSortMap('__[T, T']) = SM, SM'
   if SM := getSortMap(T) /\
      SM' := getSortMap(T') .
  eq getSortMap('sort_->_.[T, T']) = getSort(T) |-> getSort(T') .
  eq getSortMap('hsort_->_.[T, T']) = getSort(T) |-> getSort(T') .
  eq getSortMap(T) = empty [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"getSort" just extracts the quoted identifier from the term:

{\codesize
\begin{verbatim}
%)

  op getSort : Term ~> Term .
  eq getSort('CafeToken[T]) = downQid(T) .

***(%
\end{verbatim}
}

\item
Similarly, \verb"getVarMap" traverses the term creating a mapping between variables
and their sort.
%
Note that we use \texttt{vvar} and \texttt{vvars} instead of \texttt{var} and
\texttt{vars}. This is due to a pre-processing step that aims to distinguish
between these variables and the ones in modules:

{\codesize
\begin{verbatim}
%)

  op getVarMap : Term -> SortMap .
  ceq getVarMap('__[T, T']) = VM, VM'
   if VM := getVarMap(T) /\
      VM' := getVarMap(T') .
  ceq getVarMap('vvar_:_.['neCafeTokenList[T], 'CafeToken[T']]) =
                                                          createMap*(QIL, Q)
   if QIL := downQidList(T) /\
      Q := downQid(T') .
  ceq getVarMap('vvars_:_.['neCafeTokenList[T], 'CafeToken[T']]) =
                                                          createMap*(QIL, Q)
   if QIL := downQidList(T) /\
      Q := downQid(T') .
  eq getVarMap(T) = empty [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"createMap*" just maps all the variables in the first argument to the sort
given as second argument:

{\codesize
\begin{verbatim}
%)

  op createMap* : QidList Qid -> SortMap .
  eq createMap*(nil, Q) = empty .
  eq createMap*(Q QIL, Q') = Q |-> Q', createMap*(QIL, Q') .

***(%
\end{verbatim}
}

\item
The function \verb"maps2maps" with $3$ arguments translates CafeOBJ mappings
into Maude mappings. Sort renamings only require changing the syntax:

{\codesize
\begin{verbatim}
%)

  op maps2maps : Term SortMap SortMap -> Term .
  ceq maps2maps('__[T, T'], SM, VM) = '__[T'', T3]
   if T'' := maps2maps(T, SM, VM) /\
      T3 := maps2maps(T', SM, VM) .
  ceq maps2maps('sort_->_.[T, T'], SM, VM) = 'sort_to_.[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .
  ceq maps2maps('hsort_->_.[T, T'], SM, VM) = 'sort_to_.[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .

***(%
\end{verbatim}
}

However, mapping operators might require a more complex translation, because
they can include mappings to terms. We check whether the lefthand side contains
variables. If it does not contain, then it is translated as an operator mapping;
otherwise, it is mapped to a term:

{\codesize
\begin{verbatim}
%)

  ceq maps2maps('op_->_.['CafeBubble[T], 'CafeBubble[T']], SM, VM) =
                        if T == T''
                        then 'op_to_.['token[T], 'token[T3]]
                        else 'op_to`term_.['bubble[T''], 'bubble[T3]]
                        fi
   if T'' := updateTermLHS(T, SM, VM) /\
      T3 := updateTermRHS(T', SM, VM) .

***(%
\end{verbatim}
}

Finally, behavioral operators are transformed into standard operators:

{\codesize
\begin{verbatim}
%)

  ceq maps2maps('bop_->_.['CafeBubble[T], 'CafeBubble[T']], SM, VM) =
                                      'op_to_.['bubble[T''], 'bubble[T3]]
   if T'' := updateTermLHS(T, SM, VM) /\
      T3 := updateTermRHS(T', SM, VM) .
  eq maps2maps(T, SM, VM) = T [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"updateTermLHS" traverses the constants in the term and,
if we find a variable previously defined, its sort is attached:

{\codesize
\begin{verbatim}
%)

  op updateTermLHS : Term SortMap SortMap -> Term .
  eq updateTermLHS(Q[TL], SM, VM) = Q[updateTermLHS*(TL, SM, VM)] .
  eq updateTermLHS(V, SM, VM) = V .
  ceq updateTermLHS(C, SM, VM) = upTerm(Q')
   if Q := downQid(C) /\
      VM[Q] =/= undefined /\
      Q' := qid(string(Q) + ":" + string(VM[Q])) .
  eq updateTermLHS(T, SM, VM) = T [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"updateTermRHS" also attaches the sort of the variables,
but it takes into account that \emph{the names of the sorts might have changed
due to the mappings}. Hence, it looks for the sort name in the sort mapping and
replaces it if required:

{\codesize
\begin{verbatim}
%)

  op updateTermRHS : Term SortMap SortMap -> Term .
  eq updateTermRHS(Q[TL], SM, VM) = Q[updateTermRHS*(TL, SM, VM)] .
  eq updateTermRHS(V, SM, VM) = V .
  ceq updateTermRHS(C, SM, VM) = upTerm(Q')
   if Q := downQid(C) /\
      VM[Q] =/= undefined /\
      SM[VM[Q]] == undefined /\
      Q' := qid(string(Q) + ":" + string(VM[Q])) .
  ceq updateTermRHS(C, SM, VM) = upTerm(Q')
   if Q := downQid(C) /\
      VM[Q] =/= undefined /\
      SM[VM[Q]] =/= undefined /\
      Q' := qid(string(Q) + ":" + string(SM[VM[Q]])) .
  eq updateTermRHS(T, SM, VM) = T [owise] .

***(%
\end{verbatim}
}

\item
The functions \verb"updateTermLHS*" and \verb"updateTermRHS*" just traverse
the list, applying the appropriate function to each element:

{\codesize
\begin{verbatim}
%)

  ops updateTermLHS* : TermList SortMap SortMap -> TermList .
  eq updateTermLHS*(empty, SM, VM) = empty .
  eq updateTermLHS*((T, TL), SM, VM) = updateTermLHS(T, SM, VM),
                                       updateTermLHS*(TL, SM, VM) .

  op updateTermRHS* : TermList SortMap SortMap -> TermList .
  eq updateTermRHS*(empty, SM, VM) = empty .
  eq updateTermRHS*((T, TL), SM, VM) = updateTermRHS(T, SM, VM),
                                       updateTermRHS*(TL, SM, VM) .

***(%
\end{verbatim}
}

\item
The function \verb"removeVarDecls" removes the variable declarations
from the term, by first removing them and then creating a new term with
the rest of the declarations:

{\codesize
\begin{verbatim}
%)

  op removeVarDecls : Term -> Term .
  eq removeVarDecls(T) = buildNotVarDecl(getNotVarDecl(T)) .

***(%
\end{verbatim}
}

\item
The function \verb"getNotVarDecl" checks that the operator at the top
is not a variable declaration:

{\codesize
\begin{verbatim}
%)

  op getNotVarDecl : Term -> TermList .
  ceq getNotVarDecl('__[Q[TL], Q'[TL']]) = T, T'
   if Q =/= 'vvar_:_. /\
      Q =/= 'vvars_:_. /\
      Q' =/= 'vvar_:_. /\
      Q' =/= 'vvars_:_. /\
      T := getNotVarDecl(Q[TL]) /\
      T' := getNotVarDecl(Q'[TL']) .
  ceq getNotVarDecl('__[Q[TL], Q'[TL']]) = T
   if Q == 'vvar_:_. or-else Q == 'vvars_:_. /\
      Q' =/= 'vvarrs_:_. /\
      Q' =/= 'vvars_:_. /\
      T := getNotVarDecl(Q'[TL']) .
  ceq getNotVarDecl('__[Q[TL], Q'[TL']]) = T
   if Q =/= 'vvarrs_:_. /\
      Q =/= 'vvars_:_. /\
      Q' == 'vvar_:_. or-else Q' == 'vvars_:_. /\
      T := getNotVarDecl(Q[TL]) .
  eq getNotVarDecl(T) = T [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"buildNotVarDecl" distinguishes whether the argument is
a singleton list or not, in order to use the \verb"__" operator:

{\codesize
\begin{verbatim}
%)

  op buildNotVarDecl : TermList ~> Term .
  eq buildNotVarDecl(T) = T .
  ceq buildNotVarDecl((T, TL)) = '__[T, buildNotVarDecl(TL)]
   if TL =/= empty .

***(%
\end{verbatim}
}

\item
The function \verb"sortViewId" is in charge of sorting the parameters, so they
do not rely on the naming features of CafeOBJ. If only one parameter is used or
the term does not use syntactic sugar, then it is kept the same way. Otherwise
an alternative function is used:

{\codesize
\begin{verbatim}
%)

  op sortViewId : ParameterDeclList Term -> Term .
  ceq sortViewId(PDL, Q[T, TL]) = Q[T, TL]
   if Q =/= '_`,_ or-else not usesSugar(T) .
  eq sortViewId(PDL, Q[TL]) = sortViewIdAux(PDL, TL) .

***(%
\end{verbatim}
}

\noindent
where \verb"sortViewIdAux" looks for the appropriate view identifiers by traversing the
list of parameters:

{\codesize
\begin{verbatim}
%)

  op sortViewIdAux : ParameterDeclList TermList -> TermList .
  eq sortViewIdAux(nil, TL) = empty .
  ceq sortViewIdAux((Q :: ME, PDL), TL) = find(Q, TL), sortViewIdAux(PDL, TL)
   if PDL == nil .
  eq sortViewIdAux((Q :: ME, PDL), TL) = '_`,_[find(Q, TL),
                                         sortViewIdAux(PDL, TL)] [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"getPDL" extracts the parameter list from a module:

{\codesize
\begin{verbatim}
%)

  op getPDL : Module ~> ParameterDeclList .
  eq getPDL(fmod Q{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm) = PDL .
  eq getPDL(mod Q{PDL} is IL sorts SS . SSDS OPDS MAS EqS RIS endm) = PDL .

***(%
\end{verbatim}
}

\item
\verb"getNewName" checks in the database whether there already
exists a view with name created by \verb"createViewName". If true, then we try with
the next natural number, otherwise this name is used:

{\codesize
\begin{verbatim}
%)

  op getNewName : Database Nat -> Qid .
  ceq getNewName(DB, N) = if getView(Q, DB) :: View
                          then getNewName(DB, s(N))
                          else Q
                          fi
   if Q := createViewName(N) .

***(%
\end{verbatim}
}

\noindent
where \verb"createViewName" just creates a new name starting by
\texttt{OTF-VIEW}~\cite{cafeOBJ2maudeUG}, which stands for ``on the fly view'',
and followed by a natural number:

{\codesize
\begin{verbatim}
%)

  op createViewName : Nat -> Qid .
  eq createViewName(N) = qid("OTF-VIEW" + string(N, 10)) .

***(%
\end{verbatim}
}

\item
The function \verb"find" looks for the given quoted identifier, standing for a
parameter, inside a list of terms:

{\codesize
\begin{verbatim}
%)

  op find : Qid TermList -> Term .
  eq find(Q, ('_`,_[T, T'], TL)) = find(Q, (T, T', TL)) .
  eq find(Q, ('_<=_['token[T], T'], TL)) = if Q == downQid(T)
                                           then T'
                                           else find(Q, TL)
                                           fi .

***(%
\end{verbatim}
}

\item
Finally, \verb"usesSugar" checks whether the notation \verb"_<=_", used to state
the name of the parameter corresponding to the view identifier, is being used:

{\codesize
\begin{verbatim}
%)

  op usesSugar : Term -> Bool .
  eq usesSugar('_<=_[TL]) = true .
  eq usesSugar(T) = false [owise] .

***(%
\end{verbatim}
}

\end{itemize}

The parsing process continues by parsing sorts. Hidden sorts are translated
as standard Maude sorts:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('*`[_`]*['CafeToken[T]], PU, U, VDS, PSM, TSM, DB) =
                                                        < PDR, nil, downQid(T), DB >
   if PDR := parseDecl('sort_.['sortToken[T]], PU, U, VDS) .

***(%
\end{verbatim}
}

We distinguish the operator at the top when dealing with sort declarations.
\begin{itemize}
\item
When only one sort is declared it is parsed and added to the temporal
modules with the Full Maude function \verb"parseDecl":

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('`[_`]['CafeToken[T]], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if T' := addSortToken('CafeToken[T]) /\
      PDR := parseDecl('sorts_.[T'], PU, U, VDS) .

***(%
\end{verbatim}
}

\item
When we have a list of sorts without subsort declaration they are just parsed
and added to the current module:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('`[_`]['__[T, T']], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if T'' := addSortToken(T) /\
      T''' := addSortToken(T') /\
      PDR := parseDecl('sorts_.['__[T'', T''']], PU, U, VDS) .

***(%
\end{verbatim}
}

\item
Finally, when we find a subsort relation both terms, the sorts are add to the
sort and the subsort relation (which might be multiple) is added to the module
thus obtained:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('`[_`]['_<_[T, T']], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if T'' := addSortToken(T) /\
      T''' := addSortToken(T') /\
      TS := sub2sort('_<_[T, T']) /\
      < PU' ; U' ;  VDS' > := parseDecl('sorts_.[TS], PU, U, VDS) /\
      PDR := parseDecl('subsorts_.['_<_[T'', T''']], PU', U', VDS') .

***(%
\end{verbatim}
}

\end{itemize}

The auxiliary functions used for parsing sorts are:
\begin{itemize}
\item
\verb"addSortToken", which transforms CafeOBJ tokens into Maude tokens for sorts:

{\codesize
\begin{verbatim}
%)

  op addSortToken : Term -> Term .
  eq addSortToken('__[T, T']) = ('__[addSortToken(T), addSortToken(T')]) .
  eq addSortToken('_<_[T, T']) = ('_<_[addSortToken(T), addSortToken(T')]) .
  eq addSortToken('CafeToken[T]) = ('sortToken[T]) .

***(%
\end{verbatim}
}

\item
\verb"sub2sort", which flattens a subsort relation to add all the sorts to
the current module:

{\codesize
\begin{verbatim}
%)

  op sub2sort : Term -> Term .
  eq sub2sort('_<_[T, T']) = combine2sort(sub2sort(T), sub2sort(T')) .
  eq sub2sort('__['CafeToken[T], T']) = ('__['sortToken[T], sub2sort(T')]) .
  eq sub2sort('CafeToken[T]) = ('sortToken[T]) .

***(%
\end{verbatim}
}

\item
\verb"combine2sort", which puts together two terms:

{\codesize
\begin{verbatim}
%)

  op combine2sort : Term Term -> Term .
  eq combine2sort('sortToken[T], T') = '__['sortToken[T], T'] .
  eq combine2sort('__[T, T''], T''') = combine2sort(T'', '__[T, T''']) .

***(%
\end{verbatim}
}

\end{itemize}

We show now how to parse operator declarations. For the declaration of a single operator
with attributes we transform the list of sorts in the arity with \verb"addSortToken",
and then add the operator declaration with \verb"parseDecl":

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('op_:_->_`{_`}.['CafeToken[T], T', 'CafeToken[T''], T'''],  PU, U,
                    VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[T], T4, 'sortToken[T''],
                       map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('op_:_->_`{_`}.['__[TL], T', 'CafeToken[T''], T'''],  PU, U, VDS,
                    PSM, TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[upTerm(tokenList2token(TL))], T4,
                       'sortToken[T''], map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('op_:_->_.['CafeToken[T], T', 'CafeToken[T'']],  PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_.['token[T], T4, cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('op_:_->_.['__[TL], T', 'CafeToken[T'']],  PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_.['token[upTerm(tokenList2token(TL))], T4,
                                                cafeType2maudeType(T'')], PU, U, VDS) .

***(%
\end{comment}
}

The declaration of constants simplifies the task, since the arity does not appear:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('op_:`->_`{_`}.['CafeToken[T], 'CafeToken[T''], T'''],  PU, U, VDS,
                    PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := parseDecl('op_:`->_`[_`].['token[T], cafeType2maudeType(T''),
                                       map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('op_:`->_.['CafeToken[T], 'CafeToken[T'']],  PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if PDR := parseDecl('op_:`->_.['token[T], cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('ops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''], PU,
                    U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_`[_`].['neTokenList[T], T4, cafeType2maudeType(T''),
                                        map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{comment}
}

Multiple operators with the same arity and coarity are just transformed into a nonempty
list of Maude tokens, and then introduced into the current module:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('ops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], PU, U, VDS,
                    PSM, TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_.['neTokenList[T], T4, cafeType2maudeType(T'')],
                       PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('ops_:`->_`{_`}.['neCafeTokenList[T], 'CafeToken[T''], T'''],  PU, U,
                    VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := parseDecl('ops_:`->_`[_`].['neTokenList[T], cafeType2maudeType(T''),
                                        map2MaudeAttr(T''')], PU, U, VDS) .

  ceq parseCafeDecl('ops_:`->_.['neCafeTokenList[T], 'CafeToken[T'']], PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if PDR := parseDecl('ops_:`->_.['neTokenList[T], cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('bop_:_->_.['CafeToken[T], T', 'CafeToken[T'']],  PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[T], T4, cafeType2maudeType(T''),
                                       behavioral], PU, U, VDS) .

  op behavioral : -> Term .
  eq behavioral = 'metadata_['token[''"behavioral".Sort]] .

  op addBehavioral : Term -> Term .
  eq addBehavioral('__[TL]) = '__[TL, behavioral] .
  eq addBehavioral(T) = '__[T, behavioral] [owise] .

  ceq parseCafeDecl('bop_:_->_`{_`}.['CafeToken[T], T', 'CafeToken[T''], T'''], PU, U,
                    VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[T], T4, cafeType2maudeType(T''),
                                       addBehavioral(map2MaudeAttr(T'''))], PU, U, VDS) .

  ceq parseCafeDecl('bops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], PU, U, VDS,
                    PSM, TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_`[_`].['neTokenList[T], T4, cafeType2maudeType(T''),
                                        behavioral], PU, U, VDS) .

  ceq parseCafeDecl('ops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''], PU,
                    U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_`[_`].['neTokenList[T], T4, cafeType2maudeType(T''),
                                        map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{comment}
}

Predicates are parsed in a similar way, since they are transformed into operators
with coarity \verb"Bool", which must be meta-represented as a token:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('pred_:_`{_`}.['CafeToken[T], T', T'''],  PU, U, VDS, PSM, TSM, DB) =
                                                                  < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[T], T4, 'sortToken[''Bool.Qid],
                       map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('pred_:_.['CafeToken[T], T'],  PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_.['token[T], T4, 'sortToken[''Bool.Qid]], PU, U, VDS) .

***(%
\end{comment}
}

The auxiliary functions used here are:
\begin{itemize}

\item
The function \verb"tokenList2token" transforms operator defintions of the
form \verb"_ _", which are not allowed by Maude, into the equivalent \verb"__"
operator:

{\codesize
\begin{verbatim}
%)

  op tokenList2token : TermList -> Qid .
  op tokenList2token : TermList String -> Qid .

  eq tokenList2token(TL) = tokenList2token(TL, "") .
  eq tokenList2token(('CafeToken[T], TL), St) =
                       tokenList2token(TL, St + string(downQid(T))) .
  eq tokenList2token(empty, St) = qid(St) .

***(%
\end{verbatim}
}

\item
The function \verb"map2MaudeAttr" translates a list of terms written using CafeOBJ
syntax into the same list using Maude syntax. The first equation deals with the
yuxtaposition operator at the top:

{\codesize
\begin{verbatim}
%)

  op map2MaudeAttr : TermList -> TermList .
  eq map2MaudeAttr('__[TL]) = '__[map2MaudeAttr(TL)] .

***(%
\end{verbatim}
}

While the rest of equations just translates the attribute and continue with the rest
of the list, until the empty list is reached:

{\codesize
\begin{verbatim}
%)

  eq map2MaudeAttr(('constr.@CafeAttr@, TL)) = 'ctor.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('associative.@CafeAttr@, TL)) = 'assoc.@Attr@,
                                                    map2MaudeAttr(TL) .
  eq map2MaudeAttr(('assoc.@CafeAttr@, TL)) = 'assoc.@Attr@, map2MaudeAttr(TL) .

***(%
  ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  eq map2MaudeAttr(('l-assoc.@CafeAttr@, TL)) =
               'gather`(_`)['neTokenList['__[''E.Sort,''e.Sort]]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('r-assoc.@CafeAttr@, TL)) =
               'gather`(_`)['neTokenList['__[''e.Sort,''E.Sort]]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('commutative.@CafeAttr@, TL)) = 'comm.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('comm.@CafeAttr@, TL)) = 'comm.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('idempotent.@CafeAttr@, TL)) = 'idem.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('idem.@CafeAttr@, TL)) = 'idem.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('nonexec.@CafeAttr@, TL)) = 'nonexec.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr((':nonexec.@CafeAttr@, TL)) = 'nonexec.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('owise.@CafeAttr@, TL)) = 'owise.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('id:`(_`)['CafeBubble[T]], TL)) = 'id:_['bubble[T]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('id:_['CafeBubble[T]], TL)) = 'id:_['bubble[T]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('idr:`(_`)['CafeBubble[T]], TL)) = 'id:_['bubble[T]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('prec:_['CafeToken[T]], TL)) = 'prec_['token[T]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('metadata['CafeToken[T]], TL)) = 'metadata_['token[T]], map2MaudeAttr(TL) .

***(%
\end{comment}
}

{\codesize
\begin{verbatim}
%)

  eq map2MaudeAttr(empty) = empty .

***(%
\end{verbatim}
}

\item
The function \verb"cafeType2maudeType" transforms CafeOBJ error types into
Maude kinds:

{\codesize
\begin{verbatim}
%)

  op cafeType2maudeType : Term -> Term .
  eq cafeType2maudeType('__[TL]) = '__[cafeTypes2maudeTypes(TL)] .
  ceq cafeType2maudeType(T) = '`[_`]['sortToken[upTerm(Q')]]
   if Q := downQid(T) /\
      St := string(Q) /\
      0 == find(St, "?", 0) /\
      St' := substr(St, 1, length(St)) /\
      Q' := qid(St') .
  eq cafeType2maudeType(T) = 'sortToken[T] [owise] .

***(%
\end{verbatim}
}

\noindent
where the function \verb"cafeTypes2maudeTypes" just traverses the list
of terms, applying the function \texttt{cafeType2maudeType} to each term:

{\codesize
\begin{verbatim}
%)

  op cafeTypes2maudeTypes : TermList -> TermList .
  eq cafeTypes2maudeTypes(empty) = empty .
  eq cafeTypes2maudeTypes((T, TL)) = cafeType2maudeType(T),
                                     cafeTypes2maudeTypes(TL) .

***(%
\end{verbatim}
}

\end{itemize}

{\codesize
\begin{comment}
%)

  op parseHiddenSort : Term ~> Sort .
  eq parseHiddenSort('CafeToken[T]) =
     if downQid(T) :: Type
     then downQid(T)
     else qidError('\y 'Warning: '\o downQid(T) 'is 'not 'a 'valid 'sort. '\n)
     fi .
  eq parseHiddenSort(T) = qidError('\y 'Warning: '\o 'invalid 'sort. '\n) [owise] .

***(%
\end{comment}
}

Variables declared with the keyword \verb"var" are just translated as \verb"vars"
declarations.

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('var_:_.['neCafeTokenList[T], T'], PU, U, VDS, PSM, TSM, DB) =
                                                          < PDR, QIL, none, DB' >
   if < PDR, QIL, none, DB' > := parseCafeDecl('vars_:_.['neCafeTokenList[T], T'],
                                         PU, U, VDS, PSM, TSM, DB) .

***(%
\end{verbatim}
}

Otherwise, variables are parsed by adding them, with their sort, to the set of operators
used to parse terms in the current module:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('vars_:_.['neCafeTokenList[T], 'CafeToken[T']], PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS parseVars(downQidList(T), parseType('sortToken[T'])) > .

***(%
\end{verbatim}
}

Equations and transitions are parsed in a similar way, so we do not show all
the variations. An unconditional equation is parsed by adding the on-the-fly
variables in the righthand side to the set of current variables, and transforming
the attributes and then using \verb"parseDecl":

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('eq_=_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, PSM, TSM, DB) =
                                              < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(upTerm(QIL), VDS') /\
      TOTF' := renameOnTheFly(cafeEqAtS2maudeEqAts(T'), VDS') /\
      PDR := parseDecl('eq_=_.['bubble[TOTF], 'bubble[TOTF']], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('beq_=_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, PSM, TSM, DB) =
                                              < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := behavioralEq(renameOnTheFly(cafeEqAtS2maudeEqAts(T'), VDS')) /\
      PDR := parseDecl('eq_=_.['bubble[TOTF], 'bubble[TOTF']], PU, U, VDS) .

***(%
\end{comment}
}

Conditional equations are parsed in the same way, since the condition is dealt inside
the \verb"parseDecl" function:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('ceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS') /\
      PDR := parseDecl('ceq_=_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('cq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], PU, U,
                    VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS') /\
      PDR := parseDecl('ceq_=_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS) .

  ceq parseCafeDecl('bceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], PU, U,
                    VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := behavioralEq(renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS')) /\
      PDR := parseDecl('ceq_=_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS) .

  ceq parseCafeDecl('bcq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], PU, U,
                    VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := behavioralEq(renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS')) /\
      PDR := parseDecl('ceq_=_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS) .

***(%
\end{comment}
}

Transitions follow the same approach, although in this case the statement parsed
by \verb"parseDecl" is a Maude rule:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('trans_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U,
                    VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(cafeEqAtS2maudeEqAts(T'), VDS') /\
      PDR := parseDecl('rl_=>_.['bubble[TOTF], 'bubble[TOTF']], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('trns_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(cafeEqAtS2maudeEqAts(T'), VDS') /\
      PDR := parseDecl('rl_=>_.['bubble[TOTF], 'bubble[TOTF']], PU, U, VDS) .

  ceq parseCafeDecl('ctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS') /\
      PDR := parseDecl('crl_=>_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS) .

  ceq parseCafeDecl('ctrns_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS') /\
      PDR := parseDecl('crl_=>_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS') .

  ceq parseCafeDecl('btrans_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if QIL := downQidList(T) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := behavioralEq(renameOnTheFly(cafeEqAtS2maudeEqAts(T'), VDS')) /\
      PDR := parseDecl('rl_=>_.['bubble[TOTF], 'bubble[TOTF']], PU, U, VDS) .

  ceq parseCafeDecl('btrns_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if QIL := downQidList(T) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := behavioralEq(renameOnTheFly(cafeEqAtS2maudeEqAts(T'), VDS')) /\
      PDR := parseDecl('rl_=>_.['bubble[TOTF], 'bubble[TOTF']], PU, U, VDS) .

  ceq parseCafeDecl('bctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := downQidList(T) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := behavioralEq(renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS')) /\
      PDR := parseDecl('crl_=>_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS) .

  ceq parseCafeDecl('bctrns_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := behavioralEq(renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS')) /\
      PDR := parseDecl('crl_=>_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS) .

***(%
\end{comment}
}

The auxiliary functions for parsing equations and transitions are:

\begin{itemize}
\item
\verb"cafeEqAtS2maudeEqAts", which just applies \texttt{cafeEqAtS2maudeEqAts*}
if it finds any attribute:

{\codesize
\begin{verbatim}
%)

  op cafeEqAtS2maudeEqAts : Term -> Term .
  eq cafeEqAtS2maudeEqAts('__[TL]) = '__[cafeEqAtS2maudeEqAts*(TL)] .
  eq cafeEqAtS2maudeEqAts(T) = T [owise] .

***(%
\end{verbatim}
}

\noindent
where \texttt{cafeEqAtS2maudeEqAts} traverses the list and transforms
the possible attributes appearing in equations and transitions:

{\codesize
\begin{verbatim}
%)

  op cafeEqAtS2maudeEqAts* : TermList -> TermList .
  eq cafeEqAtS2maudeEqAts*((TL, ''`{.Qid, ''owise.Qid, TL'', ''`}.Qid)) =
                      TL, ''`[.Qid, ''owise.Qid, TL'', ''`].Qid .
  eq cafeEqAtS2maudeEqAts*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) =
                      TL, ''`[.Qid, ''nonexec.Qid, TL'', ''`].Qid .
  eq cafeEqAtS2maudeEqAts*((TL, ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid)) =
                      TL, ''`[.Qid, ''metadata.Qid, TL'', ''`].Qid .
  eq cafeEqAtS2maudeEqAts*(TL) = TL [owise] .

  op behavioralEq : Term -> TermList .
  eq behavioralEq('__[TL]) = '__[behavioralEq*(TL)] .
  eq behavioralEq(T) = '__[T, ''`[.Qid, ''metadata.Qid, ''"behavioral".Sort, ''`].Qid] [owise] .

  op behavioralEq* : TermList -> TermList .
  eq behavioralEq*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) =
                      TL, ''`[.Qid, ''nonexec.Qid, TL'', ''metadata.Qid, ''"behavioral".Sort,''`].Qid .
  eq behavioralEq*((TL, ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid)) =
                      TL, ''`[.Qid, ''metadata.Qid, TL'', ''metadata.Qid, ''"behavioral".Sort,''`].Qid .
  eq behavioralEq*(TL) = TL, ''`[.Qid, ''metadata.Qid, ''"behavioral".Sort,''`].Qid [owise] .


***(%
\end{verbatim}
}

\item
\verb"improveLabel", which removes spaces from the label and introduces a letter if
it starts with another character:

{\codesize
\begin{verbatim}
%)

  var STR : String .

  op improveLabel : QidList -> QidList .
  ceq improveLabel('`[ Q Q' QIL '`] ': QIL') = improveLabel('`[ Q'' QIL '`] ': QIL')
   if Q' =/= '`] /\
      Q'' := qid(string(Q) + "-" + string(Q')) .
  eq improveLabel('`[ Q '`] ': QIL) = '`[ startsByLetterOrNumber(Q) '`] ': QIL .
  eq improveLabel(QIL) = QIL [owise] .

  op startsByLetterOrNumber : Qid -> Qid .
  ceq startsByLetterOrNumber(Q) = startsByLetterOrNumber(STR)
   if STR := string(Q) .
  eq startsByLetterOrNumber(Q) = Q [owise] .

  op startsByLetterOrNumber : String -> Qid .
  ceq startsByLetterOrNumber(STR) =
            if (N >= 65 and N <= 90) or (N >= 97 and N <= 122)
            then qid(STR)
            else qid("cafe-label-" + STR)
            fi
   if N := ascii(substr(STR, 0, 1)) .

***(%
\end{verbatim}
}

\item
\verb"opDeclSetFromQidList", which extracts an \verb"OpDeclSet" from a list of quoted
identifiers to extend the variable set with the variables defined on the fly in CafeOBJ:

{\codesize
\begin{verbatim}
%)

  op opDeclSetFromQidList : QidList -> OpDeclSet .
  eq opDeclSetFromQidList(nil) = none .
  ceq opDeclSetFromQidList(Q QL) = op qid(St') : nil -> qid(St'') [none] .
                                   opDeclSetFromQidList(QL)
   if Q =/= ': /\
      St := string(Q) /\
      N := find(St, ":", 0) /\
      St' := substr(St, 0, N) /\
      St'' := substr(St, s(N), length(St)) /\
      St'' =/= "" .
  eq opDeclSetFromQidList(Q QL) = opDeclSetFromQidList(QL) [owise] .

  op renameOnTheFly : Term OpDeclSet -> Term .
  eq renameOnTheFly('__[TL], VDS) = '__[renameOnTheFly*(TL, VDS)] .
  ceq renameOnTheFly(C, VDS) = upTerm(Q')
   if Q := downQid(C) /\
      op Q : nil -> Ty [none] . VDS' := VDS /\
      St := string(Q) /\
      St' := string(Ty) /\
      St'' := St + ":" + St' /\
      Q' := qid(St'') .
  eq renameOnTheFly(T, VDS) = T [owise] .


  op renameOnTheFly* : TermList OpDeclSet -> TermList .
  eq renameOnTheFly*(empty, VDS) = empty .
  eq renameOnTheFly*((T, TL), VDS) = renameOnTheFly(T, VDS), renameOnTheFly*(TL, VDS) .
***(%
\end{verbatim}
}

\end{itemize}

% The reduction and induction commands are just skipped when parsing a module.
% We will deal with them separately in the open-close environment:

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('reduce_.[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl('red_.[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':goal`{_`}[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':ind`on`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':apply`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':sel`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':postpone`..@CafeInductiveComm@, PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':imp`[_`].[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':imp`[_`]by`{_`}[T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:ctf`{_`}[T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:ctf`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:cvss`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:cvvs`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:cvsv`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:cevss`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:cevs`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:cesv`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:cesvs`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':show`proof.@CafeInductiveComm@, PU, U, VDS, PSM, TSM, DB) =
                                                               < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':desc`proof.@CafeInductiveComm@, PU, U, VDS, PSM, TSM, DB) =
                                                               < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':desc`..@CafeInductiveComm@, PU, U, VDS, PSM, TSM, DB) =
                                                               < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':id`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':proof`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .

***(%
\end{comment}
}

{\codesize
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
}

The module \verb"CafePARSER" is in charge of parsing complete modules and views:

{\codesize
\begin{verbatim}
%)

load search_predicate.maude

mod CafePARSER is
  inc CafeDECL-PARSING .
  pr DATABASE-HANDLING .
  pr SEARCH_PREDICATE .
  pr MACROS .
  pr GOAL .

***(%
\end{verbatim}
}

It builds a new term of sort \verb"CafeParseResult" returning the updated database and
a list of quoted identifiers reporting the errors found during the parsing process:

{\codesize
\begin{verbatim}
%)

  op <_,_> : Database QidList -> CafeParseResult [ctor] .
  op <_,_,_,_> : Database SortMap TheorySortMap QidList -> CafeParseResult [ctor] .

***(%
\end{verbatim}
}

% We also define other constructor for \verb"CafeParseResult", that will be
% used in open-close environments. Since these environments do not change the
% database, it is composed of a list of quoted identifiers pointing out the
% errors found during the parsing, and another list showing the results of the
% reduction commands:

{\codesize
\begin{comment}
%)

  op <_|_|_|_> : Database ScoreInfoMap QidList QidList -> CafeParseResult [ctor] .

***(%
\end{comment}
}

{\codesize
\begin{comment}
%)

  vars T T' T'' T''' T1 T2 T3 T4 T5 T6 TP TI : Term .
  var  T? : [Term] .
  vars TL TL' TL'' PL PL' TLR TL1 TL2 : TermList .
  vars V V' : Variable .
  vars C C' : Constant .
  vars DB DB' : Database .
  *** TN: TheoryName
  vars F Q Q' Q'' QI QI' TN ID : Qid .
  *** TS: TheorySort
  var  TS : Sort .
  vars QIL QIL' QIL'' : QidList .
  vars S S' S'' S''' St St' St'' St''' : String .
  vars CafeM CafeM' : CafeModule .
  var  VDS : OpDeclSet .
  vars PDR PDR' : ParseDeclResult .
  vars PU PU' U U' M : Module .
  vars Ty Ty1 Ty2 : Type .
  vars N N' N'' : Nat .
  **** PSM: Principal Sort Map
  vars PSM PSM' SM SM' : SortMap .
  vars TSM TSM' HSM HSM' : TheorySortMap .
  vars QS QS' : QidSet .
  vars MACS MACS' : Macros .
  var  H : Header .
  var  I : Import .
  vars IL IL' : ImportList .
  var  Srt : Sort .
  vars SS SS' : SortSet .
  var  SSDS : SubsortDeclSet .
  vars ODS ODS' : OpDeclSet .
  var  OD : OpDecl .
  var  MAS : MembAxSet .
  vars EqS EqS' : EquationSet .
  var  RS : RuleSet .
  var  M? : [Module] .
  vars M' M'' M''' M1 M2 M3 : Module .
  vars DB'' DB3 : Database .
  vars AtS AtS' : AttrSet .
  var  CND : Condition .
  vars ST ST' ST'' : SharingTable .
  vars G G' G'' : Goal .
  var  TyL : TypeList .
  vars Eq Eq' : Equation .
  var  CMD : Qid .
  vars P P' P'' : ProofTree .
  vars PrL PrL' PrL'' PrL1 PrL2 : ProofTreeList .
  vars B B' : Bool .
  var  SR : SearchRes .
  vars NL NL' : NatList .
  vars PO PO' PO'' : ProofOrder .
  vars SIM SIM' : ScoreInfoMap .
  vars SIS SIS1 SIS2 : ScoreInfoSet .
  vars CS CS' : ConsSub .
  var  ML : MList .
  var  MLb : MacroLabel .
  var  TrS : TermSet .
  var  SB : Substitution .
  var  SISP : SISPair .

***(%
\end{comment}
}

The constants \verb"errModName" and \texttt{paramThWarn} will report specific
errors:

{\codesize
\begin{verbatim}
%)

  op errModName : -> QidList .
  eq errModName = '\n '\r 'ERROR: '\o 'The 'module 'name 'is 'not 'a
                  'valid 'identifier. .

  op paramThWarn : -> QidList .
  eq paramThWarn = '\n '\r 'Warning: '\o 'Parameterized 'theories 'are 'not 'allowed
                   'in 'Maude. '\n 'The 'module 'was 'introduced 'with '\g 'tight '\o
                   'semantics. '\n .

***(%
\end{verbatim}
}

The function in charge of parsing modules is \verb"procCafeMod". It receives as
arguments the term to be parsed and the current Full Maude database. It just duplicates
the term to be parsed and calls to \verb"procCafeMod2":

{\codesize
\begin{verbatim}
%)

  op procCafeMod : Term SortMap TheorySortMap TheorySortMap Database -> CafeParseResult .
  eq procCafeMod(T, PSM, HSM, TSM, DB) = procCafeMod2(T, T, PSM, HSM, TSM, DB) .

***(%
\end{verbatim}
}

The function \verb"procCafeMod2" distinguishes between modules with loose and
tight semantics. Modules with tight semantics, will be translated as Maude modules,
and hence we just use the function \verb"procCafeMod3", propagating the parameters
if required. Note that we use an empty module, \verb"emptyFModule", indicating that
it has tight semantics:

{\codesize
\begin{verbatim}
%)

  op procCafeMod2 : Term Term SortMap TheorySortMap TheorySortMap Database
                    -> CafeParseResult .
  eq procCafeMod2(T, 'cmod!_`{_`}['CafeToken[T'], T''], PSM, HSM, TSM, DB) =
                      procCafeMod3(T, 'CafeToken[T'], empty, T'',
                                   emptyFModule, PSM, HSM, TSM, DB) .
  eq procCafeMod2(T, 'cmod!_`{_`}['_`(_`)[T', T''], T3], PSM, HSM, TSM, DB) =
                      procCafeMod3(T, T', T'', T3, emptyFModule, PSM, HSM, TSM, DB) .
  ceq procCafeMod2(T, 'cmod!_`{_`}['_`[_`]['CafeToken[T'], 'CafeToken[TP]], T3], PSM,
                   HSM, TSM, DB) =
                 procCafeMod3(T, 'CafeToken[T'], empty, T3, emptyFModule, PSM', HSM, TSM, DB)
   if QI := downQid(T') /\
      QI' := downQid(TP) /\
      PSM' := add2PrincipalMap(QI, QI', PSM) .
  ceq procCafeMod2(T, 'cmod!_`{_`}['_`{_|_`}['CafeToken[T'], T'', 'CafeToken[TP]], T3],
                   PSM, HSM, TSM, DB) =
                      procCafeMod3(T, 'CafeToken[T'], T'', T3, emptyFModule, PSM', HSM, TSM, DB)
   if QI := downQid(T') /\
      QI' := downQid(TP) /\
      PSM' := add2PrincipalMap(QI, QI', PSM) .

  op add2PrincipalMap : Qid Qid SortMap -> SortMap .
  eq add2PrincipalMap(QI, QI', (QI |-> Q, PSM)) = QI |-> QI', PSM .
  eq add2PrincipalMap(QI, QI', PSM) = QI |-> QI', PSM [owise] .

***(%
\end{verbatim}
}

When parsing modules with loose semantics first introduce them as a theory but,
in order to accept a wider range of CafeOBJ modules, we also introduce it into the
database as a module, adding the suffix \verb"-MODCAFE" to its name.
Note that we do not allow parameterized theories, so we use the \verb"paramThWarn"
message when they are used.
%
Also note that we use an empty module or theory depending of the semantics we
want to use:

{\codesize
\begin{verbatim}
%)

  ceq procCafeMod2(T, 'cmod*_`{_`}['CafeToken[T'], T''], PSM, HSM, TSM, DB) =
        if QIL == nil
        then procCafeMod3(T, T3, empty, T'', emptyFModule, PSM', HSM', TSM, DB')
        else < DB', PSM', HSM', QIL >
        fi
   if < DB', PSM', HSM', QIL > := procCafeMod3(T, 'CafeToken[T'], empty, addBool(T''),
                                         emptyFTheory, PSM, HSM, TSM, DB) /\
      QI := downQid(T') /\
      QI' := qid(string(QI) + "-MODCAFE") /\
      T3 := 'CafeToken[upTerm(QI')] .
  ceq procCafeMod2(T, 'cmod*_`{_`}['_`[_`]['CafeToken[T'], 'CafeToken[TP]], T''], PSM,
                   HSM, TSM, DB) =
        if QIL == nil
        then procCafeMod3(T, T3, empty, T'', emptyFModule, PSM', HSM', TSM, DB')
        else < DB', PSM', HSM', QIL >
        fi
   if QI := downQid(T') /\
      Q := downQid(TP) /\
      QI' := qid(string(QI) + "-MODCAFE") /\
      T3 := 'CafeToken[upTerm(QI')] /\
      PSM' := add2PrincipalMap(QI, Q, PSM) /\
      < DB', PSM', HSM', QIL > := procCafeMod3(T, 'CafeToken[T'], empty, addBool(T''),
                                         emptyFTheory, PSM', HSM, TSM, DB) .
  ceq procCafeMod2(T, 'cmod*_`{_`}['_`{_|_`}['CafeToken[T'], T'','CafeToken[TP]], T3],
                   PSM, HSM, TSM, DB) =
        if QIL == nil
        then < DB', PSM', HSM', paramThWarn >
        else < DB', PSM', HSM', QIL >
        fi
   if QI := downQid(T') /\
      Q := downQid(TP) /\
      PSM' := add2PrincipalMap(QI, Q, PSM) /\
      < DB', PSM', HSM', QIL > := procCafeMod3(T, 'CafeToken[T'], T'', addBool(T3),
                                         emptyFModule, PSM', HSM, TSM, DB) .

 op addBool : Term -> Term .
 eq addBool(T) = if addsBool?(T)
                 then T
                 else '__['inc`(_`)['token[''BOOL.Qid]], T]
                 fi .

 op addsBool? : Term -> Bool .
 eq addsBool?('__[TL]) = addsBool?*(TL) .
 eq addsBool?('pr`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?('protecting`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?('inc`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?('including`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?('ex`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?('extending`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?('us`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?('using`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?(T) = false [owise] .

 op addsBool?* : TermList -> Bool .
 eq addsBool?*((T, TL)) = addsBool?(T) or addsBool?*(TL) .
 eq addsBool?*(empty) = false .

***(%
\end{verbatim}
}

In other case an error is returned:

{\codesize
\begin{verbatim}
%)

***  eq procCafeMod2(T, Q[T', T''], DB) = < DB, errModName > [owise] .

***(%
\end{verbatim}
}

The function \verb"procCafeMod3" deals with parameterized modules. If the current
modules is not parameterized we just set the name of the module and apply the
\texttt{procCafeMod4} function:

{\codesize
\begin{verbatim}
%)

  op procCafeMod3 : Term Term Term Term Module SortMap TheorySortMap TheorySortMap
                    Database -> CafeParseResult .
  ceq procCafeMod3(T, 'CafeToken[T'], empty, T'', U, PSM, HSM, TSM, DB) =
         procCafeMod4(T, T'', setName(U, QI), setName(U, QI), none, PSM, HSM, TSM, DB)
   if QI := downQid(T') .

***(%
\end{verbatim}
}

When the module is parameterized we set the name of the module and then parse
the parameters to introduce them into the current module.
We use the \texttt{parseParList} function from Full Maude, which returns a
parameter list from a term.

{\codesize
\begin{verbatim}
%)

  ceq procCafeMod3(T, 'CafeToken[T'], PL, T'', U, PSM, HSM, TSM, DB) =
         procCafeMod4(T, T3, setPars(setName(U, QI), parseParList(PL')),
                      setName(U, QI), none, PSM, HSM, TSM, DB)
   if PL =/= empty /\
      PL' := cafeParam2maudeParam(PL) /\
      QI := downQid(T') /\
      QIL := cafeParamNames(PL) /\
      SM := cafeTheoryMap(PL) /\
      TSM' := restrictTheorySortMap(TSM, SM) /\
      T3 := paramSortsMap(T'', TSM', QIL) .

  op restrictTheorySortMap : TheorySortMap SortMap -> TheorySortMap .
  eq restrictTheorySortMap((Q -> SS, TSM), (Q' |-> Q, SM)) =
                                       (Q' -> SS), restrictTheorySortMap(TSM, SM) .
  eq restrictTheorySortMap(TSM, SM) = empty [owise] .

  op cafeTheoryMap : Term -> SortMap .
  eq cafeTheoryMap('_::_['CafeToken[T], 'token[T']]) = downQid(T) |-> downQid(T') .
  ceq cafeTheoryMap('_`,_[T, T']) = SM, SM'
   if SM := cafeTheoryMap(T) /\
      SM' := cafeTheoryMap(T') .

***(%
\end{verbatim}
}

In other case an error is returned:

{\codesize
\begin{verbatim}
%)

  eq procCafeMod3(T, T', PL, T'', U, PSM, HSM, TSM, DB) = < DB, PSM, HSM, errModName > [owise] .

***(%
\end{verbatim}
}

The auxiliary functions required to deal with parameters are:
\begin{itemize}
\item
\verb"cafeParam2maudeParam", which translates the parameter declaration to Maude syntax:

{\codesize
\begin{verbatim}
%)

  op cafeParam2maudeParam : Term -> Term .
  eq cafeParam2maudeParam('_::_['CafeToken[T], T']) = '_::_['token[T], T'] .
  ceq cafeParam2maudeParam('_`,_[T, T']) = '_`,_[T'', T3]
   if T'' := cafeParam2maudeParam(T) /\
      T3 := cafeParam2maudeParam(T') .

***(%
\end{verbatim}
}

\item
\verb"cafeParamNames", which extracts the name of the parameters:

{\codesize
\begin{verbatim}
%)

  op cafeParamNames : Term -> QidList .
  eq cafeParamNames('_::_['CafeToken[T], T']) = downQid(T) .
  ceq cafeParamNames('_`,_[T, T']) = QIL QIL'
   if QIL := cafeParamNames(T) /\
      QIL' := cafeParamNames(T') .

***(%
\end{verbatim}
}

\item
\verb"paramSortsMap", which transforms the qualified sorts in CafeOBJ syntax into
qualified sorts in Maude syntax. It renames constants (which includes the
metarepresentation of variables) by using the names of the parameters obtained with
\texttt{cafeParamNames}. If the function is a composed term, it applies
\texttt{paramSortsMap*}:

{\codesize
\begin{verbatim}
%)

  op paramSortsMap : Term TheorySortMap QidList -> Term .
  eq paramSortsMap(Q[TL], TSM, QIL) = Q[paramSortsMap*(TL, TSM, QIL)] .

***(%
\end{verbatim}
}

Variables are not modified:

{\codesize
\begin{verbatim}
%)

  eq paramSortsMap(V, TSM, QIL) = V .

***(%
\end{verbatim}
}

For constants, we distinguish whether they stand for a constant (including sorts)
or for a variable. When they stand for a constant, (i.e., the String \verb@":"@ cannot
be found) we split the term looking for the \verb@"."@ String, which is used in CafeOBJ
to qualify sorts, and built it again by using the \verb@"$"@ used by Maude:

{\codesize
\begin{verbatim}
%)

  ceq paramSortsMap(C, TSM, QIL) = upTerm(QI)
   if Q := downQid(C) /\
      St := string(Q) /\
      find(St, ":", 0) == notFound /\
      N := find(St, ".", 0) /\
      St' := substr(St, 0, N) /\
      St'' := substr(St, N + 1, length(St)) /\
      Q' := qid(St'') /\
      Q' in QIL /\
      QI := qid(St'' + "$" + St') .

  ceq paramSortsMap(C, (TN -> (TS ; SS), TSM), QIL) = upTerm(QI)
   if TS := downQid(C) /\
      St := string(TS) /\
      QI := qid(string(TN) + "$" + St) .

  ceq paramSortsMap(C, TSM, QIL) = upTerm(QI)
   if Q := downQid(C) /\
      St := string(Q) /\
      find(St, ":", 0) == notFound /\
      N := find(St, ".", 0) /\
      St' := substr(St, 0, N) /\
      St'' := substr(St, N + 1, length(St)) /\
      Q' := qid(St'') /\
      Q'' := paramSortsMap(upTerm(Q'), TSM, QIL) /\
      QI := qid(St' + "." + string(Q'')) [owise] .

***(%
\end{verbatim}
}

When the constant stands for a variable, we proceed in a similar way but taking into
account that the name of the variable must be placed first in both cases:

{\codesize
\begin{verbatim}
%)

  ceq paramSortsMap(C, TSM, QIL) = upTerm(QI)
   if Q := downQid(C) /\
      St := string(Q) /\
      N := find(St, ":", 0) /\
      N' := find(St, ".", 0) /\
      St' := substr(St, 0, N + 1) /\
      St'' := substr(St, N + 1, _-_(N', N + 1)) /\
      St''' := substr(St, N' + 1, length(St)) /\
      Q' := qid(St''') /\
      Q' in QIL /\
      QI := qid(St' + St''' + "$" + St'') .

  ceq paramSortsMap(C, (TN -> (TS ; SS), TSM), QIL) = upTerm(QI)
   if Q := downQid(C) /\
      St := string(Q) /\
      N := find(St, ":", 0) /\
      St' := substr(St, 0, N + 1) /\
      St'' := substr(St, N + 1, length(St)) /\
      TS := qid(St'') /\
      QI := qid(St' + string(TN) + "$" + St'') .

***(%
\end{verbatim}
}

In other case, the constant is not modified:

{\codesize
\begin{verbatim}
%)

  eq paramSortsMap(C, TSM, QIL) = C [owise] .

***(%
\end{verbatim}
}

\item
\verb"paramSortsMap*", which just traverses the list, applying
\texttt{paramSortsMap} to each element:

{\codesize
\begin{verbatim}
%)

  op paramSortsMap* : TermList TheorySortMap QidList -> TermList .
  eq paramSortsMap*(empty, TSM, QIL) = empty .
  eq paramSortsMap*((T, TL), TSM, QIL) = paramSortsMap(T, TSM, QIL),
                                         paramSortsMap*(TL, TSM, QIL) .

***(%
\end{verbatim}
}

\item
\verb"_in_", which looks for a quoted identifier in a list:

{\codesize
\begin{verbatim}
%)

  op _in_ : Qid QidList -> Bool .
  eq Q in nil = false .
  eq Q in Q QIL = true .
  eq Q in QIL = false [owise] .

***(%
\end{verbatim}
}

\end{itemize}

The function \verb"procCafeMod4" traverses the module, applying the function
\verb"parseCafeDecl" shown above to each statement:

{\codesize
\begin{verbatim}
%)

  op procCafeMod4 : Term Term Module Module OpDeclSet SortMap TheorySortMap TheorySortMap
                    Database -> CafeParseResult .
  ceq procCafeMod4(T, '__[T', T''], PU, U, VDS, PSM, HSM, TSM, DB) =
        if QIL == nil
        then procCafeMod4(T, T'', preModule(PDR), unit(PDR), vars(PDR), PSM, HSM', TSM, DB')
        else < DB, PSM, HSM', QIL >
        fi
   if < PDR, QIL, SS, DB' > := parseCafeDecl(T', PU, U, VDS, PSM, TSM, DB) /\
      HSM' := addHiddenSort(HSM, getName(U), SS) .

  op addHiddenSort : TheorySortMap Qid SortSet -> TheorySortMap .
  eq addHiddenSort((Q -> SS, HSM), Q, SS') = (Q -> (SS ; SS'), HSM) .
  eq addHiddenSort(HSM, Q, SS) = Q -> SS, HSM [owise] .

***(%
\end{verbatim}
}

When only one statement remains it is parsed and the module is evaluated by means
of the \verb"evalPreModule" function:

{\codesize
\begin{verbatim}
%)

  ceq procCafeMod4(T, F[TL], PU, U, VDS, PSM, HSM, TSM, DB) = < DB3, PSM, HSM', nil >
   if F =/= '__ /\
      < PDR, nil, SS, DB' > := parseCafeDecl(F[TL], PU, U, VDS, PSM, TSM, DB) /\
      DB'' := evalPreModule(predefinedCafeEqual(preModule(PDR)),
                            predefinedCafeEqual(unit(PDR)),
                            vars(PDR), insTermModule(getName(U), T, DB')) /\
      DB3 := updateDatabase4cafe(getName(U), DB'') /\
      HSM' := addHiddenSort(HSM, getName(U), SS) .

  ceq procCafeMod4(T, C, PU, U, VDS, PSM, HSM, TSM, DB) = < DB3, PSM, HSM', nil >
   if < PDR, nil, SS, DB' > := parseCafeDecl(C, PU, U, VDS, PSM, TSM, DB) /\
      DB'' := evalPreModule(predefinedCafeEqual(preModule(PDR)),
                            predefinedCafeEqual(unit(PDR)),
                            vars(PDR), insTermModule(getName(U), T, DB')) /\
      DB3 := updateDatabase4cafe(getName(U), DB'') /\
      HSM' := addHiddenSort(HSM, getName(U), SS) .

  ceq procCafeMod4(T, F[TL], PU, U, VDS, PSM, HSM, TSM, DB) = < DB, PSM, HSM', QIL >
   if F =/= '__ /\
      < PDR, QIL, SS, DB' > := parseCafeDecl(F[TL], PU, U, VDS, PSM, TSM, DB) /\
      QIL =/= nil /\
      HSM' := addHiddenSort(HSM, getName(U), SS) .

***  vars Set Set' : SET .
  vars ME ME' : ModuleExpression .
  var  RenS : RenamingSet .
  var  ParamL : ParameterList .

  vars U'' U3 U4 U5 TM TM' FM FM' : Module .
***  var  VDS : OpDeclSet .
  vars MNS MNS' MNS'' MNS3 MNS4 MNS5 MNS6 : Set{ModuleName} .
  vars VES VES' VES'' VES3 : Set{ViewExp} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars STR STR' : String .
  var  COND : Condition .

  op nonexecInLabel : Module -> Module .
  eq nonexecInLabel(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm) =
       fmod H is IL sorts SS . SSDS ODS MAS nonexecInLabel(EqS) endfm .
  eq nonexecInLabel(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm) =
       mod H is IL sorts SS . SSDS ODS MAS nonexecInLabel(EqS) RS endm .
  eq nonexecInLabel(fth H is IL sorts SS . SSDS ODS MAS EqS endfth) =
       fth H is IL sorts SS . SSDS ODS MAS nonexecInLabel(EqS) endfth .
  eq nonexecInLabel(th H is IL sorts SS . SSDS ODS MAS EqS RS endth) =
       th H is IL sorts SS . SSDS ODS MAS nonexecInLabel(EqS) RS endth .
  eq nonexecInLabel(M?) = M? [owise] .

  op nonexecInLabel : EquationSet -> EquationSet .
  eq nonexecInLabel((none).EquationSet) = none .
  eq nonexecInLabel(eq T = T' [AtS] . EqS) = eq T = T' [nonexecInLabel(AtS)] .
                                             nonexecInLabel(EqS) .
  eq nonexecInLabel(ceq T = T' if COND [AtS] . EqS) =
             ceq T = T' if COND [nonexecInLabel(AtS)] . nonexecInLabel(EqS) .

  op nonexecInLabel : AttrSet -> AttrSet .
  eq nonexecInLabel(label('cafe-label-:nonexec) AtS) = nonexec AtS .
  ceq nonexecInLabel(label(Q) AtS) = label(Q') nonexec AtS
   if STR := string(Q) /\
      N := find(STR, "-:nonexec", 0) /\
      STR' := substr(STR, 0, N) + substr(STR, N + 9, length(STR)) /\
      Q' := qid(STR') .
  ceq nonexecInLabel(label(Q) AtS) = label(Q') nonexec AtS
   if STR := string(Q) /\
      N := find(STR, "cafe-label-:nonexec-", 0) /\
      STR' := substr(STR, 0, N) + substr(STR, N + 20, length(STR)) /\
      Q' := qid(STR') .
  eq nonexecInLabel(AtS) = AtS [owise] .

  op updateDatabase4cafe : ModuleExpression Database -> Database .
  ceq updateDatabase4cafe(ME, DB) = DB'
   if DB' := updateDatabase4cafeAux(ME, DB) .
  eq updateDatabase4cafe(ME, DB) = DB [owise] .

  op filterPredefEqs : EquationSet -> EquationSet .
  eq filterPredefEqs(eq T = T' [AtS metadata("built-in in CafeOBJ")] . EqS) =
                                        filterPredefEqs(EqS) .
  eq filterPredefEqs(ceq T = T' if CND [AtS metadata("built-in in CafeOBJ")] . EqS) =
                                        filterPredefEqs(EqS) .
  eq filterPredefEqs(EqS) = EqS [owise] .

  op isSystem : Module -> Bool .
  eq isSystem(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm) = true .
  eq isSystem(th H is IL sorts SS . SSDS ODS MAS EqS RS endth) = true .
  eq isSystem(M) = false [owise] .

  op updateDatabase4cafeAux : ModuleExpression Database -> Database .
  ceq updateDatabase4cafeAux(ME, DB) =
             db(< ME ; T ; nonexecInLabel(addEqual&SearchEqs(U')) ;
                  nonexecInLabel(addEqual&SearchEqs(U'')) ; U3 ;
                  VDS ; MNS ; VES > MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)
   if db(< ME ; T ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS', VIS, VES', MNS'',
           MNS3, MNS4, QIL) := DB /\
      U5 := getFlatModule(modExp(evalModExp(ME, DB)),
                 database(evalModExp(ME, DB))) .
  eq updateDatabase4cafeAux(ME, DB) = DB [owise] .

  op addEqual&SearchEqs : Module -> Module .
  ceq addEqual&SearchEqs(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm) =
                         fmod H is IL sorts SS . SSDS ODS MAS (EqS EqS') endfm
   if EqS' := createEqsFromSorts(SS) createEqsFromImports(IL) .
  ceq addEqual&SearchEqs(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm) =
                         mod H is IL sorts SS . SSDS ODS MAS (EqS EqS') RS endm
   if EqS' := createEqsFromSorts(SS) createEqsFromImports(IL) .
  ceq addEqual&SearchEqs(fth H is IL sorts SS . SSDS ODS MAS EqS endfth) =
                         fth H is IL sorts SS . SSDS ODS MAS (EqS EqS') endfth
   if EqS' := createEqsFromSorts(SS) createEqsFromImports(IL) .
  ceq addEqual&SearchEqs(th H is IL sorts SS . SSDS ODS MAS EqS RS endth) =
                         th H is IL sorts SS . SSDS ODS MAS (EqS EqS') RS endth
   if EqS' := createEqsFromSorts(SS) createEqsFromImports(IL) .

  op predefinedCafeEqual : Module -> Module .
  ceq predefinedCafeEqual(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm) =
                          fmod H is IL' sorts SS . SSDS ODS MAS EqS endfm
   if IL' := (IL protecting 'EQL .) .
  ceq predefinedCafeEqual(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm) =
                          mod H is IL' sorts SS . SSDS ODS MAS EqS RS endm
   if IL' := (IL protecting 'EQL . protecting 'RWL .) .
  ceq predefinedCafeEqual(fth H is IL sorts SS . SSDS ODS MAS EqS endfth) =
                          fth H is IL' sorts SS . SSDS ODS MAS EqS endfth
   if IL' := (IL protecting 'EQL .) .
  ceq predefinedCafeEqual(th H is IL sorts SS . SSDS ODS MAS EqS RS endth) =
                          th H is IL' sorts SS . SSDS ODS MAS EqS RS endth
   if IL' := (IL protecting 'EQL . protecting 'RWL .) .
  eq predefinedCafeEqual(M?) = M? [owise] .

  op createEqsFromSorts : SortSet -> EquationSet .
  eq createEqsFromSorts(none) = none .
  ceq createEqsFromSorts(Srt ; SS) = eq '_=_[V, V] = 'true.Bool [metadata("built-in in CafeOBJ")] .
                                     createEqsFromSorts(SS)
   if V := qid("V:" + string(Srt)) /\
      V' := qid("V':" + string(Srt)) .

  op createEqsFromImports : ImportList -> EquationSet .
  eq createEqsFromImports(nil) = none .
  eq createEqsFromImports(I IL) = createEqsFromImport(I) createEqsFromImports(IL) .

  op createEqsFromImport : Import -> EquationSet .
  eq createEqsFromImport(protecting ME .) = createEqsFromME(ME) .
  eq createEqsFromImport(extending ME .) = createEqsFromME(ME) .
  eq createEqsFromImport(including ME .) = createEqsFromME(ME) .

  op createEqsFromME : ModuleExpression -> EquationSet .
  eq createEqsFromME(Q) = getEqs4Predefined(Q) .
  eq createEqsFromME(ME + ME') = createEqsFromME(ME) createEqsFromME(ME') .
  eq createEqsFromME(ME * (RenS)) = createEqsFromME(ME) .
  eq createEqsFromME(ME{ParamL}) = createEqsFromME(ME) .

  vars V1 V2 V3 : Variable .

  op getEqs4Predefined : Qid -> EquationSet .
  ceq getEqs4Predefined('NAT) =
                eq '_=_[V1, V1] = 'true.Bool [metadata("built-in in CafeOBJ")] .
                eq '_=_[V2, V2] = 'true.Bool [metadata("built-in in CafeOBJ")] .
                eq '_=_[V3, V3] = 'true.Bool [metadata("built-in in CafeOBJ")] .
   if V1 := 'V:Zero /\
      V2 := 'V:NzNat /\
      V3 := 'V:Nat .
  eq getEqs4Predefined(Q) = none [owise] .

***(%
\end{verbatim}
}

The function \verb"procCafeView" is in charge of processing views. It just
translates the view and introduces it into the database:

{\codesize
\begin{verbatim}
%)

  op procCafeView : Term SortMap Database -> CafeParseResult .
  ceq procCafeView('cview_from_to_`{`}[T, 'token[T'], 'token[T'']], PSM, DB) =
           procCafeView('cview_from_to_`{_`}[T, 'token[T'], 'token[T''], T3], PSM, DB)
   if Q := downQid(T') /\
      Q' := downQid(T'') /\
      (Q' |-> QI, PSM') := PSM /\
      M := getFlatModule(Q, DB) /\
      'Bool ; Srt := getSorts(M) /\
      QI =/= Srt /\
      T3 := 'sort_->_.['CafeToken[upTerm(Srt)], 'CafeToken[upTerm(QI)]] .
  ceq procCafeView(T, PSM, DB) = < DB', nil >
   if T' := view2view(T) /\
      DB' := procView(T', DB) [owise] .

***(%
\end{verbatim}
}

\noindent
where the auxiliary functions behave as follows:
\begin{itemize}
\item
\verb"view2view" translates the term to Maude syntax, and then applies
the \verb"maps2maps" function shown above to the body:

{\codesize
\begin{verbatim}
%)

  op view2view : Term -> Term .
  eq view2view('cview_from_to_`{_`}[T, T', T'', T3]) =
        'view_from_to_is_endv[token2token(T), T', T'', maps2maps(T3)] .
  eq view2view('cview_from_to_`{`}[T, T', T'']) =
        'view_from_to_is_endv[token2token(T), T', T'', 'none.ViewDeclSet] .

***(%
\end{verbatim}
}

\item
\verb"token2token" translates a CafeOBJ token into a Maude token:

{\codesize
\begin{verbatim}
%)

  op token2token : Term -> Term .
  eq token2token('CafeToken[T]) = 'token[T] .
  eq token2token(T) = T [owise] .

***(%
\end{verbatim}
}
\end{itemize}

{\codesize
\begin{comment}
%)

  op openCloseModNameUp : -> Constant .
  eq openCloseModNameUp = ''OPEN_CLOSE.Qid .

  op openCloseModName : -> Qid .
  eq openCloseModName = 'OPEN_CLOSE .

  op procOpenCloseEnv : Term Term SortMap TheorySortMap TheorySortMap Database
                        ScoreInfoMap -> CafeParseResult .

  *** This equation is used when an id is used to identify the proof being carried in the
  *** open-close environment, and hence it is required to update the map.
  ceq procOpenCloseEnv(T, T', PSM, HSM, TSM, DB, SIM) = < DB' | SIM' | QIL | QIL' >
   if (TI, TL') := getIds(T') /\
      ID := downQid(TI) /\
      T1 := 'CafeToken[openCloseModNameUp] /\
      T2 := '__['inc`(_`)[cleanOpenCloseName(T)], T'] /\
      < DB', PSM', HSM', QIL > := procCafeMod('cmod!_`{_`}[T1, T2], PSM, HSM, TSM, DB) /\
      M := nonexecInLabel(getFlatModule(openCloseModName, DB')) /\
      M' := nonexecInLabel(getTopModule(openCloseModName, DB')) /\
      TLR := getRedTerms(M, T', T2) /\
      TL := getRedThCommands(T') /\
      SIM' := addSIM(SIM, ID, $ M, M', TLR $) /\
      QIL' := processRedThCommands(M, PSM, HSM, TSM, DB', TL, T2, mtPT, 'foo:Foo,
                                   mtMacros, finished, SIM') .

  *** This equation is used when no id is used to identify the proof
  ceq procOpenCloseEnv(T, T', PSM, HSM, TSM, DB, SIM) = < DB' | SIM | QIL | QIL' >
   if getIds(T') == empty /\
      T1 := 'CafeToken[openCloseModNameUp] /\
      T2 := '__['inc`(_`)[cleanOpenCloseName(T)], T'] /\
      < DB', PSM', HSM', QIL > := procCafeMod('cmod!_`{_`}[T1, T2], PSM, HSM, TSM, DB) /\
      M := nonexecInLabel(getFlatModule(openCloseModName, DB')) /\
      TL := getRedThCommands(T') /\
      QIL' := processRedThCommands(M, PSM, HSM, TSM, DB', TL, T2, mtPT, 'foo:Foo,
                                   mtMacros, finished, SIM) .

  eq procOpenCloseEnv(T, T', PSM, HSM, TSM, DB, SIM) =
                         < DB | SIM | nil | 'Environment 'not 'parsed. > [owise] .

  op cleanOpenCloseName : Term -> Term .
  eq cleanOpenCloseName('`(_`)[T]) = T .
  eq cleanOpenCloseName(T) = T [owise] .

  op getIds : Term -> TermList .
  eq getIds('__[T, T']) = getId(T), getIds(T') .
  eq getIds(T) = getId(T) [owise] .

  op getId : Term -> TermList .
  eq getId(':id`(_`)['CafeToken[T]]) = T .
  eq getId(T) = empty [owise] .

  op getRedTerms : Module Term Term -> TermList .
  eq getRedTerms(M, '__[T, T'], T1) = getRedTerm(M, T, T1), getRedTerms(M, T', T1) .
  eq getRedTerms(M, T, T1) = getRedTerm(M, T, T1) [owise] .

  op getRedTerm : Module Term Term -> TermList .
  ceq getRedTerm(M, 'red_.['CafeBubble[T]], T') = T1
   if ODS := parseModule4Vars(T') /\
      QIL := downQidList(T) /\
      ODS' := opDeclSetFromQidList(QIL) /\
      T'' := renameOnTheFly(T, ODS ODS') /\
      T1 := getTerm(metaParse(M, downQidList(T''), anyType)) .
  eq getRedTerm(M, T, T') = empty [owise] .

  op getRedThCommands : Term -> TermList .
  eq getRedThCommands('__[T, T']) = getRedThCommand(T), getRedThCommands(T') .
  eq getRedThCommands(T) = getRedThCommand(T) [owise] .

  op getRedThCommand : Term -> TermList .
  eq getRedThCommand('reduce_.['CafeBubble[T]]) = 'red_.['bubble[T]] .
  eq getRedThCommand('red_.['CafeBubble[T]]) = 'red_.['bubble[T]] .
  eq getRedThCommand(':goal`{_`}[T]) = ':goal`{_`}[T] .
  eq getRedThCommand(':ind`on`(_`)['CafeToken[T]]) = ':ind`on`(_`)[T] .
  eq getRedThCommand(':apply`(_`)['neCafeTokenList[T]]) = ':apply`(_`)[T] .
  eq getRedThCommand(':sel`(_`)['CafeToken[T]]) = ':sel`(_`)[T] .
  eq getRedThCommand(':postpone`..@CafeInductiveComm@) = ':postpone`..@CafeInductiveComm@ .
  eq getRedThCommand(':imp`[_`].['CafeToken[T]]) = ':imp`[_`].[T] .
  eq getRedThCommand(':imp`[_`]by`{_`}['CafeToken[T], 'neCafeTokenList[T']]) =
                                                    ':imp`[_`]by`{_`}[T, T'] .
  eq getRedThCommand(':id`(_`)['CafeToken[T]]) = empty .
  eq getRedThCommand(':proof`(_`)['CafeToken[T]]) = ':proof`(_`)[T] .
  eq getRedThCommand(':def_=`:ctf`{_`}['CafeToken[T], T']) =
                                                   ':def_=`:ctf`{_`}[T, T'] .
  eq getRedThCommand(':def_=`:ctf`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:ctf`[_`][T, T'] .
  eq getRedThCommand(':def_=`:cvss`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:cvss`[_`][T, T'] .
  eq getRedThCommand(':def_=`:cvvs`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:cvvs`[_`][T, T'] .
  eq getRedThCommand(':def_=`:cvsv`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:cvsv`[_`][T, T'] .
  eq getRedThCommand(':def_=`:cevss`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:cevss`[_`][T, T'] .
  eq getRedThCommand(':def_=`:cevs`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:cevs`[_`][T, T'] .
  eq getRedThCommand(':def_=`:cesv`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:cesv`[_`][T, T'] .
  eq getRedThCommand(':def_=`:cesvs`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:cesvs`[_`][T, T'] .
  eq getRedThCommand(':show`proof.@CafeInductiveComm@) = ':show`proof.@CafeInductiveComm@ .
  eq getRedThCommand(':desc`proof.@CafeInductiveComm@) = ':desc`proof.@CafeInductiveComm@ .
  eq getRedThCommand(':desc`..@CafeInductiveComm@) = ':desc`..@CafeInductiveComm@ .
  eq getRedThCommand(T) = empty [owise] .

  op processRedThCommands : Module SortMap TheorySortMap TheorySortMap Database
                            TermList Term ProofTree Variable Macros ProofOrder
                            ScoreInfoMap -> QidList .
  eq processRedThCommands(M, PSM, HSM, TSM, DB, empty, T, P, V, MACS, PO, SIM) = nil .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':goal`{_`}[T], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P', V, MACS, PO', SIM)
   if [P', PO', QIL] := evalGoalCommand(M, T, T1, PSM, HSM, TSM, DB, PO) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':ind`on`(_`)[T], TL), T1, P, V,
                           MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, T', MACS, PO,SIM)
   if T' := downTerm(T) /\
      T' :: Variable /\
      QIL := '\n 'Induction 'set 'on metaPrettyPrint(M, T', po) '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':apply`(_`)[T], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, (':apply`(_`)['__[T3, TL']], TL),
                                    T1, P', V, MACS, PO', SIM)
   if '__[T2, T3, TL'] := T /\
      TL' =/= empty /\
      Q := downQid(T2) /\
      [P', PO', QIL] := evalApply(M, Q, P, V, MACS, PO) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':apply`(_`)[T], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, (':apply`(_`)[T3], TL),
                                    T1, P', V, MACS, PO', SIM)
   if '__[T2, T3] := T /\
      Q := downQid(T2) /\
      [P', PO', QIL] := evalApply(M, Q, P, V, MACS, PO) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':apply`(_`)[T], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P', V, MACS, PO', SIM)
   if Q := downQid(T) /\
      [P', PO', QIL] := evalApply(M, Q, P, V, MACS, PO) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':sel`(_`)[T], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P', V, MACS, PO', SIM)
   if Q := downQid(T) /\
      NL := qid2natlist(Q) /\
      P' := selectGoal(P, NL) /\
      PO' := selectGoal(PO, NL) /\
      QIL := '\n 'Sentence Q 'selected. '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':postpone`..@CafeInductiveComm@, TL),
                           T1, P, V, MACS, NL y PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P', V, MACS, PO', SIM)
   if PO' := PO y NL /\
      P' := selectGoal(P, fst(PO')) /\
      QIL := '\n 'Sentence printIndex(NL) 'postponed. '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':imp`[_`].[T], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P', V, MACS, PO, SIM)
   if Q := downQid(T) /\
      [P', B] := applyImp(P, Q) /\
      QIL := if B
             then '\n 'New 'goal 'generated: printCurrent(P')
             else '\n 'Command 'failed. '\n
             fi .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':imp`[_`]by`{_`}[T, T'], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P', V, MACS, PO, SIM)
   if Q := downQid(T) /\
      SB := procImpSub(getMod(P, fst(PO)), T') /\
      [P', B] := applyImp(P, Q, SB) /\
      QIL := if B
             then '\n 'New 'goal 'generated: printCurrent(P')
             else '\n 'Command 'failed. '\n
             fi .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:ctf`{_`}[T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - Eq #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - Eq # := parseEqMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':ctf ' '`{ ' printEq(M', Eq) ' '`} '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:ctf`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':ctf ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:cvss`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 . cvss #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      subsortSingleBinaryOpConstraints(M', T2) /\
      QIL := '\n Q 'defined 'as ':cvss ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:cvvs`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 . cvvs #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':cvvs ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:cvsv`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 . cvsv #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':cvsv ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:cevss`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 . cevss #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':cevss ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:cevs`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 . cevs #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':cevs ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:cesv`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 . cesv #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      subsortUnaryBinaryOpConstraints(M', T2) /\
      QIL := '\n Q 'defined 'as ':cesv ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:cesvs`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 . cesvs #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':cesvs ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                           (':show`proof.@CafeInductiveComm@, TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V, MACS, PO, SIM)
   if QIL := '\n 'Current 'goals: printGoals(P) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                           (':desc`proof.@CafeInductiveComm@, TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V, MACS, PO, SIM)
   if QIL := '\n 'Current 'proof: printProofTree(P) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                           (':desc`..@CafeInductiveComm@, TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V, MACS, PO, SIM)
   if QIL := '\n 'Current 'goal: printCurrent(P) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, ('red_.['bubble[T]], TL), T1, P, V,
                           MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V, MACS, PO, SIM)
   if QIL := evalRedCommand(M, T, T1) .
  eq processRedThCommands(M, PSM, HSM, TSM, DB, (':id`(_`)[T], TL), T1, P, V, MACS,
                          PO, SIM) =
           processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V, MACS, PO, SIM) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':proof`(_`)[T], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V, MACS, PO, SIM)
   if Q := downQid(T) /\
      QIL := inferProof(M, Q, SIM[Q], mtMacros) .
  eq processRedThCommands(M, PSM, HSM, TSM, DB, (T, TL), T1, P, V, MACS, PO, SIM) =
           '\n 'Error 'in 'command.
           processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,MACS, PO, SIM) [owise] .

  *** Module.
  *** Term to be reduced.
  *** Module in term representation, including vars
  op evalRedCommand : Module Term Term -> QidList .
  ceq evalRedCommand(M, T, T') = evalRedCommand(M, T'')
   if ODS := parseModule4Vars(T') /\
      QIL := downQidList(T) /\
      ODS' := opDeclSetFromQidList(QIL) /\
      T'' := renameOnTheFly(T, ODS ODS') .

  op evalRedCommand : Module Term -> QidList .
  ceq evalRedCommand(M, T) = QIL
   if T1 := getTerm(metaParse(M, downQidList(T), anyType)) /\
      T' := getTerm(metaReduce(M, T1)) /\
      T'' := addComments(T') /\
      QIL := evalRedCommandFinal(M, T'', T1) .
***(
  ceq evalRedCommand(M, T) = QIL
   if T1 := getTerm(metaParse(M, downQidList(T), anyType)) /\
      T'' := addComments(T1) /\
      QIL := evalRedCommandFinal(M, T'', T1) .
      *** TODO: Simplificar si mismo argumento
)

  op evalRedCommandFinal : Module Term Term -> QidList .
  ceq evalRedCommandFinal(M, T, T1) = QIL '\n QIL'
   if | T', QIL, ST | := changeSearch(M, T, mtST) /\
      {T'', Ty} := metaReduce(M, T') /\
      QIL' := printRedRes(M, T1, T'', Ty) .
***(
  ceq evalRedCommandFinal(M, T, T1) = QIL '\n QIL'
   if | T', QIL | := myRed(M, T) /\
      QIL' := printRedRes(M, T1, T', type(M, T')) .
)

  sort GoalRes .
  op [_,_,_] : ProofTree ProofOrder QidList -> GoalRes [ctor] .

  op evalGoalCommand : Module Term Term SortMap TheorySortMap TheorySortMap Database
                       ProofOrder -> GoalRes .
  ceq evalGoalCommand(M, T, T2, PSM, HSM, TSM, DB, PO) = [P, (nil).NatList, QIL']
   if T1 := 'CafeToken[openCloseModNameUp] /\
      < DB', PSM', HSM', QIL > := procCafeMod('cmod!_`{_`}[T1, addEqs(T2, T)], PSM, HSM, TSM, DB) /\
      M' := nonexecInLabel(getFlatModule(openCloseModName, DB')) /\
      P := getNew(M, getEqs(M), getEqs(M')) /\
      QIL' := 'New 'goal 'introduced: '\n printGoals(P) '\n .
  eq evalGoalCommand(M, T, T1, PSM, HSM, TSM, DB, PO) =
                       [mtPT, finished, '\n 'Error 'processing 'goal. '\n] [owise] .

  op evalApply : Module Qid ProofTree Variable Macros ProofOrder -> GoalRes .
  ceq evalApply(M, 'si, P, V, MACS, PO) = [P', PO', QIL]
   if ODS := getCtors(M, getType(V)) /\
      [P', PO'] := applyInduction(P, V, PO) /\
      QIL := '\n 'Induction 'applied 'on metaPrettyPrint(M, V, po) ':
             '\n 'New 'goal: printGoals(P') '\n .
  ceq evalApply(M, 'tc, P, V, MACS, PO) = [P', PO', QIL]
   if [P', PO'] := applyTC(P, PO) /\
      QIL := '\n 'Theorem 'of 'constants 'applied.
             '\n 'New 'goal: printGoals(P') '\n .
  ceq evalApply(M, 'rd, P, V, MACS, PO) = [P'', PO', QIL]
   if [P', B] := applyRed(P) /\
      PO' := if B
             then pop(PO)
             else PO
             fi /\
      B' := PO' == finished /\
      P'' := if B and (not B')
             then selectGoal(P', fst(PO'))
             else P'
             fi /\
      QIL := '\n '\n 'Reduction 'applied.
             'The 'goal 'was if B then nil else 'not fi 'discarded
             if B and (not B')
             then '\n 'Next 'goal 'is '\! printIndex(fst(PO')) '\o
             else if B'
                  then '\n '\! 'PROOF 'FINISHED! '\o '\n
                  else nil
                  fi
             fi .
  ceq evalApply(M, 'rd-, P, V, MACS, PO) = [P'', PO', QIL]
   if [P', B] := applyRed(P) /\
      PO' := if B
             then pop(PO)
             else PO
             fi /\
      B' := PO' == finished /\
      P'' := if B and (not B')
             then selectGoal(P', fst(PO'))
             else P'
             fi /\
      QIL := '\n '\n 'Reduction 'applied.
             'The 'goal 'was if B then nil else 'not fi 'discarded
             if B and (not B')
             then '\n 'Next 'goal 'is '\! printIndex(fst(PO')) '\o
             else if B'
                  then '\n '\! 'PROOF 'FINISHED! '\o '\n
                  else nil
                  fi
             fi .
  ceq evalApply(M, Q, P, V, # M', Q - Eq # MACS, PO) = [P', PO', QIL]
   if P' := applyEquationMacro(P, Q, Eq) /\
      PO' := indProofOrder(fst(PO), 2) y pop(PO) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .
  ceq evalApply(M, Q, P, V, # M', Q - T # MACS, PO) = [P', PO', QIL]
   if Ty := getType(metaReduce(M', T)) /\
      [P', PO'] := applyTermMacro(P, PO, Q, T, Ty) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .
  ceq evalApply(M, Q, P, V, # M', Q - T . cvss # MACS, PO) = [P', PO', QIL]
   if Ty := getType(metaReduce(M', T)) /\
      [P', PO'] := applyTermMacro(P, PO, Q, T, cvss, Ty) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .
  ceq evalApply(M, Q, P, V, # M', Q - T . cevs # MACS, PO) = [P', PO', QIL]
   if Ty := getType(metaReduce(M', T)) /\
      [P', PO'] := applyTermMacro(P, PO, Q, T, cevs, Ty) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .

  op getCtors : Module Sort -> OpDeclSet .
  eq getCtors(M, Srt) = getCtors(M, getOps(M), Srt) .

  op getCtors : Module OpDeclSet Sort -> OpDeclSet .
  eq getCtors(M, op Q : TyL -> Srt [ctor AtS] . ODS, Srt) = op Q : TyL -> Srt [ctor AtS] .
                                                            getCtors(M, ODS, Srt) .
  ceq getCtors(M, op Q : TyL -> Ty [ctor AtS] . ODS, Srt) = op Q : TyL -> Srt [ctor AtS] .
                                                            getCtors(M, ODS, Srt)
   if Ty =/= 'Universal /\
      sameKind(M, Ty, Srt) /\
      sortLeq(M, Ty, Srt) .
  eq getCtors(M, ODS, Srt) = none [owise] .

  op getExactCtors : Module Sort -> OpDeclSet .
  eq getExactCtors(M, Srt) = getExactCtors(M, getOps(M), Srt) .

  op getExactCtors : Module OpDeclSet Sort -> OpDeclSet .
  eq getExactCtors(M, op Q : TyL -> Srt [ctor AtS] . ODS, Srt) = op Q : TyL -> Srt [ctor AtS] .
                                                            getExactCtors(M, ODS, Srt) .
  eq getExactCtors(M, ODS, Srt) = none [owise] .

  op buildTermsCtors : OpDeclSet String -> TermList .
  eq buildTermsCtors(none, STR) = empty .
  ceq buildTermsCtors(OD ODS, STR) = (T, TL)
   if T := buildTermCtor(OD, STR) /\
      TL := buildTermsCtors(ODS, STR) .

  op buildTermCtor : OpDecl String -> Term .
  ceq buildTermCtor(op Q : nil -> Srt [AtS] ., STR) = C
   if C := qid(string(Q) + "." + string(Srt)) .
  ceq buildTermCtor(op Q : TyL -> Srt [AtS] ., STR) = Q[TL]
   if TL := buildArgs(TyL, empty, STR) [owise] .

  op procImpSub : Module Term ~> Substitution .
  eq procImpSub(M, '__[TL]) = $procImpSub(getOps(M), TL) .

  op $procImpSub : OpDeclSet TermList ~> Substitution .
  eq $procImpSub(ODS, empty) = none .
  ceq $procImpSub(ODS, (T, ''<-.Qid, T', '';.Qid, TL)) = V <- C ; $procImpSub(ODS, TL)
   if V := downQid(T) /\
      Q := downQid(T') /\
      op Q : nil -> Ty [AtS] . ODS' := ODS /\
      C := qid(string(Q) + "." + string(Ty)) .

  ************************************************************************************
  ********************************* APPLY TERM MACRO *********************************
  ************************************************************************************

  op applyTermMacro : ProofTree ProofOrder Qid Term Type -> IndResPair .
  eq applyTermMacro(P, PO, Q, T, Ty) = $applyTermMacro(P, PO, Q, T, Ty) .

  op $applyTermMacro : ProofTree ProofOrder Qid Term Type -> IndResPair .
  eq $applyTermMacro(mtPT, PO, Q, T, Ty) = [mtPT, finished] .
  ceq $applyTermMacro(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, PO, Q, T, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if [ PrL', PO' ] := $applyTermMacro*(PrL, PO, Q, T, Ty) .
  ceq $applyTermMacro(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO, Q, T, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if ODS := getCtors(M, Ty) /\
      TL := ordTrueFalse(buildTermsCtors(ODS, "CS")) /\
      ML := createModules(M, T, TL) /\
      PrL' := createCTFTerm(ML, NL, Q, EqS) /\
      PO' := indProofOrder(fst(PO), size(TL)) y pop(PO) .

  op applyTermMacro : ProofTree ProofOrder Qid Term MacroLabel Type -> IndResPair .
  eq applyTermMacro(P, PO, Q, T, MLb, Ty) = $applyTermMacro(P, PO, Q, T, MLb, Ty) .
  ceq $applyTermMacro(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, PO, Q, T, MLb, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if [ PrL', PO' ] := $applyTermMacro*(PrL, PO, Q, T, MLb, Ty) .
  *** Case selection cvss: value (eq1) + seq seq (eq2)
  ceq $applyTermMacro(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO, Q, T, cvss, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if TL := buildVSS(M, Ty) /\
      ML := createModules(M, T, TL) /\
      PrL' := createCTFTerm(ML, NL, Q, EqS) /\
      PO' := indProofOrder(fst(PO), size(TL)) y pop(PO) .
  *** Case selection cevs: empty (eq1) + value seq (eq2)
  ceq $applyTermMacro(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO, Q, T, cevs, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if TL := buildEVS(M, Ty) /\
      ML := createModules(M, T, TL) /\
      PrL' := createCTFTerm(ML, NL, Q, EqS) /\
      PO' := indProofOrder(fst(PO), size(TL)) y pop(PO) [print TL] .

  op buildVSS : Module Type -> TermList .
  ceq buildVSS(M, Ty) = TL', TL
   if ODS := getExactCtors(M, Ty) /\
      TL := buildTermsCtors(ODS, "VSS") /\
      SS := lesserSorts(M, Ty) /\
      TL' := buildTermsOrFreshConst(M, SS) .

  op buildEVS : Module Type -> TermList .
  ceq buildEVS(M, Ty) = combineEVS(TL, TL')
   if ODS := getExactCtors(M, Ty) /\
      TL := buildTermsCtors(ODS, "VSS") /\
      SS := lesserSorts(M, Ty) /\
      TL' := buildTermsOrFreshConst(M, SS) .

  op combineEVS : TermList TermList ~> TermList .
  eq combineEVS((C, T), TL) = C, putTogether(T, TL) .
  eq combineEVS((T, C), TL) = C, putTogether(T, TL) .

  op putTogether : Term TermList -> TermList .
  eq putTogether(T, empty) = empty .
  eq putTogether(Q[T, T'], (T1, TL)) = Q[T1, T'], putTogether(Q[T, T'], TL) .

  op buildTermsOrFreshConst : Module SortSet -> TermList .
  eq buildTermsOrFreshConst(M, none) = empty .
  ceq buildTermsOrFreshConst(M, Srt ; SS) = TL, buildTermsOrFreshConst(M, SS)
   if ODS := getExactCtors(M, Srt) /\
      ODS =/= none /\
      TL := buildTermsCtors(ODS, "VSS") .
  ceq buildTermsOrFreshConst(M, Srt ; SS) = T, buildTermsOrFreshConst(M, SS)
   if getExactCtors(M, Srt) == none /\
      T := qid("VSSVal" + string(Srt) + "." + string(Srt)) .



  op $applyTermMacro : ProofTree ProofOrder Qid Term MacroLabel Type -> IndResPair .
  eq $applyTermMacro(mtPT, PO, Q, T, MLb, Ty) = [mtPT, finished] .

  op $applyTermMacro* : ProofTreeList ProofOrder Qid Term Type -> IndResPair .
  eq $applyTermMacro*(mtPT, PO, Q, T, Ty) = [mtPT, finished] .
  ceq $applyTermMacro*(| M', G, PrL, N | PrL', PO, Q, T, Ty) = [PrL1 PrL2, PO' y PO'']
   if [PrL1, PO'] := $applyTermMacro(| M', G, PrL, N |, PO, Q, T, Ty) /\
      [PrL2, PO''] := $applyTermMacro*(PrL', PO, Q, T, Ty) .

  op $applyTermMacro* : ProofTreeList ProofOrder Qid Term MacroLabel Type -> IndResPair .
  eq $applyTermMacro*(mtPT, PO, Q, T, MLb, Ty) = [mtPT, finished] .
  ceq $applyTermMacro*(| M', G, PrL, N | PrL', PO, Q, T, MLb, Ty) = [PrL1 PrL2, PO' y PO'']
   if [PrL1, PO'] := $applyTermMacro(| M', G, PrL, N |, PO, Q, T, MLb, Ty) /\
      [PrL2, PO''] := $applyTermMacro*(PrL', PO, Q, T, MLb, Ty) .

  sort MList .
  subsort Module < MList .

  op mtML : -> MList [ctor] .
  op _._ : MList MList -> MList [ctor assoc id: mtML] .

  op ordTrueFalse : TermList -> TermList .
  eq ordTrueFalse(('false.Bool, 'true.Bool)) = 'true.Bool, 'false.Bool .
  eq ordTrueFalse(TL) = TL [owise] .

  op createModules : Module Term TermList -> MList .
  eq createModules(M, T, empty) = mtML .
  ceq createModules(M, T, ('true.Bool, TL)) = addHyp(M, Eq) . createModules(M, T, TL)
   if '_=_[T1, T2] := T /\
      Eq := eq T1 = T2 [metadata("CTF-true")] . .
  ceq createModules(M, T, (T', TL)) = addHyp(addCons(M, T'), Eq) . createModules(M, T, TL)
   if STR := createName(T') /\
      Eq := eq T = T' [metadata(STR)] . [owise] .

  op createName : Term -> String .
  eq createName(C) = "CTF-" + string(getName(C)) .
  eq createName(V) = "CTF-" + string(getName(V)) .
  eq createName(Q[TL]) = "CTF-" + string(Q) .

  op createCTFTerm : MList NatList Qid EquationSet -> ProofTreeList .
  eq createCTFTerm(ML, NL, Q, EqS) = $createCTFTerm(ML, NL, Q, EqS, 1) .

  op $createCTFTerm : MList NatList Qid EquationSet Nat -> ProofTreeList .
  eq $createCTFTerm(mtML, NL, Q, EqS, N) = mtPT .
  eq $createCTFTerm(M . ML, NL, Q, EqS, N) = | M, [NL N, Q, EqS, N == 1, false], mtPT, 1 |
                                             $createCTFTerm(ML, NL, Q, EqS, s(N)) .

  ************************************************************************************
  ******************************* APPLY EQUATION MACRO *******************************
  ************************************************************************************

  op applyEquationMacro : ProofTree Qid Equation -> ProofTree .
  eq applyEquationMacro(P, Q, Eq) = $applyEquationMacro(P, Q, Eq) .

  op $applyEquationMacro : ProofTree Qid Equation -> ProofTree .
  eq $applyEquationMacro(mtPT, Q, Eq) = mtPT .
  ceq $applyEquationMacro(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, Q, Eq') =
                                   | M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |
   if PrL' := $applyEquationMacro*(PrL, Q, Eq') .
  ceq $applyEquationMacro(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, Q, Eq') =
                                   | M, [NL, CMD, EqS, false, PRVN], PrL', 3 |
   if M' := createCTFmodTrue(M, Eq') /\
      M'' := createCTFmodFalse(M, Eq') /\
      PrL' := | M', [NL 1, Q, EqS, true, false], mtPT, 1 |
              | M'', [NL 2, Q, EqS, false, false], mtPT, 1 | .

  op $applyEquationMacro* : ProofTreeList Qid Equation -> ProofTree .
  eq $applyEquationMacro*(mtPT, Q, Eq) = mtPT .
  eq $applyEquationMacro*(| M', G, PrL, N | PrL', Q, Eq) =
                $applyEquationMacro(| M', G, PrL, N |, Q, Eq)
                $applyEquationMacro*(PrL', Q, Eq) .

  op createCTFmodTrue : Module Equation -> Module .
  ceq createCTFmodTrue(M, eq T = T' [AtS] .) = addHyp(M, Eq)
   if Eq := eq T = T' [AtS metadata("CTF-true")] . .

  op createCTFmodFalse : Module Equation -> Module .
  ceq createCTFmodFalse(M, eq T = T' [AtS] .) = addHyp(M, Eq)
   if Eq := eq '_=_[T, T'] = 'false.Bool [AtS metadata("CTF-false")] . .

  ************************************************************************************
  ********************************** EQUATION MACRO **********************************
  ************************************************************************************

  op parseEqMacro : ProofTree Qid Term -> Macros .
  eq parseEqMacro(mtPT, Q, T) = mtMacros .
  eq parseEqMacro(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, Q, T) =
          parseEqMacro*(PrL, Q, T) .
  eq parseEqMacro(| M, [NL, CMD, EqS, true, PRVN], PrL, N' |, Q, T) =
          parseEqMacro(M, Q, T) .

  op parseEqMacro* : ProofTreeList Qid Term -> Macros .
  eq parseEqMacro*(mtPT, Q, T) = mtMacros .
  eq parseEqMacro*(| M', G, PrL, N | PrL', Q, T) = parseEqMacro(| M', G, PrL, N |, Q, T)
                                                   parseEqMacro*(PrL', Q, T) .

  op parseEqMacro : Module Qid Term -> Macros .
  ceq parseEqMacro(M, Q, 'eq_=_.['CafeBubble[T],'CafeBubble[T']]) = # M, Q - Eq #
   if T1 := getTerm(metaParse(M, downQidList(T), anyType)) /\
      T2 := getTerm(metaParse(M, downQidList(T'), anyType)) /\
      Eq := eq T1 = T2 [none] . .
  eq parseEqMacro(M, Q, T) = mtMacros [owise] .

  ************************************************************************************
  ************************************ TERM MACRO ************************************
  ************************************************************************************

  op parseTermMacro : ProofTree Qid Term -> Macros .
  eq parseTermMacro(mtPT, Q, T) = mtMacros .
  eq parseTermMacro(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, Q, T) =
          parseTermMacro*(PrL, Q, T) .
  eq parseTermMacro(| M, [NL, CMD, EqS, true, PRVN], PrL, N' |, Q, T) =
          parseTermMacro(M, Q, T) .

  op parseTermMacro* : ProofTreeList Qid Term -> Macros .
  eq parseTermMacro*(mtPT, Q, T) = mtMacros .
  eq parseTermMacro*(| M', G, PrL, N | PrL', Q, T) = parseTermMacro(| M', G, PrL, N |, Q, T)
                                                     parseTermMacro*(PrL', Q, T) .

  op parseTermMacro : Module Qid Term -> Macros .
  ceq parseTermMacro(M, Q, '__[TL, ''..Qid]) = if T? :: Term
                                          then # M, Q - T? #
                                          else parseTermMacro(M, Q, '__[TL])
                                          fi
   if T? := getTerm(metaParse(M, downQidList('__[TL, '.]), anyType)) .
  ceq parseTermMacro(M, Q, T) = if T? :: Term
                                then # M, Q - T? #
                                else mtMacros
                                fi
   if T? := getTerm(metaParse(M, downQidList(T), anyType)) [owise] .

  ************************************************************************************
  ****************************** SIMULTANEOUS INDUCTION ******************************
  ************************************************************************************

  sort IndResPair .
  op [_,_] : ProofTreeList ProofOrder -> IndResPair [ctor] .

  op applyInduction : ProofTree Variable ProofOrder -> IndResPair .
  eq applyInduction(mtPT, V, PO) = [mtPT, finished] .
  ceq applyInduction(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, V, PO) =
                          [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if [PrL', PO'] := applyInduction*(PrL, V, PO) .
  ceq applyInduction(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, V, PO) =
                          [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if ODS := getCtors(M, getType(V)) /\
      TL := buildTermsCtors(ODS, "") /\
      Ty := getType(V) /\
      C := qid(substr(string(Ty), 0, 1) + "#" + string(Ty) + "." + string(Ty)) /\
      EqS' := createHI(EqS, V, C) /\
      OD := op getName(C) : nil -> getType(C) [metadata("generated-si")] . /\
      M' := addHyp(addOp(M, OD), EqS') /\
      PO' := indProofOrder(fst(PO), size(TL)) y pop(PO) /\
      PrL' := subGoal*(M', [NL, CMD, EqS, true, PRVN], V, TL, NL, 1) .

  op applyInduction* : ProofTreeList Variable ProofOrder -> IndResPair .
  eq applyInduction*(mtPT, V, PO) = [mtPT, finished] .
  ceq applyInduction*(| M', G, PrL, N | PrL', V, PO) = [P' P'', PO' y PO'']
   if [P', PO'] := applyInduction(| M', G, PrL, N |, V, PO) /\
      [P'', PO''] := applyInduction*(PrL', V, PO) .

  op subGoal* : Module Goal Variable TermList NatList Nat -> ProofTreeList .
  eq subGoal*(M, G, V, empty, NL, N) = mtPT .
  eq subGoal*(M, G, V, (T, TL), NL, N) = subGoal(M, getEq(G), V, T, NL, N)
                                         subGoal*(M, G, V, TL, NL, s(N)) .

  op subGoal : Module EquationSet Variable Term NatList Nat -> ProofTree .
  eq subGoal(M, EqS, V, T, NL, N) =
            | addCons(M, T), [NL N, 'SI, makeSub(EqS, V, T), N == 1, false], mtPT, 1 | .

  *** We make sure not to add constant constructors by skipping them at first.
  op addCons : Module Term -> Module .
  ceq addCons(M, C) = M
   if Q := getName(C) /\
      op Q : TyL -> Ty [AtS] . ODS := getOps(M) .
  eq addCons(M, T) = $addCons(M, T) [owise] .

  op $addCons : Module Term -> Module .
  eq $addCons(M, V) = M .
  ceq $addCons(M, C) = addOp(M, OD)
   if OD := op getName(C) : nil -> getType(C) [metadata("generated-si")] . .
  eq $addCons(M, Q[TL]) = $addCons*(M, TL) .

  op $addCons* : Module TermList -> Module .
  eq $addCons*(M, empty) = M .
  eq $addCons*(M, (T, TL)) = $addCons*($addCons(M, T), TL) .

  op makeSub : EquationSet Variable Term -> EquationSet .
  eq makeSub(none, V, T) = none .
  eq makeSub(eq T = T' [AtS] . EqS, V, T1) =
         eq subTerm(T, V, T1) = subTerm(T', V, T1) [AtS] .
         makeSub(EqS, V, T1) .
  eq makeSub(ceq T = T' if COND [AtS] . EqS, V, T1) =
         ceq subTerm(T, V, T1) = subTerm(T', V, T1) if subCond(COND, V, T1) [AtS] .
         makeSub(EqS, V, T1) .

  op createHI : EquationSet Variable Term -> EquationSet .
  eq createHI(none, V, T) = none .
  eq createHI(eq T = T' [AtS] . EqS, V, T1) =
         eq subTerm(T, V, T1) = subTerm(T', V, T1) [metadata("HI") AtS] .
         createHI(EqS, V, T1) .
  eq createHI(ceq T = T' if COND [AtS] . EqS, V, T1) =
         ceq subTerm(T, V, T1) = subTerm(T', V, T1)
          if subCond(COND, V, T1) [metadata("HI") AtS] .
         createHI(EqS, V, T1) .

  op subTerm : Term Variable Term -> Term .
  eq subTerm(Q[TL], V, T) = Q[subTermList(TL, V, T)] .
  eq subTerm(V, V, T) = T .
  eq subTerm(T, V, T') = T [owise] .

  op subTermList : TermList Variable Term -> TermList .
  eq subTermList(empty, V, T) = empty .
  eq subTermList((T, TL), V, T') = subTerm(T, V, T'), subTermList(TL, V, T') .

  op subCond : Condition Variable Term -> Condition .
  eq subCond(nil, V, T) = nil .
  eq subCond(T = T' /\ COND, V, T1) = subTerm(T, V, T1) = subTerm(T', V, T1) /\
                                      subCond(COND, V, T1) .
  eq subCond(T : Srt /\ COND, V, T1) = subTerm(T, V, T1) : Srt /\
                                       subCond(COND, V, T1) .
  eq subCond(T := T' /\ COND, V, T1) = subTerm(T, V, T1) := subTerm(T', V, T1) /\
                                       subCond(COND, V, T1) .
  eq subCond(T => T' /\ COND, V, T1) = subTerm(T, V, T1) => subTerm(T', V, T1) /\
                                       subCond(COND, V, T1) .

  op buildArgs : TypeList TermList String -> TermList .
  eq buildArgs(nil, TL, STR) = empty .
  ceq buildArgs(Ty TyL, TL, STR) = (C, TL')
   if C := buildArg(Ty, TL, STR) /\
      TL' := buildArgs(TyL, (C, TL), STR) .

  op buildArg : Type TermList String -> TermList .
  ceq buildArg(Ty, (TL, C, TL'), St) = $buildArg(Ty, (TL, TL'), St, 0)
   if STR := string(Ty) /\
      C := qid(substr(STR, 0, 1) +  "#" + St + STR + "." + STR) .
  ceq buildArg(Ty, TL, St) = C
   if STR := string(Ty) /\
      C := qid(substr(STR, 0, 1) + "#" + St + STR + "." + STR) [owise] .

  op $buildArg : Type TermList String Nat -> TermList .
  ceq $buildArg(Ty, (TL, C, TL'), St, N) = $buildArg(Ty, (TL, TL'), St, s(N))
   if STR := string(Ty) /\
      C := qid(substr(STR, 0, 1) + string(N, 10) + "#" + St + STR + "." + STR) .
  ceq $buildArg(Ty, TL, St, N) = C
   if STR := string(Ty) /\
      C := qid(substr(STR, 0, 1) + string(N, 10) + "#" + St + STR + "." + STR) [owise] .

  op indProofOrder : NatList Nat -> ProofOrder .
  eq indProofOrder(NL, s(N)) = indProofOrder(NL, N) y NL s(N) .
  eq indProofOrder(NL, 0) = finished .

  sort Vars2ConsPair .
  op [_,_] : Equation Module -> Vars2ConsPair [ctor] .
  op [_,_] : TermList Module -> Vars2ConsPair [ctor] .
  op [_,_] : Condition Module -> Vars2ConsPair [ctor] .

  ***********************************************************************************
  ***************************** APPLY IMPLIES SUBSTITUTION **************************
  ***********************************************************************************

  op applyImp : ProofTree Qid Substitution -> ProofBool .
  eq applyImp(mtPT, Q, SB) = [mtPT, false] .
  ceq applyImp(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, Q, SB) =
                           [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, B]
   if [PrL', B] := applyImp*(PrL, Q, SB) .
  ceq applyImp(| M, [NL, CMD, Eq, true, PRVN], mtPT, N' |, Q, SB) = [PrL', B]
   if [PrL', B] := applyImp(M, Eq, Q, NL, SB) .

  op applyImp* : ProofTreeList Qid Substitution -> ProofBool .
  eq applyImp*(mtPT, Q, SB) = [mtPT, false] .
  ceq applyImp*(| M', G, PrL, N | PrL', Q, SB) = [PrL1 PrL2, B or B']
   if [PrL1, B] := applyImp(| M', G, PrL, N |, Q, SB) /\
      [PrL2, B'] := applyImp*(PrL', Q, SB) .

  op applyImp : Module Equation Qid NatList Substitution -> ProofBool .
  ceq applyImp(M, Eq, Q, NL, SB) = [| M, [NL, 'imp, Eq', true, false], mtPT, 1 |, true]
   if eq T = 'true.Bool [label(Q) AtS] . EqS := getEqs(M) /\
      Eq' := impEq(M, Eq, substitute(T, SB)) .
  eq applyImp(M, Eq, Q, N, SB) = [mtPT, false] [owise] .

  op substitute : Term Substitution -> Term .
  eq substitute(Q[TL], SB) = Q[substitute*(TL, SB)] .
  eq substitute(C, SB) = C .
  eq substitute(V, V <- T ; SB) = T .
  eq substitute(V, SB) = V [owise] .

  op substitute* : TermList Substitution -> TermList .
  eq substitute*(empty, SB) = empty .
  eq substitute*((T, TL), SB) = substitute(T, SB), substitute*(TL, SB) .

  ***********************************************************************************
  ********************************** APPLY IMPLIES **********************************
  ***********************************************************************************

  op applyImp : ProofTree Qid -> ProofBool .
  eq applyImp(mtPT, Q) = [mtPT, false] .
  ceq applyImp(| M, [NL, CMD, Eq, false, PRVN], PrL, N' |, Q) =
                           [| M, [NL, CMD, Eq, false, PRVN], PrL', s(size*(PrL')) |, B]
   if [PrL', B] := $applyImp*(PrL, Q) .
  ceq applyImp(| M, [NL, CMD, Eq, true, PRVN], mtPT, N' |, Q) =
                          *** [| M, [NL, CMD, Eq, false, PRVN], PrL', s(size*(PrL')) |, B]
                          [PrL', B]
   if [PrL', B] := applyImp(M, Eq, Q, NL) .

  op $applyImp* : ProofTreeList Qid -> ProofBool .
  eq $applyImp*(mtPT, Q) = [mtPT, false] .
  ceq $applyImp*(| M', G, PrL, N | PrL', Q) = [PrL1 PrL2, B or B']
   if [PrL1, B] := applyImp(| M', G, PrL, N |, Q) /\
      [PrL2, B'] := $applyImp*(PrL', Q) .

  op applyImp : Module Equation Qid NatList -> ProofBool .
  ceq applyImp(M, Eq, Q, NL) = [| M, [NL, 'imp, Eq', true, false], mtPT, 1 |, true]
   if eq T = 'true.Bool [label(Q) AtS] . EqS := getEqs(M) /\
      Eq' := impEq(M, Eq, T) .
  eq applyImp(M, Eq, Q, N) = [mtPT, false] [owise] .

  op impEq : Module Equation Term -> Equation .
  ceq impEq(M, eq T = 'true.Bool [AtS] ., T') = eq '_implies_[T1, T] = 'true.Bool [AtS] .
   if T1 := getTerm(metaReduce(M, T')) .
  ceq impEq(M, eq T = T' [AtS] ., T'') = eq '_implies_[T1, '_=_[T', T]] =
                                        'true.Bool [AtS] .
   if T1 := getTerm(metaReduce(M, T'')) [owise] .

  ************************************************************************************
  ******************************* THEOREM OF CONSTANTS *******************************
  ************************************************************************************

  op applyTC : ProofTree ProofOrder -> IndResPair .
  eq applyTC(P, PO) = $applyTC(P, PO) .

  op $applyTC : ProofTree ProofOrder -> IndResPair .
  eq $applyTC(mtPT, PO) = [mtPT, finished] .
  ceq $applyTC(| M', [NL, CMD, EqS, false, PRVN], PrL, N' |, PO) =
                         [| M', [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if [PrL', PO'] := $applyTC*(PrL, PO) .
  ceq $applyTC(| M', [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO) =
                         [| M', [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if PrL' := vars2cons*(EqS, M', NL, 1) /\
      PO' := indProofOrder(fst(PO), sizeEQS(EqS)) y pop(PO) .

  op $applyTC* : ProofTreeList ProofOrder -> IndResPair .
  eq $applyTC*(mtPT, PO) = [mtPT, finished] .
  ceq $applyTC*(| M', G, PrL, N | PrL', PO) = [P PrL'', PO' y PO'']
   if [P, PO'] := $applyTC(| M', G, PrL, N |, PO) /\
      [PrL'', PO''] := $applyTC*(PrL', PO) .

  op vars2cons* : EquationSet Module NatList Nat -> ProofTreeList .
  eq vars2cons*(none, M, NL, N) = mtPT .
  ceq vars2cons*(Eq EqS, M, NL, N) = | M', [NL N, 'TC, Eq', N == 1, false], mtPT, 1 |
                                     vars2cons*(EqS, M, NL, s(N))
   if [Eq', M'] := vars2cons(Eq, M) .

  op vars2cons : Equation Module -> Vars2ConsPair .
  ceq vars2cons(eq T = T' [AtS] ., M) = [eq T1 = T2 [AtS] ., M'']
   if [T1, M'] := vars2cons(T, M) /\
      [T2, M''] := vars2cons(T', M') .
  ceq vars2cons(ceq T = T' if COND [AtS] ., M) =
               [ceq T1 = T2 if CND [AtS] ., M''']
   if [T1, M'] := vars2cons(T, M) /\
      [T2, M''] := vars2cons(T', M') /\
      [CND, M'''] := vars2cons*(COND, M) .

  op vars2cons* : TermList Module -> Vars2ConsPair .
  eq vars2cons*(empty, M) = [empty, M] .
  ceq vars2cons*((T, TL), M) = [(T', TL'), M'']
   if [T', M'] := vars2cons(T, M) /\
      [TL', M''] := vars2cons*(TL, M') .

  op vars2cons : Term Module -> Vars2ConsPair .
  eq vars2cons(C, M) = [C, M] .
  ceq vars2cons(V, M) = [C, M']
   if STR := string(getType(V)) /\
      C := qid(string(getName(V)) + "@" + STR + "." + STR) /\
      OD := op getName(C) : nil -> getType(V) [none] . /\
      M' := addOp(M, OD) .
  ceq vars2cons(Q[TL], M) = [Q[TL'], M']
   if [TL', M'] := vars2cons*(TL, M) .

  op vars2cons* : Condition Module -> Vars2ConsPair .
  eq vars2cons*((nil).Condition, M) = [(nil).Condition, M] .
  ceq vars2cons*(T = T' /\ COND, M) = [T1 = T2 /\ CND, M''']
   if [T1, M'] := vars2cons(T, M) /\
      [T2, M''] := vars2cons(T', M') /\
      [CND, M'''] := vars2cons*(COND, M'') .
  ceq vars2cons*(T : Srt /\ COND, M) = [T1 : Srt /\ CND, M'']
   if [T1, M'] := vars2cons(T, M) /\
      [CND, M''] := vars2cons*(COND, M') .
  ceq vars2cons*(T := T' /\ COND, M) = [T1 := T2 /\ CND, M''']
   if [T1, M'] := vars2cons(T, M) /\
      [T2, M''] := vars2cons(T', M') /\
      [CND, M'''] := vars2cons*(COND, M'') .
  ceq vars2cons*(T => T' /\ COND, M) = [T1 => T2 /\ CND, M''']
   if [T1, M'] := vars2cons(T, M) /\
      [T2, M''] := vars2cons(T', M') /\
      [CND, M'''] := vars2cons*(COND, M'') .

  op sizeEQS : EquationSet -> Nat .
  eq sizeEQS(none) = 0 .
  eq sizeEQS(Eq EqS) = s(sizeEQS(EqS)) .

  ***********************************************************************************
  *********************************** SELECT GOAL ***********************************
  ***********************************************************************************

  op selectGoal : ProofTree NatList -> ProofTree .
  eq selectGoal(mtPT, NL) = mtPT .
  ceq selectGoal(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |, NL') =
                            | M, [NL, CMD, EqS, NL == NL', PRVN], PrL', N' |
   if PrL' := selectGoal*(PrL, NL') .

  op selectGoal* : ProofTreeList NatList -> ProofTreeList .
  eq selectGoal*(mtPT, NL) = mtPT .
  eq selectGoal*(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' | PrL', NL') =
       selectGoal(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |, NL') selectGoal*(PrL', NL') .

  op qid2natlist : Qid -> NatList .
  eq qid2natlist(Q) = str2natlist(string(Q)) .

  op str2natlist : String -> NatList .
  ceq str2natlist(S) = rat(substr(S, 0, N), 10) str2natlist(substr(S, N + 1, length(S)))
   if N := find(S, "-", 0) .
  eq str2natlist(S) = rat(S, 10) [owise] .

  op selectGoal : ProofOrder NatList -> ProofOrder .
  eq selectGoal(PO y NL y PO', NL) = NL y PO y PO' .
  eq selectGoal(PO, NL) = PO [owise] .

  vars CURR PRVN : Bool .

  op addOp : Module OpDecl -> Module .
  eq addOp(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm, OD) =
             fmod H is IL sorts SS . SSDS ODS OD MAS EqS endfm .
  eq addOp(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm, OD) =
             mod H is IL sorts SS . SSDS ODS OD MAS EqS RS endm .
  eq addOp(fth H is IL sorts SS . SSDS ODS MAS EqS endfth, OD) =
             fth H is IL sorts SS . SSDS ODS OD MAS EqS endfth .
  eq addOp(th H is IL sorts SS . SSDS ODS MAS EqS RS endth, OD) =
             th H is IL sorts SS . SSDS ODS OD MAS EqS RS endth .

  op addHyp : Module EquationSet -> Module .
  eq addHyp(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm, EqS') =
             fmod H is IL sorts SS . SSDS ODS MAS EqS EqS' endfm .
  eq addHyp(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm, EqS') =
             mod H is IL sorts SS . SSDS ODS MAS EqS EqS' RS endm .
  eq addHyp(fth H is IL sorts SS . SSDS ODS MAS EqS endfth, EqS') =
             fth H is IL sorts SS . SSDS ODS MAS EqS EqS' endfth .
  eq addHyp(th H is IL sorts SS . SSDS ODS MAS EqS RS endth, EqS') =
             th H is IL sorts SS . SSDS ODS MAS EqS EqS' RS endth .

  op addEqs : Term Term -> Term .
  eq addEqs('__[T1, T2], T) = '__[T1, addEqs(T2, T)] .
  eq addEqs(T, T') = '__[T, T'] [owise] .

  ************************************************************************************
  *********************************** GET NEW GOAL ***********************************
  ************************************************************************************

  op getNew : Module EquationSet EquationSet ~> ProofTree .
  eq getNew(M, Eq EqS, Eq EqS') = getNew(M, EqS, EqS') .
  ceq getNew(M, none, EqS) = setToGoal(M, EqS)
   if EqS =/= none .

  op setToGoal : Module EquationSet -> ProofTree .
  eq setToGoal(M, EqS) = | M, [nil, 'root, EqS, true, false], mtPT, 1 | .

  ************************************************************************************
  *********************************** REDUCE COMMAND *********************************
  ************************************************************************************

  sort ProofBool .
  op [_,_] : ProofTreeList Bool -> ProofBool [ctor] .

  op applyRed : ProofTree -> ProofBool .
  ceq applyRed(| M, [NL, CMD, EqS, true, PRVN], PrL, N' |) =
               [| M, [NL, CMD, EqS', not B, B], PrL, N' |, B]
   if [EqS', B] := reduceAll(M, EqS) .
  ceq applyRed(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |) =
                         [| M, [NL, CMD, EqS, false, PRVN], PrL', N' |, B]
   if [PrL', B] := applyRed*(PrL) .

  sort EquationReduction .
  op [_,_] : EquationSet Bool -> EquationReduction [ctor] .

  op reduceAll : Module EquationSet -> EquationReduction .
  eq reduceAll(M, none) = [none, true] .
  ceq reduceAll(M, eq T = T' [AtS] . EqS) = [Eq EqS', B and B']
   if T1 := getTerm(metaReduce(M, T)) /\
      T2 := getTerm(metaReduce(M, T')) /\
      B := T1 == T2 /\
      Eq := if B then eq T = T' [AtS] .
                 else eq T1 = T2 [AtS] .
                 fi /\
      [EqS', B'] := reduceAll(M, EqS) .

  op applyRed* : ProofTreeList -> ProofBool .
  eq applyRed*(mtPT) = [mtPT, false] .
  ceq applyRed*(| M, G, PrL, N' | PrL') = [P PrL'', B or B']
   if [P, B] := applyRed(| M, G, PrL, N' |) /\
      [PrL'', B'] := applyRed*(PrL') .

  op applyRed- : ProofTree -> ProofBool .
  ceq applyRed-(| M, [NL, CMD, eq T = T' [AtS] ., true, PRVN], PrL, N' |) =
               [| M, [NL, CMD, eq T = T' [AtS] ., not B, B], PrL, N' |, B]
   if T1 := getTerm(metaReduce(M, T)) /\
      T2 := getTerm(metaReduce(M, T')) /\
      B := T1 == T2 .
  ceq applyRed-(| M, [NL, CMD, Eq, false, PRVN], PrL, N' |) =
                         [| M, [NL, CMD, Eq, false, PRVN], PrL', N' |, B]
   if [PrL', B] := applyRed-*(PrL) .

  op applyRed-* : ProofTreeList -> ProofBool .
  eq applyRed-*(mtPT) = [mtPT, false] .
  ceq applyRed-*(| M, G, PrL, N' | PrL') = [P PrL'', B or B']
   if [P, B] := applyRed-(| M, G, PrL, N' |) /\
      [PrL'', B'] := applyRed-*(PrL') .

  **************************************************************************************
  *********************************** PRINT CURRENT ************************************
  **************************************************************************************

  op printCurrent : ProofTree -> QidList .
  eq printCurrent(mtPT) = nil .
  eq printCurrent(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |) =
                                   '\n CMD ' printEqS(M, EqS, ' ) '\n .
  eq printCurrent(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |) = printCurrent*(PrL) [owise] .

  op printCurrent* : ProofTreeList -> QidList .
  eq printCurrent*(mtPT) = nil .
  eq printCurrent*(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' | PrL') =
         printCurrent(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |) printCurrent*(PrL') .

  ************************************************************************************
  *********************************** PRINT PROOF ************************************
  ************************************************************************************

  op printProofTree : ProofTree -> QidList .
  eq printProofTree(P) = $printProofTree(P, 0) .

  op $printProofTree : ProofTree Nat -> QidList .
  eq $printProofTree(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N |, N') =
                               printPremises(M, N')
                               '\n printTab(N') printIndex(NL)
                               if PRVN then '* else nil fi
                               if CURR then '> else nil fi
                               CMD '
                               printEqS(M, EqS, printTab(N'))
                               $printProofTree*(PrL, s(N')) .

  op $printProofTree* : ProofTreeList Nat -> QidList .
  eq $printProofTree*(mtPT, N) = nil .
  eq $printProofTree*(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N | PrL', N') =
                       $printProofTree(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N |, N')
                       $printProofTree*(PrL', N') .

  op printTab : Nat -> QidList .
  eq printTab(0) = nil .
  eq printTab(s(N)) = '\t printTab(N) .

  ***********************************************************************************
  ********************************* PRINT PREMISES **********************************
  ***********************************************************************************

  op printPremises : Module Nat -> QidList .
  eq printPremises(M, N) = printPremises(M, getEqs(M), N) .

  op printPremises : Module EquationSet Nat -> QidList .
  ceq printPremises(M, eq T = T' [metadata(S) AtS] . EqS, N) =
        '\n printTab(N) '-- 'Assumption:
        '\n printTab(N) printEq(M, eq T = T' [metadata(S) AtS] .)
        printPremises(M, EqS, N)
   if S == "generated-si" or
      S == "HI" or
      find(S, "CTF", 0) =/= notFound .
  eq printPremises(M, EqS, N) = nil [owise] .

  *************************************************************************************
  *********************************** PRINT LEAVES ************************************
  *************************************************************************************

  op printGoals : ProofTree -> QidList .
  eq printGoals(mtPT) = nil .
  eq printGoals(| M, [NL, CMD, EqS, CURR, PRVN], mtPT, N' |) =
                                   '\n printIndex(NL)
                                   if PRVN then '* else nil fi
                                   if CURR then '> else nil fi
                                   CMD '
                                   printEqS(M, EqS, ') .
  eq printGoals(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |) = printGoals*(PrL) [owise] .

  op printGoals* : ProofTreeList -> QidList .
  eq printGoals*(mtPT) = nil .
  eq printGoals*(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' | PrL') =
         printGoals(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |) printGoals*(PrL') .

  op printIndex : NatList -> QidList .
  eq printIndex(nil) = nil .
  eq printIndex(NL) = qid(natlist2string(NL)) .

  op natlist2string : NatList -> String .
  eq natlist2string(nil) = "" .
  eq natlist2string(N) = string(N, 10) + "." .
  eq natlist2string(N NL) = string(N, 10) + "-" + natlist2string(NL) [owise] .

  op printEqS : Module EquationSet QidList -> QidList .
  eq printEqS(M, none, QIL) = nil .
  eq printEqS(M, Eq EqS, QIL) = printEq(M, Eq) '\n QIL printEqS(M, EqS, QIL) .

  op printEq : Module EquationSet -> QidList .
  eq printEq(M, eq T = T' [label(Q) nonexec] .) = 'eq ' '`[ Q ':nonexec '`] ':
                                                      metaPrettyPrint(M, T, po) ' '=
                                                      metaPrettyPrint(M, T', po) '. .
  eq printEq(M, eq T = T' [label(Q)] .) = 'eq ' '`[ Q '`] ':
                                              metaPrettyPrint(M, T, po) ' '=
                                              metaPrettyPrint(M, T', po) '. .
  eq printEq(M, eq T = T' [nonexec] .) = 'eq ' '`[ ':nonexec '`] ':
                                             metaPrettyPrint(M, T, po) ' '=
                                             metaPrettyPrint(M, T', po) '. .
  eq printEq(M, eq T = T' [metadata(S) AtS] .) = printEq(M, eq T = T' [AtS] .) .
  eq printEq(M, eq T = T' [none] .) = 'eq metaPrettyPrint(M, T, po) ' '=
                                          metaPrettyPrint(M, T', po) '. .
  eq printEq(M, ceq T = T' if COND [label(Q) nonexec] .) =
                    'ceq ' '`[ Q ':nonexec '`] ': metaPrettyPrint(M, T, po) ' '=
                                                 metaPrettyPrint(M, T', po) '. .
  eq printEq(M, ceq T = T' if COND [label(Q)] .) =
                    'ceq ' '`[ Q '`] ': metaPrettyPrint(M, T, po) ' '=
                                        metaPrettyPrint(M, T', po) '. .
  eq printEq(M, ceq T = T' if COND [nonexec] .) =
                    'ceq ' '`[ ':nonexec '`] ': metaPrettyPrint(M, T, po) ' '=
                                                metaPrettyPrint(M, T', po) '. .

  ************************************************************************************
  *********************************** INFER PROOF ************************************
  ************************************************************************************

  op inferProof : Module Qid ScoreInfoSet Macros -> QidList .
  ceq inferProof(M, Q, SIS, MACS) = printProof(M, Q, Q', TL, QIL)
   if Q' := getNameProofScore(SIS) /\
      TL := inferGoal(SIS) /\
      EqS := goalEqS(TL, Q, 0) /\
      P := | M, [nil, 'root, EqS, true, false], mtPT, 1 | /\
      QIL := developProof(P, nil, SIS, MACS) .
  eq inferProof(M, Q, SIS, MACS) = '\n '\! '\r 'Error 'while 'generating 'proof '\o '\n [owise] .

  op goalEqS : TermList Qid Nat -> EquationSet .
  eq goalEqS(empty, Q, N) = none .
  ceq goalEqS((T, TL), Q, N) = eq T = 'true.Bool [label(Q') nonexec] .
                               goalEqS(TL, Q, s(N))
   if Q' := if N == 0
            then Q
            else qid(string(Q) + string(N, 10))
            fi .

  op developProof : ProofTree ProofOrder ScoreInfoSet Macros -> QidList .
  eq developProof(P, finished, SIS, MACS) = nil .
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS)
   if eq T = 'true.Bool [AtS] . EqS := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      V := indRequired(SIS, M, T) /\
      [P', PO'] := applyInduction(P, V, NL y PO) /\
      QIL := '\t ':ind 'on ' '`( metaPrettyPrint(M, V, po) '`) '\n '\n
             '\t ':apply '`( 'si '`) '\n '\n .
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS)
   if eq T = 'true.Bool [AtS] . EqS := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      tcRequired(T) /\
      [P', PO'] := applyTC(P, NL y PO) /\
      QIL := '\t ':apply '`( 'tc '`) '\n '\n .
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P'', PO', SIS, MACS)
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      redRequired(SIS, M, T) /\
      [P', B] := applyRed(P) /\
      PO' := if B
             then PO
             else NL y PO
             fi /\
      B' := PO' == finished /\
      P'' := if B and (not B')
             then selectGoal(P', fst(PO'))
             else P'
             fi /\
      QIL := '\t ':apply ' '`( 'rd '`) '\n '\n .
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS')
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      not redRequired(SIS, M, T) /\
      T1 := ctfTermRequired(SIS, M, T) /\
      Ty := getType(metaNormalize(M, T1)) /\
      | MACS', Q | := addNewMac(MACS, M, T1) /\
      [P', PO'] := applyTermMacro(P, NL y PO, Q, T1, Ty) /\
      QIL := printCtfTermComm(M, Q, T1) .
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS')
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      not redRequired(SIS, M, T) /\
      ctfTermRequired(SIS, M, T) == empty /\
      Eq := ctfRequired(SIS, M, T) /\
      | MACS', Q | := addNewMac(MACS, M, Eq) /\
      P' := applyEquationMacro(P, Q, Eq) /\
      PO' := indProofOrder(NL, 2) y PO /\
      QIL := printCtfComm(M, Q, Eq) .
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', NL y PO, SIS, MACS)
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      ctfTermRequired(SIS, M, T) == empty /\
      ctfRequired(SIS, M, T) == none /\
      | Q, SB | := impRequired(SIS, M, T) /\
      [P', B] := if SB == none
                 then applyImp(P, Q)
                 else applyImp(P, Q, SB)
                 fi /\
      B' := P == P' /\
      QIL := if SB == none
             then '\t ':imp ' '`[ Q '`] ' '. '\n '\n
             else '\t ':imp ' '`[ Q '`] ' 'by ' '`{ printSub(SB) '`} '\n '\n
             fi .
  eq developProof(P, NL y PO, SIS, MACS) =
              if PO =/= finished
              then '\t ':postpone '. '\n '\n
                   developProof(selectGoal(P, fst(PO)), PO, SIS, MACS)
              else nil
              fi [owise] .

  op indRequired : ScoreInfoSet Module Term -> TermList .
  ceq indRequired(SIS, M, T) = V
   if TrS := getVars(T) /\
      V := getIndVar(T, TrS, SIS) .
  eq indRequired(SIS, M, T) = empty [owise] .

  op tcRequired : Term -> Bool .
  eq tcRequired(T) = hasVariables(T) .

  op ctfTermRequired : ScoreInfoSet Module Term -> TermList .
  ceq ctfTermRequired(SIS, M, T) = $ctfTermRequired(SIS1, SIS2, M, T, 2)
   if [SIS1, SIS2] := divideByExecEqs(SIS, 1) .

  op $ctfTermRequired : ScoreInfoSet ScoreInfoSet Module Term Nat -> TermList .
  ceq $ctfTermRequired($ M, M', (TL, T, TL') $ SIS, SIS2, M'', T', N) = T3
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      eq T1 = T2 [AtS] . EqS := getEqs(M') /\
      isExec(AtS) /\
      ((T2 == 'true.Bool) or (T2 == 'false.Bool)) /\
      not isEquality(T1) /\
      T3 := applyCS(T1, CS) /\
      T4 := applyCS(T2, CS)/\
      not eqDefinedFor(M'', T3) /\
      T5 := getTerm(metaReduce(M'', '_=_[T3, T4])) /\
      T5 =/= 'true.Bool /\
      T5 =/= 'false.Bool .
  ceq $ctfTermRequired($ M, M', (TL, T, TL') $
                       $ M1, M2, (TL1, T1, TL2) $ SIS, SIS2, M'', T', N) = T5
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      CS' := getSub(M1, T1, M'', T') /\
      *** Consistent premises
      consistentPremises(M1, M'', CS') /\
      eq T3 = T'' [AtS] . EqS := getEqs(M') /\
      isExec(AtS) /\
      eq T4 = T''' [AtS'] . EqS' := getEqs(M2) /\
      isExec(AtS') /\
      T5 := applyCS(T3, CS) /\
      T5 := applyCS(T4, CS') /\
      T'' =/= T''' /\
      isCtor(M, T'') /\
      isCtor(M1, T''') /\
      not isEquality(T3) /\
      not isEquality(T4) /\
      ((T'' =/= 'true.Bool) and (T'' =/= 'false.Bool)) /\
      ((T''' =/= 'true.Bool) and (T''' =/= 'false.Bool)) /\
      not eqDefinedFor(M'', T5) .
  eq $ctfTermRequired(SIS1, SIS2, M, T, N) =
      if (SIS2 == noScoreInfo) or (ctfRequired(SIS1, M, T) =/= none)
      then empty
      else $ctfTermRequired(fst(divideByExecEqs(SIS2, N)),
                            snd(divideByExecEqs(SIS2, N)), M, T, s(N))
      fi [owise] .

  op eqDefinedFor : Module Term -> Bool .
  ceq eqDefinedFor(M, T) = true
   if eq T = T' [AtS] . EqS := getEqs(M) .
  eq eqDefinedFor(M, T) = false [owise] .

  op eqDefinedFor : Module Term Term -> Bool .
  ceq eqDefinedFor(M, T, T') = true
   if eq T = T' [AtS] . EqS := getEqs(M) .
  ceq eqDefinedFor(M, T, T') = true
   if eq '_=_[T, T'] = T'' [AtS] . EqS := getEqs(M) .
  ceq eqDefinedFor(M, T, 'false.Bool) = true
   if eqDefinedFor(M, T, 'true.Bool) .
  eq eqDefinedFor(M, T, T') = false [owise] .

  op ctfRequired : ScoreInfoSet Module Term -> EquationSet .
  ceq ctfRequired(SIS, M, T) = $ctfRequired(SIS1, SIS2, M, T, 2)
   if [SIS1, SIS2] := divideByExecEqs(SIS, 1) .

  op $ctfRequired : ScoreInfoSet ScoreInfoSet Module Term Nat -> EquationSet .
  ceq $ctfRequired($ M, M', (TL, T, TL') $ SIS, SIS2, M'', T', N) = Eq
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      eq T1 = T2 [AtS] . EqS := getEqs(M') /\
      T'' := getTerm(metaReduce(M, T2)) /\
      isExec(AtS) /\
      T3 := applyCS(T1, CS) /\
      T4 := applyCS(T2, CS) /\
      not eqDefinedFor(M'', T3, T4) /\
      not eqDefinedFor(M'', T3) /\
      Eq := ctfEq(T3, T4) .
  eq $ctfRequired(SIS1, SIS2, M, T, N) =
      if SIS2 == noScoreInfo
      then none
      else $ctfRequired(fst(divideByExecEqs(SIS2, N)),
                        snd(divideByExecEqs(SIS2, N)), M, T, s(N))
      fi [owise] .

  op ctfEq : Term Term -> Equation .
  eq ctfEq('_=_[T1, T2], 'false.Bool) = eq T1 = T2 [none] . .
  eq ctfEq(T1, T2) = if T2 == 'false.Bool
                     then eq T1 = 'true.Bool [none] .
                     else eq T1 = T2 [none] .
                     fi [owise] .

  op isExec : AttrSet -> Bool .
  eq isExec(nonexec AtS) = false .
  eq isExec(AtS) = true [owise] .

  sort ImpRequiredPair .
  op noImpRequired : -> ImpRequiredPair [ctor] .
  op |_,_| : Qid Substitution -> ImpRequiredPair [ctor] .

  op impRequired : ScoreInfoSet Module Term -> ImpRequiredPair .
  ceq impRequired($ M, M', (TL, '_implies_[T1, T2], TL') $ SIS, M'', T) = | Q, none |
   if CS := getSub(M, T2, M'', T) /\
      *** Same premises
      samePremises(M, M', M'', CS) /\
      T3 := getTermImplication('_implies_[T1, T2], T, CS) /\
      eq T3 = 'true.Bool [label(Q) AtS] . EqS := getEqs(M'') .
  ceq impRequired($ M, M', (TL, '_implies_[T1, T2], TL') $ SIS, M'', T) = | Q, SB |
   if CS := getSub(M, T2, M'', T) /\
      *** Same premises
      samePremises(M, M', M'', CS) /\
      T3 := getTermImplication('_implies_[T1, T2], T, CS) /\
      eq T4 = 'true.Bool [label(Q) AtS] . EqS := getEqs(M'') /\
      T3 =/= T4 /\
      SB := computeSub(T4, T3) .
  eq impRequired(SIS, M, T) = noImpRequired [owise] .

  op getTermImplication : Term Term ConsSub -> TermList .
  ceq getTermImplication('_implies_[T1, T2], T, CS) = T3
   if impLevels(T) == impLevels(T2) /\
      T3 := applyCS(T1, CS) .
  ceq getTermImplication('_implies_[T1, T2], T, CS) = getTermImplication(T2, T, CS)
   if impLevels(T2) > impLevels(T) .
  eq getTermImplication(T, T', CS) = empty [owise] .

  *** Term with variables (premise)
  *** Ground term (term being reduced, once substituted)
  op computeSub : Term Term ~> Substitution .
  eq computeSub(C, C) = none .
  eq computeSub(V, T) = V <- T .
  eq computeSub(Q[TL], Q[TL']) = computeSub*(TL, TL') .

  op computeSub* : TermList TermList ~> Substitution .
  eq computeSub*(empty, empty) = none .
  eq computeSub*((T, TL), (T', TL')) = computeSub(T, T') ; computeSub*(TL, TL') .

  op implies? : Term -> Bool .
  eq implies?('_implies_[TL]) = true .
  eq implies?(T) = false [owise] .

  op impLevels : Term -> Nat .
  eq impLevels('_implies_[T, T']) = s(impLevels(T')) .
  eq impLevels(T) = 0 [owise] .

  op redRequired : ScoreInfoSet Module Term -> Bool .
  ceq redRequired($ M, M', (TL, T, TL') $ SIS, M'', T') = true
   if impLevels(T) == impLevels(T') /\
      CS := getSub(M, T, M'', T') /\
      T1 := applyCS(T, CS) /\
      T2 := getTerm(metaReduce(M, T)) /\
      T3 := getTerm(metaReduce(M'', T')) /\
      *** Same premises
      samePremises(M, M', M'', CS) /\
      T2 == T3 .
  eq redRequired(SIS, M, T) = false [owise] .

  op isEquality : Term -> Bool .
  eq isEquality('_=_[T1, T2]) = true .
  eq isEquality(T) = false [owise] .

  *** Flat module
  *** Top module
  *** Goal module
  op samePremises : Module Module Module ConsSub -> Bool .
  eq samePremises(M, M', M'', CS) = samePremises(M, getEqs(M'), M'', CS) .

  op samePremises : Module EquationSet Module ConsSub -> Bool .
  ceq samePremises(M, eq T = T' [AtS] . EqS, M', CS) = eqDefinedFor(M', T1, T2) and
                                                       samePremises(M, EqS, M', CS)
   if isExec(AtS) /\
      T1 := applyCS(T, CS) /\
      T2 := applyCS(T', CS) .
  eq samePremises(M, EqS, M', CS) = true [owise] .

  *** Flat module
  *** Top module
  *** Goal module
  op consistentPremises : Module Module ConsSub -> Bool .
  eq consistentPremises(M', M'', CS) = consistentPremises(getEqs(M'), M'', CS) .

  op consistentPremises : EquationSet Module ConsSub -> Bool .
  ceq consistentPremises(eq T = T' [AtS] . EqS, M', CS) = (T3 =/= 'false.Bool) and
                                                          consistentPremises(EqS, M', CS)
   if isExec(AtS) /\
      T1 := applyCS(T, CS) /\
      T2 := applyCS(T', CS) /\
      T3 := getTerm(metaReduce(M', '_=_[T1, T2])) .
  eq consistentPremises(EqS, M', CS) = true [owise] .

  op getNameProofScore : ScoreInfoSet -> Qid .
  eq getNameProofScore($ M, M', (T, TL)$ SIS) = getNameProofScore(getImports(M')) .

  op getNameProofScore : ImportList -> Qid .
  eq getNameProofScore(including 'BOOL . IL) = getNameProofScore(IL) .
  eq getNameProofScore(protecting 'EQL . IL) = getNameProofScore(IL) .
  eq getNameProofScore(including Q . IL) = cut(Q) [owise] .

  op cut : Qid -> Qid .
  ceq cut(Q) = qid(substr(STR, 0, N))
   if STR := string(Q) /\
      N := find(STR, "-MODCAFE", 0) .
  eq cut(Q) = Q [owise] .

  op renameRepVars : Term -> Term .
  ceq renameRepVars(T) = T
   if TrS := getVars(T) /\
      moreThanOne(T, TrS) == emptyTermSet .
  ceq renameRepVars(T) = renameRepVars(oneSub(T, V, V'))
   if TrS := getVars(T) /\
      V := moreThanOne(T, TrS) /\
      V' := newVar(V, TrS, 0) .

  op renameRepVars* : TermList -> TermList .
  eq renameRepVars*(empty) = empty .
  eq renameRepVars*((T, TL)) = renameRepVars(T), renameRepVars*(TL) .

  op oneSub : Term Variable Variable -> Term .
  eq oneSub(Q[TL], V, V') = Q[oneSub*(TL, V, V')] .
  eq oneSub(V, V, V') = V' .
  eq oneSub(T, V, V') = T [owise] .

  op oneSub* : TermList Variable Variable -> TermList .
  eq oneSub*(empty, V, V') = empty .
  eq oneSub*((TL, T), V, V') = if oneSub(T, V, V') == T
                               then oneSub*(TL, V, V'), T
                               else TL, oneSub(T, V, V')
                               fi .

  op newVar : Variable TermSet Nat -> Variable .
  ceq newVar(V, V' | TrS, N) = newVar(V, TrS, s(N))
   if V' := qid(string(getName(V)) + string(N, 10) + ":" + string(getType(V))) .
  ceq newVar(V, TrS, N) = V'
   if V' := qid(string(getName(V)) + string(N, 10) + ":" + string(getType(V))) [owise] .

  op moreThanOne : Term TermSet -> TermSet .
  ceq moreThanOne(T, V | TrS) = V
   if numReps(T, V) =/= 1 .
  eq moreThanOne(T, TrS) = emptyTermSet [owise] .

  op numReps : Term Variable -> Nat .
  eq numReps(C, V) = 0 .
  eq numReps(V, V') = if V == V'
                      then 1
                      else 0
                      fi .
  eq numReps(Q[TL], V) = numReps*(TL, V) .

  op numReps* : TermList Variable -> Nat .
  eq numReps*(empty, V) = 0 .
  eq numReps*((T, TL), V) = numReps(T, V) + numReps*(TL, V) .

  op inferGoal : ScoreInfoSet ~> TermList .
  ceq inferGoal($ M, M', (T, TL)$ SIS) = TL2
   if TL' := TL, completeTermList(SIS) /\
      TL1 := inferGoal(M, (T, TL')) /\
      TL2 := renameRepVars*(TL1) .

  sort InferenceResult .
  op [_,_] : Term TermList -> InferenceResult [ctor] .

  op inferGoal : Module TermList -> TermList .
  ceq inferGoal(M, (T, TL)) = T1, TL'
   if [T1, TL1] := $inferGoal(M, T, TL, empty) /\
      TL' := inferGoal(M, TL1) .
  eq inferGoal(M, empty) = empty .

  op $inferGoal : Module Term TermList TermList ~> InferenceResult .
  eq $inferGoal(M, T, empty, TL') = [T, TL'] .
  ceq $inferGoal(M, T, (T', TL), TL') = $inferGoal(M, T'', TL, TL')
   if T'' := unifyGoal(M, T, T') .
  eq $inferGoal(M, T, (T', TL), TL') = $inferGoal(M, T, TL, (TL', T')) [owise] .

  op unifyGoal : Module Term Term ~> Term .
  eq unifyGoal(M, V, V') = V .
  eq unifyGoal(M, V, C) = V .
  ceq unifyGoal(M, C, C') = V
   if not isCtor(M, C) /\
      not isCtor(M, C') /\
      Ty := getType(C) /\
      sameKind(M, Ty, getType(C')) /\
      V := qid(substr(string(Ty), 0, 1) + ":" + string(Ty)) .
  ceq unifyGoal(M, Q[TL], Q[TL']) = Q[TL'']
   if TL'' := unifyGoal*(M, TL, TL') .
  eq unifyGoal(M, '_implies_[T, T'], T'') = unifyGoal(M, T', T'') .
  eq unifyGoal(M, T, '_implies_[T', T'']) = unifyGoal(M, T, T'') .
  ceq unifyGoal(M, T, T') = V
   if isCtor(M, T) /\
      isCtor(M, T') /\
      Ty := getType(metaReduce(M, T)) /\
      V := qid(substr(string(Ty), 0, 1) + ":" + string(Ty)) [owise] .

  op unifyGoal* : Module TermList TermList ~> TermList .
  eq unifyGoal*(M, empty, empty) = empty .
  eq unifyGoal*(M, (T, TL), (T', TL')) = unifyGoal(M, T, T'), unifyGoal*(M, TL, TL') .

  op printProof : Module Qid Qid TermList QidList -> QidList .
  eq printProof(M, Q, Q', TL, QIL) =
          '\n 'open Q' '. '\n
          '\t ':goal '`{ '\n
          printGoals(M, TL, Q, 0)
          '\t '`} '\n '\n
          QIL '\n
          'close .

  op printGoals : Module TermList Qid Nat -> QidList .
  eq printGoals(M, empty, Q, N) = nil .
  ceq printGoals(M, (T, TL), Q, N) =
          '\t '\t 'eq ' '`[ Q' ':nonexec '`] ' ':
                                 metaPrettyPrint(M, T, po) ' '= 'true '. '\n
          printGoals(M, TL, Q, s(N))
   if Q' := if N == 0
            then Q
            else qid(string(Q) + string(N, 10))
            fi .

  op printSub : Substitution -> QidList .
  eq printSub(none) = nil .
  eq printSub(V <- C ; SB) = V '<- getName(C) ';  printSub(SB) .

  *** When inferring goal it is possible that fresh constants appear. In this case
  *** we need to add them or turn them into variables.

  sort SISPair .
  op [_,_] : ScoreInfoSet ScoreInfoSet -> SISPair [ctor] .

  ops fst snd : SISPair -> ScoreInfoSet .
  eq fst([SIS1, SIS2]) = SIS1 .
  eq snd([SIS1, SIS2]) = SIS2 .

  op divideByExecEqs : ScoreInfoSet Nat -> SISPair .
  eq divideByExecEqs(SIS, N) = $divideByExecEqs(SIS, N, [noScoreInfo, noScoreInfo]) .

  op $divideByExecEqs : ScoreInfoSet Nat SISPair -> SISPair .
  eq $divideByExecEqs(noScoreInfo, N, SISP) = SISP .
  eq $divideByExecEqs($ M, M', TL $ SIS, N, [SIS1, SIS2]) =
       if numExecEqs(M') == 0
       then $divideByExecEqs(SIS, N, [SIS1, SIS2])
       else if numExecEqs(M') == N
            then $divideByExecEqs(SIS, N, [$ M, M', TL $ SIS1, SIS2])
            else $divideByExecEqs(SIS, N, [SIS1, $ M, M', TL $ SIS2])
            fi
       fi .

  op numExecEqs : Module -> Nat .
  eq numExecEqs(M) = numExecEqs(getEqs(M)) .

  op numExecEqs : EquationSet -> Nat .
  ceq numExecEqs(eq T = T' [AtS] . EqS) = s(numExecEqs(EqS))
   if isExec(AtS) .
  ceq numExecEqs(ceq T = T' if COND [AtS] . EqS) = s(numExecEqs(EqS))
   if isExec(AtS) .
  eq numExecEqs(EqS) = 0 [owise] .

  ***********************************************************************************
  ***                             AUXILIARY FUNCTIONS                             ***
  ***                                 hasVariables                                ***
  ***********************************************************************************

  op hasVariables : Term -> Bool .
  eq hasVariables(C) = false .
  eq hasVariables(V) = true .
  eq hasVariables(Q[TL]) = hasVariables*(TL) .

  op hasVariables* : TermList -> Bool .
  eq hasVariables*(empty) = false .
  eq hasVariables*((T, TL)) = hasVariables(T) or hasVariables*(TL) .

  ***********************************************************************************
  ***                             AUXILIARY FUNCTIONS                             ***
  ***                            Case splitting: cvss                             ***
  ***********************************************************************************

  op subsortSingleBinaryOpConstraints : Module Term -> Bool .
  ceq subsortSingleBinaryOpConstraints(M, T) = subsortSingleBinaryOpConstraints(M, Ty)
   if Ty := getType(metaReduce(M, T)) .

  op subsortSingleBinaryOpConstraints : Module Type -> Bool .
  eq subsortSingleBinaryOpConstraints(M, Ty) = hasSingleBinaryCtor(getOps(M), Ty) and
                                               hasSubsort(getSubsorts(M), Ty) .

  op hasSingleBinaryCtor : OpDeclSet Type -> Bool .
  eq hasSingleBinaryCtor(op Q : Ty1 Ty2 -> Ty [ctor AtS] . ODS, Ty) = hasNoOther(ODS, Ty) .
  eq hasSingleBinaryCtor(ODS, Ty) = false [owise] .

  op hasNoOther : OpDeclSet Type -> Bool .
  eq hasNoOther(op Q : TyL -> Ty [ctor AtS] . ODS, Ty) = false .
  eq hasNoOther(ODS, Ty) = true [owise] .

  op hasSubsort : SubsortDeclSet Type -> Bool .
  eq hasSubsort(subsort Ty1 < Ty . SSDS, Ty) = true .
  eq hasSubsort(SSDS, Ty) = false [owise] .


  ***********************************************************************************
  ***                             AUXILIARY FUNCTIONS                             ***
  ***                            Case splitting: cevs                             ***
  ***********************************************************************************

  op subsortUnaryBinaryOpConstraints : Module Term -> Bool .
  ceq subsortUnaryBinaryOpConstraints(M, T) = subsortUnaryBinaryOpConstraints(M, Ty)
   if Ty := getType(metaReduce(M, T)) .

  op subsortUnaryBinaryOpConstraints : Module Type -> Bool .
  eq subsortUnaryBinaryOpConstraints(M, Ty) = hasBinaryCtor(getOps(M), Ty) and
                                              hasUnaryCtor(getOps(M), Ty) and
                                              hasSubsort(getSubsorts(M), Ty) .

  op hasBinaryCtor : OpDeclSet Type -> Bool .
  eq hasBinaryCtor(op Q : Ty1 Ty2 -> Ty [ctor AtS] . ODS, Ty) = true .
  eq hasBinaryCtor(ODS, Ty) = false [owise] .

  op hasUnaryCtor : OpDeclSet Type -> Bool .
  eq hasUnaryCtor(op Q : nil -> Ty [ctor AtS] . ODS, Ty) = true .
  eq hasUnaryCtor(ODS, Ty) = false [owise] .

  ***********************************************************************************
  ***                             AUXILIARY FUNCTIONS                             ***
  ***                                   getIndVar                                 ***
  ***********************************************************************************

  *** Variables
  *** Reduced term
  op getIndVar : Term TermSet ScoreInfoSet -> TermList .
  eq getIndVar(T, emptyTermSet, SIS) = empty .
  ceq getIndVar(T, (V | TrS), SIS) = V
   if isIndVar(T, V, SIS) .
  ceq getIndVar(T, (V | TrS), SIS) = getIndVar(T, TrS, SIS)
   if not isIndVar(T, V, SIS) .

  op isIndVar : Term Variable ScoreInfoSet -> Bool .
  eq isIndVar(T, V, noScoreInfo) = true .
  eq isIndVar(T, V, $ M, M', empty $ SIS) = isIndVar(T, V, SIS) .
  ceq isIndVar(T, V, $ M, M', (T', TL) $ SIS) = isIndVar(T, V, $ M, M', TL $ SIS)
   if T'' := getMatch(T, T', V) /\
      isCtor(M, T'') .
  *** In this case we have several goals and the current reduction is not related
  *** to the current goal.
  ceq isIndVar(T, V, $ M, M', (T', TL) $ SIS) = isIndVar(T, V, $ M, M', TL $ SIS)
   if getMatch(T, T', V) == empty .
  eq isIndVar(T, V, SIS) = false [owise] .

  op getMatch : Term Term Variable -> TermList .
  eq getMatch(V, T, V) = T .
  eq getMatch(Q[TL], Q[TL'], V) = getMatch*(TL, TL', V) .
  eq getMatch(T, '_implies_[T1, T2], V) = getMatch(T, T2, V) .
  eq getMatch('_implies_[T1, T2], T, V) = getMatch(T2, T, V) .
  eq getMatch(T, T', V) = empty [owise] .

  op getMatch* : TermList TermList Variable ~> TermList .
  eq getMatch*((T, TL), (T', TL'), V) = getMatch(T, T', V), getMatch*(TL, TL', V) .
  eq getMatch*(TL, TL', V) = empty [owise] .

  ***********************************************************************************
  ******************************* AUXILIARY FUNCTIONS *******************************
  ************************************* isCtor **************************************
  ***********************************************************************************

  *** This function checks whether the outer operator is a constructor while the rest
  *** of the arguments are fresh constants.
  *** In the case of constants it is enough for it to be a constructor.

  op isCtor : Module Term -> Bool .
  eq isCtor(M, T) = isCtor(getOps(M), T) .

  op isCtor : OpDeclSet Term -> Bool .
  eq isCtor(ODS, V) = true .
  ceq isCtor(op Q : nil -> Ty [ctor AtS] . ODS, C) = true
   if Q := getName(C) .
  eq isCtor(op Q : TyL -> Ty [ctor AtS] . ODS, Q[TL]) =
            allNonCtorConstants(op Q : TyL -> Ty [ctor AtS] . ODS, TL) .
  eq isCtor(ODS, T) = false [owise] .

  op allNonCtorConstants : OpDeclSet TermList -> Bool .
  eq allNonCtorConstants(ODS, empty) = true .
  eq allNonCtorConstants(ODS, (T, TL)) = nonCtorConstant(ODS, T) and
                                         allNonCtorConstants(ODS, TL) .

  op nonCtorConstant : OpDeclSet Term -> Bool .
  eq nonCtorConstant(ODS, V) = false .
  eq nonCtorConstant(ODS, Q[TL]) = false .
  ceq nonCtorConstant(op Q : nil -> Ty [ctor AtS] . ODS, C) = false
   if Q := getName(C) .
  eq nonCtorConstant(ODS, C) = true [owise] .

  ***********************************************************************************
  ******************************* AUXILIARY FUNCTIONS *******************************
  ********************************** EXTRACTS VARS **********************************
  ***********************************************************************************

  op getVars : Term -> TermSet .
  eq getVars(C) = emptyTermSet .
  eq getVars(V) = V .
  eq getVars(Q[TL]) = getVars*(TL) .

  op getVars* : TermList -> TermSet .
  eq getVars*(empty) = emptyTermSet .
  eq getVars*((T, TL)) = getVars(T) | getVars*(TL) .

  ***********************************************************************************
  ******************************* AUXILIARY FUNCTIONS *******************************
  ******************************** PRINT CTF COMMAND ********************************
  ***********************************************************************************

  op printCtfComm : Module Qid Equation -> QidList .
  eq printCtfComm(M, Q, eq T = T' [AtS] .) = '\t ':def Q '= ':ctf ' '`{ 'eq
                                             metaPrettyPrint(M, T, po) ' '=
                                             metaPrettyPrint(M, T', po) '. '`} '\n '\n
                                             '\t ':apply '`( Q '`) '\n '\n .

  op printCtfTermComm : Module Qid Term -> QidList .
  eq printCtfTermComm(M, Q, T) = '\t ':def Q '= ':ctf ' '`[
                             metaPrettyPrint(M, T, po) ' '. '`] '\n '\n
                             '\t ':apply '`( Q '`) '\n '\n .

  ***********************************************************************************
  ******************************* AUXILIARY FUNCTIONS *******************************
  ********************************** ADD NEW MACRO **********************************
  ***********************************************************************************

  sort NewMacPair .
  op |_,_| : Macros Qid -> NewMacPair [ctor] .

  op addNewMac : Macros Module Equation -> NewMacPair .
  eq addNewMac(MACS, M, Eq) = addNewMac(MACS, M, Eq, 1) .

  op addNewMac : Macros Module Equation Nat -> NewMacPair .
  ceq addNewMac(# M, Q - Eq # MACS, M', Eq', N) = addNewMac(# M, Q - Eq # MACS, M', Eq', s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(# M, Q - T # MACS, M', Eq', N) = addNewMac(# M, Q - T # MACS, M', Eq', s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(MACS, M, Eq, N) = | # M, Q - Eq # MACS, Q |
   if Q := qid("csb" + string(N, 10)) [owise] .

  op addNewMac : Macros Module Term -> NewMacPair .
  eq addNewMac(MACS, M, T) = addNewMac(MACS, M, T, 1) .

  op addNewMac : Macros Module Term Nat -> NewMacPair .
  ceq addNewMac(# M, Q - Eq # MACS, M', T, N) = addNewMac(# M, Q - Eq # MACS, M', T, s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(# M, Q - T # MACS, M', T', N) = addNewMac(# M, Q - T # MACS, M', T', s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(MACS, M, T, N) = | # M, Q - T # MACS, Q |
   if Q := qid("csb" + string(N, 10)) [owise] .

  ************************************************************************************
  ******************************* AUXILIARY FUNCTIONS ********************************
  ****************************** CONSTANT SUBSTITUTIONS ******************************
  ************************************************************************************

  sort ConsSub .
  op mtCS : -> ConsSub [ctor] .
  op _to_ : Constant Constant -> ConsSub [ctor] .
  op __ : ConsSub ConsSub -> ConsSub [ctor assoc comm id: mtCS] .

  *** Module for reduction
  *** Term in reduction
  *** Module for the goal
  *** Goal
  op getSub : Module Term Module Term ~> ConsSub .
  ceq getSub(M, Q[TL], M', Q[TL']) = getSub*(M, TL, M', TL')
   if Q =/= '_implies_ .
  eq getSub(M, V, M', V') = mtCS .
  eq getSub(M, C, M', C) = mtCS .
  ceq getSub(M, C, M', C') = C to C'
   if C =/= C' /\
      not isCtor(M, C) /\
      not isCtor(M', C') .
  eq getSub(M, '_implies_[T, T'], M', T'') = getSub(M, T', M', T'') .
  eq getSub(M, T, M', '_implies_[T', T'']) = getSub(M, T, M', T'') .

  op getSub* : Module TermList Module TermList ~> ConsSub .
  eq getSub*(M, empty, M', empty) = mtCS .
  eq getSub*(M, (T, TL), M', (T', TL')) = getSub(M, T, M', T')
                                          getSub*(M, TL, M', TL') .

  op applyCS : Term ConsSub -> Term .
  eq applyCS(Q[TL], CS) = Q[applyCS*(TL, CS)] .
  eq applyCS(V, CS) = V .
  eq applyCS(C, (C to C') CS) = C' .
  eq applyCS(C, CS) = C [owise] .

  op applyCS* : TermList ConsSub -> TermList .
  eq applyCS*(empty, CS) = empty .
  eq applyCS*((T, TL), CS) = applyCS(T, CS), applyCS*(TL, CS) .

  ************************************************************************************
  ******************************* AUXILIARY FUNCTIONS ********************************
  ************************************************************************************

  op parseModule4Vars : TermList -> OpDeclSet .
  eq parseModule4Vars(empty) = none .
  eq parseModule4Vars('__[TL]) = parseModule4Vars(TL) .
  eq parseModule4Vars(('var_:_.[T , T'], TL)) = parseVars('var_:_.[T , T'])
                                                parseModule4Vars(TL) .
  eq parseModule4Vars(('vars_:_.[T , T'], TL)) = parseVars('vars_:_.[T , T'])
                                                 parseModule4Vars(TL) .
  eq parseModule4Vars((T, TL)) = parseModule4Vars(TL) [owise] .

  op parseVars : Term -> OpDeclSet .
  ceq parseVars('var_:_.['neCafeTokenList['__[TL]], 'CafeToken[T]]) =
                                                           parseVars*(TL, Srt)
   if Srt := downQid(T) .
  ceq parseVars('vars_:_.['neCafeTokenList['__[TL]], 'CafeToken[T]]) =
                                                           parseVars*(TL, Srt)
   if Srt := downQid(T) .
  ceq parseVars('var_:_.['neCafeTokenList[T], 'CafeToken[T']]) =
                                                           op Q : nil -> Srt [none] .
   if Q := downQid(T) /\
      Srt := downQid(T') .
  ceq parseVars('var_:_.['neCafeTokenList[T], 'CafeToken[T']]) =
                                                           op Q : nil -> Srt [none] .
   if Q := downQid(T) /\
      Srt := downQid(T') .

  op parseVars* : TermList Sort -> OpDeclSet .
  eq parseVars*(empty, Srt) = none .
  eq parseVars*((T, TL), Srt) = op downQid(T) : nil -> Srt [none] .
                                parseVars*(TL, Srt) .

  op printRedRes : Module Term Term Type -> QidList .
  eq printRedRes(M, T, T', Ty) = '\n 'reduce metaPrettyPrint(M, T, po) '. '\n
                                 '\g '\! 'Result: '\o metaPrettyPrint(M, T', po) ': Ty
                                 '\n .

***(%
\end{comment}
}
{\codesize
\begin{verbatim}
%)

endm

***(%
\end{verbatim}
}

\subsection{Pretty printing\label{subsec:pretty}}

Once the modules are parsed, it might be interesting to print them. However, we
cannot print them from the corresponding Maude module, since we have lost information
about things like hidden sorts, behavioral equations, etc. For this reason, we will
show how to print the term standing for the original CafeOBJ specification.
%
The module \verb"CAFE-PRETTY-PRINT" is in charge of printing:

{\codesize
\begin{verbatim}
%)

mod CAFE-PRETTY-PRINT is
  pr CafePARSER .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  vars QIL QIL' QIL'' QIL1 QIL2 QIL3 QIL4 QILL QILA PL : QidList .
  vars T T' T'' T''' T1 T2 T3 TW TW' : Term .
  vars ODS ODS' ODS'' VDS : OpDeclSet .
  vars St St' St'' St''' : String .
  vars ME ME' : ModuleExpression .
  vars EqS EqS' : EquationSet .
  vars TL TL' TL'' : TermList .
  var  SSDS : SubsortDeclSet .
  vars AtS AtS' : AttrSet .
  vars Q Q' GID QI : Qid .
  vars RS RS' : RuleSet .
  var  COND : Condition .
  vars M M' FM : Module .
  var  RP : ResultPair .
  var  IL : ImportList .
  var  MAS : MembAxSet .
  var  DB : Database .
  var  Ct : Constant .
  var  C : Condition .
  var  V : Variable .
  var  SS : SortSet .
  vars B B' : Bool .
  vars N N' : Nat .
  var  H : Header .
  var  S : Sort .

***(%
\end{comment}
}

We fix the Maude options for printing in the \verb"printOpts" constant:

{\codesize
\begin{verbatim}
%)

  op printOpts : -> PrintOptionSet .
  eq printOpts = mixfix number rat format .

***(%
\end{verbatim}
}

The character preceding or following a scape character is usually printed without
separation, which worsens the legibility. To prevent the system from doing it, we
use the function \verb"addSpace", which adds extra space if required:

{\codesize
\begin{verbatim}
%)

  op addSpace : QidList -> QidList .
  eq addSpace(QIL) = addSpaceL(addSpaceR(QIL)) .

***(%
\end{verbatim}
}

\noindent
where the auxiliary functions \verb"addSpaceL" and \verb"addSpaceR"
add a space at the left and the right of the list, respectively:

{\codesize
\begin{verbatim}
%)

  op addSpaceL : QidList -> QidList .
  eq addSpaceL('`( QIL) = ' '`( QIL .
  eq addSpaceL('`[ QIL) = ' '`[ QIL .
  eq addSpaceL('`{ QIL) = ' '`{ QIL .
  eq addSpaceL(QIL) = QIL [owise] .

  op addSpaceR : QidList -> QidList .
  eq addSpaceR(QIL '`)) = QIL '`) ' .
  eq addSpaceR(QIL '`]) = QIL '`] ' .
  eq addSpaceR(QIL '`}) = QIL '`} ' .
  eq addSpaceR(QIL) = QIL [owise] .

***(%
\end{verbatim}
}

The function \verb"printCond" prints a condition. It traverses each
specific condition until \verb"nil" is reached. We just show the
equality case, where both terms are printed by using the
\texttt{printOpts} constant above:

{\codesize
\begin{verbatim}
%)

  op printCond : Module Condition -> QidList .
  eq printCond(M, nil) = nil .
  eq printCond(M, T = T' /\ C) = metaPrettyPrint(M, T, printOpts) '=
                                 metaPrettyPrint(M, T', printOpts)
                                 if C == nil
                                 then nil
                                 else '/\ printCond(M, C)
                                 fi .

***(%
   ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  eq printCond(M, T := T' /\ C) = metaPrettyPrint(M, T, printOpts) ':=
                                  metaPrettyPrint(M, T', printOpts)
                                  if C == nil
                                  then nil
                                  else '/\ printCond(M, C)
                                  fi .
  eq printCond(M, T => T' /\ C) = metaPrettyPrint(M, T, printOpts) '=>
                                  metaPrettyPrint(M, T', printOpts)
                                  if C == nil
                                  then nil
                                  else '/\ printCond(M, C)
                                  fi .
  eq printCond(M, T : S /\ C) = metaPrettyPrint(M, T, printOpts) ': S
                                if C == nil
                                then nil
                                else '/\ printCond(M, C)
                                fi .

  op printCafeAtS : AttrSet -> QidList .
  eq printCafeAtS(label(Q) AtS) = printCafeAtS(AtS) .
  eq printCafeAtS(metadata("added") AtS) = printCafeAtS(AtS) .
  eq printCafeAtS(none) = nil .
  eq printCafeAtS(AtS) = '\g ' '`{ '\o printCafeAtSAux(AtS) '\g '`} '\o .

  op printCafeAtSAux : AttrSet -> QidList .
  eq printCafeAtSAux(none) = nil .
  eq printCafeAtSAux(nonexec AtS) = 'nonexec printCafeAtSAux(AtS) .
  eq printCafeAtSAux(metadata(St) AtS) = 'metadata: qid(St) printCafeAtSAux(AtS) .
  eq printCafeAtSAux(AtS) = 'No 'print 'specified. [owise] .

  op printLabel : AttrSet -> QidList .
  ceq printLabel(label(Q) AtS) = ' '`[ Q '`] ' ':
   if substr(string(Q), 0, 5) =/= "lemma" .
  eq printLabel(AtS) = nil [owise] .

***(%
  **************************
  *** Print CafeOBJ Term ***
  **************************
\end{comment}
}

The function \verb"printCafeModule" is in charge of printing CafeOBJ modules.
We only distinguish cases to print the appropriate keyword, but the rest of the
methods are common for both kinds of modules:

{\codesize
\begin{verbatim}
%)

  op printCafeModule : Term Module Database Bool -> QidList .
  ceq printCafeModule('cmod!_`{_`}[T, T'], M, DB, B) =
                      '\n 'mod! printCafeName(DB, M, T) '`{
                      '\n first(printCafeBody*(paramSortsMap(T', empty, PL), M, DB, none, PL))
                      '\n '`}
   if PL := paramNames(T) .
  ceq printCafeModule('cmod*_`{_`}[T, T'], M, DB, B) =
                      '\n 'mod* printCafeName(DB, M, T) '`{
                      '\n first(printCafeBody*(paramSortsMap(T', empty, PL), M, DB, none, PL))
                      '\n '`}
   if PL := paramNames(T) .

***(%
\end{verbatim}
}

\noindent
where the function \verb"paramNames" just extracts the parameter names from
the term:

{\codesize
\begin{verbatim}
%)

  op paramNames : Term -> QidList .
  eq paramNames('_`(_`)[T, T']) = cafeParamNames(T') .

***(%
\end{verbatim}
}

The function \verb"printCafeName" is in charge of printing the header
of the module. It distinguishes between all the possible module expressions:

{\codesize
\begin{verbatim}
%)

  op printCafeName : Database Module Term -> QidList .
  eq printCafeName(DB, M, 'CafeToken[T]) = downQid(T) .
  eq printCafeName(DB, M, 'token[T]) = downQid(T) .
  ceq printCafeName(DB, M, '_`(_`)[T, T']) = QIL '`( QIL' '`) '
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeViewExp(DB, M, T') .
  ceq printCafeName(DB, M, '_*`{_`}[T, T']) = QIL '* ' '`{ QIL' '`}
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeRen(T') .
  ceq printCafeName(DB, M, '_+_[T, T']) = QIL '+ QIL'
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeName(DB, M, T') .

***(%
\end{verbatim}
}

The following auxiliary functions are required by \texttt{printCafeName}:
\begin{itemize}
\item
\verb"printCafeViewExp", which prints any view expression:

{\codesize
\begin{verbatim}
%)

  op printCafeViewExp : Database Module Term -> QidList .
  eq printCafeViewExp(DB, M, 'token[T]) = downQid(T) .
  ceq printCafeViewExp(DB, M, '_`,_[T, T']) = QIL '`, ' QIL'
   if QIL := printCafeViewExp(DB, M, T) /\
      QIL' := printCafeViewExp(DB, M, T') .
  ceq printCafeViewExp(DB, M, '_::_[T, T']) = QIL ':: QIL'
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeName(DB, M, T') .
  ceq printCafeViewExp(DB, M, '_<=_[T, T']) = QIL '<= QIL'
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeViewExp(DB, M, T') .
  ceq printCafeViewExp(DB, M, 'view`to_`{_`}[T, T']) =
                                     'view 'to QIL ' '`{ ' QIL' ' '`}
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeMaps(DB, M, T') .
  ceq printCafeViewExp(DB, M, '_`{_`}[T, T']) = QIL ' '`{ ' QIL' ''`}
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeMaps(DB, M, T') .

***(%
\end{verbatim}
}

\item
\verb"printCafeMaps", which prints the possible mappings appearing in views:

{\codesize
\begin{verbatim}
%)

  op printCafeMaps : Database Module Term -> QidList .
  ceq printCafeMaps(DB, M, '__[T, T']) = QIL QIL'
   if QIL := printCafeMaps(DB, M, T) /\
      QIL' := printCafeMaps(DB, M, T') .
  ceq printCafeMaps(DB, M, 'sort_->_.[T, T']) = 'sort Q 'to Q'
   if Q := printCafeName(DB, M, T) /\
      Q' := printCafeName(DB, M, T') .
  ceq printCafeMaps(DB, M, 'hsort_->_.[T, T']) = 'hsort Q 'to Q'
   if Q := printCafeName(DB, M, T) /\
      Q' := printCafeName(DB, M, T') .
  ceq printCafeMaps(DB, M, 'op_->_.['CafeBubble[T], 'CafeBubble[T']]) =
                                                          'op QIL '-> QIL'
   if QIL := metaPrettyPrint(M, T, printOpts) /\
      QIL' := metaPrettyPrint(M, T', printOpts) .

***(%
\end{verbatim}
}

\item
\verb"printCafeRen", which is in charge of printing renamings:

{\codesize
\begin{verbatim}
%)

  op printCafeRen : Term -> QidList .
  ceq printCafeRen('__[T, T']) = QIL '`, ' QIL'
   if QIL := printCafeRen(T) /\
      QIL' := printCafeRen(T') .
  ceq printCafeRen('sort_->_.[T, T']) = 'sort QIL '-> QIL'
   if QIL := printCafeSort(T) /\
      QIL' := printCafeSort(T') .
  ceq printCafeRen('hsort_->_.[T, T']) = 'hsort QIL '-> QIL'
   if QIL := printCafeSort(T) /\
      QIL' := printCafeSort(T') .
  ceq printCafeRen('op_->_.[T, T']) = 'op QIL '-> QIL'
   if QIL := printCafeTerm(T) /\
      QIL' := printCafeTerm(T') .
  ceq printCafeRen('bop_->_.[T, T']) = 'op QIL '-> QIL'
   if QIL := printCafeTerm(T) /\
      QIL' := printCafeTerm(T') .

***(%
\end{verbatim}
}

\item
\verb"printCafeTerm", which prints a token or a singleton bubble:

{\codesize
\begin{verbatim}
%)

  op printCafeTerm : Term -> QidList .
  eq printCafeTerm('token[T]) = downQid(T) .
  eq printCafeTerm('CafeToken[T]) = downQid(T) .
  eq printCafeTerm('CafeBubble[T]) = downQid(T) .

***(%
\end{verbatim}
}

\item
\verb"printCafeSort", which just prints a token or a quoted identifier:

{\codesize
\begin{verbatim}
%)

  op printCafeSort : Term -> QidList .
  eq printCafeSort('CafeToken[T]) = downQid(T) .
  eq printCafeSort(T) = downQid(T) [owise] .

***(%
\end{verbatim}
}

\end{itemize}

We define the sort \verb"PrintCafePair" to return a pair consisting of
the list of quoted identifier computed thus far and the set of variables
defined in the module:

{\codesize
\begin{verbatim}
%)

  sort PrintCafePair .
  op <_,_> : QidList OpDeclSet -> PrintCafePair [ctor] .

***(%
\end{verbatim}
}

We also define methods \verb"first" and \verb"second" to obtain the
corresponding components:

{\codesize
\begin{verbatim}
%)

  op first : PrintCafePair -> QidList .
  eq first(< QIL, ODS >) = QIL .

  op second : PrintCafePair -> OpDeclSet .
  eq second(< QIL, ODS >) = ODS .

***(%
\end{verbatim}
}

The function \verb"printCafeBody*" receives the term standing for the original
CafeOBJ specification, the obtained Maude module, the current database, a set of
variables, and a list of parameters and returns a term of sort containing the
representation of the module and the whole set of variables. It just traverses
all the sentences in the module applying \texttt{printCafeBody} to each of them:

{\codesize
\begin{verbatim}
%)

  op printCafeBody* : Term Module Database OpDeclSet QidList -> PrintCafePair .
  ceq printCafeBody*('__[T, T'], M, DB, ODS, PL) = <
                     if QIL =/= nil
                     then '\t QIL '\n
                     else nil
                     fi QIL', ODS'' >
   if < QIL, ODS' > := printCafeBody(T, M, DB, ODS, PL) /\
      < QIL', ODS'' > := printCafeBody*(T', M, DB, ODS', PL) .
  ceq printCafeBody*(T, M, DB, ODS, PL) = < '\t QIL, ODS' >
   if < QIL, ODS' > := printCafeBody(T, M, DB, ODS, PL) .

***(%
\end{verbatim}
}

The function \verb"printCafeBody" receives a specific CafeOBJ statement and prints it.
When dealing with importations, we just use the \texttt{printCafeName} shown above:

%  *************************
%  *** Importing modules ***
%  *************************

{\codesize
\begin{verbatim}
%)

  op printCafeBody : Term Module Database OpDeclSet QidList -> PrintCafePair .
  ceq printCafeBody('protecting`(_`)[T], M, DB, ODS, PL) =
                                                   < 'protecting '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('pr`(_`)[T], M, DB, ODS, PL) = < 'pr '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('extending`(_`)[T], M, DB, ODS, PL) =
                                                   < 'extending '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('ex`(_`)[T], M, DB, ODS, PL) = < 'ex '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('including`(_`)[T], M, DB, ODS, PL) =
                                                   < 'including '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('inc`(_`)[T], M, DB, ODS, PL) = < 'inc '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('using`(_`)[T], M, DB, ODS, PL) = < 'using '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('us`(_`)[T], M, DB, ODS, PL) = < 'us '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .

***(%
\end{verbatim}
}

Printing sorts requires to modify them in order to qualify the terms following the
CafeOBJ syntax:

%  ************************
%  *** Sort definitions ***
%  ************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('*`[_`]*[T], M, DB, ODS, PL) = < '* '`[ QIL '`] '*, ODS >
   if QIL := prettyprintParams(printCafeSort(T), PL) .
  ceq printCafeBody('`[_`]['__[T, T']], M, DB, ODS, PL) = < '`[ QIL QIL' '`], ODS >
   if QIL := prettyprintParams(printCafeSort(T), PL) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) .
  ceq printCafeBody('`[_`]['CafeToken[T]], M, DB, ODS, PL) = < '`[ QIL '`], ODS >
   if QIL := prettyprintParams(printCafeSort(T), PL) .
  ceq printCafeBody('`[_`]['_<_[T, T']], M, DB, ODS, PL) = < '`[ QIL '< QIL' '`], ODS >
   if QIL := prettyprintParams*(printCafeSortList(T), PL) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) .

***(%
\end{verbatim}
}

The auxiliary function required by this function are:
\begin{itemize}
\item
\verb"prettyprintParams", which translates sorts from Maude syntax
to CafeOBJ syntax. As we decribed in Section~\ref{subsec:parsing}, we distinguish
whether the character stands for a variable or a constant. If it is a constant, we
have to reorder the term:

{\codesize
\begin{verbatim}
%)

  op prettyprintParams : Qid QidList -> Qid .
  ceq prettyprintParams(Q, PL) = QI
   if St := string(Q) /\
      find(St, ":", 0) == notFound /\
      N := find(St, "$", 0) /\
      St' := substr(St, 0, N) /\
      Q' := qid(St') /\
      Q' in PL /\
      St'' := substr(St, N + 1, length(St)) /\
      QI := qid(St'' + "." + St') .

***(%
\end{verbatim}
}

If it is a variable, we have to mantain the variable name at the beginning of
the character:

{\codesize
\begin{verbatim}
%)

  ceq prettyprintParams(Q, PL) = QI
   if St := string(Q) /\
      N := find(St, ":", 0) /\
      N' := find(St, "$", 0) /\
      St' := substr(St, 0, N) /\
      St'' := substr(St, N + 1, sd(N', N + 1)) /\
      Q' := qid(St'') /\
      Q' in PL /\
      St''' := substr(St, N' + 1, length(St)) /\
      QI := qid(St' + ":" + St''' + "." + St'') .
  eq prettyprintParams(Q, PL) = Q [owise] .

***(%
\end{verbatim}
}

\noindent
and \verb"prettyprintParams*" just traverses the list, applying
\texttt{prettyprintParams} to each element:

{\codesize
\begin{verbatim}
%)

  op prettyprintParams* : QidList QidList -> QidList .
  eq prettyprintParams*(nil, PL) = nil .
  eq prettyprintParams*(Q QIL, PL) =
                 prettyprintParams(Q, PL)
                 prettyprintParams*(QIL, PL) .

***(%
\end{verbatim}
}

\item
\verb"printCafeSortList", which prints all the subterms of the given term by
traversing the flattened list:

{\codesize
\begin{verbatim}
%)

  op printCafeSortList : Term -> QidList .
  ceq printCafeSortList('__[TL]) = QIL
   if QIL := printCafeSortList*(flatten(TL)) .
  eq printCafeSortList(T) = printCafeSort(T) [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"printCafeSortList*" just traverses the list, applying
\verb"printCafeSort" to each element:

{\codesize
\begin{verbatim}
%)

  op printCafeSortList* : TermList -> QidList .
  eq printCafeSortList*(empty) = nil .
  eq printCafeSortList*((T, TL)) = printCafeSort(T) printCafeSortList*(TL) .

***(%
\end{verbatim}
}

\noindent
and \verb"flatten" just removes the juxtaposition operator from a list:

{\codesize
\begin{verbatim}
%)

  op flatten : TermList -> TermList .
  eq flatten(empty) = empty .
  eq flatten(('__[TL], TL')) = flatten((TL, TL')) .
  eq flatten((T, TL)) = T, flatten(TL) [owise] .

***(%
\end{verbatim}
}

\end{itemize}

The printing function does not print variables, since the parsing to compute the
structure of the terms eliminates the syntactic sugar. Instead, we add the variables
to the set of operators:

%  *****************************
%  *** Variable declarations ***
%  *****************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('var_:_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                                       < nil, ODS ODS' >
   if ODS' := parseVars(downQidList(T), downQid(T')) .
  ceq printCafeBody('vars_:_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                                       < nil, ODS ODS' >
   if ODS' := parseVars(downQidList(T), downQid(T')) .

***(%
\end{verbatim}
}

Although several cases are distinguished for printing operators, most of them
work in the same way. We just show the case for basic operator declarations,
where the head and the coarity are printed:

%  *****************************
%  *** Operator declarations ***
%  *****************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('op_:`->_.[T, 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'op QIL ': '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := downQid(T') .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq printCafeBody('op_:`->_`{_`}.[T, 'CafeToken[T'], T''], M, DB, ODS, PL) =
                                        < 'op QIL ': '-> Q' ' '`{ QIL' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('bop_:`->_.[T, 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'bop QIL ': '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := prettyprintParams(downQid(T'), PL) .
  ceq printCafeBody('bop_:`->_`{_`}.[T, 'CafeToken[T'], T''], M, DB, ODS, PL) =
                                        < 'bop QIL ': '-> Q' ' '`{ QIL' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('ops_:`->_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'ops QIL ': '-> Q, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) .
  ceq printCafeBody('ops_:`->_`{_`}.['neCafeTokenList[T], 'CafeToken[T'], T''],
                    M, DB, ODS, PL) = < 'ops QIL ': '-> Q ' '`{ QIL' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('bops_:`->_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'bops QIL ': '-> Q, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) .
  ceq printCafeBody('bops_:`->_`{_`}.['neCafeTokenList[T], 'CafeToken[T'], T''],
                    M, DB, ODS, PL) = < 'bops QIL ': '-> Q ' '`{ QIL' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('op_:_->_.[T, T', 'CafeToken[T'']], M, DB, ODS, PL) =
                                        < 'op QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('op_:_->_`{_`}.[T, T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'op QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .
  ceq printCafeBody('bop_:_->_.[T, T', 'CafeToken[T'']], M, DB, ODS, PL) =
                                        < 'bop QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('bop_:_->_`{_`}.[T, T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'bop QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .
  ceq printCafeBody('ops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']],
                    M, DB, ODS, PL) = < 'ops QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('ops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'ops QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .
  ceq printCafeBody('bops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']],
                    M, DB, ODS, PL) = < 'bops QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('bops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'bops QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .

***(%
\end{comment}
}

\noindent
and for predicates, where we take care of parameters in the arity:

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('pred_:_.[T, T'], M, DB, ODS, PL) =
                                        < 'pred QIL ': QIL' '., ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq printCafeBody('pred_:_`{_`}.[T, T', T''], M, DB, ODS, PL) =
                                        < 'pred QIL ': QIL' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      QIL'' := printCafeAttS(T'', M, DB) .

***(%
\end{comment}
}

The auxiliary function \verb"printCafeOperatorHead" just puts together all the
characters in the operator name:

{\codesize
\begin{verbatim}
%)

  op printCafeOperatorHead : Term -> QidList .
  eq printCafeOperatorHead('CafeToken[T]) = downQid(T) .
  ceq printCafeOperatorHead('__[T, T']) = QIL QIL'
   if QIL := printCafeOperatorHead(T) /\
      QIL' := printCafeOperatorHead(T') .

***(%
\end{verbatim}
}

The printing function for equations and rules are also very similar, so we will
only describe an unconditional equation and a conditional rule. Since we are interested
in each part of the equation the parsing in this case is complicated, so we explain
it in detail:
\begin{itemize}
\item
We check whether the term has a label by parsing the term after trying to extract it.
If the parsing succeeds, then we keep in the \texttt{TW} the term after removing the
label; otherwise, we keep the same term.

\item
Similarly, we extract the attributes from the righthand side. However, this function
cannot fail, so it is not necessary to parse the obtained term.

\item
We compute the list of quoted identifiers standing for the new lefthand side. It will
be use to compute the new variables, kept in \verb"ODS'".

\item
We solve the bubbles in the lefthand side and keep the result in \verb"T1".

\item
We solve the bubbles in the righthand side and keep the obtained term in \verb"T2".
Solving this term requires a special function that takes into account the new
variables that appeared in the lefthand side.

\item
The representation of these terms is kept in \verb"QIL'" and \verb"QIL''", respectively.

\item
The representation of the label is stored in \verb"QILL", while the representation of
the attributes is kept in \verb"QILA".

\item
Finally, the equation is built and returned.

\end{itemize}

%  *****************************
%  *** Equation declarations ***
%  *****************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('eq_=_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'eq QILL QIL' '= QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq printCafeBody('beq_=_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'eq QILL QIL' '= QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[TW'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('ceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ceq QILL QIL' '= QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[T'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                       solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .
  ceq printCafeBody('bceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ceq QILL QIL' '= QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[T'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                       solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .
  ceq printCafeBody('cq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'cq QILL QIL1 '= QIL2 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[T'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL1 := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL2 := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                        solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .
  ceq printCafeBody('bcq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'cq QILL QIL1 '= QIL2 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[T'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL1 := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL2 := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                        solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

  *************************
  *** Rule declarations ***
  *************************
  ceq printCafeBody('trans_=>_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'trans QILL QIL' '=> QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[TW'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('btrans_=>_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'trans QILL QIL' '=> QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[TW'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('trns_=>_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'trans QILL QIL' '=> QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('ctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ctrans QILL QIL' '=> QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                         solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

  ceq printCafeBody('bctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ctrans QILL QIL' '=> QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                         solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

***(%
\end{comment}
}

Regarding conditional transitions, we have to extended the operations we performed for
unconditional statements by:
\begin{itemize}
\item
Extracting the attributes from the term standing for the condition, since this is now
the last term.

\item
Extending the module with information about sorts, required by the operators defined
with the sort \verb"Universal", to parse the condition. This is performed by applying
the Full Maude function \verb"addInfoConds" to the module extended with the variables
defined in the lefthand side.

\item
Using this extended module to solve the bubbles in the condition, and then printing
it in \verb"QIL3".

\item
The printed transition is finally composed and returned.
\end{itemize}

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('ctrns_=>_if_.['CafeBubble[T], 'CafeBubble[T'],
                    'CafeBubble[T'']], M, DB, ODS, PL) =
                           < 'ctrns QILL QIL' '=> QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                    solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

***(%
\end{verbatim}
}

The auxiliary functions used in this case are:
\begin{itemize}
\item
\verb"solveSecondTerm", which add a special operator \verb"_=_" on a new sort
\verb"@@@". We then solve the bubbles in this new sort by using the new operator.
Finally, the constants used in the parsing process are transformed back into variables
if they appear in the operator set:

{\codesize
\begin{verbatim}
%)

  op solveSecondTerm : Module Term Term OpDeclSet Database -> Term .
  ceq solveSecondTerm(M, 'bubble[T], 'bubble[T'], ODS, DB) = T2
   if M' := addOps((ODS op '_=_ : 'Universal 'Universal -> 'Bool [poly(1 2)] .),
               addSorts('@@@, M)) /\
      QIL := downQidList(T) /\
      QIL' := downQidList(T') /\
      RP := metaParse(M', '`( QIL '`) '= '`( QIL' '`), '@@@) /\
      '_=_[T1, T2] := constsToVars(getTerm(RP), ODS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  eq printCafeBody(T, M, DB, ODS, PL) = < '\r '\! 'Print 'error. '\o, ODS > [owise] .

***(%
\end{comment}
}

\item
\verb"extractLabel", which extracts a label at the beggining of the term:

{\codesize
\begin{verbatim}
%)

  op extractLabel : Term -> Term .
  ceq extractLabel('__[''`[.Qid, T, ''`].Qid, '':.Qid, TL]) = '__[TL]
   if TL =/= empty /\
      Q := downTerm(T) .
  eq extractLabel(T) = T [owise] .

***(%
\end{verbatim}
}

\item
\verb"printLabel", which transforms a term into a list of quoted identifiers.
If the term does not correspond with a label, it is not printed:

{\codesize
\begin{verbatim}
%)

  op printLabel : Term -> QidList .
  ceq printLabel('__[''`[.Qid, T, ''`].Qid, '':.Qid, TL]) = ' '`[ Q '`] ' ':
   if TL =/= empty /\
      Q := downTerm(T) .
  eq printLabel(T) = nil [owise] .

***(%
\end{verbatim}
}

\item
\verb"removeEqAtS", which traverses the list of terms, looking for possible
attributes:

{\codesize
\begin{verbatim}
%)

  op removeEqAtS : Term -> Term .
  ceq removeEqAtS('__[TL]) = if sizeTL(TL') > 1
                             then '__[TL']
                             else TL'
                             fi
   if TL' := removeEqAts*(TL) .
  eq removeEqAtS(TL) = TL [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"removeEqAts*" removes the \verb"nonexec" and \verb"metadata" attributes:

{\codesize
\begin{verbatim}
%)

  op removeEqAts* : TermList -> TermList .
  eq removeEqAts*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) = TL .
  eq removeEqAts*((TL, ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid)) = TL .
  eq removeEqAts*(TL) = TL [owise] .

***(%
\end{verbatim}
}

\noindent
and \verb"sizeTL" just computes the size of a list of terms:

{\codesize
\begin{verbatim}
%)

  op sizeTL : TermList -> Nat .
  eq sizeTL(empty) = 0 .
  eq sizeTL((T, TL)) = s(sizeTL(TL)) .

***(%
\end{verbatim}
}

\item
Analogously, \verb"getEqAtS" returns the terms standing for the attributes:

{\codesize
\begin{verbatim}
%)

  op getEqAtS : Term -> TermList .
  eq getEqAtS('__[TL]) = getEqAtS*(TL) .
  eq getEqAtS(T) = empty [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"getEqAtS*" just looks for the \verb"nonexec" or \verb"metadata" attributes:

{\codesize
\begin{verbatim}
%)

  op getEqAtS* : Term -> TermList .
  eq getEqAtS*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) =
                                   ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid .
  eq getEqAtS*((TL, ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid)) =
                                   ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid .
  eq getEqAtS*(TL) = empty [owise] .

***(%
\end{verbatim}
}

\item
Finally, \verb"printAtS" prints the list by placing spaces at both sides (since
the attributes are placed inside curly braces):

{\codesize
\begin{verbatim}
%)

  op printAtS : TermList -> QidList .
  eq printAtS(empty) = nil .
  eq printAtS(TL) = ' downQidList(TL) ' [owise] .

***(%
\end{verbatim}
}

\end{itemize}

{\codesize
\begin{comment}

The function \verb"printCafeAttS" is used to print the attributes in operator
declarations:
%)

  op printCafeAttS : Term Module Database -> QidList .
  ceq printCafeAttS('__[T, T'], M, DB) = QIL QIL'
   if QIL := printCafeAttS(T, M, DB) /\
      QIL' := printCafeAttS(T', M, DB) .
  eq printCafeAttS('constr.@CafeAttr@, M, DB) = 'constr .
  eq printCafeAttS('associative.@CafeAttr@, M, DB) = 'associative .
  eq printCafeAttS('assoc.@CafeAttr@, M, DB) = 'assoc .
  eq printCafeAttS('l-assoc.@CafeAttr@, M, DB) = 'l-assoc .
  eq printCafeAttS('r-assoc.@CafeAttr@, M, DB) = 'r-assoc .
  eq printCafeAttS('commutative.@CafeAttr@, M, DB) = 'commutative .
  eq printCafeAttS('comm.@CafeAttr@, M, DB) = 'comm .
  eq printCafeAttS('idempotent.@CafeAttr@, M, DB) = 'idempotent .
  eq printCafeAttS('idem.@CafeAttr@, M, DB) = 'idem .
  eq printCafeAttS('nonexec.@CafeAttr@, M, DB) = 'nonexec .
  ceq printCafeAttS('prec:_['CafeToken[T]], M, DB) = 'prec: Q
   if Q := downQid(T) .
  ceq printCafeAttS('id:`(_`)['CafeBubble[T]], M, DB) = 'id: '`( QIL '`) '
   if T1 := solveBubbles('bubble[T], M, false, none, DB) /\
      QIL := metaPrettyPrint(M, T1, printOpts) .
  ceq printCafeAttS('id:_['CafeBubble[T]], M, DB) = 'id: QIL '
   if T1 := solveBubbles('bubble[T], M, false, none, DB) /\
      QIL := metaPrettyPrint(M, T1, printOpts) .
  ceq printCafeAttS('idr:`(_`)['CafeBubble[T]], M, DB) = 'idr: '`( QIL '`) '
   if T1 := solveBubbles('bubble[T], M, false, none, DB) /\
      QIL := metaPrettyPrint(M, T1, printOpts) .

***(%
\end{comment}
}
{\codesize
\begin{verbatim}
%)

endm

***(%
\end{verbatim}
}

\subsection{Defining commands for CafeOBJ specifications\label{subsec:cafe:commands}}

We present here how to define the behavior of the commands specified for CafeOBJ
specifications. To add any other command the programmer must define it in the module
\texttt{TRANSLATION-COMMANDS} described in Section~\ref{subsec:syntax} and then define
its behavior in
the \texttt{CAFE2MAUDE-DATABASE-HANDLING} module:

{\codesize
\begin{verbatim}
%)

mod CAFE2MAUDE-DATABASE-HANDLING is
  pr CAFE-PRETTY-PRINT .
  pr CafePARSER .

***(%
\end{verbatim}
}

This module define the \verb"CafeDatabaseClass" sort, which will be used in all
the rules involving CafeOBJ specifications. Since we also want the rest of rules
from Full Maude to work, we add a subsort declaration stating that our class is
a subclass of \verb"DatabaseClass", defined in Full Maude. Finally, we define a
constant \texttt{CafeDatabase} for creating new objects:

{\codesize
\begin{verbatim}
%)

  sort CafeDatabaseClass .
  subsort CafeDatabaseClass < DatabaseClass .
  op CafeDatabase : -> CafeDatabaseClass [ctor] .

***(%
\end{verbatim}
}

We also define a new attribute, that will store whether the user wants the system
to perform a strict translation:

{\codesize
\begin{verbatim}
%)

  op strict :_ : Bool -> Attribute [ctor] .

***(%
\end{verbatim}
}

We specify an attribute \verb"psorts" to keep track of the principal sorts
in the module:

{\codesize
\begin{verbatim}
%)

  op psorts :_ : SortMap -> Attribute [ctor] .

***(%
\end{verbatim}
}

Similarly, the attribute \verb"hsorts" keeps track of hidden sorts:

{\codesize
\begin{verbatim}
%)

  op hsorts :_ : TheorySortMap -> Attribute [ctor] .

  op provided :_ : QidSet -> Attribute [ctor] .

  op scoreInfoMap :_ : ScoreInfoMap -> Attribute [ctor] .

  op initialPrincipalSorts : -> SortMap .
  eq initialPrincipalSorts = ('NAT |-> 'Nat) .

  op initCafeAttS : -> AttributeSet .
  eq initCafeAttS = strict : false, psorts : initialPrincipalSorts, hsorts : empty,
                    provided : none, scoreInfoMap : mtSIM .


***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  var  N : Nat .
  var  X@Database : CafeDatabaseClass .
  var  CafeM : CafeModule .
  var  O : Oid .
  vars Q Q' QI F : Qid .
  vars QIL QIL' QIL'' : QidList .
  vars T T' T'' : Term .
  var  TL : TermList .
  vars H H' : Header .
  vars DB DB' DB'' : Database .
  vars MD SM SM' SM'' : SModule .
  var  Atts : AttributeSet .
  vars RP RP' : ResultPair? .
  vars ME ME' ME'' : ModuleExpression .
  var  B : Bool .
  var  ODS : OpDeclSet .
  vars M M' : Module .
  **** PSM: Principal Sort Map
  vars PSM PSM' : SortMap .
  vars HSM HSM' : TheorySortMap .
  var  TSM : TheorySortMap .
  vars QS QS' : QidSet .
  vars SIM SIM' : ScoreInfoMap .

***(%
\end{comment}
}

The rule \verb"load-CafeLOOSE" is in charge of loading a module with loose semantics.
It uses the function \verb"procCafeMod" from Section~\ref{subsec:parsing} to parse the
terms. If there is no errors (i.e., the variable \verb"QIL" is equals to \verb"nil")
then the database is updated and a message indicating that the module has been introduced
is shown.
If \verb"QIL" we check whether it contains an error that can be solved by translating
theories as modules. If this is the case and the user does not need a strict translation
(the boolean variable \verb"B" in the attribute \verb"strict" is set to \verb"false")
then the database is updated and a warning message is shown. Otherwise, the database
is not modified and a message is printed:

{\codesize
\begin{verbatim}
%)

  crl [load-CafeLOOSE] :
      < O : X@Database | input : ('cmod*_`{_`}[T, T']), db : DB, output : nil,
                         default : ME, strict : B, psorts : PSM, hsorts : HSM, Atts >
   => if QIL == nil
      then
      < O : X@Database | input : nilTermList, db : DB',
                         output : ('Introduced 'Loose 'Cafe 'Module:
                                   '\g header2Qid(parseHeader(getHeader(T))) '\o '\n),
                         default : parseHeader(getHeader(T)), strict : B,
                         psorts : PSM', hsorts : HSM', Atts >
      else if QIL == paramThWarn
           then if B then
                     < O : X@Database | input : nilTermList, db : DB, output : QIL,
                                        default : ME, strict : B, psorts : PSM,
                                        hsorts : HSM, Atts >
                else
                     < O : X@Database | input : nilTermList, db : DB', output : QIL,
                                        default : parseHeader(getHeader(T)),
                                        strict : B, psorts : PSM',
                                        hsorts : HSM', Atts >
                fi
           else < O : X@Database | input : nilTermList, db : DB, output : QIL,
                                   default : ME, strict : B, psorts : PSM,
                                   hsorts : HSM, Atts >
           fi
      fi
   if TSM := getTheorySort(DB) /\
      < DB', PSM', HSM', QIL > := procCafeMod('cmod*_`{_`}[T, T'], PSM, HSM, TSM, DB) .

***(%
\end{verbatim}
}

The auxiliary function \verb"getHeader" just returns the module name without parameters
and using a Maude token constructor:

{\codesize
\begin{verbatim}
%)

  op getHeader : Term -> Term .
  eq getHeader('CafeToken[T]) = 'token[T] .
  eq getHeader('_`(_`)['CafeToken[T], T']) = 'token[T] .
  eq getHeader('_`[_`]['CafeToken[T], T']) = 'token[T] .
  eq getHeader('_`{_|_`}['CafeToken[T], T', T'']) = 'token[T] .

***(%
\end{verbatim}
}

Similarly to the previous rule, \verb"load-CafeTIGHT" is in charge of loading modules
with tight semantics. In this case we do not have to take into account whether the
message contains a warning message, because parameterized modules are allowed in Maude.
Hence, we just parse the terms with \verb"procCafeMod" and update the database if no
errors are found:

{\codesize
\begin{verbatim}
%)

   crl [load-CafeTIGHT] :
       < O : X@Database | input : ('cmod!_`{_`}[T, T']), db : DB, output : nil,
                          default : ME, strict : B, psorts : PSM, hsorts : HSM, Atts >
    => if QIL == nil
       then
       < O : X@Database | input : nilTermList, db : DB',
                          output : ('Introduced 'Tight 'Cafe 'Module: '\g
                                header2Qid(parseHeader(getHeader(T))) '\o '\n),
                          default : parseHeader(getHeader(T)), strict : B,
                          psorts : PSM', hsorts : HSM', Atts >
       else
       < O : X@Database | input : nilTermList, db : DB, output : QIL,
                          default : ME, strict : B, psorts : PSM, hsorts : HSM, Atts >
       fi
    if TSM := getTheorySort(DB) /\
       < DB', PSM', HSM', QIL > := procCafeMod('cmod!_`{_`}[T, T'], PSM, HSM, TSM, DB) .

***(%
\end{verbatim}
}

Finally, the rule \verb"load-CafeVIEW" loads a CafeOBJ view into the database.
It uses the \verb"procCafeView" function to parse the view and, if no errors are
found, then the database is updated:

{\codesize
\begin{verbatim}
%)

  crl [load-CafeVIEW] :
      < O : X@Database | input : ('cview_from_to_`{_`}[T, TL]), db : DB,
                         output : nil, psorts : PSM, Atts >
   => if QIL == nil
      then
      < O : X@Database | input : nilTermList, db : DB',
                         output : ('Introduced 'Cafe 'View: '\g
                                   header2Qid(parseHeader(getHeader(T))) '\o '\n),
                         psorts : PSM, Atts >
      else
      < O : X@Database | input : nilTermList, db : DB, output : QIL, psorts : PSM, Atts >
      fi
   if < DB', QIL > := procCafeView('cview_from_to_`{_`}[T, TL], PSM, DB) .

  crl [load-CafeVIEW] :
      < O : X@Database | input : ('cview_from_to_`{`}[T, TL]), db : DB,
                         output : nil, psorts : PSM, Atts >
   => if QIL == nil
      then
      < O : X@Database | input : nilTermList, db : DB',
                         output : ('Introduced 'Cafe 'View: '\g
                                   header2Qid(parseHeader(getHeader(T))) '\o '\n),
                         psorts : PSM, Atts >
      else
      < O : X@Database | input : nilTermList, db : DB, output : QIL, psorts : PSM, Atts >
      fi
   if < DB', QIL > := procCafeView('cview_from_to_`{`}[T, TL], PSM, DB) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  crl [load-open-close-block] :
      < O : X@Database | input : ('copen_._close[T, T']), db : DB,
                         output : nil, psorts : PSM, hsorts : HSM,
                         scoreInfoMap : SIM, Atts >
   => if QIL == nil
      then
      < O : X@Database | input : nilTermList, db : DB,
                         output : ('\n '\! 'Opening 'module '\o
                                   getOpenName(T) ': '\n QIL' '\n),
                         psorts : PSM, hsorts : HSM,
                         scoreInfoMap : SIM', Atts >
      else
      < O : X@Database | input : nilTermList, db : DB, output : QIL,
                         psorts : PSM, hsorts : HSM,
                         scoreInfoMap : SIM, Atts >
      fi
   if TSM := getTheorySort(DB) /\
      < DB' | SIM' | QIL | QIL' > := procOpenCloseEnv(T, T', PSM, HSM, TSM, DB, SIM) .

  op getOpenName : Term -> QidList .
  eq getOpenName('CafeToken[T]) = downQid(T) .
  eq getOpenName('token[T]) = downQid(T) .
  eq getOpenName('_+_[T, T']) = getOpenName(T) '+ getOpenName(T') .
  eq getOpenName('`(_`)[T]) = getOpenName(T) .

***(%
\end{comment}
}

The rule \verb"original-cafe-module" displays the CafeOBJ module originally
introduced by the user. It just obtains the module name from the command,
looks for the module in the database and prints it with \texttt{printCafeModule}:

%  ************************************************************************
%  ************************* ORIGINAL CAFE MODULE *************************
%  ************************************************************************

{\codesize
\begin{verbatim}
%)

  crl [original-cafe-module] :
      < O : X@Database | input : ('original`CafeOBJ`module_.['token[T]]),
                         output : nil, db : DB, Atts >
   => < O : X@Database | input : nilTermList, output : QIL,
                         db : DB, Atts >
   if Q := downQid(T) /\
      < T' ; ODS ; M > := getTermModule(Q, DB) /\
      M' := getFlatModule(Q, DB) /\
      QIL := printCafeModule(T', M', DB, false) .

***(%
\end{verbatim}
}

Alternatively, the rule \verb"original-cafe-module-error" is applied when
the module cannot be found:

{\codesize
\begin{verbatim}
%)

  crl [original-cafe-module-error] :
      < O : X@Database | input : ('original`CafeOBJ`module_.['token[T]]),
                         output : nil, db : DB, Atts >
   => < O : X@Database | input : nilTermList, output : ('\n '\r 'ERROR: '\o
                                              'The 'module 'cannot 'be 'found. '\n),
                         db : DB, Atts >
   if Q := downQid(T) /\
      not getTermModule(Q, DB) :: Tuple{Term,OpDeclSet,Module} .

***(%
\end{verbatim}
}

The rule \verb"strict-on" sets the value in \verb"strict" to \verb"true", and
prints a message indicating that the operation was successful:

%  **********************************************************************
%  ************************* SEMANTICS COMMANDS *************************
%  **********************************************************************

{\codesize
\begin{verbatim}
%)

  rl [strict-on] :
     < O : X@Database | input : ('strict`translation`on`..@Command@), strict : B,
                        output : nil, Atts >
  => < O : X@Database | input : nilTermList, strict : true,
                        output : ('\n '\b 'The 'modules 'will 'be 'introduced
                                  'as 'originally 'written. '\o '\n), Atts > .

***(%
\end{verbatim}
}

Similarly, the rule \verb"strict-off" sets the value in \verb"strict" to \verb"false"
and prints the corresponding message:

{\codesize
\begin{verbatim}
%)

  rl [strict-off] :
     < O : X@Database | input : ('strict`translation`off`..@Command@), strict : B,
                        output : nil, Atts >
  => < O : X@Database | input : nilTermList, strict : false,
                        output : ('\n '\b 'The 'translation 'will 'adapt 'CafeOBJ
                                  'specifications 'to 'meet 'Maude 'requirements 'when
                                  'possible. '\o '\n), Atts > .

  crl [require] :
      < O : X@Database | input : ('require_['neCafeTokenList[T]]),
                         output : nil, provided : QS, Atts >
   => < O : X@Database | input : nilTermList,
                         output : QIL, provided : QS, Atts >
   if Q := getModuleRequired(T) /\
      Q' := getFileRequired(T) /\
      QIL := if contained(Q, QS)
             then '\! '\b 'Required 'module '\o Q '\! '\b 'loaded. '\n
             else '\n '\! '\r 'Module '\o Q '\! '\r 'from 'file '\o Q'
                  '\! '\r 'required. 'Please 'load 'the 'file. '\n
             fi .

  crl [provide] :
      < O : X@Database | input : ('provide_['neCafeTokenList[T]]), output : nil,
                         provided : QS, Atts >
   => < O : X@Database | input : nilTermList, output : nil,
                         provided : (QS ; QS'), Atts >
   if QS' := getProvided(T) .

  op getProvided : TermList -> QidSet .
  eq getProvided(empty) = none .
  eq getProvided('__[TL]) = getProvided(TL) .
  eq getProvided((T, TL)) = downQid(T) ; getProvided(TL) .
  eq getProvided(TL) = none [owise] .

  ops getModuleRequired getFileRequired : Term -> Qid .
  eq getModuleRequired('__[T, T']) = downQid(T) .
  eq getFileRequired('__[T, T']) = downQid(T') .

  op contained : Qid QidSet -> Bool .
  eq contained(Q, Q ; QS) = true .
  eq contained(Q, QS) = false [owise] .

***(%
\end{verbatim}
}

%  ***********************************************************************
%  ************************* AUXILIARY FUNCTIONS *************************
%  ***********************************************************************

{\codesize
\begin{verbatim}
%)

  var  SMI : Set{ModuleInfo} .
  vars SMN1 SMN2 SMN3 SMN4 : Set{ModuleName} .
  var  SVI : Set{ViewInfo} .
  var  SVE : Set{ViewExp} .
  var  MN : ModuleName .
  var  DT : Default{Term} .
  vars M1 M2 M3 M4 : Module .

  op getTheorySort : Database -> TheorySortMap [memo] .
  eq getTheorySort(db(SMI, SMN1, SVI, SVE, SMN2, SMN3, SMN4, QIL)) = getTheorySort(SMI) .

  op getTheorySort : Set{ModuleInfo} -> TheorySortMap [memo] .
  eq getTheorySort(emptyInfoSet) = predefinedTheorySort .
  ceq getTheorySort(< MN ; DT ; M1 ; M2 ; M3 ; ODS ; SMN1 ; SVE > SMI) =
       if isTheory(M1)
       then Q -> getSorts(M1)
       else empty
       fi, getTheorySort(SMI)
   if Q := getName(M1) .
  ceq getTheorySort(< MN ; M1 ; M2 ; M3 ; M4 ; ODS ; SMN1 ; SVE > SMI) =
       if isTheory(M2)
       then getName(M2) -> getSorts(M2)
       else empty
       fi, getTheorySort(SMI)
   if Q := getName(M1) .
  eq getTheorySort(SMI) = empty [owise] .

  var  IL : ImportList .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  var  MAS : MembAxSet .
  var  ES : EquationSet .
  var  RS : RuleSet .

  op isTheory : Module -> Bool .
  eq isTheory(fth H is IL sorts SS . SSDS ODS MAS ES endfth) = true .
  eq isTheory(th H is IL sorts SS . SSDS ODS MAS ES RS endth) = true .
  eq isTheory(M) = false [owise] .

  op predefinedTheorySort : -> TheorySortMap [memo] .
  *** TODO: add more predefined
  eq predefinedTheorySort = 'TRIV -> 'Elt .
endm

***(%
\end{verbatim}
}

The module \verb"LOOP-PRE-PROCESSING" performs some normalization actions on
the modules to simplify the parsing functions and the use of the \verb"metaParse"
command. This is specially important due to the use of bubbles, that do not delimit
the terms. Hence the functions in this module:
\begin{itemize}
\item
Add a dot at the end of the statements that do not require it and are not ``closed''
by themselves (e.g.\ the sort declaration constructor \verb"[_]" is closed, while
view mappings are not closed).

\item
Modify some characters that might cause ambiguity, such as the \verb"mod" keyword
at the beginning of a module and is also used by Maude modules.
\end{itemize}

Although the functions distinguish several cases all of them are basically implemented
in the same way, so we do not show the details here:

{\codesize
\begin{verbatim}
%)

mod LOOP-PRE-PROCESSING is
  pr LOOP-MODE .
  pr EXT-BOOL .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  vars Q Q' : Qid .
  vars QIL QIL' QIL'' QIL2 QIL3 : QidList .
  var  S : State .
  var  N : Nat .

***(%
\end{comment}
}

{\codesize
\begin{comment}

The function \verb"normalizeCafeOBJ" add a final \verb"." to delimit each possible
CafeOBJ statement:
%)

  op normalizeCafeOBJ : QidList -> QidList .
  ceq normalizeCafeOBJ(QIL Q Q' QIL') = normalizeCafeOBJ(QIL Q '. Q' QIL')
   if Q =/= '. /\ Q =/= '`, /\ Q =/= '`] /\ Q =/= '* /\ Q =/= '`) /\ Q =/= 'proof /\
     (Q' == 'eq or-else Q' == 'ceq or-else Q' == 'cq or-else
      Q' == 'op or-else Q' == 'ops or-else Q' == 'bop or-else
      Q' == 'bops or-else Q' == 'var or-else
      Q' == 'vars or-else Q' == 'beq or-else Q' == 'bceq or-else
      Q' == 'bcq or-else Q' == 'trans or-else Q' == 'btrans or-else
      Q' == 'ctrans or-else Q' == 'bctrans or-else Q' == 'trns or-else
      Q' == 'ctrns or-else Q' == 'btrns or-else Q' == 'bctrns or-else
      Q' == 'pred or-else Q' == 'red or-else Q' == 'reduce) .
  eq normalizeCafeOBJ(QIL Q '`}) = if Q =/= '. and Q =/= '`] and
                                      Q =/= '* and Q =/= '`) and Q =/= 'proof
                                   then normalizeImports(QIL Q '. '`})
                                   else normalizeImports(QIL Q '`})
                                   fi [owise] .
  eq normalizeCafeOBJ(QIL) = normalizeImports(QIL) [owise] .

  op normalizeImports : QidList -> QidList .
  eq normalizeImports(QIL) = normalizeImports(QIL, nil) .

  op normalizeImports : QidList QidList -> QidList .
  eq normalizeImports(nil, QIL) = QIL .
  ceq normalizeImports('protecting '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'pr '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('pr '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'pr '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('including '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'inc '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('inc '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'inc '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('extending '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'ex '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('ex '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'ex '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('using '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'us '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('us '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'us '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  eq normalizeImports(Q QIL, QIL') = normalizeImports(QIL, QIL' Q) [owise] .

  sort NormRes .
  op <<<_,_>>> : QidList QidList -> NormRes [ctor] .

  op normalizeImp : QidList QidList Nat -> NormRes .
  eq normalizeImp('`) QIL, QIL', 0) = <<< QIL' '`), QIL >>> .
  eq normalizeImp('`) QIL, QIL', s(N)) = normalizeImp(QIL, QIL' '`), N) .
  eq normalizeImp('`( QIL, QIL', N) = normalizeImp(QIL, QIL' '`(, s(N)) .
  ceq normalizeImp('`{ QIL, QIL', N) = normalizeImp(QIL3, QIL' '`{ QIL2, N)
   if <<< QIL2, QIL3 >>> := otfView(QIL, 0) .
  eq normalizeImp(Q QIL, QIL', N) = normalizeImp(QIL, QIL' Q, N) [owise] .


  op normalizeCafeOBJView : QidList -> QidList .
  ceq normalizeCafeOBJView(QIL '`, Q QIL') = normalizeCafeOBJView(QIL '. Q QIL')
   if Q == 'sort or-else Q == 'hsort or-else Q == 'op or-else
      Q == 'bop or-else Q == 'vvar or-else Q == 'vvars .
  eq normalizeCafeOBJView(QIL 'var QIL') = normalizeCafeOBJView(QIL 'vvar QIL') .
  eq normalizeCafeOBJView(QIL 'vars QIL') = normalizeCafeOBJView(QIL 'vvars QIL') .
  eq normalizeCafeOBJView(QIL) = QIL [owise] .

  op otfView : QidList Nat -> NormRes .
  eq otfView(QIL, N) = otfView(QIL, nil, N) .

  op otfView : QidList QidList Nat -> NormRes .
  eq otfView('`} QIL, QIL', 0) = <<< normalizeCafeOBJView(QIL' '. '`}), QIL >>> .
  eq otfView('`} QIL, QIL', s(N)) = otfView(QIL, QIL' '`}, N) .
  eq otfView('`{ QIL, QIL', N) = otfView(QIL, QIL' '`{, s(N)) .
  eq otfView(Q QIL, QIL', N) = otfView(QIL, QIL' Q, N) [owise] .

  op normalizeOpenClose : QidList -> QidList .
  *** We look for the end of the module expression to place the dot
  ceq normalizeOpenClose(Q Q' QIL) = Q '. normOpenCloseAux(Q' QIL)
   if Q' == '`[ or-else Q == '* or-else
      Q' == 'eq or-else Q' == 'ceq or-else Q' == 'cq or-else
      Q' == 'op or-else Q' == 'ops or-else Q' == 'bop or-else
      Q' == 'bops or-else Q' == 'var or-else
      Q' == 'vars or-else Q' == 'beq or-else Q' == 'bceq or-else
      Q' == 'bcq or-else Q' == 'trans or-else Q' == 'btrans or-else
      Q' == 'ctrans or-else Q' == 'bctrans or-else Q' == 'trns or-else
      Q' == 'ctrns or-else Q' == 'btrns or-else Q' == 'bctrns or-else
      Q' == 'pred or-else Q' == 'red or-else Q' == 'reduce .
  eq normalizeOpenClose(Q '. QIL) = Q '. normOpenCloseAux(QIL) .
  eq normalizeOpenClose(Q Q' QIL) = Q normalizeOpenClose(Q' QIL) [owise] .


  op normOpenCloseAux : QidList -> QidList .
  ceq normOpenCloseAux(QIL Q Q' QIL') = normOpenCloseAux(QIL Q '. Q' QIL')
   if Q =/= '. /\ Q =/= '`, /\ Q =/= '`] /\ Q =/= '* /\ Q =/= '`) /\ Q =/= '`{ /\
      Q =/= '`} /\ Q =/= 'proof /\
     (Q' == 'eq or-else Q' == 'ceq or-else Q' == 'cq or-else
      Q' == 'op or-else Q' == 'ops or-else Q' == 'bop or-else
      Q' == 'bops or-else Q' == 'var or-else
      Q' == 'vars or-else Q' == 'beq or-else Q' == 'bceq or-else
      Q' == 'bcq or-else Q' == 'trans or-else Q' == 'btrans or-else
      Q' == 'ctrans or-else Q' == 'bctrans or-else Q' == 'trns or-else
      Q' == 'ctrns or-else Q' == 'btrns or-else Q' == 'bctrns or-else
      Q' == 'pred or-else Q' == 'red or-else Q' == 'reduce) .
  eq normOpenCloseAux(QIL Q 'close) = if Q =/= '. and Q =/= '`] and
                                         Q =/= '* and Q =/= '`) and
                                         Q =/= '`} and Q =/= 'proof
                                      then QIL Q '. 'close
                                      else QIL Q 'close
                                      fi [owise] .

  eq ['mod! QIL '`}, S, QIL'] = [normalizeCafeOBJ('cmod! QIL '`}), S, QIL'] .
  eq ['module! QIL '`}, S, QIL'] = ['mod! QIL '`}, S, QIL'] .
  eq ['mod* QIL '`}, S, QIL'] = [normalizeCafeOBJ('cmod* QIL '`}), S, QIL'] .
  eq ['mod QIL '`}, S, QIL'] = [normalizeCafeOBJ('cmod* QIL '`}), S, QIL'] .
  eq ['module* QIL '`}, S, QIL'] = ['mod* QIL '`}, S, QIL'] .
  eq ['module QIL '`}, S, QIL'] = ['mod* QIL '`}, S, QIL'] .
  eq ['open QIL 'close, S, QIL'] = ['copen normalizeOpenClose(QIL 'close), S, QIL'] .
  ceq ['view QIL Q '`}, S, QIL'] = [normalizeCafeOBJView('cview QIL Q '. '`}), S, QIL']
   if Q =/= '`{ .
  eq ['view QIL '`{ '`}, S, QIL'] = [normalizeCafeOBJView('cview QIL '`{ '`}), S, QIL'] .
  eq ['make Q QIL, S, QIL'] = ['mod! Q '`{ 'pr QIL '`}, S, QIL'] .
  eq ['cmod! Q 'principal-sort Q' '`{ QIL', S, QIL''] =
     ['cmod! Q '`[ Q' '`] '`{ QIL', S, QIL''] .
  eq ['cmod* Q 'principal-sort Q' '`{ QIL', S, QIL''] =
     ['cmod* Q '`[ Q' '`] '`{ QIL', S, QIL''] .
  eq ['cmod! Q '`( QIL '`) 'principal-sort Q' '`{ QIL', S, QIL''] =
     ['cmod! Q '`{ QIL '| Q' '`} '`{ QIL', S, QIL''] .
  eq ['cmod* Q '`( QIL '`) 'principal-sort Q' '`{ QIL', S, QIL''] =
     ['cmod* Q '`{ QIL '| Q' '`} '`{ QIL', S, QIL''] .
  eq [QIL 'p-sort Q '`{ QIL', S, QIL''] = [QIL 'principal-sort Q '`{ QIL', S, QIL''] .
  ceq [QIL 'eq '`[ Q '`] Q' QIL', S, QIL''] = [QIL 'eq '`[ Q '`] ': Q' QIL', S, QIL'']
   if Q' =/= ': .
  eq ['select Q, S, QIL'] = ['select Q '., S, QIL'] .

***(%
\end{comment}
}
{\codesize
\begin{verbatim}
  ...
%)

endm

***(%
\end{verbatim}
}

Finally, the \verb"CAFE2MAUDE" module is the standard module dealing with input/output
through the Loop Mode~\cite[Chapter~17]{maude-book}. Basically, this module uses a tuple
built with the operator \verb"[_,_,_]", where the first argument corresponds to the
input introduced by the user, the third one the output shown to the user, and the second
one is a term of sort \verb"State" that can be defined by the user for each application:

{\codesize
\begin{verbatim}
%)

mod CAFE2MAUDE is
  ex LOOP-PRE-PROCESSING .
  pr META-CAFE2MAUDE-SIGNATURE .
  pr CAFE2MAUDE-DATABASE-HANDLING .

***(%
\end{verbatim}
}

We will use the sort \verb"Object" for the current state, which means that we will
store the values in a term built with the operator \verb"<_:_|_>", with the first
argument the name of the object, the second one the name of the class, and the third
one a set of attributes.
%
We also define a constant \verb"o" of sort \verb"Oid" to define the name of the initial
state:

{\codesize
\begin{verbatim}
%)

  subsort Object < State .
  op o : -> Oid .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  var  H : Header .
  var  O : Oid .
  var  X@Database : CafeDatabaseClass .
  vars Q Q' QI : Qid .
  vars QIL QIL' QIL'' : QidList .
  var  TL : TermList .
  var  DB : Database .
  var  Atts : AttributeSet .
  var  S : State .

***(%
\end{comment}
}

We define the constant \verb"cafe4maude-init" as the initial system. The user has to
rewrite it with the special command \verb"loop" to start the input/output loop.

%  ---------------------------------------------------------------------------------------
%  --------------------------------------- IN --------------------------------------------
%  ---------------------------------------------------------------------------------------

{\codesize
\begin{verbatim}
%)

  op cafe4maude-init : -> System .

***(%
\end{verbatim}
}

When the user types that command the system will apply the rule \verb"init" below.
It creates the whole sytem, with an empty list of quoted identifiers in the input
(the first \verb"nil"), another one in the output (the second \verb"nil"), and an
object with name \verb"o", class \verb"CafeDatabase", and attributes for the database
(verb"db"), the parsed \verb"input", the messages we want to print (\verb"output"),
the \verb"default" modules (all these attributes are inherited from Full Maude),
and for indicating whether the translation is \verb"strict", which is initially
set to \verb"false":

{\codesize
\begin{verbatim}
%)

  rl [init] :
     cafe4maude-init
  => [nil, < o : CafeDatabase | db : initialDatabase, input : nilTermList,
                                output : ('\n '\t '\b 'Cafe4Maude '1.2 '\o
                                          'started. '\n 'CafeOBJ 'specifications
                                          'can 'be 'introduced 'now 'into 'the
                                          'Full 'Maude 'database. '\n),
                                default : 'CONVERSION, initCafeAttS >,
                                nil] .

***(%
\end{verbatim}
}

The rule \verb"input" moves the list of quoted identifiers in the first argument of the
tuple to the \verb"input" attribute, trying to parse it first. We use the
\verb"CafeGRAMMAR" module to parse this input since this module, as explained in
Section~\ref{subsec:syntax}, contains the syntax of all our programs and commands,
as well as the syntax inherited from Full Maude:

{\codesize
\begin{verbatim}
%)

  rl [input] :
     [QI QIL, < O : X@Database | input : nilTermList, output : nil, Atts >, QIL' ]
  => if metaParse(CafeGRAMMAR, QI QIL, '@Input@) :: ResultPair
     then [nil,
           < O : X@Database | input : getTerm(metaParse(CafeGRAMMAR, QI QIL, '@Input@)),
                              output : nil, Atts >,
          QIL']
     else [nil,
           < O : X@Database | input : nilTermList,
                              output : ('\r 'WARNING: '\o printSyntaxError(metaParse(
                                        CafeGRAMMAR, QI QIL, '@Input@), QI QIL) '\n
                                        'ERROR: 'No 'parse 'for 'input.), Atts >,
           QIL' ]
     fi .

***(%
\end{verbatim}
}

On the other hand, the rule \verb"output" moves the output from the attribute
\verb"output" to the third element of the tuple:

{\codesize
\begin{verbatim}
%)

  rl [output] :
     [QIL, < O : X@Database | output : (QI QIL'), Atts >, QIL'']
  => [QIL, < O : X@Database | output : nil, Atts >, (QI QIL' QIL'')] .
endm

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

set print conceal on .

print conceal mod_is_sorts_._____endm .
print conceal fmod_is_sorts_.____endfm .
print conceal db .


*** trace exclude CAFE2MAUDE .
set show loop stats off .
set show loop timing off .

*** for debugging purposes
set print attribute on .

set show advisories off .

***(%

\end{comment}
}
%)

load model-checker.maude

select CAFE2MAUDE .

loop cafe4maude-init .

load predefined.maude