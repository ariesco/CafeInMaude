
***(%

We present in this section the main modules required for dealing with CafeOBJ
specifications~\cite{cafe-report}. First, we will see how to define the syntax,
and how to parse the terms to obtain the Maude modules~\cite{maude-book}. Then,
we will show how to pretty print these terms and how to create new commands and
rules and will be added in addition to the ones already defined in Full Maude.

{\codesize
\begin{comment}
%)

******************************************************
***predefined modules
******************************************************
***for HS

fmod COMPONENTS is
  sorts AComp OComp State .
  subsort AComp OComp < State .

  op empty-state : -> State .
  op __ : State State -> State [assoc comm id: empty-state format(o nt o)] .
endfm

*****************************************************
***for translation
*****************************************************

***(%
\end{comment}
}

\subsection{Syntax\label{subsec:syntax}}

The module \verb"CafeBUBBLES" defines the sorts \verb"@CafeBubble@" for bubbles (that is,
terms that can take any form, like the lefthand side of an equation), \verb"@CafeBubble@"
for tokens (like sorts), and \verb"@NeCafeTokenList@" for nonempty lists of tokens:

{\codesize
\begin{verbatim}
%)

fmod CafeBUBBLES is
  including QID-LIST .

  sorts @CafeBubble@ @CafeToken@ @NeCafeTokenList@ .

  op CafeBubble : QidList -> @CafeBubble@ [special (id-hook Bubble (1 -1 ( ))
                            op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                            op-hook qidSymbol (<Qids> : ~> Qid))] .

  op CafeToken : Qid -> @CafeToken@ [special (id-hook Bubble (1 1)
                            op-hook qidSymbol (<Qids> : ~> Qid)
                            id-hook Exclude(. [] < { } ( )))] .

  op neCafeTokenList : QidList -> @NeCafeTokenList@ [special (id-hook Bubble (1 -1)
                            op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                            op-hook qidSymbol (<Qids> : ~> Qid)
                            id-hook Exclude(. { } ))] .
endfm

***(%
\end{verbatim}
}

The module \verb"Cafe-ATTRIBUTES" defines the possible attributes that can be used
in operators and equations:

{\codesize
\begin{verbatim}
%)

fmod Cafe-ATTRIBUTES is
  pr CafeBUBBLES .

***(%
\end{verbatim}
}

It defines the sorts \verb"@CafeAttr@" for a single attribute and
\verb"@CafeAttrList@" for lists of attributes:

{\codesize
\begin{verbatim}
%)

  sorts @CafeAttr@ @CafeAttrList@ .
  subsorts @CafeAttr@ < @CafeAttrList@ .

***(%
\end{verbatim}
}

The attributes are defined following the CafeOBJ syntax. The unary attributes
are all defined in the same way, the identity attributes require take a bubble as
argument, while the precedence attribute takes a token:

{\codesize
\begin{verbatim}
%)

  op __ : @CafeAttrList@ @CafeAttrList@ -> @CafeAttrList@ [ctor assoc] .
  ops assoc associative l-assoc r-assoc comm commutative constr nonexec
      idem idempotent : -> @CafeAttr@ [ctor] .
  op id:`(_`) : @CafeBubble@ -> @CafeAttr@ [ctor] .
  op idr:`(_`) : @CafeBubble@ -> @CafeAttr@ [ctor] .
  op prec:_ : @CafeToken@ -> @CafeAttr@ [ctor] .
  op strat:_ : @NeCafeTokenList@ -> @CafeAttr@ [ctor] .

***(%
\end{verbatim}
}

Although the \verb"metadata" attribute is not currently available for CafeOBJ
specifications, it might be useful, so we support it by defining the appropriate
operator. However, it can also be defined in a comment, as explained
in~\cite{cafeOBJ2maudeUG}:

{\codesize
\begin{verbatim}
%)

  op metadata_ : @CafeToken@ -> @CafeAttr@ [ctor] .
endfm

***(%
\end{verbatim}
}

The syntax must also include the commands that we want to use for CafeOBJ specifications.
These commands are defined in the \verb"TRANSLATION-COMMANDS" module, which imports the
\verb"COMMANDS" module from Full Maude. To add new commands the user must define them
here and then specify their behavior in the module \texttt{CAFE2MAUDE-DATABASE-HANDLING}
described in Section~\ref{subsec:cafe:commands}:

{\codesize
\begin{verbatim}
%)

fmod TRANSLATION-COMMANDS is
  inc COMMANDS .

***(%
\end{verbatim}
}

We have defined three commands:
\begin{itemize}
\item
The first one will force the translation to be done without using the modifications
presented in~\cite{cafeOBJ2maudeUG}, that drop some requirements from the importations
modes and on the usage of theories to allow a wider range of CafeOBJ specifications to
be translated:

{\codesize
\begin{verbatim}
%)

  op strict`translation`on`. : -> @Command@ .

***(%
\end{verbatim}
}

\item
Analogously, the second one will allow these modifications:

{\codesize
\begin{verbatim}
%)

  op strict`translation`off`. : -> @Command@ .

***(%
\end{verbatim}
}

\item
The third one will require a CafeOBJ module to be shown:

{\codesize
\begin{verbatim}
%)

  op show`CafeOBJ`module_. : @Token@ -> @Command@ .
endfm

***(%
\end{verbatim}
}

\end{itemize}

The module \verb"CafeMETA-SIGN" defines the syntax for CafeOBJ modules:

{\codesize
\begin{verbatim}
%)

fmod CafeMETA-SIGN is
  including FULL-MAUDE-SIGN .
  including Cafe-ATTRIBUTES .

***(%
\end{verbatim}
}

It first defines all the required sorts, and the subsort relations between them:

{\codesize
\begin{verbatim}
%)

  sorts @CafeMODULE@ @HiddenSortDecl@ @VisibleSortDecl@ @CafeOpDecl@
        @CafeImportDecl@ @CafeType@ @CafeTypeList@ @CafeSortList@ @CafeSort@
        @BehaviorEquationDecl@ @CafeDeclList@ @CafeEqDecl@ @CafeVarDecl@
        @CafeSubSortRel@ @CafeLDeclList@ @CafeModExp@ @CafeParameter@ @CafeParameters@
        @CafeInterface@ @CafeViewDecl@ @CafeViewDeclList@ @CafeTransDecl@ @CafeViewId@
        @CafeViewIdList@ @ReductionDecl@ .

  subsort @CafeToken@ < @CafeSort@ < @CafeType@ .

***(%
  ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  subsort @CafeSort@ < @CafeSortList@ .
  subsort @CafeType@ < @CafeTypeList@ .
  subsorts @CafeImportDecl@ @CafeVarDecl@ @CafeEqDecl@ @VisibleSortDecl@ @CafeOpDecl@
           @CafeTransDecl@ @ReductionDecl@ < @CafeLDeclList@ .
  subsorts @HiddenSortDecl@ @BehaviorEquationDecl@ @CafeLDeclList@
           < @CafeDeclList@ .
  subsort @ModExp@ < @CafeModExp@ . *** !!!!
  subsort @ModExp@ < @CafeViewId@ .
  subsort @CafeViewId@ < @CafeViewIdList@ .
  *** !!!! subsort @CafeToken@ < @CafeModExp@ .
  subsort @CafeParameter@ < @CafeParameters@ .
  subsort @CafeToken@  < @CafeInterface@ .
  subsort @CafeViewDecl@ < @CafeViewDeclList@ .

  subsort @CafeMODULE@ < @Input@ .

  op __ : @CafeDeclList@ @CafeDeclList@ -> @CafeDeclList@ [assoc prec 10] .
  op __ : @CafeLDeclList@ @CafeLDeclList@ -> @CafeLDeclList@ [assoc prec 10] .
  op __ : @CafeTypeList@ @CafeTypeList@ -> @CafeTypeList@ [assoc prec 10] .
  op _,_ : @CafeParameters@ @CafeParameters@ -> @CafeParameters@ [assoc prec 45] .
  op none : -> @CafeViewDeclList@ [ctor] .
  op __ : @CafeViewDeclList@ @CafeViewDeclList@ -> @CafeViewDeclList@ [assoc id: none] .

  op _::_ : @CafeToken@ @CafeModExp@ -> @CafeParameter@ [prec 5 gather (e &)] .

  op _`(_`) : @CafeToken@ @CafeParameters@ -> @CafeInterface@ .

***(%
\end{comment}
}

Then it defines the syntax of every possible construction in CafeOBJ. For example,
we can define the syntax for:
\begin{itemize}
\item
Hidden sorts, which receive a token and create a \verb"@HiddenSortDecl@":

{\codesize
\begin{verbatim}
%)

  op *`[_`]* : @CafeToken@ -> @HiddenSortDecl@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  *** cafe module expressions !!!!
  *** op _+_ : @CafeModExp@ @CafeModExp@ -> @CafeModExp@ [ctor assoc prec 42] .
  op _`(_`) : @CafeModExp@ @CafeViewId@ -> @CafeModExp@ [ctor prec 40] .
  op _*`{_`} : @CafeModExp@ @CafeViewDeclList@ -> @CafeModExp@ [ctor prec 43] .

***(%
\end{comment}
}

\item
View identifiers, which can be either:
\begin{itemize}
\item
On the fly view declarations, receiving a module expression and a declaration
list:

{\codesize
\begin{verbatim}
%)

  op view`to_`{_`} : @CafeModExp@ @CafeViewDeclList@ -> @CafeViewId@ [ctor] .

***(%
\end{verbatim}
}

\item
The abbreviated version of the previous declaration, which does not require the
\verb"view to" keywords:

{\codesize
\begin{verbatim}
%)

  op _`{_`} : @CafeModExp@ @CafeViewDeclList@
              -> @CafeViewId@ [ctor prec 15] .

***(%
\end{verbatim}
}

\item
A view identifier assigned to a specific module expression:

{\codesize
\begin{verbatim}
%)

  op _<=_ : @CafeModExp@ @CafeViewId@
            -> @CafeViewId@ [ctor prec 20] .

***(%
\end{verbatim}
}

\item
Finally, lists of view identifiers are created by using the operator \verb"_,_".
Note that this operator is the one with the lower precedence, since it must not
interfer with the previous declarations:

{\codesize
\begin{verbatim}
%)

  op _,_ : @CafeViewIdList@ @CafeViewIdList@
           -> @CafeViewIdList@ [ctor assoc prec 25] .

***(%
\end{verbatim}
}

\end{itemize}

\item
Importations, including all the possible variants:

{\codesize
\begin{verbatim}
%)

  op protecting`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op pr`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op extending`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op ex`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op including`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op inc`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op using`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op us`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .

***(%
\end{verbatim}
}

\item
Sort and subsort declarations:

{\codesize
\begin{verbatim}
%)

  op `[_`] : @CafeSortList@ -> @VisibleSortDecl@ [ctor prec 5] .
  op `[_`] : @CafeSubSortRel@ -> @VisibleSortDecl@ [ctor prec 5] .

***(%
\end{verbatim}
}

\item
Subsort relations:

{\codesize
\begin{verbatim}
%)

  op _<_ : @CafeSortList@ @CafeSortList@ -> @CafeSubSortRel@ [ctor] .
  op _<_ : @CafeSortList@ @CafeSubSortRel@ -> @CafeSubSortRel@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  op var_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeVarDecl@ [ctor] .
  op vars_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeVarDecl@ [ctor] .

***(%
\end{comment}
}

\item
Equations. Note that the label or the possible attributes are not included
into the operator definition. Instead, we will deal with the bubble defining
the lefthand side to check whether there is a label. Similarly, we will
analyze the last bubble looking for attributes, such as \verb"nonexec":

{\codesize
\begin{verbatim}
%)

  op eq_=_. : @CafeBubble@ @CafeBubble@ -> @CafeEqDecl@ [ctor] .
  op ceq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ -> @CafeEqDecl@ [ctor] .
  op cq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ -> @CafeEqDecl@ [ctor] .

***(%
\end{verbatim}
}

\item
Transitions. Analogously to the case above, we do not declare explicitly the label
or the attributes of the transitions:

{\codesize
\begin{verbatim}
%)

  op trans_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op trns_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op ctrans_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                      -> @CafeTransDecl@ [ctor] .
  op ctrns_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                     -> @CafeTransDecl@ [ctor] .
  op btrans_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op btrns_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op bctrans_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                       -> @CafeTransDecl@ [ctor] .
  op bctrns_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                      -> @CafeTransDecl@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  *** Operator definitions
  op op_:`->_`{_`}. : @CafeToken@ @CafeType@ @CafeAttrList@ -> @CafeOpDecl@ [ctor] .
  op op_:_->_`{_`}. : @CafeToken@ @CafeTypeList@ @CafeSort@ @CafeAttrList@
                      -> @CafeOpDecl@ [ctor] .
  op op_:`->_. : @CafeToken@ @CafeType@ -> @CafeOpDecl@ [ctor] .
  op op_:_->_. : @CafeToken@ @CafeTypeList@ @CafeType@ -> @CafeOpDecl@ [ctor] .
  op ops_:`->_`{_`}. : @NeCafeTokenList@ @CafeType@ @CafeAttrList@ -> @CafeOpDecl@ [ctor] .
  op ops_:_->_`{_`}. : @NeCafeTokenList@ @CafeTypeList@ @CafeType@ @CafeAttrList@
                       -> @CafeOpDecl@ [ctor] .
  op ops_:`->_. : @NeCafeTokenList@ @CafeType@ -> @CafeOpDecl@ [ctor] .
  op ops_:_->_. : @NeCafeTokenList@ @CafeTypeList@ @CafeType@  -> @CafeOpDecl@ [ctor] .

***(%
\end{comment}
}

\item
Predicates. In this case the sorts for the definition are more specific than in the
cases above (where we just used bubbles), so we distinguish whether attributes are
declared or not:

{\codesize
\begin{verbatim}
%)

  op pred_:_`{_`}. : @CafeToken@ @CafeTypeList@ @CafeAttrList@
                     -> @CafeOpDecl@ [ctor] .
  op pred_:_. : @CafeToken@ @CafeTypeList@ -> @CafeOpDecl@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ***observer declaration
  op bop_:_->_. : @CafeToken@ @CafeTypeList@ @CafeSort@  -> @CafeOpDecl@ [ctor] .
  op bops_:_->_. : @NeCafeTokenList@ @CafeTypeList@ @CafeSort@ -> @CafeOpDecl@ [ctor] .
  op bop_:_->_`{_`}. : @CafeToken@ @CafeTypeList@ @CafeSort@ @CafeAttrList@
                       -> @CafeOpDecl@ [ctor] .
  op bops_:_->_`{_`}. : @NeCafeTokenList@ @CafeTypeList@ @CafeType@ @CafeAttrList@
                        -> @CafeOpDecl@ [ctor] .
  op bceq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ ->
                   @BehaviorEquationDecl@ [ctor] .
  op bcq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ ->
                  @BehaviorEquationDecl@ [ctor] .

  *** View declarations
  op vvar_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeViewDecl@ [ctor] .
  op vvars_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeViewDecl@ [ctor] .
  op sort_->_. : @CafeToken@ @CafeToken@ -> @CafeViewDecl@ [ctor] .
  op hsort_->_. : @CafeToken@ @CafeToken@ -> @CafeViewDecl@ [ctor] .
  op op_->_. : @CafeBubble@ @CafeBubble@ -> @CafeViewDecl@ [ctor] .
  op bop_->_. : @CafeBubble@ @CafeBubble@ -> @CafeViewDecl@ [ctor] .

  *** Reduction declarations
  op reduce_. : @CafeBubble@ -> @ReductionDecl@ [ctor] .
  op red_. : @CafeBubble@ -> @ReductionDecl@ [ctor] .

***(%
\end{comment}
}

\item
Module and view declarations. Note that they do not have the exact syntax used
by CafeOBJ. This distinction is obtained after a pre-processing stage that makes sure
that there is no clash with the Maude syntax for modules and views:

{\codesize
\begin{verbatim}
%)

  op cmod*_`{_`} : @CafeInterface@ @CafeDeclList@ -> @CafeMODULE@ [ctor] .
  op cmod!_`{_`} : @CafeInterface@ @CafeLDeclList@ -> @CafeMODULE@ [ctor] .
  op cview_from_to_`{_`} : @CafeToken@ @CafeModExp@ @CafeModExp@
                           @CafeViewDeclList@ -> @CafeMODULE@ [ctor] .

***(%
\end{verbatim}
}

\item
Open-close environment. This block is composed by a module expression and a list of
declarations, possibly including reduction commands. Note that we have introduced an
extra dot to ease the parsing; this dot will be added during the preprocessing stage,
so the user is not required to type it:

{\codesize
\begin{verbatim}
%)

  op copen_._close : @CafeModExp@ @CafeLDeclList@ -> @CafeMODULE@ [ctor] .
endfm

***(%
\end{verbatim}
}

\end{itemize}

The module \verb"META-CAFE2MAUDE-SIGNATURE" contains the metapresented signature
required by CafeOBJ, which extends the one for Full Maude:

{\codesize
\begin{verbatim}
%)

fmod META-CAFE2MAUDE-SIGNATURE is
 including META-FULL-MAUDE-SIGN .

 op CafeGRAMMAR : -> FModule .
 eq CafeGRAMMAR = addImports((including 'CafeMETA-SIGN .)
                             (including 'TRANSLATION-COMMANDS .), GRAMMAR ) .
endfm

***(%
\end{verbatim}
}

The modules \verb"CafeSIGN" and \verb"OPERATOR-Cafe", just describe auxiliary functions
for dealing with CafeOBJ modules, like functions for adding new sorts, equations, or
transitions, or for obtaining these values.

{\codesize
\begin{comment}
%)

fmod META-CAFE-SYNTAX is
  including EXT-SORT .

  sorts CafeHeader CafeImport CafeImportList CafeRen CafeRenSet HiddenSortDecl
        CafeOpDecl CafePredDecl CafeOpDeclSet CafeModExp CafeBehaviorEq CafeEq CafeEqSet
        CafeAttr CafeAttrSet CafeTrans CafeBehaviorTrans CafeTransSet CafeModule .

***(%
\end{comment}
}

\begin{comment}
*********************************************************************
****************************** HEADERS ******************************
*********************************************************************
\end{comment}

{\codesize
\begin{comment}
%)

  subsort Qid < CafeHeader .
  op _(_) : Qid ParameterDeclList -> CafeHeader [ctor] .

***(%
\end{comment}
}

\begin{comment}
**************************************************************************
****************************** IMPORTATIONS ******************************
**************************************************************************
\end{comment}

{\codesize
\begin{comment}
%)

  subsort CafeImport < CafeImportList .
  op none : -> CafeImportList [ctor] .
  op __ : CafeImportList CafeImportList -> CafeImportList [ctor assoc comm id: none format(d ni d)] .

  op pr(_) : CafeModExp -> CafeImport [ctor] .
  op ex(_) : CafeModExp -> CafeImport [ctor] .
  op inc(_) : CafeModExp -> CafeImport [ctor] .
  op us(_) : CafeModExp -> CafeImport [ctor] .

  subsort Qid < CafeModExp .

  op _+_ : CafeModExp CafeModExp ~> CafeModExp [ctor assoc comm] .
  op _*{_} : CafeModExp CafeRenSet -> CafeModExp [ctor] .
  op _[_] : CafeModExp ParameterList -> CafeModExp [ctor] .

  subsort CafeRen < CafeRenSet .

  op _,_ : CafeRenSet CafeRenSet -> CafeRenSet [ctor assoc comm] .
  op hsort_->_ : Sort Sort -> CafeRen [ctor] .
  op sort_->_ : Sort Sort -> CafeRen [ctor] .
  op op_->_ : Qid Qid -> CafeRen [ctor] .
  op bop_->_ : Qid Qid -> CafeRen [ctor] .

***(%
\end{comment}
}

\begin{comment}
*******************************************************************
****************************** SORTS ******************************
*******************************************************************
\end{comment}

{\codesize
\begin{comment}
%)

  op *[_]* : Sort -> HiddenSortDecl [ctor] .
  op noHiddenSort : -> HiddenSortDecl [ctor] .

***(%
\end{comment}
}

\begin{comment}
**********************************************************************
****************************** SUBSORTS ******************************
**********************************************************************
\end{comment}

{\codesize
\begin{comment}
%)

  sorts CafeSubsortDecl CafeSubsortDeclSet .
  subsort CafeSubsortDecl < CafeSubsortDeclSet .

  op none : -> CafeSubsortDeclSet [ctor] .
  op __ : CafeSubsortDeclSet CafeSubsortDeclSet -> CafeSubsortDeclSet
         [ctor assoc comm id: none format(d ni d)] .

  op [_<_] : Sort Sort -> CafeSubsortDecl [ctor] .

***(%
\end{comment}
}

\begin{comment}
***********************************************************************
****************************** OPERATORS ******************************
***********************************************************************
\end{comment}

{\codesize
\begin{comment}
%)

  subsort CafeOpDecl CafePredDecl < CafeOpDeclSet .
  op none : -> CafeOpDeclSet [ctor] .
  op __ : CafeOpDeclSet CafeOpDeclSet -> CafeOpDeclSet [ctor assoc comm id: none format(d ni d)] .

  op op_:_->_{_} : Qid TypeList Type CafeAttrSet
                   -> CafeOpDecl [ctor format(b o b o b o b o b o)] .

  op bop_:_->_{_} : Qid TypeList Type CafeAttrSet
                    -> CafeOpDecl [ctor format(b o b o b o b o b o)] .
  op pred_:_{_} : Qid TypeList CafeAttrSet
                   -> CafePredDecl [ctor format(b o b o b o b o)] .

  subsort CafeAttr < CafeAttrSet .
  op none : -> CafeAttrSet [ctor] .
  op __ : CafeAttrSet CafeAttrSet -> CafeAttrSet [ctor assoc comm id: none] .

  ops constr comm assoc idem owise l-assoc r-assoc coherent nonexec : -> CafeAttr [ctor] .
  op meta-data : String -> CafeAttr [ctor] .
  ops id:(_) idr:(_) : Term -> CafeAttr [ctor] .
  op prec:(_) : Nat -> CafeAttr [ctor] .
  op strat:(_) : NeNatList -> CafeAttr [ctor] .
  op label:(_) : Qid -> CafeAttr [ctor] .

***(%
\end{comment}
}

\begin{comment}
***********************************************************************
****************************** EQUATIONS ******************************
***********************************************************************
\end{comment}

{\codesize
\begin{comment}
%)

  subsort CafeBehaviorEq CafeEq < CafeEqSet .
  op none : -> CafeEqSet [ctor] .
  op __ : CafeEqSet CafeEqSet -> CafeEqSet [ctor assoc comm id: none format(d ni d)] .

  op eq_=_{_}. : Term Term CafeAttrSet -> CafeEq [ctor format(b o b o b o b o o)] .
  op beq_=_{_}. : Term Term CafeAttrSet -> CafeBehaviorEq [ctor format(b o b o b o b o o)] .
  op ceq_=_if_{_}. : Term Term EqCondition CafeAttrSet -> CafeEq [ctor format(b o b o b o o o o o o)] .
  op bceq_=_if_{_}. : Term Term EqCondition CafeAttrSet -> CafeBehaviorEq [ctor format(b o b o b o o o o o o)] .

***(%
\end{comment}
}

\begin{comment}
*************************************************************************
****************************** TRANSITIONS ******************************
*************************************************************************
\end{comment}

{\codesize
\begin{comment}
%)

  subsort CafeTrans CafeBehaviorTrans < CafeTransSet .
  op none : -> CafeTransSet [ctor] .
  op __ : CafeTransSet CafeTransSet -> CafeTransSet [ctor assoc comm id: none format(d ni d)] .

  op trans_=>_{_}. : Term Term CafeAttrSet -> CafeTrans [ctor format(b o b o b o o o o)] .
  op btrans_=>_{_}. : Term Term CafeAttrSet -> CafeBehaviorTrans [ctor format(b o b o b o o o o)] .
  op ctrans_=>_if_{_}. : Term Term Condition CafeAttrSet -> CafeTrans [ctor format(b o b o b o o o o o o)] .
  op bctrans_=>_if_{_}. : Term Term Condition CafeAttrSet -> CafeBehaviorTrans [ctor format(b o b o b o o o o o o)] .

***(%
\end{comment}
}

\begin{comment}
*********************************************************************
****************************** MODULES ******************************
*********************************************************************
\end{comment}

{\codesize
\begin{comment}
%)

  op mod*_{__[_]____} : CafeHeader CafeImportList HiddenSortDecl SortSet
                        CafeSubsortDeclSet CafeOpDeclSet CafeEqSet CafeTransSet
                        -> CafeModule
                        [ctor gather(& & & & & & & &) format(d d s n++i ni ni d d ni ni ni ni n--i d)] .

  op mod!_{__[_]____} : CafeHeader CafeImportList HiddenSortDecl SortSet
                        CafeSubsortDeclSet CafeOpDeclSet CafeEqSet CafeTransSet
                        -> CafeModule
                        [ctor gather(& & & & & & & &) format(d d s n++i ni ni d d ni ni ni ni n--i d)] .
endfm

fmod MAUDE2CAFE-META-TRANSLATION is
 pr META-CAFE-SYNTAX .

 vars S S' : Sort .
 vars Q Q' : Qid .
 var  SSD : CafeSubsortDecl .
 var  SSDS : CafeSubsortDeclSet .
 var  PDL : ParameterDeclList .
 var  I : CafeImport .
 var  IL : CafeImportList .
 var  OD : CafeOpDecl .
 var  ODS : CafeOpDeclSet .
 vars ME ME' : CafeModExp .
 var  PL : ParameterList .
 var  RS : CafeRenSet .
 var  R : CafeRen .
 var  At : CafeAttr .
 var  AtS : CafeAttrSet .
 var  St : String .
 var  N : Nat .
 vars T T' : Term .
 var  NNL : NeNatList .
 var  TyL : TypeList .
 var  Ty : Type .
 var  Eq : CafeEq .
 var  EqS : CafeEqSet .
 var  C : Condition .
 var  Tr : CafeTrans .
 var  TrS : CafeTransSet .
 var  HS : HiddenSortDecl .
 var  H : CafeHeader .
 var  SS : SortSet .

 op cafe2maude : CafeModule -> Module .
 eq cafe2maude(mod* H {IL HS [SS] SSDS ODS EqS TrS}) =
       mod cafe2maude(H) is
           cafe2maude*(IL)
           sorts cafe2maude(HS) ; SS .
           cafe2maude*(SSDS)
           cafe2maude*(ODS)
           none
           cafe2maude*(EqS)
           cafe2maude*(TrS)
       endm .
 eq cafe2maude(mod! H {IL HS [SS] SSDS ODS EqS TrS}) =
       th cafe2maude(H) is
           cafe2maude*(IL)
           sorts cafe2maude(HS) ; SS .
           cafe2maude*(SSDS)
           cafe2maude*(ODS)
           none
           cafe2maude*(EqS)
           cafe2maude*(TrS)
       endth .

 op cafe2maude : CafeHeader -> Header .
 eq cafe2maude(Q) = Q .
 eq cafe2maude(Q(PDL)) = Q{PDL} .

 op cafe2maude* : CafeImportList -> ImportList .
 eq cafe2maude*((none).CafeImportList) = nil .
 eq cafe2maude*(I IL) = cafe2maude(I) cafe2maude*(IL) .

 op cafe2maude : CafeImport -> Import .
 eq cafe2maude(pr(ME)) = protecting cafe2maudeME(ME) . .
 eq cafe2maude(ex(ME)) = extending cafe2maudeME(ME) . .
 eq cafe2maude(inc(ME)) = including cafe2maudeME(ME) . .
 eq cafe2maude(us(ME)) = including cafe2maudeME(ME) . .

 op cafe2maudeME : CafeModExp -> ModuleExpression .
 eq cafe2maudeME(Q) = Q .
 eq cafe2maudeME(ME + ME') = cafe2maudeME(ME) + cafe2maude(ME') .
 eq cafe2maudeME(ME * {RS}) = cafe2maudeME(ME) * (cafe2maude*(RS)) .
 eq cafe2maudeME(ME[PL]) = cafe2maudeME(ME) {PL} .

 op cafe2maude* : CafeRenSet -> RenamingSet .
 eq cafe2maude*((R, RS)) = cafe2maude(R), cafe2maude*(RS) .
 eq cafe2maude*(R) = cafe2maude(R) .

 op cafe2maude : CafeRen -> Renaming .
 eq cafe2maude(hsort S -> S') = sort S to S' .
 eq cafe2maude(sort S -> S') = sort S to S' .
 eq cafe2maude(op Q -> Q) = op Q to Q [none] .
 eq cafe2maude(bop Q -> Q) = op Q to Q [none] .

 op cafe2maude : HiddenSortDecl -> SortSet .
 eq cafe2maude(*[ S ]*) = S .
 eq cafe2maude(noHiddenSort) = none .

 op cafe2maude* : CafeSubsortDeclSet -> SubsortDeclSet .
 eq cafe2maude*((none).CafeSubsortDeclSet) = none .
 eq cafe2maude*(SSD SSDS) = cafe2maude(SSD) cafe2maude*(SSDS) .

 op cafe2maude : CafeSubsortDecl -> SubsortDecl .
 eq cafe2maude([S < S']) = subsort S < S . .

 op cafe2maude* : CafeOpDeclSet -> OpDeclSet .
 eq cafe2maude*((none).CafeOpDeclSet) = none .
 eq cafe2maude*(OD ODS) = cafe2maude(OD) cafe2maude*(ODS) .

 op cafe2maude : CafeOpDecl -> OpDecl .
 eq cafe2maude(op Q : TyL -> Ty {AtS}) = op Q : TyL -> Ty [cafe2maude*(AtS)] . .
 eq cafe2maude(bop Q : TyL -> Ty {AtS}) = op Q : TyL -> Ty [cafe2maude*(AtS)] . .
 eq cafe2maude(pred Q : TyL {AtS}) = op Q : TyL -> 'Bool [cafe2maude*(AtS)] . .

 op cafe2maude* : CafeAttrSet -> AttrSet .
 eq cafe2maude*((none).CafeAttrSet) = none .
 eq cafe2maude*(At AtS) = cafe2maude(At) cafe2maude*(AtS) .

 *** TODO: Behavioural axioms can be used in equational reduction,
 *** and an operator attribute coherent is added for this purpose.

 op cafe2maude : CafeAttr -> Attr .
 eq cafe2maude(constr) = ctor .
 eq cafe2maude(comm) = comm .
 eq cafe2maude(assoc) = assoc .
 eq cafe2maude(idem) = idem .
 eq cafe2maude(owise) = owise .
 eq cafe2maude(l-assoc) = gather('E 'e) .
 eq cafe2maude(r-assoc) = gather('e 'E) .
 eq cafe2maude(nonexec) = nonexec .
 eq cafe2maude(meta-data(St)) = metadata(St) .
 eq cafe2maude(id:(T)) = id(T) .
 eq cafe2maude(idr:(T)) = right-id(T) .
 eq cafe2maude(prec:(N)) = prec(N) .
 eq cafe2maude(strat:(NNL)) = strat(NNL) .
 eq cafe2maude(label:(Q)) = label(Q) .

 op cafe2maude* : CafeEqSet -> EquationSet .
 eq cafe2maude*((none).CafeEqSet) = none .
 eq cafe2maude*(Eq EqS) = cafe2maude(Eq) cafe2maude*(EqS) .

 op cafe2maude : CafeEq -> Equation .
 eq cafe2maude(eq T = T' {AtS} .) = eq T = T' [cafe2maude*(AtS)] . .
 eq cafe2maude(beq T = T' {AtS} .) = eq T = T' [cafe2maude*(AtS)] . .
 eq cafe2maude(ceq T = T' if C {AtS} .) = ceq T = T' if C [cafe2maude*(AtS)] . .
 eq cafe2maude(bceq T = T' if C {AtS} .) = ceq T = T' if C [cafe2maude*(AtS)] . .

 op cafe2maude* : CafeTransSet -> RuleSet .
 eq cafe2maude*((none).CafeTransSet) = none .
 eq cafe2maude*(Tr TrS) = cafe2maude(Tr) cafe2maude*(TrS) .

 op cafe2maude : CafeTrans -> Rule .
 eq cafe2maude(trans T => T' {AtS} .) = rl T => T' [cafe2maude*(AtS)] . .
 eq cafe2maude(btrans T => T' {AtS} .) = rl T => T' [cafe2maude*(AtS)] . .
 eq cafe2maude(ctrans T => T' if C {AtS} .) = crl T => T' if C [cafe2maude*(AtS)] . .
 eq cafe2maude(bctrans T => T' if C {AtS} .) = crl T => T' if C [cafe2maude*(AtS)] . .
endfm

fmod CAFE-DATABASE is
  pr MAUDE2CAFE-META-TRANSLATION .
  pr DATABASE .

  sort CafeDB .
  op cafeModule : Qid CafeModule -> CafeDB [ctor] .

  op emptyCDB : -> CafeDB [ctor] .
  op __ : CafeDB CafeDB -> CafeDB [ctor assoc comm id: emptyCDB] .

  var  Q : Qid .
  vars CM CM' : CafeModule .
  var  CDB : CafeDB .
  vars DB DB' : Database .
  var  T : Term .
  var  M : Module .

  op set : CafeDB Qid CafeModule -> CafeDB .
  eq set(cafeModule(Q, CM) CDB, Q, CM') = cafeModule(Q, CM') CDB .
  eq set(CDB, Q, CM) = cafeModule(Q, CM) CDB [owise] .

  op getTopModule : CafeDB Qid ~> CafeModule .
  eq getTopModule(cafeModule(Q, CM) CDB, Q) = CM .

  op setTopModule : CafeDB Qid CafeModule -> CafeDB .
  eq setTopModule(cafeModule(Q, CM) CDB, Q, CM') = cafeModule(Q, CM') CDB .
  eq setTopModule(CDB, Q, CM) = cafeModule(Q, CM) CDB .

  op introduceAll : CafeDB Database -> Database .
  eq introduceAll(emptyCDB, DB) = DB .
  ceq introduceAll(cafeModule(Q, CM) CDB, DB) = introduceAll(CDB, DB')
   if DB' := insertTopModule(Q, cafe2maude(CM), DB) .
endfm

fmod CAFE-META-LEVEL is
 pr CAFE-DATABASE .

 var  M : Module .
 var  CM : CafeModule .
 var  H : CafeHeader .
 vars IL IL' : CafeImportList .
 var  HS : HiddenSortDecl .
 var  S : Sort .
 vars SS SS' : SortSet .
 vars SSDS SSDS' : CafeSubsortDeclSet .
 vars ODS ODS' : CafeOpDeclSet .
 vars EqS EqS' : CafeEqSet .
 vars TS TS' : CafeTransSet .
 var  T : Term .
 var  PDL : ParameterDeclList .
 var  Q : Qid .
 var  B : Bound .
 var  N : Nat .
 var  CDB : CafeDB .
 vars DB DB' DB'' : Database .

 op getHeader : CafeModule -> CafeHeader .
 op getName : CafeModule -> Qid .

 eq getHeader(mod* H {IL HS [SS] SSDS ODS EqS TS}) = H .
 eq getHeader(mod! H {IL HS [SS] SSDS ODS EqS TS}) = H .

 eq getName(mod* H {IL HS [SS] SSDS ODS EqS TS}) = getName(H) .
 eq getName(mod! H {IL HS [SS] SSDS ODS EqS TS}) = getName(H) .

 op getName : CafeHeader -> Qid .
 eq getName(Q) = Q .
 eq getName(Q(PDL)) = Q .

 op getImports : CafeModule -> CafeImportList .
 op getHiddenSort : CafeModule -> HiddenSortDecl .
 op getSorts : CafeModule -> SortSet .
 op getSubsorts : CafeModule -> CafeSubsortDeclSet .
 op getOps : CafeModule -> CafeOpDeclSet .
 op getEqs : CafeModule -> CafeEqSet .
 op getTrans : CafeModule -> CafeTransSet .

 eq getImports(mod* H {IL HS [SS] SSDS ODS EqS TS}) = IL .
 eq getImports(mod! H {IL HS [SS] SSDS ODS EqS TS}) = IL .

 eq getHiddenSort(mod* H {IL HS [SS] SSDS ODS EqS TS}) = HS .
 eq getHiddenSort(mod! H {IL HS [SS] SSDS ODS EqS TS}) = HS .

 eq getSorts(mod* H {IL HS [SS] SSDS ODS EqS TS}) = SS .
 eq getSorts(mod! H {IL HS [SS] SSDS ODS EqS TS}) = SS .

 eq getSubsorts(mod* H {IL HS [SS] SSDS ODS EqS TS}) = SSDS .
 eq getSubsorts(mod! H {IL HS [SS] SSDS ODS EqS TS}) = SSDS .

 eq getOps(mod* H {IL HS [SS] SSDS ODS EqS TS}) = ODS .
 eq getOps(mod! H {IL HS [SS] SSDS ODS EqS TS}) = ODS .

 eq getEqs(mod* H {IL HS [SS] SSDS ODS EqS TS}) = EqS .
 eq getEqs(mod! H {IL HS [SS] SSDS ODS EqS TS}) = EqS .

 eq getTrans(mod* H {IL HS [SS] SSDS ODS EqS TS}) = TS .
 eq getTrans(mod! H {IL HS [SS] SSDS ODS EqS TS}) = TS .

 op addImports : CafeModule CafeImportList -> CafeModule .
 op replaceHiddenSort : CafeModule Sort -> CafeModule .
 op addSorts : CafeModule SortSet -> CafeModule .
 op addSubsorts : CafeModule CafeSubsortDeclSet -> CafeModule .
 op addOps : CafeModule CafeOpDeclSet -> CafeModule .
 op addEqs : CafeModule CafeEqSet -> CafeModule .
 op addTrans : CafeModule CafeTransSet -> CafeModule .

 eq addImports(mod* H {IL HS [SS] SSDS ODS EqS TS}, IL') =
                  mod* H {IL IL' HS [SS] SSDS ODS EqS TS} .
 eq addImports(mod! H {IL HS [SS] SSDS ODS EqS TS}, IL') =
                  mod! H {IL IL' HS [SS] SSDS ODS EqS TS} .

 eq replaceHiddenSort(mod* H {IL HS [SS] SSDS ODS EqS TS}, S) =
                  mod* H {IL *[ S ]* [SS] SSDS ODS EqS TS} .
 eq replaceHiddenSort(mod! H {IL HS [SS] SSDS ODS EqS TS}, S) =
                  mod! H {IL *[ S ]* [SS] SSDS ODS EqS TS} .

 eq addSorts(mod* H {IL HS [SS] SSDS ODS EqS TS}, SS') =
                  mod* H {IL HS [SS ; SS'] SSDS ODS EqS TS} .
 eq addSorts(mod! H {IL HS [SS] SSDS ODS EqS TS}, SS') =
                  mod! H {IL HS [SS ; SS'] SSDS ODS EqS TS} .

 eq addSubsorts(mod* H {IL HS [SS] SSDS ODS EqS TS}, SSDS') =
                  mod* H {IL HS [SS] SSDS SSDS' ODS EqS TS} .
 eq addSubsorts(mod! H {IL HS [SS] SSDS ODS EqS TS}, SSDS') =
                  mod! H {IL HS [SS] SSDS SSDS' ODS EqS TS} .

 eq addOps(mod* H {IL HS [SS] SSDS ODS EqS TS}, ODS') =
                  mod* H {IL HS [SS] SSDS ODS ODS' EqS TS} .
 eq addOps(mod! H {IL HS [SS] SSDS ODS EqS TS}, ODS') =
                  mod! H {IL HS [SS] SSDS ODS ODS' EqS TS} .

 eq addEqs(mod* H {IL HS [SS] SSDS ODS EqS TS}, EqS') =
                  mod* H {IL HS [SS] SSDS ODS EqS EqS' TS} .
 eq addEqs(mod! H {IL HS [SS] SSDS ODS EqS TS}, EqS') =
                  mod! H {IL HS [SS] SSDS ODS EqS EqS' TS} .

 eq addTrans(mod* H {IL HS [SS] SSDS ODS EqS TS}, TS') =
                  mod* H {IL HS [SS] SSDS ODS EqS TS TS'} .
 eq addTrans(mod! H {IL HS [SS] SSDS ODS EqS TS}, TS') =
                  mod! H {IL HS [SS] SSDS ODS EqS TS TS'} .

 op removeSorts : CafeModule SortSet -> CafeModule .
 eq removeSorts(mod* H {IL HS [S ; SS] SSDS ODS EqS TS}, S ; SS') =
              removeSorts(mod* H {IL HS [SS] SSDS ODS EqS TS}, SS') .
 eq removeSorts(mod! H {IL HS [S ; SS] SSDS ODS EqS TS}, S ; SS') =
              removeSorts(mod! H {IL HS [SS] SSDS ODS EqS TS}, SS') .
 eq removeSorts(CM, SS) = CM [owise] .

  op metaReduce : Qid Term CafeDB Database -> ResultPair .
  ceq metaReduce(Q, T, CDB, DB) = metaReduce(M, T)
   if DB' := introduceAll(CDB, DB) /\
      DB'' := if compiledModule(Q, DB')
              then DB
              else procModule(Q, DB')
              fi /\
      M := getTopModule(Q, DB'') .

  op metaRewrite : Qid Term Bound CafeDB Database -> ResultPair .
  ceq metaRewrite(Q, T, B, CDB, DB) = metaRewrite(M, T, B)
   if DB' := introduceAll(CDB, DB) /\
      DB'' := if compiledModule(Q, DB')
              then DB
              else procModule(Q, DB')
              fi /\
      M := getTopModule(Q, DB'') .

  op metaFrewrite : Qid Term Bound Nat CafeDB Database -> ResultPair .
  ceq metaFrewrite(Q, T, B, N, CDB, DB) = metaFrewrite(M, T, B, N)
   if DB' := introduceAll(CDB, DB) /\
      DB'' := if compiledModule(Q, DB')
              then DB
              else procModule(Q, DB')
              fi /\
      M := getTopModule(Q, DB'') .
endfm

***(%
\end{comment}
}

\subsection{Parsing\label{subsec:parsing}}

The module \verb"CafeDECL-PARSING" is in charge of parsing a term built following
the syntactical constructions presented above:

{\codesize
\begin{verbatim}
%)

fmod CafeDECL-PARSING is
  pr META-CAFE-SYNTAX .
  inc UNIT-DECL-PARSING .
  pr MAP{Qid, Qid} * (sort Map{Qid, Qid} to SortMap) .

***(%
\end{verbatim}
}

It defines the sort \verb"CafeParseResult" to return the result of the parsing process.
The is composed of:
\begin{itemize}
\item
A term of sort \verb"ParseDeclResult". This sort, defined in Full Maude, keeps
the module obtained thus far, another module still containing bubbles, and a set of
operator declarations standing for the declaration of variables on the fly.

\item
A list of quoted identifiers, that will propagate the errors found during the
parsing process.

\item
A database, that will be updated with the new module or view if the parsing is
successful.
\end{itemize}

{\codesize
\begin{verbatim}
%)

  sort CafeParseResult .
  op <_,_,_> : ParseDeclResult QidList Database -> CafeParseResult [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  vars T T' T'' T''' T3 T4 TV TS : Term .
  vars S S' S'' : Term .
  vars TL TL' TL'' : TermList .
  vars VDS VDS' : OpDeclSet .
  var  PDR : ParseDeclResult .
  vars F O : Qid .
  vars H : Header .
  vars SSDS : SubsortDeclSet .
  vars OPDS : OpDeclSet .
  vars MAS : MembAxSet .
  vars EqS : EquationSet .
  vars RIS : RuleSet .
  vars IL : ImportList .
  vars SS : SortSet .
  vars QIL' QIL QL QL' QL'' : QidList .
  vars PU U PU' U' : Module .
  var  HS : Sort .
  var  TyL : TypeList .
  var  Ty : Type .
  vars QI Q Q' : Qid .
  vars M M' : Module .
  vars DB DB' DB'' : Database .
  var  RP : [ResultPair] .
  var  N : Nat .
  var  B : Bool .
  var  PDL : ParameterDeclList .
  var  ME : ModuleExpression .
  vars SM SM' VM VM' : SortMap .
  var  V : Variable .
  var  C : Constant .
  vars St St' St'' St''' : String .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}

The function \verb"parseCafeModExp" transforms the CafeOBJ syntax
for module expressions into Maude syntax. Note that the syntax for tokens is also
translated when required:

{\codesize
\begin{verbatim}
%)

  op parseCafeModExp : Term -> ModuleExpression .
  eq parseCafeModExp('CafeToken[T]) = 'token[T] .
  eq parseCafeModExp('token[T]) = 'token[T] .
  ceq parseCafeModExp('_`(_`)[T, T']) = '_`{_`}[T'', T''']
   if T'' := parseCafeModExp(T) /\
      T''' := parseCafeViewExp(T') .
  ceq parseCafeModExp('_*`{_`}[T, T']) = '_*`(_`)[T'', T''']
   if T'' := parseCafeModExp(T) /\
      T''' := parseCafeRen(T') .
  ceq parseCafeModExp('_+_[T, T']) = '_+_[T'', T''']
   if T'' := parseCafeModExp(T) /\
      T''' := parseCafeModExp(T') .

***(%
\end{verbatim}
}

\end{comment}

The function \verb"parseCafeRen" translates CafeOBJ renamings. Note that
the renaming for hidden sorts is translated as a renaming for standard sorts, since
there is no hidden sorts in Maude:

{\codesize
\begin{verbatim}
%)

  op parseCafeRen : Term -> Term .
  ceq parseCafeRen('__[T, T']) = '_`,_[T'', T3]
   if T'' := parseCafeRen(T) /\
      T3 := parseCafeRen(T') .
  ceq parseCafeRen('sort_->_.[T, T']) = 'sort_to_[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .
  ceq parseCafeRen('hsort_->_.[T, T']) = 'sort_to_[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .
  eq parseCafeRen('op_->_.['CafeBubble[T], 'CafeBubble[T']]) =
                                    'op_to_['token[T], 'token[T']] .
  eq parseCafeRen('bop_->_.['CafeBubble[T], 'CafeBubble[T']]) =
                                    'op_to_['token[T], 'token[T']] .
  eq parseCafeRen(T) = T [owise] .

***(%
\end{verbatim}
}

The function \verb"sort2sort" translates CafeOBJ tokens into Maude tokens
for sorts, while \verb"parseCafeViewExp" translates view tokens:

{\codesize
\begin{verbatim}
%)

  op sort2sort : Term -> Term .
  eq sort2sort('CafeToken[T]) = 'sortToken[T] .
  eq sort2sort(T) = T [owise] .

  op parseCafeViewExp : Term -> ViewExp .
  eq parseCafeViewExp('token[T]) = 'viewToken[T] .
  eq parseCafeViewExp(T) = T [owise] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)


  **************************************
  ***convert to Functional Module
  **************************************

***(%
\end{comment}
}

The function \verb"parseCafeDecl" uses the function \texttt{parseCafeModExp}
to parse de module expression. Once this expression is obtained it uses the
Full Maude function

{\codesize
\begin{verbatim}
%)

  op parseCafeDecl : Term Module Module OpDeclSet Database -> CafeParseResult .
  ceq parseCafeDecl('protecting`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('protecting_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('pr`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('protecting_.[T'], PU, U, VDS) .

***(%
  ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('extending`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('extending_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('ex`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('extending_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('inc`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('including`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('using`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('us`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .

***(%
\end{comment}
}

The function \verb"parseCafeModExp" returns a term of sort \verb"ParseResult".
This sort contains a database and, depending the context where it is applied,
a module expression, a view expression, or a list of terms:

{\codesize
\begin{verbatim}
%)

  sort ParseResult .
  op <_,_> : ModuleExpression Database -> ParseResult [ctor] .
  op <_,_> : ViewExp Database -> ParseResult [ctor] .
  op <_,_> : TermList Database -> ParseResult [ctor] .

***(%
\end{verbatim}
}

Parsing simple module expressions, summations, and expressions with renamings is
straightforward:

{\codesize
\begin{verbatim}
%)

  op parseCafeModExp : Term Database -> ParseResult .
  eq parseCafeModExp('CafeToken[T], DB) = < 'token[T], DB > .
  eq parseCafeModExp('token[T], DB) = < 'token[T], DB > .
  ceq parseCafeModExp('_+_[T, T'], DB) = < '_+_[T'', T'''], DB'' >
   if < T'', DB' > := parseCafeModExp(T, DB) /\
      < T''', DB'' > := parseCafeModExp(T', DB') .
  ceq parseCafeModExp('_*`{_`}[T, T'], DB) = < '_*`(_`)[T'', T'''], DB' >
   if < T'', DB' > := parseCafeModExp(T, DB) /\
      T''' := parseCafeRen(T') .

***(%
\end{verbatim}
}

Parsing a module expression involving view expression requires the database, because
we need the list of parameters to deal with on-the-fly view declarations:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeModExp('_`(_`)[T, T'], DB) = < '_`{_`}[T'', T'''], DB'' >
   if < T'', DB' > := parseCafeModExp(T, DB) /\
      M := getTopModule(parseModExp(T''), DB') /\
      PDL := getPDL(M) /\
      < T''', DB'' > := parseCafeViewExp(PDL, sortViewId(PDL, T'), DB') .

***(%
\end{verbatim}
}

Parsing a view identifier requires the parameter list of the module being instantiated,
the view identifier itself, and the database.

{\codesize
\begin{verbatim}
%)

  op parseCafeViewExp : ParameterDeclList Term Database -> ParseResult .
  eq parseCafeViewExp(PDL, 'token[T], DB) = < 'viewToken[T], DB > .
  eq parseCafeViewExp(PDL, '_<=_[T, T'], DB) = parseCafeViewExp(PDL, T', DB) .
  ceq parseCafeViewExp(PDL, '_`,_[TL], DB) = < '_`,_[TL'], DB' >
   if < TL', DB' > := parseCafeViewExp*(PDL, TL, DB) .

***(%
\end{verbatim}
}

When parsing views declared on the fly we create a new auxiliary view, add it to the
database, and return the new database and the name of the auxiliary view:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeViewExp(Q :: ME, 'view`to_`{_`}[T, T'], DB) =
                                                      < 'viewToken[upTerm(Q')], DB' >
   if Q' := getNewName(DB, 0) /\
      T'' := 'token[upTerm(Q')] /\
      TV := 'view_from_to_is_endv[T'', 'token[upTerm(ME)], T, maps2maps(T')] /\
      DB' := procView(TV, DB) .
  ceq parseCafeViewExp(Q :: ME, '_`{_`}[T, T'], DB) = < 'viewToken[upTerm(Q')], DB' >
   if Q' := getNewName(DB, 0) /\
      T'' := 'token[upTerm(Q')] /\
      TV := 'view_from_to_is_endv[T'', 'token[upTerm(ME)], T, maps2maps(T')] /\
      DB' := procView(TV, DB) .

***(%
\end{verbatim}
}

The auxiliary functions used thus far are defined as follows:
\begin{itemize}
\item
The function \verb"parseCafeViewExp*" traverses the terms in the list,
pairing them with the parameters from the module being instantiated:

{\codesize
\begin{verbatim}
%)

  op parseCafeViewExp* : ParameterDeclList TermList Database -> ParseResult .
  eq parseCafeViewExp*(PDL, empty, DB) = < empty, DB > .
  ceq parseCafeViewExp*((Q :: ME, PDL), (T, TL), DB) = < (T', TL'), DB'' >
   if < T', DB' > := parseCafeViewExp(Q :: ME, T, DB) /\
      < TL', DB'' > := parseCafeViewExp(PDL, TL, DB') .

***(%
\end{verbatim}
}

\item
The function \verb"maps2maps" transforms CafeOBJ mappings into Maude mappings.
This is achieved by first computing the mappings for sorts and variables,
removing the variable declarations, which are not allowed in Maude, and
then applying an auxiliary \verb"maps2maps" function with $3$ arguments:

{\codesize
\begin{verbatim}
%)

  op maps2maps : Term -> Term .
  ceq maps2maps(T) = maps2maps(T', SM, VM)
   if SM := getSortMap(T) /\
      VM := getVarMap(T) /\
      T' := removeVarDecls(T) .

***(%
\end{verbatim}
}

\item
The function \verb"getSortMap" traverses the mappings, transforming them into
Maude mappings:

{\codesize
\begin{verbatim}
%)

  op getSortMap : Term -> SortMap .
  ceq getSortMap('__[T, T']) = SM, SM'
   if SM := getSortMap(T) /\
      SM' := getSortMap(T') .
  eq getSortMap('sort_->_.[T, T']) = getSort(T) |-> getSort(T') .
  eq getSortMap('hsort_->_.[T, T']) = getSort(T) |-> getSort(T') .
  eq getSortMap(T) = empty [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"getSort" just extracts the quoted identifier from the term:

{\codesize
\begin{verbatim}
%)

  op getSort : Term ~> Term .
  eq getSort('CafeToken[T]) = downQid(T) .

***(%
\end{verbatim}
}

\item
Similarly, \verb"getVarMap" traverses the term creating a mapping between variables
and their sort.
%
Note that we use \texttt{vvar} and \texttt{vvars} instead of \texttt{var} and
\texttt{vars}. This is due to a pre-processing step that aims to distinguish
between these variables and the ones in modules:

{\codesize
\begin{verbatim}
%)

  op getVarMap : Term -> SortMap .
  ceq getVarMap('__[T, T']) = VM, VM'
   if VM := getVarMap(T) /\
      VM' := getVarMap(T') .
  ceq getVarMap('vvar_:_.['neCafeTokenList[T], 'CafeToken[T']]) =
                                                          createMap*(QIL, Q)
   if QIL := downQidList(T) /\
      Q := downQid(T') .
  ceq getVarMap('vvars_:_.['neCafeTokenList[T], 'CafeToken[T']]) =
                                                          createMap*(QIL, Q)
   if QIL := downQidList(T) /\
      Q := downQid(T') .
  eq getVarMap(T) = empty [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"createMap*" just maps all the variables in the first argument to the sort
given as second argument:

{\codesize
\begin{verbatim}
%)

  op createMap* : QidList Qid -> SortMap .
  eq createMap*(nil, Q) = empty .
  eq createMap*(Q QIL, Q') = Q |-> Q', createMap*(QIL, Q') .

***(%
\end{verbatim}
}

\item
The function \verb"maps2maps" with $3$ arguments translates CafeOBJ mappings
into Maude mappings. Sort renamings only require changing the syntax:

{\codesize
\begin{verbatim}
%)

  op maps2maps : Term SortMap SortMap -> Term .
  ceq maps2maps('__[T, T'], SM, VM) = '__[T'', T3]
   if T'' := maps2maps(T, SM, VM) /\
      T3 := maps2maps(T', SM, VM) .
  ceq maps2maps('sort_->_.[T, T'], SM, VM) = 'sort_to_.[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .
  ceq maps2maps('hsort_->_.[T, T'], SM, VM) = 'sort_to_.[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .

***(%
\end{verbatim}
}

However, mapping operators might require a more complex translation, because
they can include mappings to terms. We check whether the lefthand side contains
variables. If it does not contain, then it is translated as an operator mapping;
otherwise, it is mapped to a term:

{\codesize
\begin{verbatim}
%)

  ceq maps2maps('op_->_.['CafeBubble[T], 'CafeBubble[T']], SM, VM) =
                        if T == T''
                        then 'op_to_.['token[T], 'token[T3]]
                        else 'op_to`term_.['bubble[T''], 'bubble[T3]]
                        fi
   if T'' := updateTermLHS(T, SM, VM) /\
      T3 := updateTermRHS(T', SM, VM) .

***(%
\end{verbatim}
}

Finally, behavioral operators are transformed into standard operators:

{\codesize
\begin{verbatim}
%)

  ceq maps2maps('bop_->_.['CafeBubble[T], 'CafeBubble[T']], SM, VM) =
                                      'op_to_.['bubble[T''], 'bubble[T3]]
   if T'' := updateTermLHS(T, SM, VM) /\
      T3 := updateTermRHS(T', SM, VM) .
  eq maps2maps(T, SM, VM) = T [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"updateTermLHS" traverses the constants in the term and,
if we find a variable previously defined, its sort is attached:

{\codesize
\begin{verbatim}
%)

  op updateTermLHS : Term SortMap SortMap -> Term .
  eq updateTermLHS(Q[TL], SM, VM) = Q[updateTermLHS*(TL, SM, VM)] .
  eq updateTermLHS(V, SM, VM) = V .
  ceq updateTermLHS(C, SM, VM) = upTerm(Q')
   if Q := downQid(C) /\
      VM[Q] =/= undefined /\
      Q' := qid(string(Q) + ":" + string(VM[Q])) .
  eq updateTermLHS(T, SM, VM) = T [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"updateTermRHS" also attaches the sort of the variables,
but it takes into account that \emph{the names of the sorts might have changed
due to the mappings}. Hence, it looks for the sort name in the sort mapping and
replaces it if required:

{\codesize
\begin{verbatim}
%)

  op updateTermRHS : Term SortMap SortMap -> Term .
  eq updateTermRHS(Q[TL], SM, VM) = Q[updateTermRHS*(TL, SM, VM)] .
  eq updateTermRHS(V, SM, VM) = V .
  ceq updateTermRHS(C, SM, VM) = upTerm(Q')
   if Q := downQid(C) /\
      VM[Q] =/= undefined /\
      SM[VM[Q]] == undefined /\
      Q' := qid(string(Q) + ":" + string(VM[Q])) .
  ceq updateTermRHS(C, SM, VM) = upTerm(Q')
   if Q := downQid(C) /\
      VM[Q] =/= undefined /\
      SM[VM[Q]] =/= undefined /\
      Q' := qid(string(Q) + ":" + string(SM[VM[Q]])) .
  eq updateTermRHS(T, SM, VM) = T [owise] .

***(%
\end{verbatim}
}

\item
The functions \verb"updateTermLHS*" and \verb"updateTermRHS*" just traverse
the list, applying the appropriate function to each element:

{\codesize
\begin{verbatim}
%)

  ops updateTermLHS* : TermList SortMap SortMap -> TermList .
  eq updateTermLHS*(empty, SM, VM) = empty .
  eq updateTermLHS*((T, TL), SM, VM) = updateTermLHS(T, SM, VM),
                                       updateTermLHS*(TL, SM, VM) .

  op updateTermRHS* : TermList SortMap SortMap -> TermList .
  eq updateTermRHS*(empty, SM, VM) = empty .
  eq updateTermRHS*((T, TL), SM, VM) = updateTermRHS(T, SM, VM),
                                       updateTermRHS*(TL, SM, VM) .

***(%
\end{verbatim}
}

\item
The function \verb"removeVarDecls" removes the variable declarations
from the term, by first removing them and then creating a new term with
the rest of the declarations:

{\codesize
\begin{verbatim}
%)

  op removeVarDecls : Term -> Term .
  eq removeVarDecls(T) = buildNotVarDecl(getNotVarDecl(T)) .

***(%
\end{verbatim}
}

\item
The function \verb"getNotVarDecl" checks that the operator at the top
is not a variable declaration:

{\codesize
\begin{verbatim}
%)

  op getNotVarDecl : Term -> TermList .
  ceq getNotVarDecl('__[Q[TL], Q'[TL']]) = T, T'
   if Q =/= 'vvar_:_. /\
      Q =/= 'vvars_:_. /\
      Q' =/= 'vvar_:_. /\
      Q' =/= 'vvars_:_. /\
      T := getNotVarDecl(Q[TL]) /\
      T' := getNotVarDecl(Q'[TL']) .
  ceq getNotVarDecl('__[Q[TL], Q'[TL']]) = T
   if Q == 'vvar_:_. or-else Q == 'vvars_:_. /\
      Q' =/= 'vvarrs_:_. /\
      Q' =/= 'vvars_:_. /\
      T := getNotVarDecl(Q'[TL']) .
  ceq getNotVarDecl('__[Q[TL], Q'[TL']]) = T
   if Q =/= 'vvarrs_:_. /\
      Q =/= 'vvars_:_. /\
      Q' == 'vvar_:_. or-else Q' == 'vvars_:_. /\
      T := getNotVarDecl(Q[TL]) .
  eq getNotVarDecl(T) = T [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"buildNotVarDecl" distinguishes whether the argument is
a singleton list or not, in order to use the \verb"__" operator:

{\codesize
\begin{verbatim}
%)

  op buildNotVarDecl : TermList ~> Term .
  eq buildNotVarDecl(T) = T .
  ceq buildNotVarDecl((T, TL)) = '__[T, buildNotVarDecl(TL)]
   if TL =/= empty .

***(%
\end{verbatim}
}

\item
The function \verb"sortViewId" is in charge of sorting the parameters, so they
do not rely on the naming features of CafeOBJ. If only one parameter is used or
the term does not use syntactic sugar, then it is kept the same way. Otherwise
an alternative function is used:

{\codesize
\begin{verbatim}
%)

  op sortViewId : ParameterDeclList Term -> Term .
  ceq sortViewId(PDL, Q[T, TL]) = Q[T, TL]
   if Q =/= '_`,_ or-else not usesSugar(T) .
  eq sortViewId(PDL, Q[TL]) = sortViewIdAux(PDL, TL) .

***(%
\end{verbatim}
}

\noindent
where \verb"sortViewIdAux" looks for the appropriate view identifiers by traversing the
list of parameters:

{\codesize
\begin{verbatim}
%)

  op sortViewIdAux : ParameterDeclList TermList -> TermList .
  eq sortViewIdAux(nil, TL) = empty .
  ceq sortViewIdAux((Q :: ME, PDL), TL) = find(Q, TL), sortViewIdAux(PDL, TL)
   if PDL == nil .
  eq sortViewIdAux((Q :: ME, PDL), TL) = '_`,_[find(Q, TL),
                                         sortViewIdAux(PDL, TL)] [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"getPDL" extracts the parameter list from a module:

{\codesize
\begin{verbatim}
%)

  op getPDL : Module ~> ParameterDeclList .
  eq getPDL(fmod Q{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm) = PDL .
  eq getPDL(mod Q{PDL} is IL sorts SS . SSDS OPDS MAS EqS RIS endm) = PDL .

***(%
\end{verbatim}
}

\item
\verb"getNewName" checks in the database whether there already
exists a view with name created by \verb"createViewName". If true, then we try with
the next natural number, otherwise this name is used:

{\codesize
\begin{verbatim}
%)

  op getNewName : Database Nat -> Qid .
  ceq getNewName(DB, N) = if getView(Q, DB) :: View
                          then getNewName(DB, s(N))
                          else Q
                          fi
   if Q := createViewName(N) .

***(%
\end{verbatim}
}

\noindent
where \verb"createViewName" just creates a new name starting by
\texttt{OTF-VIEW}~\cite{cafeOBJ2maudeUG}, which stands for ``on the fly view'',
and followed by a natural number:

{\codesize
\begin{verbatim}
%)

  op createViewName : Nat -> Qid .
  eq createViewName(N) = qid("OTF-VIEW" + string(N, 10)) .

***(%
\end{verbatim}
}

\item
The function \verb"find" looks for the given quoted identifier, standing for a
parameter, inside a list of terms:

{\codesize
\begin{verbatim}
%)

  op find : Qid TermList -> Term .
  eq find(Q, ('_`,_[T, T'], TL)) = find(Q, (T, T', TL)) .
  eq find(Q, ('_<=_['token[T], T'], TL)) = if Q == downQid(T)
                                           then T'
                                           else find(Q, TL)
                                           fi .

***(%
\end{verbatim}
}

\item
Finally, \verb"usesSugar" checks whether the notation \verb"_<=_", used to state
the name of the parameter corresponding to the view identifier, is being used:

{\codesize
\begin{verbatim}
%)

  op usesSugar : Term -> Bool .
  eq usesSugar('_<=_[TL]) = true .
  eq usesSugar(T) = false [owise] .

***(%
\end{verbatim}
}

\end{itemize}

The parsing process continues by parsing sorts. Hidden sorts are translated
as standard Maude sorts:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('*`[_`]*['CafeToken[T]], PU, U, VDS, DB) = < PDR, nil, DB >
   if PDR := parseDecl('sort_.['sortToken[T]], PU, U, VDS) .

***(%
\end{verbatim}
}

We distinguish the operator at the top when dealing with sort declarations.
\begin{itemize}
\item
When only one sort is declared it is parsed and added to the temporal
modules with the Full Maude function \verb"parseDecl":

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('`[_`]['CafeToken[T]], PU, U, VDS, DB) = < PDR, nil, DB >
   if T' := addSortToken('CafeToken[T]) /\
      PDR := parseDecl('sorts_.[T'], PU, U, VDS) .

***(%
\end{verbatim}
}

\item
When we have a list of sorts without subsort declaration they are just parsed
and added to the current module:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('`[_`]['__[T, T']], PU, U, VDS, DB) = < PDR, nil, DB >
   if T'' := addSortToken(T) /\
      T''' := addSortToken(T') /\
      PDR := parseDecl('sorts_.['__[T'', T''']], PU, U, VDS) .

***(%
\end{verbatim}
}

\item
Finally, when we find a subsort relation both terms, the sorts are add to the
sort and the subsort relation (which might be multiple) is added to the module
thus obtained:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('`[_`]['_<_[T, T']], PU, U, VDS, DB) = < PDR, nil, DB >
   if T'' := addSortToken(T) /\
      T''' := addSortToken(T') /\
      TS := sub2sort('_<_[T, T']) /\
      < PU' ; U' ;  VDS' > := parseDecl('sorts_.[TS], PU, U, VDS) /\
      PDR := parseDecl('subsorts_.['_<_[T'', T''']], PU', U', VDS') .

***(%
\end{verbatim}
}

\end{itemize}

The auxiliary functions used for parsing sorts are:
\begin{itemize}
\item
\verb"addSortToken", which transforms CafeOBJ tokens into Maude tokens for sorts:

{\codesize
\begin{verbatim}
%)

  op addSortToken : Term -> Term .
  eq addSortToken('__[T, T']) = ('__[addSortToken(T), addSortToken(T')]) .
  eq addSortToken('_<_[T, T']) = ('_<_[addSortToken(T), addSortToken(T')]) .
  eq addSortToken('CafeToken[T]) = ('sortToken[T]) .

***(%
\end{verbatim}
}

\item
\verb"sub2sort", which flattens a subsort relation to add all the sorts to
the current module:

{\codesize
\begin{verbatim}
%)

  op sub2sort : Term -> Term .
  eq sub2sort('_<_[T, T']) = combine2sort(sub2sort(T), sub2sort(T')) .
  eq sub2sort('__['CafeToken[T], T']) = ('__['sortToken[T], sub2sort(T')]) .
  eq sub2sort('CafeToken[T]) = ('sortToken[T]) .

***(%
\end{verbatim}
}

\item
\verb"combine2sort", which puts together two terms:

{\codesize
\begin{verbatim}
%)

  op combine2sort : Term Term -> Term .
  eq combine2sort('sortToken[T], T') = '__['sortToken[T], T'] .
  eq combine2sort('__[T, T''], T''') = combine2sort(T'', '__[T, T''']) .

***(%
\end{verbatim}
}

\end{itemize}

We show now how to parse operator declarations. For the declaration of a single operator
with attributes we transform the list of sorts in the arity with \verb"addSortToken",
and then add the operator declaration with \verb"parseDecl":

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('op_:_->_`{_`}.['CafeToken[T], T', 'CafeToken[T''], T'''],  PU, U,
                    VDS, DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[T], T4, 'sortToken[T''],
                       map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('op_:_->_`{_`}.['__[TL], T', 'CafeToken[T''], T'''],  PU, U, VDS,
                    DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[upTerm(tokenList2token(TL))], T4,
                       'sortToken[T''], map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('op_:_->_.['CafeToken[T], T', 'CafeToken[T'']],  PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_.['token[T], T4, cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('op_:_->_.['__[TL], T', 'CafeToken[T'']],  PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_.['token[upTerm(tokenList2token(TL))], T4,
                                                cafeType2maudeType(T'')], PU, U, VDS) .

***(%
\end{comment}
}

The declaration of constants simplifies the task, since the arity does not appear:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('op_:`->_`{_`}.['CafeToken[T], 'CafeToken[T''], T'''],  PU, U, VDS,
                    DB) = < PDR, nil, DB >
   if PDR := parseDecl('op_:`->_`[_`].['token[T], cafeType2maudeType(T''),
                                       map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('op_:`->_.['CafeToken[T], 'CafeToken[T'']],  PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if PDR := parseDecl('op_:`->_.['token[T], cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('ops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''], PU,
                    U, VDS, DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_`[_`].['neTokenList[T], T4, cafeType2maudeType(T''),
                                        map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{comment}
}

Multiple operators with the same arity and coarity are just transformed into a nonempty
list of Maude tokens, and then introduced into the current module:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('ops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], PU, U, VDS,
                    DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_.['neTokenList[T], T4, cafeType2maudeType(T'')],
                       PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('ops_:`->_`{_`}.['neCafeTokenList[T], 'CafeToken[T''], T'''],  PU, U,
                    VDS, DB) = < PDR, nil, DB >
   if PDR := parseDecl('ops_:`->_`[_`].['neTokenList[T], cafeType2maudeType(T''),
                                        map2MaudeAttr(T''')], PU, U, VDS) .

  ceq parseCafeDecl('ops_:`->_.['neCafeTokenList[T], 'CafeToken[T'']], PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if PDR := parseDecl('ops_:`->_.['neTokenList[T], cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('bop_:_->_.['CafeToken[T], T', 'CafeToken[T'']],  PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_.['token[T], T4, cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('bop_:_->_`{_`}.['CafeToken[T], T', 'CafeToken[T''], T'''], PU, U,
                    VDS, DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[T], T4, cafeType2maudeType(T''),
                                       map2MaudeAttr(T''')], PU, U, VDS) .

  ceq parseCafeDecl('bops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], PU, U, VDS,
                    DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_.['neTokenList[T], T4, cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('ops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''], PU,
                    U, VDS, DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_`[_`].['neTokenList[T], T4, cafeType2maudeType(T''),
                                        map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{comment}
}

Predicates are parsed in a similar way, since they are transformed into operators
with coarity \verb"Bool", which must be meta-represented as a token:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('pred_:_`{_`}.['CafeToken[T], T', T'''],  PU, U, VDS, DB) =
                                                                  < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[T], T4, 'sortToken[''Bool.Qid],
                       map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('pred_:_.['CafeToken[T], T'],  PU, U, VDS, DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_.['token[T], T4, 'sortToken[''Bool.Qid]], PU, U, VDS) .

***(%
\end{comment}
}

The auxiliary functions used here are:
\begin{itemize}

\item
The function \verb"tokenList2token" transforms operator defintions of the
form \verb"_ _", which are not allowed by Maude, into the equivalent \verb"__"
operator:

{\codesize
\begin{verbatim}
%)

  op tokenList2token : TermList -> Qid .
  op tokenList2token : TermList String -> Qid .

  eq tokenList2token(TL) = tokenList2token(TL, "") .
  eq tokenList2token(('CafeToken[T], TL), St) =
                       tokenList2token(TL, St + string(downQid(T))) .
  eq tokenList2token(empty, St) = qid(St) .

***(%
\end{verbatim}
}

\item
The function \verb"map2MaudeAttr" translates a list of terms written using CafeOBJ
syntax into the same list using Maude syntax. The first equation deals with the
yuxtaposition operator at the top:

{\codesize
\begin{verbatim}
%)

  op map2MaudeAttr : TermList -> TermList .
  eq map2MaudeAttr('__[TL]) = '__[map2MaudeAttr(TL)] .

***(%
\end{verbatim}
}

While the rest of equations just translates the attribute and continue with the rest
of the list, until the empty list is reached:

{\codesize
\begin{verbatim}
%)

  eq map2MaudeAttr(('constr.@CafeAttr@, TL)) = 'ctor.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('associative.@CafeAttr@, TL)) = 'assoc.@Attr@,
                                                    map2MaudeAttr(TL) .
  eq map2MaudeAttr(('assoc.@CafeAttr@, TL)) = 'assoc.@Attr@, map2MaudeAttr(TL) .

***(%
  ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  eq map2MaudeAttr(('l-assoc.@CafeAttr@, TL)) =
               'gather`(_`)['neTokenList['__[''E.Sort,''e.Sort]]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('r-assoc.@CafeAttr@, TL)) =
               'gather`(_`)['neTokenList['__[''e.Sort,''E.Sort]]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('commutative.@CafeAttr@, TL)) = 'comm.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('comm.@CafeAttr@, TL)) = 'comm.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('idempotent.@CafeAttr@, TL)) = 'idem.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('idem.@CafeAttr@, TL)) = 'idem.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('nonexec.@CafeAttr@, TL)) = 'nonexec.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('id:`(_`)['CafeBubble[T]], TL)) = 'id:_['bubble[T]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('idr:`(_`)['CafeBubble[T]], TL)) = 'id:_['bubble[T]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('prec:_['CafeToken[T]], TL)) = 'prec_['token[T]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('strat:_['neCafeTokenList[T]], TL)) = 'strat_['NeTokenList[T]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('metadata['CafeToken[T]], TL)) = 'metadata_['token[T]], map2MaudeAttr(TL) .

***(%
\end{comment}
}

{\codesize
\begin{verbatim}
%)

  eq map2MaudeAttr(empty) = empty .

***(%
\end{verbatim}
}

\item
The function \verb"cafeType2maudeType" transforms CafeOBJ error types into
Maude kinds:

{\codesize
\begin{verbatim}
%)

  op cafeType2maudeType : Term -> Term .
  eq cafeType2maudeType('__[TL]) = '__[cafeTypes2maudeTypes(TL)] .
  ceq cafeType2maudeType(T) = '`[_`]['sortToken[upTerm(Q')]]
   if Q := downQid(T) /\
      St := string(Q) /\
      0 == find(St, "?", 0) /\
      St' := substr(St, 1, length(St)) /\
      Q' := qid(St') .
  eq cafeType2maudeType(T) = 'sortToken[T] [owise] .

***(%
\end{verbatim}
}

\noindent
where the function \verb"cafeTypes2maudeTypes" just traverses the list
of terms, applying the function \texttt{cafeType2maudeType} to each term:

{\codesize
\begin{verbatim}
%)

  op cafeTypes2maudeTypes : TermList -> TermList .
  eq cafeTypes2maudeTypes(empty) = empty .
  eq cafeTypes2maudeTypes((T, TL)) = cafeType2maudeType(T),
                                     cafeTypes2maudeTypes(TL) .

***(%
\end{verbatim}
}

\end{itemize}

{\codesize
\begin{comment}
%)

  op parseHiddenSort : Term ~> Sort .
  eq parseHiddenSort('CafeToken[T]) =
     if downQid(T) :: Type
     then downQid(T)
     else qidError('\y 'Warning: '\o downQid(T) 'is 'not 'a 'valid 'sort. '\n)
     fi .
  eq parseHiddenSort(T) = qidError('\y 'Warning: '\o 'invalid 'sort. '\n) [owise] .

***(%
\end{comment}
}

Variables declared with the keyword \verb"var" are just translated as \verb"vars"
declarations.

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('var_:_.['neCafeTokenList[T], T'], PU, U, VDS, DB) =
                                                          < PDR, QIL, DB' >
   if < PDR, QIL, DB' > := parseCafeDecl('vars_:_.['neCafeTokenList[T], T'],
                                         PU, U, VDS, DB) .

***(%
\end{verbatim}
}

Otherwise, variables are parsed by adding them, with their sort, to the set of operators
used to parse terms in the current module:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('vars_:_.['neCafeTokenList[T], 'CafeToken[T']], PU, U, VDS, DB) =
                                                                     < PDR, nil, DB >
   if PDR := < PU ; U ; VDS parseVars(downQidList(T), parseType('sortToken[T'])) > .

***(%
\end{verbatim}
}

Equations and transitions are parsed in a similar way, so we do not show all
the variations. An unconditional equation is parsed by adding the on-the-fly
variables in the righthand side to the set of current variables, and transforming
the attributes and then using \verb"parseDecl":

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('eq_=_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, DB) =
                                              < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T'' := cafeEqAtS2maudeEqAts(T') /\
      PDR := parseDecl('eq_=_.['bubble[T], 'bubble[T'']], PU, U, VDS') .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('beq_=_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, DB) =
                                              < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T'' := cafeEqAtS2maudeEqAts(T') /\
      PDR := parseDecl('eq_=_.['bubble[T], 'bubble[T'']], PU, U, VDS') .

***(%
\end{comment}
}

Conditional equations are parsed in the same way, since the condition is dealt inside
the \verb"parseDecl" function:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('ceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('ceq_=_if_.['bubble[T], 'bubble[T'], 'bubble[T''']],
                       PU, U, VDS') .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('cq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], PU, U,
                    VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('ceq_=_if_.['bubble[T], 'bubble[T'], 'bubble[T''']], PU, U, VDS') .

  ceq parseCafeDecl('bceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], PU, U,
                    VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('ceq_=_if_.['bubble[T], 'bubble[T'], 'bubble[T''']], PU, U, VDS') .

  ceq parseCafeDecl('bcq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], PU, U,
                    VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('ceq_=_if_.['bubble[T], 'bubble[T'], 'bubble[T''']], PU, U, VDS') .

***(%
\end{comment}
}

Transitions follow the same approach, although in this case the statement parsed
by \verb"parseDecl" is a Maude rule:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('trans_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U,
                    VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T'' := cafeEqAtS2maudeEqAts(T') /\
      PDR := parseDecl('rl_=>_.['bubble[T], 'bubble[T'']], PU, U, VDS') .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('trns_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T'' := cafeEqAtS2maudeEqAts(T') /\
      PDR := parseDecl('rl_=>_.['bubble[T], 'bubble[T'']], PU, U, VDS') .

  ceq parseCafeDecl('ctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('crl_=>_if_.['bubble[T], 'bubble[T'], 'bubble[T''']], PU, U, VDS') .

  ceq parseCafeDecl('ctrns_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('crl_=>_if_.['bubble[T], 'bubble[T'], 'bubble[T''']], PU, U, VDS') .

  ceq parseCafeDecl('btrans_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T'' := cafeEqAtS2maudeEqAts(T') /\
      PDR := parseDecl('rl_=>_.['bubble[T], 'bubble[T'']], PU, U, VDS') .

  ceq parseCafeDecl('btrns_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T'' := cafeEqAtS2maudeEqAts(T') /\
      PDR := parseDecl('rl_=>_.['bubble[T], 'bubble[T'']], PU, U, VDS') .

  ceq parseCafeDecl('bctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('crl_=>_if_.['bubble[T], 'bubble[T'], 'bubble[T''']], PU, U, VDS') .

  ceq parseCafeDecl('bctrns_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('crl_=>_if_.['bubble[T], 'bubble[T'], 'bubble[T''']], PU, U, VDS') .

***(%
\end{comment}
}

The auxiliary functions for parsing equations and transitions are:

\begin{itemize}
\item
\verb"cafeEqAtS2maudeEqAts", which just applies \texttt{cafeEqAtS2maudeEqAts*}
if it finds any attribute:

{\codesize
\begin{verbatim}
%)

  op cafeEqAtS2maudeEqAts : Term -> Term .
  eq cafeEqAtS2maudeEqAts('__[TL]) = '__[cafeEqAtS2maudeEqAts*(TL)] .
  eq cafeEqAtS2maudeEqAts(T) = T [owise] .

***(%
\end{verbatim}
}

\noindent
where \texttt{cafeEqAtS2maudeEqAts} traverses the list and transforms
the possible attributes appearing in equations and transitions:

{\codesize
\begin{verbatim}
%)

  op cafeEqAtS2maudeEqAts* : TermList -> TermList .
  eq cafeEqAtS2maudeEqAts*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) =
                      TL, ''`[.Qid, ''nonexec.Qid, TL'', ''`].Qid .
  eq cafeEqAtS2maudeEqAts*((TL, ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid)) =
                      TL, ''`[.Qid, ''metadata.Qid, TL'', ''`].Qid .
  eq cafeEqAtS2maudeEqAts*(TL) = TL [owise] .

***(%
\end{verbatim}
}

\item
\verb"opDeclSetFromQidList", which extracts an \verb"OpDeclSet" from a list of quoted
identifiers to extend the variable set with the variables defined on the fly in CafeOBJ:

{\codesize
\begin{verbatim}
%)

  op opDeclSetFromQidList : QidList -> OpDeclSet .
  eq opDeclSetFromQidList(nil) = none .
  ceq opDeclSetFromQidList(Q QL) = op qid(St') : nil -> qid(St'') [none] .
                                   opDeclSetFromQidList(QL)
   if Q =/= ': /\
      St := string(Q) /\
      N := find(St, ":", 0) /\
      St' := substr(St, 0, N) /\
      St'' := substr(St, s(N), length(St)) .
  eq opDeclSetFromQidList(Q QL) = opDeclSetFromQidList(QL) [owise] .

***(%
\end{verbatim}
}

\end{itemize}

% The reduction commands are just skipped when parsing a module. We will deal with them
% separately in the open-close environment:

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('reduce_.[T], PU, U, VDS, DB) = < PDR, nil, DB >
   if PDR := < PU ; U ; VDS > .

  ceq parseCafeDecl('red_.[T], PU, U, VDS, DB) = < PDR, nil, DB >
   if PDR := < PU ; U ; VDS > .

***(%
\end{comment}
}

{\codesize
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
}

The module \verb"CafePARSER" is in charge of parsing complete modules and views:

{\codesize
\begin{verbatim}
%)

mod CafePARSER is
  inc CafeDECL-PARSING .
  pr DATABASE-HANDLING .

***(%
\end{verbatim}
}

It builds a new term of sort \verb"CafeParseResult" returning the updated database and
a list of quoted identifiers reporting the errors found during the parsing process:

{\codesize
\begin{verbatim}
%)

  op <_,_> : Database QidList -> CafeParseResult [ctor] .

***(%
\end{verbatim}
}

% We also define other constructor for \verb"CafeParseResult", that will be
% used in open-close environments. Since these environments do not change the
% database, it is composed of a list of quoted identifiers pointing out the
% errors found during the parsing, and another list showing the results of the
% reduction commands:

{\codesize
\begin{comment}
%)

  op <_|_|_> : Database QidList QidList -> CafeParseResult [ctor] .

***(%
\end{comment}
}

{\codesize
\begin{comment}
%)

  vars T T' T'' T1 T2 T3 T4 : Term .
  vars TL PL PL' : TermList .
  var  V : Variable .
  var  C : Constant .
  vars DB DB' : Database .
  vars F Q Q' QI QI' : Qid .
  vars QIL QIL' : QidList .
  vars S S' S'' S''' St St' St'' St''' : String .
  var  VDS : OpDeclSet .
  vars PDR PDR' : ParseDeclResult .
  vars PU PU' U U' M : Module .
  var  Ty : Type .
  vars N N' : Nat .

***(%
\end{comment}
}

The constants \verb"errModName" and \texttt{paramThWarn} will report specific
errors:

{\codesize
\begin{verbatim}
%)

  op errModName : -> QidList .
  eq errModName = '\n '\r 'ERROR: '\o 'The 'module 'name 'is 'not 'a
                  'valid 'identifier. .

  op paramThWarn : -> QidList .
  eq paramThWarn = '\n '\r 'Warning: '\o 'Parameterized 'theories 'are 'not 'allowed
                   'in 'Maude. '\n 'The 'module 'was 'introduced 'with '\g 'tight '\o
                   'semantics. '\n .

***(%
\end{verbatim}
}

The function in charge of parsing modules is \verb"procCafeMod". It receives as
arguments the term to be parsed and the current Full Maude database. It just duplicates
the term to be parsed and calls to \verb"procCafeMod2":

{\codesize
\begin{verbatim}
%)

  op procCafeMod : Term Database -> CafeParseResult .
  eq procCafeMod(T, DB) = procCafeMod2(T, T, DB) .

***(%
\end{verbatim}
}

The function \verb"procCafeMod2" distinguishes between modules with loose and
tight semantics. Modules with tight semantics, will be translated as Maude modules,
and hence we just use the function \verb"procCafeMod3", propagating the parameters
if required. Note that we use an empty module, \verb"emptyFModule", indicating that
it has tight semantics:

{\codesize
\begin{verbatim}
%)

  op procCafeMod2 : Term Term Database -> CafeParseResult .
  eq procCafeMod2(T, 'cmod!_`{_`}['CafeToken[T'], T''], DB) =
                      procCafeMod3(T, 'CafeToken[T'], empty, T'',
                                   emptyFModule, DB) .
  eq procCafeMod2(T, 'cmod!_`{_`}['_`(_`)[T', T''], T3], DB) =
                      procCafeMod3(T, T', T'', T3, emptyFModule, DB) .

***(%
\end{verbatim}
}

When parsing modules with loose semantics first introduce them as a theory but,
in order to accept a wider range of CafeOBJ modules, we also introduce it into the
database as a module, adding the suffix \verb"-MODCAFE" to its name.
Note that we do not allow parameterized theories, so we use the \verb"paramThWarn"
message when they are used.
%
Also note that we use an empty module or thery depending of the semantics we
want to use:

{\codesize
\begin{verbatim}
%)

  ceq procCafeMod2(T, 'cmod*_`{_`}['CafeToken[T'], T''], DB) =
        if QIL == nil
        then procCafeMod3(T, T3, empty, T'', emptyFModule, DB')
        else < DB', QIL >
        fi
   if < DB', QIL > := procCafeMod3(T, 'CafeToken[T'], empty, T'',
                                   emptyFTheory, DB) /\
      QI := downQid(T') /\
      QI' := qid(string(QI) + "-MODCAFE") /\
      T3 := 'CafeToken[upTerm(QI')] .
  ceq procCafeMod2(T, 'cmod*_`{_`}['_`(_`)['CafeToken[T'], T''], T3], DB) =
        if QIL == nil
        then < DB', paramThWarn >
        else < DB', QIL >
        fi
   if < DB', QIL > := procCafeMod3(T, 'CafeToken[T'], T'', T3, emptyFModule, DB) .

***(%
\end{verbatim}
}

In other case an error is returned:

{\codesize
\begin{verbatim}
%)

  eq procCafeMod2(T, Q[T', T''], DB) = < DB, errModName > [owise] .

***(%
\end{verbatim}
}

The function \verb"procCafeMod3" deals with parameterized modules. If the current
modules is not parameterized we just set the name of the module and apply the
\texttt{procCafeMod4} function:

{\codesize
\begin{verbatim}
%)

  op procCafeMod3 : Term Term Term Term Module Database -> CafeParseResult .
  ceq procCafeMod3(T, 'CafeToken[T'], empty, T'', U, DB) =
         procCafeMod4(T, T'', setName(U, QI), setName(U, QI), none, DB)
   if QI := downQid(T') .

***(%
\end{verbatim}
}

When the module is parameterized we set the name of the module and then parse
the parameters to introduce them into the current module.
We use the \texttt{parseParList} function from Full Maude, which returns a
parameter list from a term.

{\codesize
\begin{verbatim}
%)

  ceq procCafeMod3(T, 'CafeToken[T'], PL, T'', U, DB) =
         procCafeMod4(T, T3, setPars(setName(U, QI), parseParList(PL')),
                      setName(U, QI), none, DB)
   if PL =/= empty /\
      PL' := cafeParam2maudeParam(PL) /\
      QI := downQid(T') /\
      QIL := cafeParamNames(PL) /\
      T3 := paramSortsMap(T'', QIL) .

***(%
\end{verbatim}
}

In other case an error is returned:

{\codesize
\begin{verbatim}
%)

  eq procCafeMod3(T, T', PL, T'', U, DB) = < DB, errModName > [owise] .

***(%
\end{verbatim}
}

The auxiliary functions required to deal with parameters are:
\begin{itemize}
\item
\verb"cafeParam2maudeParam", which translates the parameter declaration to Maude syntax:

{\codesize
\begin{verbatim}
%)

  op cafeParam2maudeParam : Term -> Term .
  eq cafeParam2maudeParam('_::_['CafeToken[T], T']) = '_::_['token[T], T'] .
  ceq cafeParam2maudeParam('_`,_[T, T']) = '_`,_[T'', T3]
   if T'' := cafeParam2maudeParam(T) /\
      T3 := cafeParam2maudeParam(T') .

***(%
\end{verbatim}
}

\item
\verb"cafeParamNames", which extracts the name of the parameters:

{\codesize
\begin{verbatim}
%)

  op cafeParamNames : Term -> QidList .
  eq cafeParamNames('_::_['CafeToken[T], T']) = downQid(T) .
  ceq cafeParamNames('_`,_[T, T']) = QIL QIL'
   if QIL := cafeParamNames(T) /\
      QIL' := cafeParamNames(T') .

***(%
\end{verbatim}
}

\item
\verb"paramSortsMap", which transforms the qualified sorts in CafeOBJ syntax into
qualified sorts in Maude syntax. It renames constants (which includes the
metarepresentation of variables) by using the names of the parameters obtained with
\texttt{cafeParamNames}. If the function is a composed term, it applies
\texttt{paramSortsMap*}:

{\codesize
\begin{verbatim}
%)

  op paramSortsMap : Term QidList -> Term .
  eq paramSortsMap(Q[TL], QIL) = Q[paramSortsMap*(TL, QIL)] .

***(%
\end{verbatim}
}

Variables are not modified:

{\codesize
\begin{verbatim}
%)

  eq paramSortsMap(V, QIL) = V .

***(%
\end{verbatim}
}

For constants, we distinguish whether they stand for a constant (including sorts)
or for a variable. When they stand for a constant, (i.e., the String \verb@":"@ cannot
be found) we split the term looking for the \verb@"."@ String, which is used in CafeOBJ
to qualify sorts, and built it again by using the \verb@"$"@ used by Maude:

{\codesize
\begin{verbatim}
%)

  ceq paramSortsMap(C, QIL) = upTerm(QI)
   if Q := downQid(C) /\
      St := string(Q) /\
      find(St, ":", 0) == notFound /\
      N := find(St, ".", 0) /\
      St' := substr(St, 0, N) /\
      St'' := substr(St, N + 1, length(St)) /\
      Q' := qid(St'') /\
      Q' in QIL /\
      QI := qid(St'' + "$" + St') .

***(%
\end{verbatim}
}

When the constant stands for a variable, we proceed in a similar way but taking into
account that the name of the variable must be placed first in both cases:

{\codesize
\begin{verbatim}
%)

  ceq paramSortsMap(C, QIL) = upTerm(QI)
   if Q := downQid(C) /\
      St := string(Q) /\
      N := find(St, ":", 0) /\
      N' := find(St, ".", 0) /\
      St' := substr(St, 0, N + 1) /\
      St'' := substr(St, N + 1, _-_(N', N + 1)) /\
      St''' := substr(St, N' + 1, length(St)) /\
      Q' := qid(St''') /\
      Q' in QIL /\
      QI := qid(St' + St''' + "$" + St'') .

***(%
\end{verbatim}
}

In other case, the constant is not modified:

{\codesize
\begin{verbatim}
%)

  eq paramSortsMap(C, QIL) = C [owise] .

***(%
\end{verbatim}
}

\item
\verb"paramSortsMap*", which just traverses the list, applying
\texttt{paramSortsMap} to each element:

{\codesize
\begin{verbatim}
%)

  op paramSortsMap* : TermList QidList -> TermList .
  eq paramSortsMap*(empty, QIL) = empty .
  eq paramSortsMap*((T, TL), QIL) = paramSortsMap(T, QIL), paramSortsMap*(TL, QIL) .

***(%
\end{verbatim}
}

\item
\verb"_in_", which looks for a quoted identifier in a list:

{\codesize
\begin{verbatim}
%)

  op _in_ : Qid QidList -> Bool .
  eq Q in nil = false .
  eq Q in Q QIL = true .
  eq Q in QIL = false [owise] .

***(%
\end{verbatim}
}

\end{itemize}

The function \verb"procCafeMod4" traverses the module, applying the function
\verb"parseCafeDecl" shown above to each statement:

{\codesize
\begin{verbatim}
%)

  op procCafeMod4 : Term Term Module Module OpDeclSet Database
                    -> CafeParseResult .
  ceq procCafeMod4(T, '__[T', T''], PU, U, VDS, DB) =
        if QIL == nil
        then procCafeMod4(T, T'', preModule(PDR), unit(PDR), vars(PDR), DB')
        else < DB,  QIL >
        fi
   if < PDR, QIL, DB' > := parseCafeDecl(T', PU, U, VDS, DB) .

***(%
\end{verbatim}
}

When only one statement remains it is parsed and the module is evaluated by means
of the \verb"evalPreModule" function:

{\codesize
\begin{verbatim}
%)

  ceq procCafeMod4(T, F[TL], PU, U, VDS, DB) =
       if QIL == nil
       then < evalPreModule(preModule(PDR), unit(PDR), vars(PDR),
                            insTermModule(getName(U), T, DB')), nil >
       else < DB, QIL >
       fi
   if F =/= '__ /\
      < PDR, QIL, DB' > := parseCafeDecl(F[TL], PU, U, VDS, DB) .

***(%
\end{verbatim}
}

The function \verb"procCafeView" is in charge of processing views. It just
translates the view and introduces it into the database:

{\codesize
\begin{verbatim}
%)

  op procCafeView : Term Database -> CafeParseResult .
  ceq procCafeView(T, DB) = < DB', nil >
   if T' := view2view(T) /\
      DB' := procView(T', DB) .

***(%
\end{verbatim}
}

\noindent
where the auxiliary functions behave as follows:
\begin{itemize}
\item
\verb"view2view" translates the term to Maude syntax, and then applies
the \verb"maps2maps" function shown above to the body:

{\codesize
\begin{verbatim}
%)

  op view2view : Term -> Term .
  eq view2view('cview_from_to_`{_`}[T, T', T'', T3]) =
        'view_from_to_is_endv[token2token(T), T', T'', maps2maps(T3)] .

***(%
\end{verbatim}
}

\item
\verb"token2token" translates a CafeOBJ token into a Maude token:

{\codesize
\begin{verbatim}
%)

  op token2token : Term -> Term .
  eq token2token('CafeToken[T]) = 'token[T] .
  eq token2token(T) = T [owise] .

***(%
\end{verbatim}
}
\end{itemize}

{\codesize
\begin{comment}
%)

  op openCloseModNameUp : -> Constant .
  eq openCloseModNameUp = ''OPEN_CLOSE.Qid .

  op openCloseModName : -> Qid .
  eq openCloseModName = 'OPEN_CLOSE .

  op procOpenCloseEnv : Term Term Database -> CafeParseResult .
  ceq procOpenCloseEnv(T, T', DB) = < DB' | QIL | QIL' >
   if T1 := 'CafeToken[openCloseModNameUp] /\
      T2 := '__['inc`(_`)[T], T'] /\
      < DB', QIL > := procCafeMod('cmod!_`{_`}[T1, T2], DB) /\
      M := getFlatModule(openCloseModName, DB') /\
      TL := getRedCommands(T') /\
      QIL' := processRedCommands(M, DB', TL) .

  op getRedCommands : Term -> TermList .
  eq getRedCommands('__[T, T']) = getRedCommands(T), getRedCommands(T') .
  eq getRedCommands(T) = getRedCommand(T) [owise] .

  op getRedCommand : Term -> TermList .
  eq getRedCommand('reduce_.['CafeBubble[T]]) = 'red_.['bubble[T]] .
  eq getRedCommand('red_.['CafeBubble[T]]) = 'red_.['bubble[T]] .
  eq getRedCommand(T) = empty [owise] .

  op processRedCommands : Module Database TermList -> QidList .
  eq processRedCommands(M, DB, empty) = nil .
  ceq processRedCommands(M, DB, ('red_.['bubble[T]], TL)) = QIL
                                                   processRedCommands(M, DB, TL)
   if *** T' := solveBubbles(T, M, false, none, DB) /\
      T' := getTerm(metaParse(M, downQidList(T), anyType)) /\
      {T'', Ty} := metaReduce(M, T') /\
      QIL := printRedRes(M, T', T'', Ty) .

  op po : -> PrintOptionSet .
  eq po = mixfix number rat format .

  op printRedRes : Module Term Term Type -> QidList .
  eq printRedRes(M, T, T', Ty) = '\n 'reduce metaPrettyPrint(M, T, po) '. '\n
                                 '\g 'Result: '\o metaPrettyPrint(M, T', po) ': Ty
                                 '\n .

***(%
\end{comment}
}
{\codesize
\begin{verbatim}
%)

endm

***(%
\end{verbatim}
}

\subsection{Meta-level module generation\label{subsec:meta-gen}}

{\codesize
\begin{verbatim}
%)

mod MAUDE-AUXILIARY-FUNCTIONS is
 pr CAFE-META-LEVEL .

 vars S S' : Sort .
 var  MSSDS : SubsortDeclSet .

 op generateSubsorts : SubsortDeclSet -> CafeSubsortDeclSet .
 eq generateSubsorts(none) = none .
 eq generateSubsorts(subsort S < S' . MSSDS) = [S < S'] generateSubsorts(MSSDS) .
endm

mod META-GENERATION is
 pr CafePARSER .
 pr MAUDE-AUXILIARY-FUNCTIONS .

 vars M M' : Module .
 vars T T' T'' T''' T1 T2 TW TW' : Term .
 vars TL TL' TL'' : TermList .
 var  DB : Database .
 var  H : CafeHeader .
 vars CM CM' CM'' : CafeModule .
 var  RS RS' : CafeRenSet .
 var  I : CafeImport .
 vars ME ME' : CafeModExp .
 vars Q Q' Q'' : Qid .
 vars QS QS' : QidSet .
 vars QIL QIL' : QidList .
 vars PL PL' : ParameterList .
 var  PDL : ParameterDeclList .
 var  S : Sort .
 var  OD : CafeOpDecl .
 var  ODS : CafeOpDeclSet .
 vars AtS AtS' : CafeAttrSet .
 var  N : Nat .
 vars NL NL' : NeNatList .
 vars TyL TyL' : TypeList .
 var  Ty : Type .
 var  PD : CafePredDecl .
 vars MODS MODS' MODS'' : OpDeclSet .
 var  RP : ResultPair .
 var  Eq : CafeEq .
 vars St St' St'' : String .
 var  Tr : CafeTrans .

 sort CafeParsingPair .
 op [_,_] : CafeModule OpDeclSet -> CafeParsingPair [ctor] .

 op generateMetaModule : Term Module Module Database -> CafeModule .
 ceq generateMetaModule('cmod!_`{_`}[T, T'], M, M', DB) = CM''
  if H := generateHeader(T) /\
     CM := addSorts(emptyTightCafeModule(H), getSorts(M')) /\
     CM' := addSubsorts(CM, generateSubsorts(getSubsorts(M'))) /\
     CM'' := generateBody*(T', M, DB, CM', none) .

 op generateMetaModule : Term Module Module Database -> CafeModule .
 ceq generateMetaModule('cmod*_`{_`}[T, T'], M, M', DB) = CM''
  if H := generateHeader(T) /\
     CM := addSorts(emptyLooseCafeModule(H), getSorts(M')) /\
     CM' := addSubsorts(CM, generateSubsorts(getSubsorts(M'))) /\
     CM'' := generateBody*(T', M, DB, CM', none) .

 op generateHeader : Term -> CafeHeader .
 eq generateHeader('_`(_`)['CafeToken[T], T']) = downQid(T)(generateParams(T')) .
 eq generateHeader('CafeToken[T]) = downQid(T) .

 op generateParams : Term -> ParameterDecl .
 eq generateParams('_`,_[T, T']) = generateParams(T), generateParams(T') .
 eq generateParams('_::_['CafeToken[T], 'token[T']]) = downQid(T) :: downQid(T') .

 op generateBody* : Term Module Database CafeModule OpDeclSet -> CafeModule .
 ceq generateBody*('__[T, T'], M, DB, CM, MODS) = CM''
  if [CM', MODS'] := generateBody(T, M, DB, CM, MODS) /\
     CM'' := generateBody*(T', M, DB, CM', MODS') .
 ceq generateBody*(T, M, DB, CM, MODS) = CM'
  if [CM', MODS'] := generateBody(T, M, DB, CM, MODS) [owise] .

 op generateBody : Term Module Database CafeModule OpDeclSet -> CafeParsingPair .

 ceq generateBody('protecting`(_`)[T], M, DB, CM, MODS) = [addImports(CM, I), MODS]
  if ME := generateModuleExp(T, M, DB) /\
     I := pr(ME) .
 ceq generateBody('pr`(_`)[T], M, DB, CM, MODS) = [addImports(CM, I), MODS]
  if ME := generateModuleExp(T, M, DB) /\
     I := pr(ME) .
 ceq generateBody('extending`(_`)[T], M, DB, CM, MODS) = [addImports(CM, I), MODS]
  if ME := generateModuleExp(T, M, DB) /\
     I := ex(ME) .
 ceq generateBody('ex`(_`)[T], M, DB, CM, MODS) = [addImports(CM, I), MODS]
  if ME := generateModuleExp(T, M, DB) /\
     I := ex(ME) .
 ceq generateBody('including`(_`)[T], M, DB, CM, MODS) = [addImports(CM, I), MODS]
  if ME := generateModuleExp(T, M, DB) /\
     I := inc(ME) .
 ceq generateBody('inc`(_`)[T], M, DB, CM, MODS) = [addImports(CM, I), MODS]
  if ME := generateModuleExp(T, M, DB) /\
     I := inc(ME) .
 ceq generateBody('using`(_`)[T], M, DB, CM, MODS) = [addImports(CM, I), MODS]
  if ME := generateModuleExp(T, M, DB) /\
     I := us(ME) .
 ceq generateBody('us`(_`)[T], M, DB, CM, MODS) = [addImports(CM, I), MODS]
  if ME := generateModuleExp(T, M, DB) /\
     I := us(ME) .

 op generateModuleExp : Term Module Database -> CafeModExp .
 eq generateModuleExp('CafeToken[T], M, DB) = downQid(T) .
 eq generateModuleExp('token[T], M, DB) = downQid(T) .
 ceq generateModuleExp('_+_[T, T'], M, DB) = ME + ME'
  if ME := generateModuleExp(T, M, DB) /\
     ME' := generateModuleExp(T', M, DB) .
 ceq generateModuleExp('_*`{_`}[T, T'], M, DB) = ME * {RS}
  if ME := generateModuleExp(T, M, DB) /\
     RS := generateRenamings(T', M, DB) .
 ceq generateModuleExp('_`(_`)[T, T'], M, DB) = ME [PL]
  if ME := generateModuleExp(T, M, DB) /\
     PL := generateInst(T', M, ME, DB) .

 op getTopModule : Term ~> CafeModExp .
 eq getTopModule(Q) = Q .
 eq getTopModule(ME * {RS}) = getTopModule(ME) .
 eq getTopModule(ME (PL)) = getTopModule(ME) .

 op generateInst : Term Module CafeModExp Database -> ParameterList .
 ceq generateInst(T, M, ME, DB) = generateInstAux(T', M, DB)
  if Q := getTopModule(ME) /\
     M' := getTopModule(Q, DB) /\
     PDL := getPDL(M') /\
     T' := sortViewId(PDL, T) .

 *** TODO
 op generateInstAux : Term Module Database -> ParameterList .
 eq generateInstAux('_<=_[T,'token[T']], M, DB) = downQid(T') .
 eq generateInstAux('token[T], M, DB) = downQid(T) .
 ceq generateInstAux('_`,_[T, T'], M, DB) = PL, PL'
  if PL := generateInstAux(T, M, DB) /\
     PL' := generateInstAux(T', M, DB) .


 ceq generateBody('*`[_`]*[T], M, DB, CM, MODS) = [CM'', MODS]
  if S := generateTerm(T, M, DB) /\
     CM' := replaceHiddenSort(CM, S) /\
     CM'' := removeSorts(CM', S) .

 op generateCafeOperatorHead : Term -> Qid .
 eq generateCafeOperatorHead('CafeToken[T]) = downQid(T) .
 ceq generateCafeOperatorHead('__[T, T']) = Q''
  if Q := generateCafeOperatorHead(T) /\
     Q' := generateCafeOperatorHead(T') /\
     Q'' := qid(string(Q) + string(Q')) .

 op generateCafeAttrSet : Term Module Database -> CafeAttrSet .
 ceq generateCafeAttrSet('__[T, T'], M, DB) = AtS AtS'
  if AtS := generateCafeAttrSet(T, M, DB) /\
     AtS' := generateCafeAttrSet(T', M, DB) .
 eq generateCafeAttrSet('constr.@CafeAttr@, M, DB) = constr .
 eq generateCafeAttrSet('associative.@CafeAttr@, M, DB) = assoc .
 eq generateCafeAttrSet('assoc.@CafeAttr@, M, DB) = assoc .
 eq generateCafeAttrSet('l-assoc.@CafeAttr@, M, DB) = l-assoc .
 eq generateCafeAttrSet('r-assoc.@CafeAttr@, M, DB) = r-assoc .
 eq generateCafeAttrSet('commutative.@CafeAttr@, M, DB) = comm .
 eq generateCafeAttrSet('comm.@CafeAttr@, M, DB) = comm .
 eq generateCafeAttrSet('idempotent.@CafeAttr@, M, DB) = idem .
 eq generateCafeAttrSet('idem.@CafeAttr@, M, DB) = idem .
 eq generateCafeAttrSet('nonexec.@CafeAttr@, M, DB) = nonexec .
 ceq generateCafeAttrSet('prec:_['CafeToken[T]], M, DB) = prec:(N)
  if Q := downQid(T) /\
     N := rat(string(Q), 10) .
 ceq generateCafeAttrSet('strat:_['NeCafeTokenList[T]], M, DB) = strat:(NL)
  if NL := generateStratOrder(T) .
 ceq generateCafeAttrSet('id:`(_`)['CafeBubble[T]], M, DB) = id:(T')
   if T' := solveBubbles('bubble[T], M, false, none, DB) .
 ceq generateCafeAttrSet('idr:`(_`)['CafeBubble[T]], M, DB) = idr:(T')
   if T' := solveBubbles('bubble[T], M, false, none, DB) .

 op generateStratOrder : Term -> NeNatList .
 ceq generateStratOrder('__[T, T']) = NL NL'
  if NL := generateStratOrder(T) /\
     NL' := generateStratOrder(T') .
 ceq generateStratOrder('CafeToken[T]) = N
  if Q := downQid(T) /\
     N := rat(string(Q), 10) .

 ceq generateBody('op_:`->_.[T, 'CafeToken[T']], M, DB, CM, MODS) = [CM', MODS]
  if Q := generateCafeOperatorHead(T) /\
     Q' := downQid(T') /\
     OD := op Q : nil -> Q' {none} /\
     CM' := addOps(CM, OD) .
 ceq generateBody('op_:`->_`{_`}.[T, 'CafeToken[T'], T''], M, DB, CM, MODS) = [CM', MODS]
  if Q := generateCafeOperatorHead(T) /\
     Q' := downQid(T') /\
     AtS := generateCafeAttrSet(T'', M, DB) /\
     OD := op Q : nil -> Q' {AtS} /\
     CM' := addOps(CM, OD) .
 ceq generateBody('bop_:`->_.[T, 'CafeToken[T']], M, DB, CM, MODS) = [CM', MODS]
  if Q := generateCafeOperatorHead(T) /\
     Q' := downQid(T') /\
     OD := bop Q : nil -> Q' {none} /\
     CM' := addOps(CM, OD) .
 ceq generateBody('bop_:`->_`{_`}.[T, 'CafeToken[T'], T''], M, DB, CM, MODS) = [CM', MODS]
  if Q := generateCafeOperatorHead(T) /\
     Q' := downQid(T') /\
     AtS := generateCafeAttrSet(T'', M, DB) /\
     OD := bop Q : nil -> Q' {AtS} /\
     CM' := addOps(CM, OD) .
 ceq generateBody('ops_:`->_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, CM,
                  MODS) = [CM', MODS]
  if QS := getOperatorNames(T) /\
     Q' := downQid(T') /\
     ODS := generateCafeOps(QS, nil, Q', none) /\
     CM' := addOps(CM, ODS) .
 ceq generateBody('ops_:`->_`{_`}.['neCafeTokenList[T], 'CafeToken[T'], T''], M, DB,
                  CM, MODS) = [CM', MODS]
  if QS := getOperatorNames(T) /\
     Q' := downQid(T') /\
     AtS := generateCafeAttrSet(T'', M, DB) /\
     ODS := generateCafeOps(QS, nil, Q', AtS) /\
     CM' := addOps(CM, ODS) .
 ceq generateBody('bops_:`->_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, CM, MODS) = [CM', MODS]
  if QS := getOperatorNames(T) /\
     Q' := downQid(T') /\
     ODS := generateCafeBops(QS, nil, Q', none) /\
     CM' := addOps(CM, ODS) .
 ceq generateBody('bops_:`->_`{_`}.['neCafeTokenList[T], 'CafeToken[T'], T''], M, DB,
                  CM, MODS) = [CM', MODS]
  if QS := getOperatorNames(T) /\
     Q' := downQid(T') /\
     AtS := generateCafeAttrSet(T'', M, DB) /\
     ODS := generateCafeBops(QS, nil, Q', AtS) /\
     CM' := addOps(CM, ODS) .
 ceq generateBody('op_:_->_.[T, T', 'CafeToken[T'']], M, DB, CM, MODS) = [CM', MODS]
  if Q := generateCafeOperatorHead(T) /\
     TyL := generateTypeList(T') /\
     Q' := downQid(T'') /\
     OD := op Q : TyL -> Q' {none} /\
     CM' := addOps(CM, OD) .
 ceq generateBody('op_:_->_`{_`}.[T, T', 'CafeToken[T''], T'''], M, DB, CM, MODS) =
                                                                               [CM', MODS]
  if Q := generateCafeOperatorHead(T) /\
     TyL := generateTypeList(T') /\
     Q' := downQid(T'') /\
     AtS := generateCafeAttrSet(T''', M, DB) /\
     OD := op Q : TyL -> Q' {AtS} /\
     CM' := addOps(CM, OD) .
 ceq generateBody('bop_:_->_.[T, T', 'CafeToken[T'']], M, DB, CM, MODS) = [CM', MODS]
  if Q := generateCafeOperatorHead(T) /\
     TyL := generateTypeList(T') /\
     Q' := downQid(T'') /\
     OD := bop Q : TyL -> Q' {none} /\
     CM' := addOps(CM, OD) .
 ceq generateBody('bop_:_->_`{_`}.[T, T', 'CafeToken[T''], T'''], M, DB, CM, MODS) =
                                                                               [CM', MODS]
  if Q := generateCafeOperatorHead(T) /\
     TyL := generateTypeList(T') /\
     Q' := downQid(T'') /\
     AtS := generateCafeAttrSet(T''', M, DB) /\
     OD := bop Q : TyL -> Q' {AtS} /\
     CM' := addOps(CM, OD) .
 ceq generateBody('ops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], M, DB, CM,
                  MODS) = [CM', MODS]
  if QS := getOperatorNames(T) /\
     TyL := generateTypeList(T') /\
     Q' := downQid(T'') /\
     ODS := generateCafeOps(QS, TyL, Q', none) /\
     CM' := addOps(CM, ODS) .
 ceq generateBody('ops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''], M,
                  DB, CM, MODS) = [CM', MODS]
  if QS := getOperatorNames(T) /\
     TyL := generateTypeList(T') /\
     Q' := downQid(T'') /\
     AtS := generateCafeAttrSet(T''', M, DB) /\
     ODS := generateCafeOps(QS, TyL, Q', AtS) /\
     CM' := addOps(CM, ODS) .
 ceq generateBody('bops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], M, DB,
                  CM, MODS) = [CM', MODS]
  if QS := getOperatorNames(T) /\
     TyL := generateTypeList(T') /\
     Q' := downQid(T'') /\
     ODS := generateCafeBops(QS, TyL, Q', none) /\
     CM' := addOps(CM, ODS) .
 ceq generateBody('bops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''], M,
                  DB, CM, MODS) = [CM', MODS]
  if QS := getOperatorNames(T) /\
     TyL := generateTypeList(T') /\
     Q' := downQid(T'') /\
     AtS := generateCafeAttrSet(T''', M, DB) /\
     ODS := generateCafeBops(QS, TyL, Q', AtS) /\
     CM' := addOps(CM, ODS) .

 ceq generateBody('pred_:_.[T, T'], M, DB, CM, MODS) = [CM', MODS]
  if Q := generateCafeOperatorHead(T) /\
     TyL := generateTypeList(T') /\
     PD := pred Q : TyL {none} /\
     CM' := addOps(CM, PD) .
  ceq generateBody('pred_:_`{_`}.[T, T', T''], M, DB, CM, MODS) = [CM', MODS]
  if Q := generateCafeOperatorHead(T) /\
     TyL := generateTypeList(T') /\
     AtS := generateCafeAttrSet(T'', M, DB) /\
     PD := pred Q : TyL {AtS} /\
     CM' := addOps(CM, PD) .

 ceq generateBody('var_:_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, CM, MODS) =
                                                                          [CM, MODS MODS']
  if MODS' := parseVars(downQidList(T), downQid(T')) .
 ceq generateBody('vars_:_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, CM, MODS) =
                                                                          [CM, MODS MODS']
  if MODS' := parseVars(downQidList(T), downQid(T')) .

 ceq generateBody('eq_=_.['CafeBubble[T], 'CafeBubble[T']], M, DB, CM, MODS) = [CM', MODS]
  if TW := if solveBubbles('bubble[extractLabel(T)], M, false, MODS, DB) :: Term
           then extractLabel(T)
           else T
           fi /\
     TW' := removeEqAtS(T') /\
     QIL := downQidList(TW) /\
     MODS' := MODS opDeclSetFromQidList(QIL) /\
     T1 := solveBubbles('bubble[TW], M, false, MODS', DB) /\
     T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], MODS', DB) /\
     AtS := generateEqAtS(T') generateEqLabel(T) /\
     Eq := eq T1 = T2 {AtS} . /\
     CM' := addEqs(CM, Eq) .
 ceq generateBody('beq_=_.['CafeBubble[T], 'CafeBubble[T']], M, DB, CM, MODS) = [CM', MODS]
  if TW := if solveBubbles('bubble[extractLabel(T)], M, false, MODS, DB) :: Term
           then extractLabel(T)
           else T
           fi /\
     TW' := removeEqAtS(T') /\
     QIL := downQidList(TW) /\
     MODS' := MODS opDeclSetFromQidList(QIL) /\
     T1 := solveBubbles('bubble[TW], M, false, MODS', DB) /\
     T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], MODS', DB) /\
     AtS := generateEqAtS(T') generateEqLabel(T) /\
     Eq := beq T1 = T2 {AtS} . /\
     CM' := addEqs(CM, Eq) .
 ceq generateBody('ceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], M,
                  DB, CM, MODS) = [CM', MODS]
  if TW := if solveBubbles('bubble[extractLabel(T)], M, false, MODS, DB) :: Term
           then extractLabel(T)
           else T
           fi /\
     TW' := removeEqAtS(T'') /\
     QIL := downQidList(TW) /\
     MODS' := MODS opDeclSetFromQidList(QIL) /\
     T1 := solveBubbles('bubble[TW], M, false, MODS', DB) /\
     T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], MODS', DB) /\
     AtS := generateEqAtS(T'') generateEqLabel(T) /\
     M' := addInfoConds(addOps(MODS', M)) /\
     Eq := ceq T1 = T2 if solveBubblesCond('bubble[TW'], M, M', false, MODS', DB) {AtS} . /\
     CM' := addEqs(CM, Eq) .
 ceq generateBody('bceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], M,
                  DB, CM, MODS) = [CM', MODS]
  if TW := if solveBubbles('bubble[extractLabel(T)], M, false, MODS, DB) :: Term
           then extractLabel(T)
           else T
           fi /\
     TW' := removeEqAtS(T'') /\
     QIL := downQidList(TW) /\
     MODS' := MODS opDeclSetFromQidList(QIL) /\
     T1 := solveBubbles('bubble[TW], M, false, MODS', DB) /\
     T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], MODS', DB) /\
     AtS := generateEqAtS(T'') generateEqLabel(T) /\
     M' := addInfoConds(addOps(MODS', M)) /\
     Eq := bceq T1 = T2 if solveBubblesCond('bubble[TW'], M, M', false, MODS', DB) {AtS} . /\
     CM' := addEqs(CM, Eq) .
 ceq generateBody('cq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], M,
                  DB, CM, MODS) = [CM', MODS]
  if TW := if solveBubbles('bubble[extractLabel(T)], M, false, MODS, DB) :: Term
           then extractLabel(T)
           else T
           fi /\
     TW' := removeEqAtS(T'') /\
     QIL := downQidList(TW) /\
     MODS' := MODS opDeclSetFromQidList(QIL) /\
     T1 := solveBubbles('bubble[TW], M, false, MODS', DB) /\
     T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], MODS', DB) /\
     AtS := generateEqAtS(T'') generateEqLabel(T) /\
     M' := addInfoConds(addOps(MODS', M)) /\
     Eq := ceq T1 = T2 if solveBubblesCond('bubble[TW'], M, M', false, MODS', DB) {AtS} . /\
     CM' := addEqs(CM, Eq) .
 ceq generateBody('bcq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], M,
                  DB, CM, MODS) = [CM', MODS]
  if TW := if solveBubbles('bubble[extractLabel(T)], M, false, MODS, DB) :: Term
           then extractLabel(T)
           else T
           fi /\
     TW' := removeEqAtS(T'') /\
     QIL := downQidList(TW) /\
     MODS' := MODS opDeclSetFromQidList(QIL) /\
     T1 := solveBubbles('bubble[TW], M, false, MODS', DB) /\
     T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], MODS', DB) /\
     AtS := generateEqAtS(T'') generateEqLabel(T) /\
     M' := addInfoConds(addOps(MODS', M)) /\
     Eq := bceq T1 = T2 if solveBubblesCond('bubble[TW'], M, M', false, MODS', DB) {AtS} . /\
     CM' := addEqs(CM, Eq) .

 ceq generateBody('trans_=>_.['CafeBubble[T], 'CafeBubble[T']], M, DB, CM, MODS) = [CM', MODS]
  if TW := if solveBubbles('bubble[extractLabel(T)], M, false, MODS, DB) :: Term
           then extractLabel(T)
           else T
           fi /\
     TW' := removeEqAtS(T') /\
     QIL := downQidList(TW) /\
     MODS' := MODS opDeclSetFromQidList(QIL) /\
     T1 := solveBubbles('bubble[TW], M, false, MODS', DB) /\
     T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], MODS', DB) /\
     AtS := generateEqAtS(T') generateEqLabel(T) /\
     Tr := trans T1 => T2 {AtS} . /\
     CM' := addTrans(CM, Tr) .
 ceq generateBody('trns_=>_.['CafeBubble[T], 'CafeBubble[T']], M, DB, CM, MODS) = [CM', MODS]
  if TW := if solveBubbles('bubble[extractLabel(T)], M, false, MODS, DB) :: Term
           then extractLabel(T)
           else T
           fi /\
     TW' := removeEqAtS(T') /\
     QIL := downQidList(TW) /\
     MODS' := MODS opDeclSetFromQidList(QIL) /\
     T1 := solveBubbles('bubble[TW], M, false, MODS', DB) /\
     T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], MODS', DB) /\
     AtS := generateEqAtS(T') generateEqLabel(T) /\
     Tr := trans T1 => T2 {AtS} . /\
     CM' := addTrans(CM, Tr) .
 ceq generateBody('btrans_=>_.['CafeBubble[T], 'CafeBubble[T']], M, DB, CM, MODS) = [CM', MODS]
  if TW := if solveBubbles('bubble[extractLabel(T)], M, false, MODS, DB) :: Term
           then extractLabel(T)
           else T
           fi /\
     TW' := removeEqAtS(T') /\
     QIL := downQidList(TW) /\
     MODS' := MODS opDeclSetFromQidList(QIL) /\
     T1 := solveBubbles('bubble[TW], M, false, MODS', DB) /\
     T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], MODS', DB) /\
     AtS := generateEqAtS(T') generateEqLabel(T) /\
     Tr := btrans T1 => T2 {AtS} . /\
     CM' := addTrans(CM, Tr) .
 ceq generateBody('ctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], M,
                  DB, CM, MODS) = [CM', MODS]
  if TW := if solveBubbles('bubble[extractLabel(T)], M, false, MODS, DB) :: Term
           then extractLabel(T)
           else T
           fi /\
     TW' := removeEqAtS(T'') /\
     QIL := downQidList(TW) /\
     MODS' := MODS opDeclSetFromQidList(QIL) /\
     T1 := solveBubbles('bubble[TW], M, false, MODS', DB) /\
     T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], MODS', DB) /\
     AtS := generateEqAtS(T'') generateEqLabel(T) /\
     M' := addInfoConds(addOps(MODS', M)) /\
     Tr := ctrans T1 => T2 if solveBubblesCond('bubble[TW'], M, M', false, MODS', DB) {AtS} . /\
     CM' := addTrans(CM, Tr) .
 ceq generateBody('ctrns_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], M,
                  DB, CM, MODS) = [CM', MODS]
  if TW := if solveBubbles('bubble[extractLabel(T)], M, false, MODS, DB) :: Term
           then extractLabel(T)
           else T
           fi /\
     TW' := removeEqAtS(T'') /\
     QIL := downQidList(TW) /\
     MODS' := MODS opDeclSetFromQidList(QIL) /\
     T1 := solveBubbles('bubble[TW], M, false, MODS', DB) /\
     T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], MODS', DB) /\
     AtS := generateEqAtS(T'') generateEqLabel(T) /\
     M' := addInfoConds(addOps(MODS', M)) /\
     Tr := ctrans T1 => T2 if solveBubblesCond('bubble[TW'], M, M', false, MODS', DB) {AtS} . /\
     CM' := addTrans(CM, Tr) .
 ceq generateBody('bctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], M,
                  DB, CM, MODS) = [CM', MODS]
  if TW := if solveBubbles('bubble[extractLabel(T)], M, false, MODS, DB) :: Term
           then extractLabel(T)
           else T
           fi /\
     TW' := removeEqAtS(T'') /\
     QIL := downQidList(TW) /\
     MODS' := MODS opDeclSetFromQidList(QIL) /\
     T1 := solveBubbles('bubble[TW], M, false, MODS', DB) /\
     T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], MODS', DB) /\
     AtS := generateEqAtS(T'') generateEqLabel(T) /\
     M' := addInfoConds(addOps(MODS', M)) /\
     Tr := bctrans T1 => T2 if solveBubblesCond('bubble[TW'], M, M', false, MODS', DB) {AtS} . /\
     CM' := addTrans(CM, Tr) .

 op generateTypeList : Term -> TypeList .
 ceq generateTypeList('__[T, T']) = TyL TyL'
  if TyL := generateTypeList(T) /\
     TyL' := generateTypeList(T') .
 eq generateTypeList('CafeToken[T]) = downQid(T) .
 eq generateTypeList(T) = downQid(T) [owise] .

 op getOperatorNames : Term -> QidSet .
 ceq getOperatorNames('__[T, T']) = QS ; QS'
  if QS := getOperatorNames(T) /\
     QS' := getOperatorNames(T') .
 eq getOperatorNames(T) = downQid(T) [owise] .

 op generateCafeOps : QidSet TypeList Type CafeAttrSet -> CafeOpDeclSet .
 eq generateCafeOps(none, TyL, Ty, AtS) = none .
 eq generateCafeOps(Q ; QS, TyL, Ty, AtS) = op Q : TyL -> Ty {AtS}
                                            generateCafeOps(QS, TyL, Ty, AtS) .

 op generateCafeBops : QidSet TypeList Type CafeAttrSet -> CafeOpDeclSet .
 eq generateCafeBops(none, TyL, Ty, AtS) = none .
 eq generateCafeBops(Q ; QS, TyL, Ty, AtS) = bop Q : TyL -> Ty {AtS}
                                             generateCafeBops(QS, TyL, Ty, AtS) .

 op generateRenamings : Term Module Database -> CafeRenSet .
 ceq generateRenamings('__[T, T'], M, DB) = RS, RS'
  if RS := generateRenamings(T, M, DB) /\
     RS' := generateRenamings(T', M, DB) .
 ceq generateRenamings('sort_->_.[T, T'], M, DB) = sort Q -> Q'
  if Q := generateTerm(T, M, DB) /\
     Q' := generateTerm(T', M, DB) .
 ceq generateRenamings('hsort_->_.[T, T'], M, DB) = hsort Q -> Q'
  if Q := generateTerm(T, M, DB) /\
     Q' := generateTerm(T', M, DB) .
 ceq generateRenamings('op_->_.[T, T'], M, DB) = op Q -> Q'
  if Q := generateTerm(T, M, DB) /\
     Q' := generateTerm(T', M, DB) .
 ceq generateRenamings('bop_->_.[T, T'], M, DB) = bop Q -> Q'
  if Q := generateTerm(T, M, DB) /\
     Q' := generateTerm(T', M, DB) .

 op generateTerm : Term Module Database -> Qid .
 eq generateTerm('CafeToken[T], M, DB) = downQid(T) .
 eq generateTerm('token[T], M, DB) = downQid(T) .

 op generateEqLabel : Term -> CafeAttrSet .
 ceq generateEqLabel('__[''`[.Qid, T, ''`].Qid, '':.Qid, TL]) = label:(Q)
  if TL =/= empty /\
     Q := downTerm(T) .
 eq generateEqLabel(T) = none [owise] .

 op generateEqAtS : Term -> CafeAttrSet .
 eq generateEqAtS('__[TL]) = generateEqAtS*(TL) .
 eq generateEqAtS(T) = none [owise] .

 op generateEqAtS* : Term -> CafeAttrSet .
 eq generateEqAtS*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) = nonexec
                                              generateEqAtS*((''`{.Qid, TL'', ''`}.Qid)) .
 ceq generateEqAtS*((TL, ''`{.Qid, ''metadata.Qid, T, TL'', ''`}.Qid)) = meta-data(St)
                                            generateEqAtS*((TL, ''`{.Qid, TL'', ''`}.Qid))
  if St := generateMetadataString(T) .
 eq generateEqAtS*(TL) = none [owise] .

 op generateMetadataString : Term -> String .
 ceq generateMetadataString(T) = St''
  if Q := downQid(T) /\
     St := string(Q) /\
     St' := substr(St, 1, length(St)) /\
     St'' := substr(St', 0, sd(length(St'), 1)) .

 *** TODO: Quitar despues de las pruebas
 eq generateBody(T, M, DB, CM, MODS) = [CM, MODS] [owise] .

 op emptyTightCafeModule : CafeHeader -> CafeModule [ctor] .
 eq emptyTightCafeModule(H) = mod! H {none noHiddenSort [none] none none none none} .

 op emptyLooseCafeModule : CafeHeader -> CafeModule [ctor] .
 eq emptyLooseCafeModule(H) = mod* H {none noHiddenSort [none] none none none none} .

 *** TODO: MOVER A UN MODULO PROPIO QUE SE INCLUYA EN ESTE Y EL SIGUIENTE
 op extractLabel : Term -> Term .
 ceq extractLabel('__[''`[.Qid, T, ''`].Qid, '':.Qid, TL]) = '__[TL]
  if TL =/= empty /\
     Q := downTerm(T) .
 eq extractLabel(T) = T [owise] .  op removeEqAtS : Term -> Term .
  ceq removeEqAtS('__[TL]) = if sizeTL(TL') > 1
                             then '__[TL']
                             else TL'
                             fi
   if TL' := removeEqAts*(TL) .
  eq removeEqAtS(TL) = TL [owise] .

 op removeEqAts* : TermList -> TermList .
 eq removeEqAts*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) = TL .
 eq removeEqAts*((TL, ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid)) = TL .
 eq removeEqAts*(TL) = TL [owise] .

 op sizeTL : TermList -> Nat .
 eq sizeTL(empty) = 0 .
 eq sizeTL((T, TL)) = s(sizeTL(TL)) .

 op solveSecondTerm : Module Term Term OpDeclSet Database -> Term .
 ceq solveSecondTerm(M, 'bubble[T], 'bubble[T'], MODS, DB) = T2
  if M' := addOps((MODS op '_=_ : 'Universal 'Universal -> '@@@ [poly(1 2)] .),
              addSorts('@@@, M)) /\
     QIL := downQidList(T) /\
     QIL' := downQidList(T') /\
     RP := metaParse(M', '`( QIL '`) '= '`( QIL' '`), '@@@) /\
     '_=_[T1, T2] := constsToVars(getTerm(RP), MODS) .
endm

fmod META-CAFE-PRETTY-PRINT is
  pr META-CAFE-SYNTAX .

***(%
\end{comment}
}

{\codesize
\begin{comment}
%)

  var  M : Module .
  var  H : CafeHeader .
  var  IL : CafeImportList .
  var  HS : HiddenSortDecl .
  var  SS : SortSet .
  vars S S' : Sort .
  var  SSDS : CafeSubsortDeclSet .
  var  ODS : CafeOpDeclSet .
  var  EqS : CafeEqSet .
  var  TrS : CafeTransSet .
  var  PDL : ParameterDeclList .
  vars Q Q' : Qid .
  var  MME : ModuleExpression .
  vars ME ME' : CafeModExp .
  var  QIL : QidList .
  vars RS RS' : CafeRenSet .
  var  PL : ParameterList .

***(%
\end{comment}
}

We fix the Maude options for printing in the \verb"printOpts" constant:

{\codesize
\begin{verbatim}
%)

  op po : -> PrintOptionSet .
  eq po = mixfix number rat format .

***(%
\end{verbatim}
}

The character preceding or following a scape character is usually printed without
separation, which worsens the legibility. To prevent the system from doing it, we
use the function \verb"addSpace", which adds extra space if required:

{\codesize
\begin{verbatim}
%)

  op addSpace : QidList -> QidList .
  eq addSpace(QIL) = addSpaceL(addSpaceR(QIL)) .

***(%
\end{verbatim}
}

\noindent
where the auxiliary functions \verb"addSpaceL" and \verb"addSpaceR"
add a space at the left and the right of the list, respectively:

{\codesize
\begin{verbatim}
%)

  op addSpaceL : QidList -> QidList .
  eq addSpaceL('`( QIL) = ' '`( QIL .
  eq addSpaceL('`[ QIL) = ' '`[ QIL .
  eq addSpaceL('`{ QIL) = ' '`{ QIL .
  eq addSpaceL(QIL) = QIL [owise] .

  op addSpaceR : QidList -> QidList .
  eq addSpaceR(QIL '`)) = QIL '`) ' .
  eq addSpaceR(QIL '`]) = QIL '`] ' .
  eq addSpaceR(QIL '`}) = QIL '`} ' .
  eq addSpaceR(QIL) = QIL [owise] .

  op print : CafeModule Module -> QidList .
  eq print(mod* H {IL HS [SS] SSDS ODS EqS TrS}, M) =
       'mod* print(H, M) .

  op print : CafeHeader Module -> QidList .
  eq print(Q, M) = Q .
  eq print(Q(PDL), M) = Q '`( print(PDL, M) '`) .

  op print : ParameterDeclList Module -> QidList .
  eq print((nil).ParameterDeclList, M) = nil .
  eq print((S :: MME, PDL), M) = S ':: metaPrettyPrint(M, MME, po)
                                if PDL == nil
                                then nil
                                else '`, print(PDL, M)
                                fi .

  op print : CafeImportList Module -> QidList .
  eq print(pr( ME ), M) = 'pr '`( print(ME, M) '`) .
  eq print(ex( ME ), M) = 'ex '`( print(ME, M) '`) .
  eq print(inc( ME ), M) = 'inc '`( print(ME, M) '`) .
  eq print(us( ME ), M) = 'us '`( print(ME, M) '`) .

  op print : CafeModExp Module -> QidList .
  eq print(ME + ME', M) = print(ME, M) '+ print(ME', M) .
  eq print(ME * { RS }, M) = print(ME, M) '* ' '`{ print(RS) '`} .
  eq print(ME [ PL ], M) = print(ME, M) '`( print(PL, M) '`) .

  op print : CafeRenSet -> QidList .
  eq print((RS, RS')) = print(RS) '`, ' print(RS') .
  eq print(hsort S -> S') = 'hsort S '-> S' .
  eq print(sort S -> S') = 'sort S '-> S' .
  eq print(op Q -> Q') = 'op Q '-> Q' .
  eq print(bop Q -> Q') = 'bop Q '-> Q' .

  op print : ParameterList Module -> QidList .
  eq print(empty, M) = nil .
  eq print((S, PL), M) = S if PL == empty
                           then nil
                           else '`, print(PL, M)
                           fi .

  op print : HiddenSortDecl -> QidList .
  eq print(noHiddenSort) = nil .
  eq print(*[ S ]*) = '*`[ S '`]* .

  op printSS : SortSet -> QidList .
  eq printSS(none) = nil .
  eq printSS(S ; SS) = S printSS(SS) .

endfm

***(%
\end{verbatim}
}

\subsection{Pretty printing\label{subsec:pretty}}

Once the modules are parsed, it might be interesting to print them. However, we
cannot print them from the corresponding Maude module, since we have lost information
about things like hidden sorts, behavioral equations, etc. For this reason, we will
show how to print the term standing for the original CafeOBJ specification.
%
The module \verb"CAFE-PRETTY-PRINT" is in charge of printing:

{\codesize
\begin{verbatim}
%)

mod CAFE-PRETTY-PRINT is
  pr CafePARSER .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  vars QIL QIL' QIL'' QIL1 QIL2 QIL3 QIL4 QILL QILA PL : QidList .
  vars T T' T'' T''' T1 T2 T3 TW TW' : Term .
  vars ODS ODS' ODS'' VDS : OpDeclSet .
  vars St St' St'' St''' : String .
  vars ME ME' : ModuleExpression .
  vars EqS EqS' : EquationSet .
  vars TL TL' TL'' : TermList .
  var  SSDS : SubsortDeclSet .
  vars AtS AtS' : AttrSet .
  vars Q Q' GID QI : Qid .
  vars RS RS' : RuleSet .
  var  COND : Condition .
  vars M M' FM : Module .
  var  RP : ResultPair .
  var  IL : ImportList .
  var  MAS : MembAxSet .
  var  DB : Database .
  var  Ct : Constant .
  var  C : Condition .
  var  V : Variable .
  var  SS : SortSet .
  vars B B' : Bool .
  vars N N' : Nat .
  var  H : Header .
  var  S : Sort .

***(%
\end{comment}
}

We fix the Maude options for printing in the \verb"printOpts" constant:

{\codesize
\begin{verbatim}
%)

  op printOpts : -> PrintOptionSet .
  eq printOpts = mixfix number rat format .

***(%
\end{verbatim}
}

The character preceding or following a scape character is usually printed without
separation, which worsens the legibility. To prevent the system from doing it, we
use the function \verb"addSpace", which adds extra space if required:

{\codesize
\begin{verbatim}
%)

  op addSpace : QidList -> QidList .
  eq addSpace(QIL) = addSpaceL(addSpaceR(QIL)) .

***(%
\end{verbatim}
}

\noindent
where the auxiliary functions \verb"addSpaceL" and \verb"addSpaceR"
add a space at the left and the right of the list, respectively:

{\codesize
\begin{verbatim}
%)

  op addSpaceL : QidList -> QidList .
  eq addSpaceL('`( QIL) = ' '`( QIL .
  eq addSpaceL('`[ QIL) = ' '`[ QIL .
  eq addSpaceL('`{ QIL) = ' '`{ QIL .
  eq addSpaceL(QIL) = QIL [owise] .

  op addSpaceR : QidList -> QidList .
  eq addSpaceR(QIL '`)) = QIL '`) ' .
  eq addSpaceR(QIL '`]) = QIL '`] ' .
  eq addSpaceR(QIL '`}) = QIL '`} ' .
  eq addSpaceR(QIL) = QIL [owise] .

***(%
\end{verbatim}
}

The function \verb"printCond" prints a condition. It traverses each
specific condition until \verb"nil" is reached. We just show the
equality case, where both terms are printed by using the
\texttt{printOpts} constant above:

{\codesize
\begin{verbatim}
%)

  op printCond : Module Condition -> QidList .
  eq printCond(M, nil) = nil .
  eq printCond(M, T = T' /\ C) = metaPrettyPrint(M, T, printOpts) '=
                                 metaPrettyPrint(M, T', printOpts)
                                 if C == nil
                                 then nil
                                 else '/\ printCond(M, C)
                                 fi .

***(%
   ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  eq printCond(M, T := T' /\ C) = metaPrettyPrint(M, T, printOpts) ':=
                                  metaPrettyPrint(M, T', printOpts)
                                  if C == nil
                                  then nil
                                  else '/\ printCond(M, C)
                                  fi .
  eq printCond(M, T => T' /\ C) = metaPrettyPrint(M, T, printOpts) '=>
                                  metaPrettyPrint(M, T', printOpts)
                                  if C == nil
                                  then nil
                                  else '/\ printCond(M, C)
                                  fi .
  eq printCond(M, T : S /\ C) = metaPrettyPrint(M, T, printOpts) ': S
                                if C == nil
                                then nil
                                else '/\ printCond(M, C)
                                fi .

  op printCafeAtS : AttrSet -> QidList .
  eq printCafeAtS(label(Q) AtS) = printCafeAtS(AtS) .
  eq printCafeAtS(metadata("added") AtS) = printCafeAtS(AtS) .
  eq printCafeAtS(none) = nil .
  eq printCafeAtS(AtS) = '\g ' '`{ '\o printCafeAtSAux(AtS) '\g '`} '\o .

  op printCafeAtSAux : AttrSet -> QidList .
  eq printCafeAtSAux(none) = nil .
  eq printCafeAtSAux(nonexec AtS) = 'nonexec printCafeAtSAux(AtS) .
  eq printCafeAtSAux(metadata(St) AtS) = 'metadata: qid(St) printCafeAtSAux(AtS) .
  eq printCafeAtSAux(AtS) = 'No 'print 'specified. [owise] .

  op printLabel : AttrSet -> QidList .
  ceq printLabel(label(Q) AtS) = ' '`[ Q '`] ' ':
   if substr(string(Q), 0, 5) =/= "lemma" .
  eq printLabel(AtS) = nil [owise] .

***(%
  **************************
  *** Print CafeOBJ Term ***
  **************************
\end{comment}
}

The function \verb"printCafeModule" is in charge of printing CafeOBJ modules.
We only distinguish cases to print the appropriate keyword, but the rest of the
methods are common for both kinds of modules:

{\codesize
\begin{verbatim}
%)

  op printCafeModule : Term Module Database Bool -> QidList .
  ceq printCafeModule('cmod!_`{_`}[T, T'], M, DB, B) =
                      '\n 'mod! printCafeName(DB, M, T) '`{
                      '\n first(printCafeBody*(paramSortsMap(T', PL), M, DB, none, PL))
                      '\n '`}
   if PL := paramNames(T) .
  ceq printCafeModule('cmod*_`{_`}[T, T'], M, DB, B) =
                      '\n 'mod* printCafeName(DB, M, T) '`{
                      '\n first(printCafeBody*(paramSortsMap(T', PL), M, DB, none, PL))
                      '\n '`}
   if PL := paramNames(T) .

***(%
\end{verbatim}
}

\noindent
where the function \verb"paramNames" just extracts the parameter names from
the term:

{\codesize
\begin{verbatim}
%)

  op paramNames : Term -> QidList .
  eq paramNames('_`(_`)[T, T']) = cafeParamNames(T') .

***(%
\end{verbatim}
}

The function \verb"printCafeName" is in charge of printing the header
of the module. It distinguishes between all the possible module expressions:

{\codesize
\begin{verbatim}
%)

  op printCafeName : Database Module Term -> QidList .
  eq printCafeName(DB, M, 'CafeToken[T]) = downQid(T) .
  eq printCafeName(DB, M, 'token[T]) = downQid(T) .
  ceq printCafeName(DB, M, '_`(_`)[T, T']) = QIL '`( QIL' '`) '
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeViewExp(DB, M, T') .
  ceq printCafeName(DB, M, '_*`{_`}[T, T']) = QIL '* ' '`{ QIL' '`}
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeRen(T') .
  ceq printCafeName(DB, M, '_+_[T, T']) = QIL '+ QIL'
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeName(DB, M, T') .

***(%
\end{verbatim}
}

The following auxiliary functions are required by \texttt{printCafeName}:
\begin{itemize}
\item
\verb"printCafeViewExp", which prints any view expression:

{\codesize
\begin{verbatim}
%)

  op printCafeViewExp : Database Module Term -> QidList .
  eq printCafeViewExp(DB, M, 'token[T]) = downQid(T) .
  ceq printCafeViewExp(DB, M, '_`,_[T, T']) = QIL '`, ' QIL'
   if QIL := printCafeViewExp(DB, M, T) /\
      QIL' := printCafeViewExp(DB, M, T') .
  ceq printCafeViewExp(DB, M, '_::_[T, T']) = QIL ':: QIL'
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeName(DB, M, T') .
  ceq printCafeViewExp(DB, M, '_<=_[T, T']) = QIL '<= QIL'
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeViewExp(DB, M, T') .
  ceq printCafeViewExp(DB, M, 'view`to_`{_`}[T, T']) =
                                     'view 'to QIL ' '`{ ' QIL' ' '`}
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeMaps(DB, M, T') .
  ceq printCafeViewExp(DB, M, '_`{_`}[T, T']) = QIL ' '`{ ' QIL' ''`}
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeMaps(DB, M, T') .

***(%
\end{verbatim}
}

\item
\verb"printCafeMaps", which prints the possible mappings appearing in views:

{\codesize
\begin{verbatim}
%)

  op printCafeMaps : Database Module Term -> QidList .
  ceq printCafeMaps(DB, M, '__[T, T']) = QIL QIL'
   if QIL := printCafeMaps(DB, M, T) /\
      QIL' := printCafeMaps(DB, M, T') .
  ceq printCafeMaps(DB, M, 'sort_->_.[T, T']) = 'sort Q 'to Q'
   if Q := printCafeName(DB, M, T) /\
      Q' := printCafeName(DB, M, T') .
  ceq printCafeMaps(DB, M, 'hsort_->_.[T, T']) = 'hsort Q 'to Q'
   if Q := printCafeName(DB, M, T) /\
      Q' := printCafeName(DB, M, T') .
  ceq printCafeMaps(DB, M, 'op_->_.['CafeBubble[T], 'CafeBubble[T']]) =
                                                          'op QIL '-> QIL'
   if QIL := metaPrettyPrint(M, T, printOpts) /\
      QIL' := metaPrettyPrint(M, T', printOpts) .

***(%
\end{verbatim}
}

\item
\verb"printCafeRen", which is in charge of printing renamings:

{\codesize
\begin{verbatim}
%)

  op printCafeRen : Term -> QidList .
  ceq printCafeRen('__[T, T']) = QIL '`, ' QIL'
   if QIL := printCafeRen(T) /\
      QIL' := printCafeRen(T') .
  ceq printCafeRen('sort_->_.[T, T']) = 'sort QIL '-> QIL'
   if QIL := printCafeSort(T) /\
      QIL' := printCafeSort(T') .
  ceq printCafeRen('hsort_->_.[T, T']) = 'hsort QIL '-> QIL'
   if QIL := printCafeSort(T) /\
      QIL' := printCafeSort(T') .
  ceq printCafeRen('op_->_.[T, T']) = 'op QIL '-> QIL'
   if QIL := printCafeTerm(T) /\
      QIL' := printCafeTerm(T') .
  ceq printCafeRen('bop_->_.[T, T']) = 'op QIL '-> QIL'
   if QIL := printCafeTerm(T) /\
      QIL' := printCafeTerm(T') .

***(%
\end{verbatim}
}

\item
\verb"printCafeTerm", which prints a token or a singleton bubble:

{\codesize
\begin{verbatim}
%)

  op printCafeTerm : Term -> QidList .
  eq printCafeTerm('token[T]) = downQid(T) .
  eq printCafeTerm('CafeToken[T]) = downQid(T) .
  eq printCafeTerm('CafeBubble[T]) = downQid(T) .

***(%
\end{verbatim}
}

\item
\verb"printCafeSort", which just prints a token or a quoted identifier:

{\codesize
\begin{verbatim}
%)

  op printCafeSort : Term -> QidList .
  eq printCafeSort('CafeToken[T]) = downQid(T) .
  eq printCafeSort(T) = downQid(T) [owise] .

***(%
\end{verbatim}
}

\end{itemize}

We define the sort \verb"PrintCafePair" to return a pair consisting of
the list of quoted identifier computed thus far and the set of variables
defined in the module:

{\codesize
\begin{verbatim}
%)

  sort PrintCafePair .
  op <_,_> : QidList OpDeclSet -> PrintCafePair [ctor] .

***(%
\end{verbatim}
}

We also define methods \verb"first" and \verb"second" to obtain the
corresponding components:

{\codesize
\begin{verbatim}
%)

  op first : PrintCafePair -> QidList .
  eq first(< QIL, ODS >) = QIL .

  op second : PrintCafePair -> OpDeclSet .
  eq second(< QIL, ODS >) = ODS .

***(%
\end{verbatim}
}

The function \verb"printCafeBody*" receives the term standing for the original
CafeOBJ specification, the obtained Maude module, the current database, a set of
variables, and a list of parameters and returns a term of sort containing the
representation of the module and the whole set of variables. It just traverses
all the sentences in the module applying \texttt{printCafeBody} to each of them:

{\codesize
\begin{verbatim}
%)

  op printCafeBody* : Term Module Database OpDeclSet QidList -> PrintCafePair .
  ceq printCafeBody*('__[T, T'], M, DB, ODS, PL) = <
                     if QIL =/= nil
                     then '\t QIL '\n
                     else nil
                     fi QIL', ODS'' >
   if < QIL, ODS' > := printCafeBody(T, M, DB, ODS, PL) /\
      < QIL', ODS'' > := printCafeBody*(T', M, DB, ODS', PL) .
  ceq printCafeBody*(T, M, DB, ODS, PL) = < '\t QIL, ODS' >
   if < QIL, ODS' > := printCafeBody(T, M, DB, ODS, PL) .

***(%
\end{verbatim}
}

The function \verb"printCafeBody" receives a specific CafeOBJ statement and prints it.
When dealing with importations, we just use the \texttt{printCafeName} shown above:

%  *************************
%  *** Importing modules ***
%  *************************

{\codesize
\begin{verbatim}
%)

  op printCafeBody : Term Module Database OpDeclSet QidList -> PrintCafePair .
  ceq printCafeBody('protecting`(_`)[T], M, DB, ODS, PL) =
                                                   < 'protecting '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('pr`(_`)[T], M, DB, ODS, PL) = < 'pr '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('extending`(_`)[T], M, DB, ODS, PL) =
                                                   < 'extending '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('ex`(_`)[T], M, DB, ODS, PL) = < 'ex '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('including`(_`)[T], M, DB, ODS, PL) =
                                                   < 'including '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('inc`(_`)[T], M, DB, ODS, PL) = < 'inc '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('using`(_`)[T], M, DB, ODS, PL) = < 'using '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('us`(_`)[T], M, DB, ODS, PL) = < 'us '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .

***(%
\end{verbatim}
}

Printing sorts requires to modify them in order to qualify the terms following the
CafeOBJ syntax:

%  ************************
%  *** Sort definitions ***
%  ************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('*`[_`]*[T], M, DB, ODS, PL) = < '* '`[ QIL '`] '*, ODS >
   if QIL := prettyprintParams(printCafeSort(T), PL) .
  ceq printCafeBody('`[_`]['__[T, T']], M, DB, ODS, PL) = < '`[ QIL QIL' '`], ODS >
   if QIL := prettyprintParams(printCafeSort(T), PL) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) .
  ceq printCafeBody('`[_`]['CafeToken[T]], M, DB, ODS, PL) = < '`[ QIL '`], ODS >
   if QIL := prettyprintParams(printCafeSort(T), PL) .
  ceq printCafeBody('`[_`]['_<_[T, T']], M, DB, ODS, PL) = < '`[ QIL '< QIL' '`], ODS >
   if QIL := prettyprintParams*(printCafeSortList(T), PL) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) .

***(%
\end{verbatim}
}

The auxiliary function required by this function are:
\begin{itemize}
\item
\verb"prettyprintParams", which translates sorts from Maude syntax
to CafeOBJ syntax. As we decribed in Section~\ref{subsec:parsing}, we distinguish
whether the character stands for a variable or a constant. If it is a constant, we
have to reorder the term:

{\codesize
\begin{verbatim}
%)

  op prettyprintParams : Qid QidList -> Qid .
  ceq prettyprintParams(Q, PL) = QI
   if St := string(Q) /\
      find(St, ":", 0) == notFound /\
      N := find(St, "$", 0) /\
      St' := substr(St, 0, N) /\
      Q' := qid(St') /\
      Q' in PL /\
      St'' := substr(St, N + 1, length(St)) /\
      QI := qid(St'' + "." + St') .

***(%
\end{verbatim}
}

If it is a variable, we have to mantain the variable name at the beginning of
the character:

{\codesize
\begin{verbatim}
%)

  ceq prettyprintParams(Q, PL) = QI
   if St := string(Q) /\
      N := find(St, ":", 0) /\
      N' := find(St, "$", 0) /\
      St' := substr(St, 0, N) /\
      St'' := substr(St, N + 1, sd(N', N + 1)) /\
      Q' := qid(St'') /\
      Q' in PL /\
      St''' := substr(St, N' + 1, length(St)) /\
      QI := qid(St' + ":" + St''' + "." + St'') .
  eq prettyprintParams(Q, PL) = Q [owise] .

***(%
\end{verbatim}
}

\noindent
and \verb"prettyprintParams*" just traverses the list, applying
\texttt{prettyprintParams} to each element:

{\codesize
\begin{verbatim}
%)

  op prettyprintParams* : QidList QidList -> QidList .
  eq prettyprintParams*(nil, PL) = nil .
  eq prettyprintParams*(Q QIL, PL) =
                 prettyprintParams(Q, PL)
                 prettyprintParams*(QIL, PL) .

***(%
\end{verbatim}
}

\item
\verb"printCafeSortList", which prints all the subterms of the given term by
traversing the flattened list:

{\codesize
\begin{verbatim}
%)

  op printCafeSortList : Term -> QidList .
  ceq printCafeSortList('__[TL]) = QIL
   if QIL := printCafeSortList*(flatten(TL)) .
  eq printCafeSortList(T) = printCafeSort(T) [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"printCafeSortList*" just traverses the list, applying
\verb"printCafeSort" to each element:

{\codesize
\begin{verbatim}
%)

  op printCafeSortList* : TermList -> QidList .
  eq printCafeSortList*(empty) = nil .
  eq printCafeSortList*((T, TL)) = printCafeSort(T) printCafeSortList*(TL) .

***(%
\end{verbatim}
}

\noindent
and \verb"flatten" just removes the juxtaposition operator from a list:

{\codesize
\begin{verbatim}
%)

  op flatten : TermList -> TermList .
  eq flatten(empty) = empty .
  eq flatten(('__[TL], TL')) = flatten((TL, TL')) .
  eq flatten((T, TL)) = T, flatten(TL) [owise] .

***(%
\end{verbatim}
}

\end{itemize}

The printing function does not print variables, since the parsing to compute the
structure of the terms eliminates the syntactic sugar. Instead, we add the variables
to the set of operators:

%  *****************************
%  *** Variable declarations ***
%  *****************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('var_:_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                                       < nil, ODS ODS' >
   if ODS' := parseVars(downQidList(T), downQid(T')) .
  ceq printCafeBody('vars_:_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                                       < nil, ODS ODS' >
   if ODS' := parseVars(downQidList(T), downQid(T')) .

***(%
\end{verbatim}
}

Although several cases are distinguished for printing operators, most of them
work in the same way. We just show the case for basic operator declarations,
where the head and the coarity are printed:

%  *****************************
%  *** Operator declarations ***
%  *****************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('op_:`->_.[T, 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'op QIL ': '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := downQid(T') .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq printCafeBody('op_:`->_`{_`}.[T, 'CafeToken[T'], T''], M, DB, ODS, PL) =
                                        < 'op QIL ': '-> Q' ' '`{ QIL' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('bop_:`->_.[T, 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'bop QIL ': '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := prettyprintParams(downQid(T'), PL) .
  ceq printCafeBody('bop_:`->_`{_`}.[T, 'CafeToken[T'], T''], M, DB, ODS, PL) =
                                        < 'bop QIL ': '-> Q' ' '`{ QIL' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('ops_:`->_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'ops QIL ': '-> Q, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) .
  ceq printCafeBody('ops_:`->_`{_`}.['neCafeTokenList[T], 'CafeToken[T'], T''],
                    M, DB, ODS, PL) = < 'ops QIL ': '-> Q ' '`{ QIL' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('bops_:`->_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'bops QIL ': '-> Q, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) .
  ceq printCafeBody('bops_:`->_`{_`}.['neCafeTokenList[T], 'CafeToken[T'], T''],
                    M, DB, ODS, PL) = < 'bops QIL ': '-> Q ' '`{ QIL' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('op_:_->_.[T, T', 'CafeToken[T'']], M, DB, ODS, PL) =
                                        < 'op QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('op_:_->_`{_`}.[T, T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'op QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .
  ceq printCafeBody('bop_:_->_.[T, T', 'CafeToken[T'']], M, DB, ODS, PL) =
                                        < 'bop QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('bop_:_->_`{_`}.[T, T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'bop QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .
  ceq printCafeBody('ops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']],
                    M, DB, ODS, PL) = < 'ops QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('ops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'ops QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .
  ceq printCafeBody('bops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']],
                    M, DB, ODS, PL) = < 'bops QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('bops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'bops QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .

***(%
\end{comment}
}

\noindent
and for predicates, where we take care of parameters in the arity:

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('pred_:_.[T, T'], M, DB, ODS, PL) =
                                        < 'pred QIL ': QIL' '., ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq printCafeBody('pred_:_`{_`}.[T, T', T''], M, DB, ODS, PL) =
                                        < 'pred QIL ': QIL' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      QIL'' := printCafeAttS(T'', M, DB) .

***(%
\end{comment}
}

The auxiliary function \verb"printCafeOperatorHead" just puts together all the
characters in the operator name:

{\codesize
\begin{verbatim}
%)

  op printCafeOperatorHead : Term -> QidList .
  eq printCafeOperatorHead('CafeToken[T]) = downQid(T) .
  ceq printCafeOperatorHead('__[T, T']) = QIL QIL'
   if QIL := printCafeOperatorHead(T) /\
      QIL' := printCafeOperatorHead(T') .

***(%
\end{verbatim}
}

The printing function for equations and rules are also very similar, so we will
only describe an unconditional equation and a conditional rule. Since we are interested
in each part of the equation the parsing in this case is complicated, so we explain
it in detail:
\begin{itemize}
\item
We check whether the term has a label by parsing the term after trying to extract it.
If the parsing succeeds, then we keep in the \texttt{TW} the term after removing the
label; otherwise, we keep the same term.

\item
Similarly, we extract the attributes from the righthand side. However, this function
cannot fail, so it is not necessary to parse the obtained term.

\item
We compute the list of quoted identifiers standing for the new lefthand side. It will
be use to compute the new variables, kept in \verb"ODS'".

\item
We solve the bubbles in the lefthand side and keep the result in \verb"T1".

\item
We solve the bubbles in the righthand side and keep the obtained term in \verb"T2".
Solving this term requires a special function that takes into account the new
variables that appeared in the lefthand side.

\item
The representation of these terms is kept in \verb"QIL'" and \verb"QIL''", respectively.

\item
The representation of the label is stored in \verb"QILL", while the representation of
the attributes is kept in \verb"QILA".

\item
Finally, the equation is built and returned.

\end{itemize}

%  *****************************
%  *** Equation declarations ***
%  *****************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('eq_=_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'eq QILL QIL' '= QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq printCafeBody('beq_=_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'eq QILL QIL' '= QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('ceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ceq QILL QIL' '= QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                       solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .
  ceq printCafeBody('bceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ceq QILL QIL' '= QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                       solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .
  ceq printCafeBody('cq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'cq QILL QIL1 '= QIL2 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL1 := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL2 := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                        solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .
  ceq printCafeBody('bcq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'cq QILL QIL1 '= QIL2 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL1 := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL2 := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                        solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

  *************************
  *** Rule declarations ***
  *************************
  ceq printCafeBody('trans_=>_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'trans QILL QIL' '=> QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('btrans_=>_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'trans QILL QIL' '=> QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('trns_=>_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'trans QILL QIL' '=> QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('ctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ctrans QILL QIL' '=> QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                         solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

  ceq printCafeBody('bctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ctrans QILL QIL' '=> QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                         solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

***(%
\end{comment}
}

Regarding conditional transitions, we have to extended the operations we performed for
unconditional statements by:
\begin{itemize}
\item
Extracting the attributes from the term standing for the condition, since this is now
the last term.

\item
Extending the module with information about sorts, required by the operators defined
with the sort \verb"Universal", to parse the condition. This is performed by applying
the Full Maude function \verb"addInfoConds" to the module extended with the variables
defined in the lefthand side.

\item
Using this extended module to solve the bubbles in the condition, and then printing
it in \verb"QIL3".

\item
The printed transition is finally composed and returned.
\end{itemize}

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('ctrns_=>_if_.['CafeBubble[T], 'CafeBubble[T'],
                    'CafeBubble[T'']], M, DB, ODS, PL) =
                           < 'ctrns QILL QIL' '=> QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                    solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

***(%
\end{verbatim}
}

The auxiliary functions used in this case are:
\begin{itemize}
\item
\verb"solveSecondTerm", which add a special operator \verb"_=_" on a new sort
\verb"@@@". We then solve the bubbles in this new sort by using the new operator.
Finally, the constants used in the parsing process are transformed back into variables
if they appear in the operator set:

{\codesize
\begin{verbatim}
%)

  op solveSecondTerm : Module Term Term OpDeclSet Database -> Term .
  ceq solveSecondTerm(M, 'bubble[T], 'bubble[T'], ODS, DB) = T2
   if M' := addOps((ODS op '_=_ : 'Universal 'Universal -> '@@@ [poly(1 2)] .),
               addSorts('@@@, M)) /\
      QIL := downQidList(T) /\
      QIL' := downQidList(T') /\
      RP := metaParse(M', '`( QIL '`) '= '`( QIL' '`), '@@@) /\
      '_=_[T1, T2] := constsToVars(getTerm(RP), ODS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  *** TODO: quitar cuando acaben las pruebas
  op asd : Term -> QidList .

  eq printCafeBody(T, M, DB, ODS, PL) = < '\r '\! 'Print 'error. asd(T) '\o, ODS > [owise] .

***(%
\end{comment}
}

\item
\verb"extractLabel", which extracts a label at the beggining of the term:

{\codesize
\begin{verbatim}
%)

  op extractLabel : Term -> Term .
  ceq extractLabel('__[''`[.Qid, T, ''`].Qid, '':.Qid, TL]) = '__[TL]
   if TL =/= empty /\
      Q := downTerm(T) .
  eq extractLabel(T) = T [owise] .

***(%
\end{verbatim}
}

\item
\verb"printLabel", which transforms a term into a list of quoted identifiers.
If the term does not correspond with a label, it is not printed:

{\codesize
\begin{verbatim}
%)

  op printLabel : Term -> QidList .
  ceq printLabel('__[''`[.Qid, T, ''`].Qid, '':.Qid, TL]) = ' '`[ Q '`] ' ':
   if TL =/= empty /\
      Q := downTerm(T) .
  eq printLabel(T) = nil [owise] .

***(%
\end{verbatim}
}

\item
\verb"removeEqAtS", which traverses the list of terms, looking for possible
attributes:

{\codesize
\begin{verbatim}
%)

  op removeEqAtS : Term -> Term .
  ceq removeEqAtS('__[TL]) = if sizeTL(TL') > 1
                             then '__[TL']
                             else TL'
                             fi
   if TL' := removeEqAts*(TL) .
  eq removeEqAtS(TL) = TL [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"removeEqAts*" removes the \verb"nonexec" and \verb"metadata" attributes:

{\codesize
\begin{verbatim}
%)

  op removeEqAts* : TermList -> TermList .
  eq removeEqAts*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) = TL .
  eq removeEqAts*((TL, ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid)) = TL .
  eq removeEqAts*(TL) = TL [owise] .

***(%
\end{verbatim}
}

\noindent
and \verb"sizeTL" just computes the size of a list of terms:

{\codesize
\begin{verbatim}
%)

  op sizeTL : TermList -> Nat .
  eq sizeTL(empty) = 0 .
  eq sizeTL((T, TL)) = s(sizeTL(TL)) .

***(%
\end{verbatim}
}

\item
Analogously, \verb"getEqAtS" returns the terms standing for the attributes:

{\codesize
\begin{verbatim}
%)

  op getEqAtS : Term -> TermList .
  eq getEqAtS('__[TL]) = getEqAtS*(TL) .
  eq getEqAtS(T) = empty [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"getEqAtS*" just looks for the \verb"nonexec" or \verb"metadata" attributes:

{\codesize
\begin{verbatim}
%)

  op getEqAtS* : Term -> TermList .
  eq getEqAtS*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) =
                                   ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid .
  eq getEqAtS*((TL, ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid)) =
                                   ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid .
  eq getEqAtS*(TL) = empty [owise] .

***(%
\end{verbatim}
}

\item
Finally, \verb"printAtS" prints the list by placing spaces at both sides (since
the attributes are placed inside curly braces):

{\codesize
\begin{verbatim}
%)

  op printAtS : TermList -> QidList .
  eq printAtS(empty) = nil .
  eq printAtS(TL) = ' downQidList(TL) ' [owise] .

***(%
\end{verbatim}
}

\end{itemize}

{\codesize
\begin{comment}

The function \verb"printCafeAttS" is used to print the attributes in operator
declarations:
%)

  op printCafeAttS : Term Module Database -> QidList .
  ceq printCafeAttS('__[T, T'], M, DB) = QIL QIL'
   if QIL := printCafeAttS(T, M, DB) /\
      QIL' := printCafeAttS(T', M, DB) .
  eq printCafeAttS('constr.@CafeAttr@, M, DB) = 'constr .
  eq printCafeAttS('associative.@CafeAttr@, M, DB) = 'associative .
  eq printCafeAttS('assoc.@CafeAttr@, M, DB) = 'assoc .
  eq printCafeAttS('l-assoc.@CafeAttr@, M, DB) = 'l-assoc .
  eq printCafeAttS('r-assoc.@CafeAttr@, M, DB) = 'r-assoc .
  eq printCafeAttS('commutative.@CafeAttr@, M, DB) = 'commutative .
  eq printCafeAttS('comm.@CafeAttr@, M, DB) = 'comm .
  eq printCafeAttS('idempotent.@CafeAttr@, M, DB) = 'idempotent .
  eq printCafeAttS('idem.@CafeAttr@, M, DB) = 'idem .
  eq printCafeAttS('nonexec.@CafeAttr@, M, DB) = 'nonexec .
  ceq printCafeAttS('prec:_['CafeToken[T]], M, DB) = 'prec: Q
   if Q := downQid(T) .
  ceq printCafeAttS('strat:_['CafeToken[T]], M, DB) = 'strat: Q
   if Q := downQid(T) .
  ceq printCafeAttS('id:`(_`)['CafeBubble[T]], M, DB) = 'id: '`( QIL '`) '
   if T1 := solveBubbles('bubble[T], M, false, none, DB) /\
      QIL := metaPrettyPrint(M, T1, printOpts) .
  ceq printCafeAttS('idr:`(_`)['CafeBubble[T]], M, DB) = 'idr: '`( QIL '`) '
   if T1 := solveBubbles('bubble[T], M, false, none, DB) /\
      QIL := metaPrettyPrint(M, T1, printOpts) .

***(%
\end{comment}
}
{\codesize
\begin{verbatim}
%)

endm

***(%
\end{verbatim}
}

\subsection{Defining commands for CafeOBJ specifications\label{subsec:cafe:commands}}

We present here how to define the behavior of the commands specified for CafeOBJ
specifications. To add any other command the programmer must define it in the module
\texttt{TRANSLATION-COMMANDS} described in Section~\ref{subsec:syntax} and then define
its behavior in
the \texttt{CAFE2MAUDE-DATABASE-HANDLING} module:

{\codesize
\begin{verbatim}
%)

mod CAFE2MAUDE-DATABASE-HANDLING is
  pr CAFE-PRETTY-PRINT .
  pr META-GENERATION .
  pr CAFE-DATABASE .
  pr CafePARSER .

***(%
\end{verbatim}
}

This module define the \verb"CafeDatabaseClass" sort, which will be used in all
the rules involving CafeOBJ specifications. Since we also want the rest of rules
from Full Maude to work, we add a subsort declaration stating that our class is
a subclass of \verb"DatabaseClass", defined in Full Maude. Finally, we define a
constant \texttt{CafeDatabase} for creating new objects:

{\codesize
\begin{verbatim}
%)

  sort CafeDatabaseClass .
  subsort CafeDatabaseClass < DatabaseClass .
  op CafeDatabase : -> CafeDatabaseClass [ctor] .

***(%
\end{verbatim}
}

We also define a new attribute, that will store whether the user wants the system
to perform a strict translation:

{\codesize
\begin{verbatim}
%)

  op strict :_ : Bool -> Attribute [ctor] .

  op cafeDB :_ : CafeDB -> Attribute [ctor] .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  var  N : Nat .
  var  X@Database : CafeDatabaseClass .
  var  O : Oid .
  vars Q QI F : Qid .
  vars QIL QIL' QIL'' : QidList .
  vars T T' T'' : Term .
  var  TL : TermList .
  vars H H' : Header .
  vars DB DB' DB'' : Database .
  vars MD SM SM' SM'' : SModule .
  var  Atts : AttributeSet .
  vars RP RP' : ResultPair? .
  vars ME ME' ME'' : ModuleExpression .
  var  B : Bool .
  var  ODS : OpDeclSet .
  vars M M' : Module .
  vars CM CM' : CafeModule .
  var  CDB CDB' : CafeDB .

***(%
\end{comment}
}

The rule \verb"load-CafeLOOSE" is in charge of loading a module with loose semantics.
It uses the function \verb"procCafeMod" from Section~\ref{subsec:parsing} to parse the
terms. If there is no errors (i.e., the variable \verb"QIL" is equals to \verb"nil")
then the database is updated and a message indicating that the module has been introduced
is shown.
If \verb"QIL" we check whether it contains an error that can be solved by translating
theories as modules. If this is the case and the user does not need a strict translation
(the boolean variable \verb"B" in the attribute \verb"strict" is set to \verb"false")
then the database is updated and a warning message is shown. Otherwise, the database
is not modified and a message is printed:

{\codesize
\begin{verbatim}
%)

  crl [load-CafeLOOSE] :
      < O : X@Database | input : ('cmod*_`{_`}[T, T']), db : DB, output : nil,
                         default : ME, strict : B, cafeDB : CDB, Atts >
   => if QIL == nil
      then
      < O : X@Database | input : nilTermList, db : DB',
                         output : ('Introduced 'Loose 'Cafe 'Module:
                                   '\g header2Qid(parseHeader(getHeader(T))) '\o '\n),
                         default : parseHeader(getHeader(T)), strict : B,
                         cafeDB : CDB', Atts >
      else if QIL == paramThWarn
           then if B then
                     < O : X@Database | input : nilTermList, db : DB, output : QIL,
                                        default : ME, strict : B, cafeDB : CDB,
                                        Atts >
                else
                     < O : X@Database | input : nilTermList, db : DB', output : QIL,
                                        default : parseHeader(getHeader(T)),
                                        strict : B, cafeDB : CDB', Atts >
                fi
           else
                < O : X@Database | input : nilTermList, db : DB, output : QIL,
                                   default : ME, strict : B, cafeDB : CDB, Atts >
           fi
      fi
   if < DB', QIL > := procCafeMod('cmod*_`{_`}[T, T'], DB) /\
      Q := parseHeader(getHeader(T)) /\
      CM' := generateMetaModule('cmod*_`{_`}[T, T'],
                     getFlatModule(Q,DB'),
                     getTopModule(Q,DB'), DB') /\
      CDB' := set(CDB, Q, CM') .

***(%
\end{verbatim}
}

The auxiliary function \verb"getHeader" just returns the module name without parameters
and using a Maude token constructor:

{\codesize
\begin{verbatim}
%)

  op getHeader : Term -> Term .
  eq getHeader('CafeToken[T]) = 'token[T] .
  eq getHeader('_`(_`)['CafeToken[T], T']) = 'token[T] .

***(%
\end{verbatim}
}

Similarly to the previous rule, \verb"load-CafeTIGHT" is in charge of loading modules
with tight semantics. In this case we do not have to take into account whether the
message contains a warning message, because parameterized modules are allowed in Maude.
Hence, we just parse the terms with \verb"procCafeMod" and update the database if no
errors are found:

{\codesize
\begin{verbatim}
%)

   crl [load-CafeTIGHT] :
       < O : X@Database | input : ('cmod!_`{_`}[T, T']), db : DB, output : nil,
                          default : ME, strict : B, cafeDB : CDB, Atts >
    => if QIL == nil
       then
       < O : X@Database | input : nilTermList, db : DB',
                          output : ('Introduced 'Tight 'Cafe 'Module: '\g
                                header2Qid(parseHeader(getHeader(T))) '\o '\n),
                          default : parseHeader(getHeader(T)), strict : B,
                          cafeDB : CDB', Atts >
       else
       < O : X@Database | input : nilTermList, db : DB, output : QIL,
                          default : ME, strict : B, cafeDB : CDB, Atts >
       fi
    if < DB', QIL > := procCafeMod('cmod!_`{_`}[T, T'], DB) /\
       Q := parseHeader(getHeader(T)) /\
       CM' := generateMetaModule('cmod!_`{_`}[T, T'],
                      getFlatModule(Q,DB'),
                      getTopModule(Q,DB'), DB') /\
       CDB' := set(CDB, Q, CM') .

***(%
\end{verbatim}
}

Finally, the rule \verb"load-CafeVIEW" loads a CafeOBJ view into the database.
It uses the \verb"procCafeView" function to parse the view and, if no errors are
found, then the database is updated:

{\codesize
\begin{verbatim}
%)

  crl [load-CafeVIEW] :
      < O : X@Database | input : ('cview_from_to_`{_`}[T, TL]), db : DB,
                         output : nil, Atts >
   => if QIL == nil
      then
      < O : X@Database | input : nilTermList, db : DB',
                         output : ('Introduced 'Cafe 'View: '\g
                                   header2Qid(parseHeader(getHeader(T))) '\o '\n),
                         Atts >
      else
      < O : X@Database | input : nilTermList, db : DB, output : QIL, Atts >
      fi
   if < DB', QIL > := procCafeView('cview_from_to_`{_`}[T, TL], DB) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  crl [load-open-close-block] :
      < O : X@Database | input : ('copen_._close[T, T']), db : DB,
                         output : nil, Atts >
   => if QIL == nil
      then
      < O : X@Database | input : nilTermList, db : DB,
                         output : ('\n 'Processing 'open-close 'environment:
                                   '\n QIL' '\n),
                         Atts >
      else
      < O : X@Database | input : nilTermList, db : DB, output : QIL, Atts >
      fi
   if < DB' | QIL | QIL' > := procOpenCloseEnv(T, T', DB) .

***(%
\end{comment}
}

The rule \verb"show-cafe-module" displays the CafeOBJ module originally
introduced by the user. It just obtains the module name from the command,
looks for the module in the database and prints it with \texttt{printCafeModule}:

%  ************************************************************************
%  ************************* ORIGINAL CAFE MODULE *************************
%  ************************************************************************

{\codesize
\begin{verbatim}
%)

  crl [show-cafe-module] :
      < O : X@Database | input : ('show`CafeOBJ`module_.['token[T]]),
                         output : nil, db : DB, Atts >
   => < O : X@Database | input : nilTermList, output : QIL,
                         db : DB, Atts >
   if Q := downQid(T) /\
      < T' ; ODS ; M > := getTermModule(Q, DB) /\
      M' := getFlatModule(Q, DB) /\
      QIL := printCafeModule(T', M', DB, false) .

***(%
\end{verbatim}
}

Alternatively, the rule \verb"show-cafe-module-error" is applied when
the module cannot be found:

{\codesize
\begin{verbatim}
%)

  crl [show-cafe-module-error] :
      < O : X@Database | input : ('show`CafeOBJ`module_.['token[T]]),
                         output : nil, db : DB, Atts >
   => < O : X@Database | input : nilTermList, output : ('\n '\r 'ERROR: '\o
                                              'The 'module 'cannot 'be 'found. '\n),
                         db : DB, Atts >
   if Q := downQid(T) /\
      not getTermModule(Q, DB) :: Tuple{Term,OpDeclSet,Module} .

***(%
\end{verbatim}
}

The rule \verb"strict-on" sets the value in \verb"strict" to \verb"true", and
prints a message indicating that the operation was successful:

%  **********************************************************************
%  ************************* SEMANTICS COMMANDS *************************
%  **********************************************************************

{\codesize
\begin{verbatim}
%)

  rl [strict-on] :
     < O : X@Database | input : ('strict`translation`on`..@Command@), strict : B,
                        output : nil, Atts >
  => < O : X@Database | input : nilTermList, strict : true,
                        output : ('\n '\b 'The 'modules 'will 'be 'introduced
                                  'as 'originally 'written. '\o '\n), Atts > .

***(%
\end{verbatim}
}

Similarly, the rule \verb"strict-off" sets the value in \verb"strict" to \verb"false"
and prints the corresponding message:

{\codesize
\begin{verbatim}
%)

  rl [strict-off] :
     < O : X@Database | input : ('strict`translation`off`..@Command@), strict : B,
                        output : nil, Atts >
  => < O : X@Database | input : nilTermList, strict : false,
                        output : ('\n '\b 'The 'translation 'will 'adapt 'CafeOBJ
                                  'specifications 'to 'meet 'Maude 'requirements 'when
                                  'possible. '\o '\n), Atts > .
endm

***(%
\end{verbatim}
}

The module \verb"LOOP-PRE-PROCESSING" performs some normalization actions on
the modules to simplify the parsing functions and the use of the \verb"metaParse"
command. This is specially important due to the use of bubbles, that do not delimit
the terms. Hence the functions in this module:
\begin{itemize}
\item
Add a dot at the end of the statements that do not require it and are not ``closed''
by themselves (e.g.\ the sort declaration constructor \verb"[_]" is closed, while
view mappings are not closed).

\item
Modify some characters that might cause ambiguity, such as the \verb"mod" keyword
at the beginning of a module and is also used by Maude modules.
\end{itemize}

Although the functions distinguish several cases all of them are basically implemented
in the same way, so we do not show the details here:

{\codesize
\begin{verbatim}
%)

mod LOOP-PRE-PROCESSING is
  pr LOOP-MODE .
  pr EXT-BOOL .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  vars Q Q' : Qid .
  vars QIL QIL' QIL'' QIL2 QIL3 : QidList .
  var  S : State .
  var  N : Nat .

***(%
\end{comment}
}

{\codesize
\begin{comment}

The function \verb"normalizeCafeOBJ" add a final \verb"." to delimit each possible
CafeOBJ statement:
%)

  op normalizeCafeOBJ : QidList -> QidList .
  ceq normalizeCafeOBJ(QIL Q Q' QIL') = normalizeCafeOBJ(QIL Q '. Q' QIL')
   if Q =/= '. /\ Q =/= '`, /\ Q =/= '`] /\ Q =/= '* /\ Q =/= '`) /\
     (Q' == 'eq or-else Q' == 'ceq or-else Q' == 'cq or-else
      Q' == 'op or-else Q' == 'ops or-else Q' == 'bop or-else
      Q' == 'bops or-else Q' == 'var or-else
      Q' == 'vars or-else Q' == 'beq or-else Q' == 'bceq or-else
      Q' == 'bcq or-else Q' == 'trans or-else Q' == 'btrans or-else
      Q' == 'ctrans or-else Q' == 'bctrans or-else Q' == 'trns or-else
      Q' == 'ctrns or-else Q' == 'btrns or-else Q' == 'bctrns or-else
      Q' == 'pred or-else Q' == 'red or-else Q' == 'reduce) .
  eq normalizeCafeOBJ(QIL Q '`}) = if Q =/= '. and Q =/= '`] and
                                      Q =/= '* and Q =/= '`)
                                   then normalizeImports(QIL Q '. '`})
                                   else normalizeImports(QIL Q '`})
                                   fi [owise] .
  eq normalizeCafeOBJ(QIL) = normalizeImports(QIL) [owise] .

  op normalizeImports : QidList -> QidList .
  eq normalizeImports(QIL) = normalizeImports(QIL, nil) .

  op normalizeImports : QidList QidList -> QidList .
  eq normalizeImports(nil, QIL) = QIL .
  ceq normalizeImports('protecting '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'pr '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('pr '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'pr '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('including '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'inc '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('inc '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'inc '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('extending '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'ex '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('ex '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'ex '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('using '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'us '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('us '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'us '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  eq normalizeImports(Q QIL, QIL') = normalizeImports(QIL, QIL' Q) [owise] .

  sort NormRes .
  op <_,_> : QidList QidList -> NormRes [ctor] .

  op normalizeImp : QidList QidList Nat -> NormRes .
  eq normalizeImp('`) QIL, QIL', 0) = < QIL' '`), QIL > .
  eq normalizeImp('`) QIL, QIL', s(N)) = normalizeImp(QIL, QIL' '`), N) .
  eq normalizeImp('`( QIL, QIL', N) = normalizeImp(QIL, QIL' '`(, s(N)) .
  ceq normalizeImp('`{ QIL, QIL', N) = normalizeImp(QIL3, QIL' '`{ QIL2, N)
   if < QIL2, QIL3 > := otfView(QIL, 0) .
  eq normalizeImp(Q QIL, QIL', N) = normalizeImp(QIL, QIL' Q, N) [owise] .


  op normalizeCafeOBJView : QidList -> QidList .
  ceq normalizeCafeOBJView(QIL '`, Q QIL') = normalizeCafeOBJView(QIL '. Q QIL')
   if Q == 'sort or-else Q == 'hsort or-else Q == 'op or-else
      Q == 'bop or-else Q == 'vvar or-else Q == 'vvars .
  eq normalizeCafeOBJView(QIL 'var QIL') = normalizeCafeOBJView(QIL 'vvar QIL') .
  eq normalizeCafeOBJView(QIL 'vars QIL') = normalizeCafeOBJView(QIL 'vvars QIL') .
  eq normalizeCafeOBJView(QIL) = QIL [owise] .

  op otfView : QidList Nat -> NormRes .
  eq otfView(QIL, N) = otfView(QIL, nil, N) .

  op otfView : QidList QidList Nat -> NormRes .
  eq otfView('`} QIL, QIL', 0) = < normalizeCafeOBJView(QIL' '. '`}), QIL > .
  eq otfView('`} QIL, QIL', s(N)) = otfView(QIL, QIL' '`}, N) .
  eq otfView('`{ QIL, QIL', N) = otfView(QIL, QIL' '`{, s(N)) .
  eq otfView(Q QIL, QIL', N) = otfView(QIL, QIL' Q, N) [owise] .

  op normalizeOpenClose : QidList -> QidList .
  *** We look for the end of the module expression to place the dot
  ceq normalizeOpenClose(Q Q' QIL) = Q '. normOpenCloseAux(Q' QIL)
   if Q' == '`[ or-else Q == '* or-else
      Q' == 'eq or-else Q' == 'ceq or-else Q' == 'cq or-else
      Q' == 'op or-else Q' == 'ops or-else Q' == 'bop or-else
      Q' == 'bops or-else Q' == 'var or-else
      Q' == 'vars or-else Q' == 'beq or-else Q' == 'bceq or-else
      Q' == 'bcq or-else Q' == 'trans or-else Q' == 'btrans or-else
      Q' == 'ctrans or-else Q' == 'bctrans or-else Q' == 'trns or-else
      Q' == 'ctrns or-else Q' == 'btrns or-else Q' == 'bctrns or-else
      Q' == 'pred or-else Q' == 'red or-else Q' == 'reduce .
  eq normalizeOpenClose(Q Q' QIL) = Q normalizeOpenClose(Q' QIL) [owise] .


  op normOpenCloseAux : QidList -> QidList .
  ceq normOpenCloseAux(QIL Q Q' QIL') = normOpenCloseAux(QIL Q '. Q' QIL')
   if Q =/= '. /\ Q =/= '`, /\ Q =/= '`] /\ Q =/= '* /\ Q =/= '`) /\
     (Q' == 'eq or-else Q' == 'ceq or-else Q' == 'cq or-else
      Q' == 'op or-else Q' == 'ops or-else Q' == 'bop or-else
      Q' == 'bops or-else Q' == 'var or-else
      Q' == 'vars or-else Q' == 'beq or-else Q' == 'bceq or-else
      Q' == 'bcq or-else Q' == 'trans or-else Q' == 'btrans or-else
      Q' == 'ctrans or-else Q' == 'bctrans or-else Q' == 'trns or-else
      Q' == 'ctrns or-else Q' == 'btrns or-else Q' == 'bctrns or-else
      Q' == 'pred or-else Q' == 'red or-else Q' == 'reduce) .
  eq normOpenCloseAux(QIL Q 'close) = if Q =/= '. and Q =/= '`] and
                                         Q =/= '* and Q =/= '`)
                                      then QIL Q '. 'close
                                      else QIL Q 'close
                                      fi [owise] .

  eq ['mod! QIL '`}, S, QIL'] = [normalizeCafeOBJ('cmod! QIL '`}), S, QIL'] .
  eq ['module! QIL '`}, S, QIL'] = ['mod! QIL '`}, S, QIL'] .
  eq ['mod* QIL '`}, S, QIL'] = [normalizeCafeOBJ('cmod* QIL '`}), S, QIL'] .
  eq ['module* QIL '`}, S, QIL'] = ['mod* QIL '`}, S, QIL'] .
  eq ['open QIL 'close, S, QIL'] = ['copen normalizeOpenClose(QIL 'close), S, QIL'] .
  eq ['view QIL '`}, S, QIL'] = [normalizeCafeOBJView('cview QIL '. '`}), S, QIL'] .
  eq ['make Q QIL, S, QIL'] = ['mod! Q '`{ 'pr QIL '`}, S, QIL'] .
  ceq [QIL 'eq '`[ Q '`] Q' QIL', S, QIL''] = [QIL 'eq '`[ Q '`] ': Q' QIL', S, QIL'']
   if Q' =/= ': .

***(%
\end{comment}
}
{\codesize
\begin{verbatim}
  ...
%)

endm

***(%
\end{verbatim}
}

Finally, the \verb"CAFE2MAUDE" module is the standard module dealing with input/output
through the Loop Mode~\cite[Chapter~17]{maude-book}. Basically, this module uses a tuple
built with the operator \verb"[_,_,_]", where the first argument corresponds to the
input introduced by the user, the third one the output shown to the user, and the second
one is a term of sort \verb"State" that can be defined by the user for each application:

{\codesize
\begin{verbatim}
%)

mod CAFE2MAUDE is
  ex LOOP-PRE-PROCESSING .
  pr META-CAFE2MAUDE-SIGNATURE .
  pr CAFE2MAUDE-DATABASE-HANDLING .

***(%
\end{verbatim}
}

We will use the sort \verb"Object" for the current state, which means that we will
store the values in a term built with the operator \verb"<_:_|_>", with the first
argument the name of the object, the second one the name of the class, and the third
one a set of attributes.
%
We also define a constant \verb"o" of sort \verb"Oid" to define the name of the initial
state:

{\codesize
\begin{verbatim}
%)

  subsort Object < State .
  op o : -> Oid .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  var  H : Header .
  var  O : Oid .
  var  X@Database : CafeDatabaseClass .
  vars Q Q' QI : Qid .
  vars QIL QIL' QIL'' : QidList .
  var  TL : TermList .
  var  DB : Database .
  var  Atts : AttributeSet .
  var  S : State .

***(%
\end{comment}
}

We define the constant \verb"cafe2maude-init" as the initial system. The user has to
rewrite it with the special command \verb"loop" to start the input/output loop.

%  ---------------------------------------------------------------------------------------
%  --------------------------------------- IN --------------------------------------------
%  ---------------------------------------------------------------------------------------

{\codesize
\begin{verbatim}
%)

  op cafe2maude-init : -> System .

***(%
\end{verbatim}
}

When the user types that command the system will apply the rule \verb"init" below.
It creates the whole sytem, with an empty list of quoted identifiers in the input
(the first \verb"nil"), another one in the output (the second \verb"nil"), and an
object with name \verb"o", class \verb"CafeDatabase", and attributes for the database
(verb"db"), the parsed \verb"input", the messages we want to print (\verb"output"),
the \verb"default" modules (all these attributes are inherited from Full Maude),
and for indicating whether the translation is \verb"strict", which is initially
set to \verb"false":

{\codesize
\begin{verbatim}
%)

  rl [init] :
     cafe2maude-init
  => [nil, < o : CafeDatabase | db : initialDatabase, input : nilTermList,
                                output : ('\n '\t '\b 'CafeOBJ2Maude '1.0 '\o
                                          'started. '\n 'CafeOBJ 'specifications
                                          'can 'be 'introduced 'now 'into 'the
                                          'Full 'Maude 'database. '\n),
                                 default : 'CONVERSION, strict : false,
                                 cafeDB : emptyCDB >, nil] .

***(%
\end{verbatim}
}

The rule \verb"input" moves the list of quoted identifiers in the first argument of the
tuple to the \verb"input" attribute, trying to parse it first. We use the
\verb"CafeGRAMMAR" module to parse this input since this module, as explained in
Section~\ref{subsec:syntax}, contains the syntax of all our programs and commands,
as well as the syntax inherited from Full Maude:

{\codesize
\begin{verbatim}
%)

  rl [input] :
     [QI QIL, < O : X@Database | input : nilTermList, output : nil, Atts >, QIL' ]
  => if metaParse(CafeGRAMMAR, QI QIL, '@Input@) :: ResultPair
     then [nil,
           < O : X@Database | input : getTerm(metaParse(CafeGRAMMAR, QI QIL, '@Input@)),
                              output : nil, Atts >,
          QIL']
     else [nil,
           < O : X@Database | input : nilTermList,
                              output : ('\r 'WARNING: '\o printSyntaxError(metaParse(
                                        CafeGRAMMAR, QI QIL, '@Input@), QI QIL) '\n
                                        'ERROR: 'No 'parse 'for 'input.), Atts >,
           QIL' ]
     fi .

***(%
\end{verbatim}
}

On the other hand, the rule \verb"output" moves the output from the attribute
\verb"output" to the third element of the tuple:

{\codesize
\begin{verbatim}
%)

  rl [output] :
     [QIL, < O : X@Database | output : (QI QIL'), Atts >, QIL'']
  => [QIL, < O : X@Database | output : nil, Atts >, (QI QIL' QIL'')] .
endm

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

set print conceal on .

print conceal mod_is_sorts_._____endm .
print conceal fmod_is_sorts_.____endfm .
print conceal db .


*** trace exclude CAFE2MAUDE .
set show loop stats off .
set show loop timing off .

loop cafe2maude-init .

***(%

\end{comment}
}
%)

