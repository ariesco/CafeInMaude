***(%

We present in this section the main modules required for dealing with CafeOBJ
specifications~\cite{cafe-report}. First, we will see how to define the syntax,
and how to parse the terms to obtain the Maude modules~\cite{maude-book}. Then,
we will show how to pretty print these terms and how to create new commands and
rules and will be added in addition to the ones already defined in Full Maude.

\subsection{Syntax\label{subsec:syntax}}

The module \verb"CafeBUBBLES" defines the sorts \verb"@CafeBubble@" for bubbles (that is,
terms that can take any form, like the lefthand side of an equation), \verb"@CafeBubble@"
for tokens (like sorts), and \verb"@NeCafeTokenList@" for nonempty lists of tokens:

{\codesize
\begin{verbatim}
%)

fmod CafeBUBBLES is
  including QID-LIST .

  sorts @CafeBubble@ @CafeToken@ @NeCafeTokenList@ .

  op CafeBubble : QidList -> @CafeBubble@ [special (id-hook Bubble (1 -1 ( ))
                            op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                            op-hook qidSymbol (<Qids> : ~> Qid))] .

  op CafeToken : Qid -> @CafeToken@ [special (id-hook Bubble (1 1)
                            op-hook qidSymbol (<Qids> : ~> Qid)
                            id-hook Exclude(. [] < { } ( )))] .

  op neCafeTokenList : QidList -> @NeCafeTokenList@ [special (id-hook Bubble (1 -1)
                            op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                            op-hook qidSymbol (<Qids> : ~> Qid)
                            id-hook Exclude(. { } ))] .
endfm

***(%
\end{verbatim}
}

The module \verb"Cafe-ATTRIBUTES" defines the possible attributes that can be used
in operators and equations:

{\codesize
\begin{verbatim}
%)

fmod Cafe-ATTRIBUTES is
  pr CafeBUBBLES .

***(%
\end{verbatim}
}

It defines the sorts \verb"@CafeAttr@" for a single attribute and
\verb"@CafeAttrList@" for lists of attributes:

{\codesize
\begin{verbatim}
%)

  sorts @CafeAttr@ @CafeAttrList@ .
  subsorts @CafeAttr@ < @CafeAttrList@ .

***(%
\end{verbatim}
}

The attributes are defined following the CafeOBJ syntax. The unary attributes
are all defined in the same way, the identity attributes require take a bubble as
argument, while the precedence attribute takes a token:

{\codesize
\begin{verbatim}
%)

  op __ : @CafeAttrList@ @CafeAttrList@ -> @CafeAttrList@ [ctor assoc] .
  ops assoc associative l-assoc r-assoc comm commutative constr nonexec :nonexec
      idem idempotent owise : -> @CafeAttr@ [ctor] .
***  TODO: Remove if not required
***  op id:`(_`) : @CafeBubble@ -> @CafeAttr@ [ctor] .
  op id:_ : @CafeBubble@ -> @CafeAttr@ [ctor] .
***  TODO: Remove if not required
***  op idr:`(_`) : @CafeBubble@ -> @CafeAttr@ [ctor] .
  op idr:_ : @CafeBubble@ -> @CafeAttr@ [ctor] .
  op prec:_ : @CafeToken@ -> @CafeAttr@ [ctor] .

***(%
\end{verbatim}
}

Although the \verb"metadata" attribute is not currently available for CafeOBJ
specifications, it might be useful, so we support it by defining the appropriate
operator. However, it can also be defined in a comment, as explained
in~\cite{cafeOBJ2maudeUG}:

{\codesize
\begin{verbatim}
%)

  op metadata_ : @CafeToken@ -> @CafeAttr@ [ctor] .
endfm

***(%
\end{verbatim}
}

The syntax must also include the commands that we want to use for CafeOBJ specifications.
These commands are defined in the \verb"TRANSLATION-COMMANDS" module, which imports the
\verb"COMMANDS" module from Full Maude. To add new commands the user must define them
here and then specify their behavior in the module \texttt{CAFE2MAUDE-DATABASE-HANDLING}
described in Section~\ref{subsec:cafe:commands}:

{\codesize
\begin{verbatim}
%)

fmod TRANSLATION-COMMANDS is
  inc COMMANDS .

***(%
\end{verbatim}
}

We have defined three commands:
\begin{itemize}
\item
The first one will force the translation to be done without using the modifications
presented in~\cite{cafeOBJ2maudeUG}, that drop some requirements from the importations
modes and on the usage of theories to allow a wider range of CafeOBJ specifications to
be translated:

{\codesize
\begin{verbatim}
%)

  op strict`translation`on`. : -> @Command@ .

***(%
\end{verbatim}
}

\item
Analogously, the second one will allow these modifications:

{\codesize
\begin{verbatim}
%)

  op strict`translation`off`. : -> @Command@ .

***(%
\end{verbatim}
}

\item
The third one will require a CafeOBJ module to be shown:

{\codesize
\begin{verbatim}
%)

  op original`CafeOBJ`module_. : @Token@ -> @Command@ .
endfm

***(%
\end{verbatim}
}

\end{itemize}

The module \verb"CafeMETA-SIGN" defines the syntax for CafeOBJ modules:

{\codesize
\begin{verbatim}
%)

fmod CafeMETA-SIGN is
  including FULL-MAUDE-SIGN .
  including Cafe-ATTRIBUTES .

***(%
\end{verbatim}
}

It first defines all the required sorts, and the subsort relations between them:

{\codesize
\begin{verbatim}
%)

  sorts @CafeMODULE@ @OpenCloseEnv@ @HiddenSortDecl@ @VisibleSortDecl@ @CafeOpDecl@
        @CafeImportDecl@ @CafeType@ @CafeTypeList@ @CafeSortList@ @CafeSort@
        @BehaviorEquationDecl@ @CafeDeclList@ @CafeEqDecl@ @CafeVarDecl@
        @CafeSubSortRel@ @CafeLDeclList@ @OpenCloseDeclList@ @CafeModExp@ @CafeParameter@
        @CafeParameters@ @CafeInterface@ @CafeViewDecl@ @CafeViewDeclList@ @CafeTransDecl@
        @CafeViewId@ @CafeViewIdList@ @ExecutionDecl@ @ReqProvDecl@
        @CafeInductiveComm@ .

  subsort @CafeToken@ < @CafeSort@ < @CafeType@ .

***(%
  ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  subsort @CafeSort@ < @CafeSortList@ .
  subsort @CafeType@ < @CafeTypeList@ .
  subsorts @CafeImportDecl@ @CafeVarDecl@ @CafeEqDecl@ @VisibleSortDecl@ @CafeOpDecl@
           @CafeTransDecl@ @ExecutionDecl@ @CafeInductiveComm@
           < @CafeLDeclList@ < @OpenCloseDeclList@  .
  subsorts @HiddenSortDecl@ @BehaviorEquationDecl@ @CafeLDeclList@
           < @CafeDeclList@ .
  subsort @ModExp@ < @CafeModExp@ . *** !!!!
  subsort @ModExp@ < @CafeViewId@ .
  subsort @CafeViewId@ < @CafeViewIdList@ .
  *** !!!! subsort @CafeToken@ < @CafeModExp@ .
  subsort @CafeParameter@ < @CafeParameters@ .
  subsort @CafeToken@  < @CafeInterface@ .
  subsort @CafeViewDecl@ < @CafeViewDeclList@ .

  subsort @CafeMODULE@ @OpenCloseEnv@ @ReqProvDecl@ < @Input@ .

  op __ : @CafeDeclList@ @CafeDeclList@ -> @CafeDeclList@ [assoc prec 10] .
  op __ : @CafeLDeclList@ @CafeLDeclList@ -> @CafeLDeclList@ [assoc prec 10] .
  op __ : @CafeTypeList@ @CafeTypeList@ -> @CafeTypeList@ [assoc prec 10] .
  op _,_ : @CafeParameters@ @CafeParameters@ -> @CafeParameters@ [assoc prec 45] .
  op none : -> @CafeViewDeclList@ [ctor] .
  op __ : @CafeViewDeclList@ @CafeViewDeclList@ -> @CafeViewDeclList@ [assoc id: none] .

  op _::_ : @CafeToken@ @CafeModExp@ -> @CafeParameter@ [prec 5 gather (e &)] .

  op _`(_`) : @CafeToken@ @CafeParameters@ -> @CafeInterface@ .
  op _`[_`] : @CafeToken@ @CafeToken@ -> @CafeInterface@ .
  op _`{_|_`} : @CafeToken@ @CafeParameters@ @CafeToken@ -> @CafeInterface@ .

***(%
\end{comment}
}

Then it defines the syntax of every possible construction in CafeOBJ. For example,
we can define the syntax for:
\begin{itemize}
\item
Hidden sorts, which receive a token and create a \verb"@HiddenSortDecl@":

{\codesize
\begin{verbatim}
%)

  op *`[_`]* : @CafeToken@ -> @HiddenSortDecl@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  *** cafe module expressions !!!!
  *** op _+_ : @CafeModExp@ @CafeModExp@ -> @CafeModExp@ [ctor assoc prec 42] .
  op _`(_`) : @CafeModExp@ @CafeViewId@ -> @CafeModExp@ [ctor prec 40] .
  op _*`{_`} : @CafeModExp@ @CafeViewDeclList@ -> @CafeModExp@ [ctor prec 43] .

***(%
\end{comment}
}

\item
View identifiers, which can be either:
\begin{itemize}
\item
On the fly view declarations, receiving a module expression and a declaration
list:

{\codesize
\begin{verbatim}
%)

  op view`to_`{_`} : @CafeModExp@ @CafeViewDeclList@ -> @CafeViewId@ [ctor] .

***(%
\end{verbatim}
}

\item
The abbreviated version of the previous declaration, which does not require the
\verb"view to" keywords:

{\codesize
\begin{verbatim}
%)

  op _`{_`} : @CafeModExp@ @CafeViewDeclList@
              -> @CafeViewId@ [ctor prec 15] .

***(%
\end{verbatim}
}

\item
A view identifier assigned to a specific module expression:

{\codesize
\begin{verbatim}
%)

  op _<=_ : @CafeModExp@ @CafeViewId@
            -> @CafeViewId@ [ctor prec 20] .

***(%
\end{verbatim}
}

\item
Finally, lists of view identifiers are created by using the operator \verb"_,_".
Note that this operator is the one with the lower precedence, since it must not
interfer with the previous declarations:

{\codesize
\begin{verbatim}
%)

  op _,_ : @CafeViewIdList@ @CafeViewIdList@
           -> @CafeViewIdList@ [ctor assoc prec 25] .

***(%
\end{verbatim}
}

\end{itemize}

\item
Importations, including all the possible variants:

{\codesize
\begin{verbatim}
%)

  op protecting`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op pr`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op extending`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op ex`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op including`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op inc`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op using`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op us`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .

***(%
\end{verbatim}
}

\item
Sort and subsort declarations:

{\codesize
\begin{verbatim}
%)

  op `[_`] : @CafeSortList@ -> @VisibleSortDecl@ [ctor prec 5] .
  op `[_`] : @CafeSubSortRel@ -> @VisibleSortDecl@ [ctor prec 5] .

***(%
\end{verbatim}
}

\item
Subsort relations:

{\codesize
\begin{verbatim}
%)

  op _<_ : @CafeSortList@ @CafeSortList@ -> @CafeSubSortRel@ [ctor] .
  op _<_ : @CafeSortList@ @CafeSubSortRel@ -> @CafeSubSortRel@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  op var_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeVarDecl@ [ctor] .
  op vars_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeVarDecl@ [ctor] .

***(%
\end{comment}
}

\item
Equations. Note that the label or the possible attributes are not included
into the operator definition. Instead, we will deal with the bubble defining
the lefthand side to check whether there is a label. Similarly, we will
analyze the last bubble looking for attributes, such as \verb"nonexec":

{\codesize
\begin{verbatim}
%)

  op eq_=_. : @CafeBubble@ @CafeBubble@ -> @CafeEqDecl@ [ctor] .
  op ceq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ -> @CafeEqDecl@ [ctor] .
  op cq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ -> @CafeEqDecl@ [ctor] .

***(%
\end{verbatim}
}

\item
Transitions. Analogously to the case above, we do not declare explicitly the label
or the attributes of the transitions:

{\codesize
\begin{verbatim}
%)

  op trans_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op trns_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op ctrans_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                      -> @CafeTransDecl@ [ctor] .
  op ctrns_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                     -> @CafeTransDecl@ [ctor] .
  op btrans_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op btrns_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op bctrans_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                       -> @CafeTransDecl@ [ctor] .
  op bctrns_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                      -> @CafeTransDecl@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  *** Operator definitions
  op op_:`->_`{_`}. : @CafeToken@ @CafeType@ @CafeAttrList@ -> @CafeOpDecl@ [ctor] .
  op op_:_->_`{_`}. : @CafeToken@ @CafeTypeList@ @CafeSort@ @CafeAttrList@
                      -> @CafeOpDecl@ [ctor] .
  op op_:`->_. : @CafeToken@ @CafeType@ -> @CafeOpDecl@ [ctor] .
  op op_:_->_. : @CafeToken@ @CafeTypeList@ @CafeType@ -> @CafeOpDecl@ [ctor] .
  op ops_:`->_`{_`}. : @NeCafeTokenList@ @CafeType@ @CafeAttrList@ -> @CafeOpDecl@ [ctor] .
  op ops_:_->_`{_`}. : @NeCafeTokenList@ @CafeTypeList@ @CafeType@ @CafeAttrList@
                       -> @CafeOpDecl@ [ctor] .
  op ops_:`->_. : @NeCafeTokenList@ @CafeType@ -> @CafeOpDecl@ [ctor] .
  op ops_:_->_. : @NeCafeTokenList@ @CafeTypeList@ @CafeType@  -> @CafeOpDecl@ [ctor] .

***(%
\end{comment}
}

\item
Predicates. In this case the sorts for the definition are more specific than in the
cases above (where we just used bubbles), so we distinguish whether attributes are
declared or not:

{\codesize
\begin{verbatim}
%)

  op pred_:_`{_`}. : @CafeToken@ @CafeTypeList@ @CafeAttrList@
                     -> @CafeOpDecl@ [ctor] .
  op pred_:_. : @CafeToken@ @CafeTypeList@ -> @CafeOpDecl@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ***observer declaration
  op bop_:_->_. : @CafeToken@ @CafeTypeList@ @CafeSort@  -> @CafeOpDecl@ [ctor] .
  op bops_:_->_. : @NeCafeTokenList@ @CafeTypeList@ @CafeSort@ -> @CafeOpDecl@ [ctor] .
  op bop_:_->_`{_`}. : @CafeToken@ @CafeTypeList@ @CafeSort@ @CafeAttrList@
                       -> @CafeOpDecl@ [ctor] .
  op bops_:_->_`{_`}. : @NeCafeTokenList@ @CafeTypeList@ @CafeType@ @CafeAttrList@
                        -> @CafeOpDecl@ [ctor] .
  op beq_=_. : @CafeBubble@ @CafeBubble@ -> @CafeEqDecl@ [ctor] .
  op bceq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ ->
                   @BehaviorEquationDecl@ [ctor] .
  op bcq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ ->
                  @BehaviorEquationDecl@ [ctor] .

  *** View declarations
  op vvar_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeViewDecl@ [ctor] .
  op vvars_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeViewDecl@ [ctor] .
  op sort_->_. : @CafeToken@ @CafeToken@ -> @CafeViewDecl@ [ctor] .
  op hsort_->_. : @CafeToken@ @CafeToken@ -> @CafeViewDecl@ [ctor] .
  op op_->_. : @CafeBubble@ @CafeBubble@ -> @CafeViewDecl@ [ctor] .
  op bop_->_. : @CafeBubble@ @CafeBubble@ -> @CafeViewDecl@ [ctor] .

  *** Reduction declarations
  op reduce_. : @CafeBubble@ -> @ExecutionDecl@ [ctor] .
  op red_. : @CafeBubble@ -> @ExecutionDecl@ [ctor] .
  op exec_. : @CafeBubble@ -> @ExecutionDecl@ [ctor] .

  *** Requires and provides
  op require_ : @NeCafeTokenList@ -> @ReqProvDecl@ [ctor] .
  op provide_ : @NeCafeTokenList@ -> @ReqProvDecl@ [ctor] .

  *** Commands for induction
  op :goal{_} : @CafeLDeclList@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:ctf{_} : @CafeToken@ @CafeEqDecl@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:ctf[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:cvss[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:cvvs[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:cvsv[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:cevss[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:cvs[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:csv[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .
  op :def_=`:csvs[_] : @CafeToken@ @CafeBubble@ -> @CafeInductiveComm@ [ctor] .

  ***(
  :cs-vss: case splitting value (eq1) and seq seq (eq2)
  :cs-vvs: case splitting value (eq1) and value seq (eq2)
  :cs-vsv: case splitting value (eq1) and seq value (eq2)
  :cs-evss: case splitting empty (eq1), value (eq2), and seq seq (eq3).
  :cs-evs: case splitting empty (eq1) and value seq (eq2).
  :cs-esv: case splitting empty (eq1) and seq value (eq2).
  :cs-esvs: case splitting empty (eq1) and seq value seq (eq2).
  )

  op :ind`on(_) : @CafeToken@ -> @CafeInductiveComm@ [ctor] .
  op :apply(_) : @NeCafeTokenList@ -> @CafeInductiveComm@ [ctor] .
  op :imp[_]. : @CafeToken@ -> @CafeInductiveComm@ [ctor] .
  op :imp[_]by{_} : @CafeToken@ @NeCafeTokenList@ -> @CafeInductiveComm@ [ctor] .
  op :sel(_) : @CafeToken@ -> @CafeInductiveComm@ [ctor] .
  op :postpone`. : -> @CafeInductiveComm@ [ctor] .
  op :show`proof : -> @CafeInductiveComm@ [ctor] .
  op :desc`proof : -> @CafeInductiveComm@ [ctor] .
  op :desc`. : -> @CafeInductiveComm@ [ctor] .

  op :id(_) : @CafeToken@ -> @CafeInductiveComm@ [ctor] .
  op :proof(_) : @CafeToken@ -> @CafeInductiveComm@ [ctor] .
  op :infer(_) : @CafeToken@ -> @CafeInductiveComm@ [ctor] .

***(%
\end{comment}
}

\item
Module and view declarations. Note that they do not have the exact syntax used
by CafeOBJ. This distinction is obtained after a pre-processing stage that makes sure
that there is no clash with the Maude syntax for modules and views:

{\codesize
\begin{verbatim}
%)

  op cmod*_`{_`} : @CafeInterface@ @CafeDeclList@ -> @CafeMODULE@ [ctor] .
  op cmod!_`{_`} : @CafeInterface@ @CafeLDeclList@ -> @CafeMODULE@ [ctor] .
  op cview_from_to_`{_`} : @CafeToken@ @CafeModExp@ @CafeModExp@
                           @CafeViewDeclList@ -> @CafeMODULE@ [ctor] .
  op cview_from_to_`{`} : @CafeToken@ @CafeModExp@ @CafeModExp@ -> @CafeMODULE@ [ctor] .

***(%
\end{verbatim}
}

\item
Open-close environment. This block is composed by a module expression and a list of
declarations, possibly including reduction commands. Note that we have introduced an
extra dot to ease the parsing; this dot will be added during the preprocessing stage,
so the user is not required to type it:

{\codesize
\begin{verbatim}
%)

  op copen_._close : @CafeModExp@ @OpenCloseDeclList@ -> @OpenCloseEnv@ [ctor] .
endfm

***(%
\end{verbatim}
}

\end{itemize}

The module \verb"META-CAFE2MAUDE-SIGNATURE" contains the metapresented signature
required by CafeOBJ, which extends the one for Full Maude:

{\codesize
\begin{verbatim}
%)

fmod META-CAFE2MAUDE-SIGNATURE is
 including META-FULL-MAUDE-SIGN .

 op CafeGRAMMAR : -> FModule .
 eq CafeGRAMMAR = addImports((including 'CafeMETA-SIGN .)
                             (including 'TRANSLATION-COMMANDS .), GRAMMAR ) .
endfm

***(%
\end{verbatim}
}

The modules \verb"CafeSIGN" and \verb"OPERATOR-Cafe", just describe auxiliary functions
for dealing with CafeOBJ modules, like functions for adding new sorts, equations, or
transitions, or for obtaining these values.

{\codesize
\begin{comment}
%)

fmod CafeSIGN is
  including EXT-SORT .

  sorts HiddenSortDecl CafeDecl CafeDeclSet BehaviorEquation CafeEquation CafeEquationSet
        CafeOpDecl CafeOpDeclSet CafeModExp .

  subsort BehaviorEquation CafeEquation < CafeEquationSet .
  subsort CafeOpDecl < CafeOpDeclSet .
  subsort CafeDecl < CafeDeclSet .
  sort CafeModule .

  op *`[_`]* : SortSet -> HiddenSortDecl .
  op (bop_:_->_) : Qid TypeList Type -> CafeDecl [ctor format(g o g o g o o )] .
  op (bops_:_->_) : QidList TypeList Type -> CafeDecl [ctor format(g o g o g o o )] .
  op none : -> CafeDeclSet [ctor] .
  op __ : CafeDeclSet CafeDeclSet -> CafeDeclSet [ctor assoc comm id: none format(d ni d)] .
  op none : -> CafeEquationSet [ctor] .
  op __ : CafeEquationSet CafeEquationSet -> CafeEquationSet [ctor assoc comm id: none format(d ni d)] .
  op none : -> CafeOpDeclSet [ctor] .
  op __ : CafeOpDeclSet CafeOpDeclSet -> CafeOpDeclSet [ctor assoc comm id: none format(d ni d)] .

  op op_:_->_ : Qid TypeList Type -> CafeOpDecl [ctor format(g o g o g o o )] .
  op eq_=_. : Term Term -> CafeEquation [ctor format(g o g o g o )] .
  op ceq_=_if_. : Term Term EqCondition -> CafeEquation [ctor format(g o g o g o o o )] .
  op bceq_=_if_. : Term Term EqCondition -> BehaviorEquation [ctor format(g o g o g o o o)] .
  op pr`(_`) : ModuleExpression -> Import [ctor] .
  op ex`(_`) : ModuleExpression -> Import [ctor] .
  op inc`(_`) : ModuleExpression -> Import [ctor] .
  op us`(_`) : ModuleExpression -> Import [ctor] .
  op none : -> HiddenSortDecl [ctor] .
  op cmod*_`{_____`} : Header ImportList HiddenSortDecl CafeOpDeclSet CafeDeclSet
                       CafeEquationSet -> CafeModule
                       [ctor gather(& & & & & &) format(d d s n++i ni d d ni n--i d)] .
  op emptyCafeModule : -> CafeModule .
endfm

fmod OPERATOR-Cafe is
  including CafeSIGN .
  including UNIT .

  sorts Bop2op Bop2opList DoubleResultPair TypeConstants TypeConstantsList
        Combine4TupleResult RuleConditionPair MetaTermTriple MetaTermTripleSet .
  subsorts Bop2op < Bop2opList .
  subsorts TypeConstants < TypeConstantsList .
  subsorts MetaTermTriple < MetaTermTripleSet .

  op `[_;_`] : CafeDecl OpDecl -> Bop2op [ctor format (o o r o o o)] .
  op nil : -> Bop2opList [ctor] .
  op __ : Bop2opList Bop2opList -> Bop2opList [assoc comm id: nil ctor prec 121 gather (e E)] .
  op <_;_> : Bop2opList SModule -> DoubleResultPair [ctor] .
  op getBOP2OP : [Bop2opList] [Qid] -> [Bop2op] .
  op getBOP : Bop2op -> Qid .
  op getOP : Bop2op -> Qid .
  op getObvdType : Bop2op -> Type .
  op getTransitions : CafeDeclSet -> CafeDeclSet .
  op getHiddenSortDecl : CafeModule -> HiddenSortDecl .
  op getCafeDeclSet : CafeModule -> CafeDeclSet .
  op getSort : HiddenSortDecl -> Sort .
  op getName : CafeModule -> Header .
  op getImports : CafeModule -> ImportList .
  op getSorts : CafeModule -> SortSet .
  op getEqs : CafeModule -> CafeEquationSet .
  op getPars : CafeModule -> ParameterDeclList .
  op getOps : CafeModule -> CafeOpDeclSet .
  op getInitialState : CafeModule -> Constant .
  op getConditionOps : CafeModule -> QidList .
  op getConditionOpsAux : CafeOpDeclSet Type -> QidList .
  op setHiddenSortDecl : CafeModule HiddenSortDecl -> CafeModule .
  op setCafeDeclSet : CafeModule CafeDeclSet -> CafeModule .
  op setName : CafeModule Header -> CafeModule .
  op setImports : CafeModule ImportList -> CafeModule .
  op setOps : CafeModule CafeOpDeclSet -> CafeModule .
  op setEqs : CafeModule CafeEquationSet -> CafeModule .
  op setPars : CafeModule ParameterDeclList -> CafeModule .
  op setSubsorts : CafeModule SubsortDeclSet -> CafeModule .
  op setSorts : CafeModule SortSet -> CafeModule .
  op addHiddenSortDecl : HiddenSortDecl CafeModule -> CafeModule .
  op addCafeDeclSet : CafeDeclSet CafeModule -> CafeModule .
  op addImports : ImportList CafeModule -> CafeModule .
  op addEqs : CafeEquationSet CafeModule -> CafeModule .
  op addSorts : SortSet CafeModule -> CafeModule .
  op addOps : CafeOpDeclSet CafeModule -> CafeModule .
  op empty : CafeModule -> CafeModule .

  vars H H' : Header .
  vars IL IL' : ImportList .
  vars HSD HSD' : HiddenSortDecl .
  vars CafeOPDS CafeOPDS' : CafeOpDeclSet .
  vars OPDS OPDS' : OpDeclSet .
  vars CafeDS CafeDS' : CafeDeclSet .
  vars EqS EqS' EqCS : EquationSet .
  vars CafeEqS CafeEqS' : CafeEquationSet .
  var SS : SortSet .
  vars S HS : Sort .
  var RIS? : [RuleSet] .
  vars U CafeM : CafeModule .
  vars U' U'' M : Module .
  var ME' : ModuleExpression .
  var PDL : ParameterDeclList .
  var MAS : MembAxSet .
  var SSDS : SubsortDeclSet .
  var FM : FModule .
  vars OPS QL CS CS' : QidList .
  vars TCL TCL' : TypeConstantsList .
  var GTL : GroundTermList .
  vars TL TL' TL'' : TermList .
  vars T T' T'' T3 OT BV SV OT' BV' SV' : Term .
  vars Attr AttrS AttrS' : AttrSet .
  vars V V' : Variable .
  vars EqC EqC' : EqCondition .
  var CON : Constant .
  var RlC : Condition .
  var Rl : Rule .
  var RlS : RuleSet .
  var RP : ResultPair .
  var Eq : Equation .
  vars MTTS MTTS' : MetaTermTripleSet .
  var BOP2OP : Bop2op .
  vars MTT MTT' : MetaTermTriple .
  vars Ty Ty' Ty'' : Type .
  vars TyL TyL' : TypeList .
  vars OP OP' OP'' C C'   : Qid .
  var BOPL : Bop2opList .

  op nil : -> TypeConstants .
  op __ : TypeConstantsList TypeConstantsList -> TypeConstantsList [assoc comm id: nil] .
  op `[_;_`] : Type QidList -> TypeConstants [ctor format (o o r o o o)] .
  op add2TypeConstants : Qid TypeConstants -> TypeConstants .
  op getConstants : Type TypeConstantsList -> QidList .
  op <_;_;_> : TermList TermList AttrSet -> Combine4TupleResult .
  op <_;_> : EqCondition RuleSet -> RuleConditionPair .
  op none : -> RuleConditionPair .
  op getVariables : Term -> TermList .
  op getVariables : TermList -> TermList .
  op getVariables : Equation -> TermList .
  op getVariables : EqCondition -> TermList .
  op combineVariables : TermList TermList -> TermList .
  op inVars : Variable TermList -> Bool .
  op substitute : Qid Variable Equation -> Equation .
  op substitute : Qid Variable Term -> Term .
  op substitute : Qid Variable TermList -> TermList .
  op substitute : Qid Variable EqCondition -> EqCondition .
  op getEquations : Constant EquationSet -> EquationSet .
  op getEquations : Term EquationSet -> EquationSet .
  op contains : Term Constant -> Bool .
  op contains : TermList Constant -> Bool .
  op removeConditionEqs : EquationSet EquationSet -> EquationSet .
  op removeConditionEqC : EquationSet EqCondition -> EqCondition .
  op replaceConditionParts : EquationSet FModule -> EquationSet .

  op getConditionEqs : QidList EquationSet -> EquationSet .
  op combineRules : RuleConditionPair -> Rule .
  op combineLRA : RuleSet -> Combine4TupleResult .
  op replaceTerm : Term Term Term -> Term .
  op replaceTermList : TermList Term Term -> TermList .
  op replaceCondition : EqCondition Term Term -> EqCondition .
  op buildVar : Type TermList -> Qid .
  op buildVarAux : TermList -> Qid .
  op <_`,_`,_`,_> : Term Qid Term Term -> MetaTermTriple [ctor] .
  op empty : -> MetaTermTripleSet [ctor] .
  op __ : MetaTermTripleSet MetaTermTripleSet -> MetaTermTripleSet [assoc comm id: empty] .
  op getCafeTerm : MetaTermTriple -> Term .
  op getObsOP : MetaTermTriple -> Qid .
  op getObsVal : MetaTermTriple -> Term .
  op getSuccVal : MetaTermTriple -> Term .
  op hasCafeTerm : MetaTermTripleSet Term -> Bool .
  op getMTT : MetaTermTripleSet Term -> MetaTermTriple .
  op setCafeTerm : MetaTermTriple Term -> MetaTermTriple .
  op setObsOP : MetaTermTriple Qid -> MetaTermTriple .
  op setObsVal : MetaTermTriple Term -> MetaTermTriple .
  op setSuccVal : MetaTermTriple Term -> MetaTermTriple .
  op term2string : TermList -> String .
  op getConstantsList : Module TypeList -> TypeConstantsList .
  op getConstantsListAux1 : OpDeclSet TypeList -> TypeConstantsList .
  op getConstantsListAux2 : OpDeclSet Type -> TypeConstants .
  op add2TypeList : TypeList TypeList -> TypeList .
  op getNewCafeTerm : Bop2opList TermList Type MetaTermTripleSet -> TermList .
  op getNewCafeTermAux : Bop2opList Term MetaTermTripleSet -> TermList .
  op initialObsSuccValue : Term MetaTermTripleSet -> Term .
  op initialObsSuccValueAux : TermList MetaTermTripleSet -> TermList .
  op buildLHS : MetaTermTripleSet -> Term .
  op buildLHSAux : MetaTermTripleSet -> TermList .
  op buildRHS : MetaTermTripleSet -> Term .
  op buildRHSAux : MetaTermTripleSet -> TermList .
  op buildObsSuccValue : MetaTermTripleSet -> MetaTermTripleSet .
  op buildObsSuccValueAux : MetaTermTripleSet MetaTermTripleSet -> MetaTermTripleSet .
  op isSetExp : Type -> Bool .
  op isOccurs : Type TypeList -> Bool .

  eq getBOP2OP (([(bop OP : TyL -> Ty ) ; (op OP' : TyL' -> Ty' [Attr] .)] BOPL), OP) =
      [(bop OP : TyL -> Ty ) ; (op OP' : TyL' -> Ty' [Attr] .)] .
  eq getBOP ([(bop OP : TyL -> Ty ) ; (op OP' : TyL' -> Ty' [Attr] .)]) = OP .
  eq getOP ([(bop OP : TyL -> Ty ) ; (op OP' : TyL' -> Ty' [Attr] .)]) = OP' .
  eq getObvdType ([(bop OP : TyL -> Ty ) ; (op OP' : TyL' -> Ty' [Attr] .)]) = Ty .
  eq getBOP2OP (BOPL, OP) = nil [owise] .

  eq getConditionOps (CafeM) =
      getConditionOpsAux (getOps (CafeM), getSort (getHiddenSortDecl (CafeM))) .
  eq getConditionOpsAux ((op OP : S TyL -> 'Bool ) CafeOPDS, S) = OP getConditionOpsAux (CafeOPDS, S) .
  eq getConditionOpsAux (CafeOPDS, S) = nil [owise] .

  eq emptyCafeModule = cmod* nullHeader {nil none none none none} .
  eq getInitialState (cmod* H {IL * [S] * CafeOPDS CafeDS CafeEqS}) = qid ("init." + string (S)) .
  eq getSort ((* [S] *)) = S .
  eq getHiddenSortDecl (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = HSD .
  eq getCafeDeclSet (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = CafeDS .
  eq getName (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = H .
  eq getImports (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = IL .
  eq getSorts (cmod* H {IL * [SS] * CafeOPDS CafeDS CafeEqS}) = SS .
  eq getSorts (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = none [owise] .
  eq getOps (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = CafeOPDS .
  eq getEqs (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = CafeEqS .
  eq getPars (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = nil .
  eq getTransitions ((bop OP : Ty TyL -> Ty ) CafeDS) = (bop OP : Ty TyL -> Ty ) getTransitions (CafeDS) .
  eq getTransitions (none) = none .
  ceq getTransitions ((bop OP : Ty TyL -> Ty' ) CafeDS) = getTransitions (CafeDS) if Ty =/= Ty' .

  eq setHiddenSortDecl (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, HSD') = cmod* H {IL HSD' CafeOPDS CafeDS CafeEqS} .
  eq setName (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, ME') = cmod* ME' {IL HSD CafeOPDS CafeDS CafeEqS} .
  eq setCafeDeclSet (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, CafeDS') = cmod* H {IL HSD CafeOPDS CafeDS' CafeEqS} .
  eq setImports (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, IL') = cmod* H {IL' HSD CafeOPDS CafeDS CafeEqS} .
  eq setSorts (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, SS) =
                cmod* H {IL * [SS] * CafeOPDS CafeDS CafeEqS} .
  eq setOps (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, CafeOPDS') = cmod* H {IL HSD CafeOPDS' CafeDS CafeEqS} .
  eq setEqs (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, CafeEqS') = cmod* H {IL HSD CafeOPDS CafeDS CafeEqS'} .
  eq setPars (CafeM, PDL) = CafeM .

  eq empty (CafeM) = emptyCafeModule .
  eq setSubsorts (CafeM, SSDS) = CafeM .

  eq addHiddenSortDecl (HSD, CafeM) = setHiddenSortDecl (CafeM, HSD) .
  eq addCafeDeclSet (CafeDS, CafeM) = setCafeDeclSet (CafeM, (CafeDS getCafeDeclSet (CafeM))) .
  eq addEqs (CafeEqS, CafeM) = setEqs (CafeM, CafeEqS getEqs (CafeM)) .
  eq addImports (IL, CafeM) = setImports (CafeM, IL getImports (CafeM)) .
  eq addOps (CafeOPDS, CafeM) = setOps (CafeM, CafeOPDS getOps (CafeM)) .
  eq addSorts (SS, CafeM) = setSorts (CafeM, SS ; getSorts (CafeM)) .
  eq add2TypeConstants (OP, [Ty ; OPS]) = [Ty ; OP OPS] .

  eq getConstants (Ty, [Ty ; OPS] TCL) = OPS .
  eq getConstants (Ty, TCL) = nil [owise] .

  eq replaceCondition ((T = T'), T'', T3) = (replaceTerm (T, T'', T3) = replaceTerm (T', T'', T3)) .
  eq replaceCondition ((T : Ty), T', T'') = (replaceTerm (T, T', T'') : Ty) .
  eq replaceCondition ((T := T'), T'', T3) = (replaceTerm (T, T'', T3) := replaceTerm (T', T'', T3)) .
  eq replaceCondition ((EqC /\ EqC'), T, T') = (replaceCondition (EqC, T, T') /\ replaceCondition (EqC', T, T')) .
  eq replaceCondition (nil, T, T') = nil .

  eq buildVar (Ty, TL) = if TL =/= empty then qid (string (Ty) + string (buildVarAux (TL))) else qid (string (Ty) + "@") fi .
  ceq buildVarAux ((T, TL)) = qid (string (getName (T)) + string (buildVarAux (TL))) if TL =/= empty .
  eq buildVarAux (T) = getName (T) .
  eq buildVarAux (empty) = nil .

  eq replaceTerm (T, T, T'') = T'' .
  ceq replaceTerm (T, T', T'') = OP [replaceTermList (TL, T', T'')] if OP [TL] := T .
  eq replaceTerm (T, T', T'') = T [owise] .
  eq replaceTermList ((T, TL), T', T'') = (replaceTerm (T, T', T''), replaceTermList (TL, T', T'')) .
  eq replaceTermList (empty, T, T') = empty .

  ceq combineRules (< EqC ; RlS >) = if TL'' :: NeTermList then (crl '__ [TL] => '__ [TL'] if EqC [AttrS] .) else (crl TL => TL' if EqC [AttrS] .) fi
    if < TL ; TL' ; AttrS > := combineLRA (RlS) /\ (T, TL'') := TL .
  eq combineRules (none) = none .
  ceq combineLRA ((rl T => T' [AttrS] .) RlS) = < (T, TL) ; (T', TL') ; (AttrS AttrS') > if < TL ; TL' ; AttrS' > := combineLRA (RlS) .
  eq combineLRA (none) = < empty ; empty ; none > .

  ceq getConditionEqs (OP QL, EqS) = getConditionEqs (OP, EqS) getConditionEqs (QL, EqS) if QL =/= (nil) .TypeList .
  eq getConditionEqs (OP, (eq OP [TL] = T' [AttrS] .) EqS) = (eq OP [TL] = T' [AttrS] .) getConditionEqs (OP, EqS) .
  eq getConditionEqs (OP, none) = none .
  eq getConditionEqs (OP, EqS) = none [owise] .
  eq getConditionEqs (nil, EqS) = none .

  eq removeConditionEqs (EqCS, (ceq T = T' if EqC [AttrS] .) EqS) =
      (ceq T = T' if removeConditionEqC (EqCS, EqC) [AttrS] .) removeConditionEqs (EqCS, EqS) .
  eq removeConditionEqs (EqCS, none) = none .
  eq removeConditionEqs (EqCS, EqS) = EqS [owise] .
  eq removeConditionEqC (((eq T = T'' [AttrS] .) EqCS), (T = T')) = (T'' = T') .
  eq removeConditionEqC (((eq T = T'' [AttrS] .) EqCS), (T := T')) = (T'' := T') .
  eq removeConditionEqC (((eq T = T'' [AttrS] .) EqCS), (T : S)) = (T'' : S) .
  eq removeConditionEqC (EqCS, (EqC /\ EqC')) = removeConditionEqC (EqCS, EqC) /\ removeConditionEqC (EqCS, EqC) .
  eq removeConditionEqC (EqCS, EqC) = EqC [owise] .

  ceq replaceConditionParts (((ceq T = T' if T'' = 'true.Bool [AttrS] .) EqS), FM) =
    ((ceq T = T' if getTerm (RP) = 'true.Bool [AttrS] .) replaceConditionParts (EqS, FM))
   if RP := metaReduce (FM, T'') /\ RP :: ResultPair .
  eq replaceConditionParts (none, FM) = none .
  eq replaceConditionParts (EqS, FM) = EqS [owise] .

  eq contains (OP [TL], CON) = contains (TL, CON) .
  eq contains (CON, CON) = true .
  eq contains (T, CON) = false [owise] .
  ceq contains ((T, TL), CON) = contains (T, CON) or contains (TL, CON) if TL =/= (empty) .EmptyCommaList .
  eq contains (empty, CON) = false .

  eq getEquations (CON, (eq T = T' [AttrS] .) EqS) =
      if contains (T, CON) then ((eq T = T' [AttrS] .) getEquations (CON, EqS)) else getEquations (CON, EqS) fi .
  eq getEquations (CON, EqS) = none [owise] .

  eq substitute (C, V, (eq T = T' [AttrS] .)) = (eq substitute (C, V, T) = substitute (C, V, T') [AttrS] .) .
  eq substitute (C, V, (ceq T = T' if EqC [AttrS] .)) = (ceq substitute (C, V, T) = substitute (C, V, T') if substitute (C, V, EqC) [AttrS] .) .
  eq substitute (C, V, OP [TL]) = if TL :: GroundTermList then OP [TL] else OP [substitute (C, V, TL)] fi .
  eq substitute (C, V, T) = if T == V then qid (string (C) + "." + string (getType (V))) else T fi .
  eq substitute (C, V, (T, TL)) = (substitute (C, V, T), substitute (C, V, TL)) .
  eq substitute (C, V, empty) = empty .
  ceq substitute (C, V, (EqC /\ EqC')) =
    (substitute (C, V, EqC) /\ substitute (C, V, EqC'))
   if EqC' =/= (nil) .EqCondition and EqC =/= (nil).EqCondition .
  eq substitute (C, V, (T := T')) = (substitute (C, V, T) := substitute (C, V, T')) .
  eq substitute (C, V, (T = T')) = (substitute (C, V, T) = substitute (C, V, T')) .
  eq substitute (C, V, (T : S)) = (substitute (C, V, T) := S) .
  eq substitute (C, V, (nil) .EqCondition) = (nil) .EqCondition .

  ceq getVariables ((EqC /\ EqC')) =
    combineVariables (getVariables (EqC), getVariables (EqC'))
   if EqC' =/= (nil) .EqCondition and EqC =/= (nil).EqCondition .
  eq getVariables ((T := T')) = getVariables (T) .
  eq getVariables ((T = T')) = getVariables (T) .
  eq getVariables ((T : S)) = getVariables (T) .
  eq getVariables ((nil) .EqCondition) = empty .

  eq inVars (V, (V', TL)) = if V == V' then true else inVars (V, TL) fi .
  eq inVars (V, empty) = false .

  eq combineVariables ((V, TL), TL') =
      if inVars (V, TL') then combineVariables (TL, TL') else combineVariables (TL, (V, TL')) fi .
  eq combineVariables (empty, TL) = TL .

  eq getVariables (OP [TL]) = if TL :: GroundTermList then empty else getVariables (TL) fi .
  eq getVariables (T) = if T :: Variable then T else empty fi .
  eq getVariables ((T, TL)) = combineVariables (getVariables (T), getVariables (TL)) .
  eq getVariables (empty) = empty .
  eq getVariables (eq T = T' [AttrS] .) = getVariables (T) .
  eq getVariables (ceq T = T' if EqC [AttrS] .) = combineVariables (getVariables (T), getVariables (EqC)) .

  eq isOccurs (Ty, (Ty' TyL)) = if Ty == Ty' then true else isOccurs (Ty, TyL) fi .
  eq isOccurs (Ty, nil) = false .

  ceq add2TypeList ((Ty TyL), TyL') =
     if not isOccurs (Ty, TyL') then add2TypeList (TyL, (Ty TyL')) else add2TypeList (TyL, TyL') fi
    if TyL =/= nil .
  eq add2TypeList (Ty, TyL) = if not isOccurs (Ty, TyL) then (Ty TyL) else TyL fi .
  eq add2TypeList (nil, TyL) = TyL .

  eq isSetExp (Ty) = false [owise] .
  ceq isSetExp (Ty) = true if length (string (Ty)) > 3 and substr(string (Ty), sd (length (string (Ty)), 3), length (string (Ty))) == "Set" .

  eq getConstantsList (M, TyL) = getConstantsListAux1 (getOps(M), TyL) .
  eq getConstantsListAux1 (OPDS, Ty TyL) = (getConstantsListAux2 (OPDS, Ty)) getConstantsListAux1 (OPDS, TyL) .
  eq getConstantsListAux1 (OPDS, nil) = nil .
  ceq getConstantsListAux2 ((op OP : TyL' -> Ty [Attr] .) OPDS, Ty') =
    if Ty == Ty' and TyL' == nil then
     add2TypeConstants (OP, getConstantsListAux2(OPDS, Ty')) else getConstantsListAux2 (OPDS, Ty') fi
   if not isSetExp (Ty') .
  ceq getConstantsListAux2 ((op OP : TyL' -> Ty  [Attr] .) OPDS, Ty') =
    if Ty == Ty'' and TyL' == nil then
     add2TypeConstants (OP, getConstantsListAux2 (OPDS, Ty')) else
     getConstantsListAux2 (OPDS, Ty') fi
    if isSetExp (Ty') /\ Ty'' := qid (substr(string (Ty'), 0, sd (length (string (Ty')), 3))) .
  eq getConstantsListAux2 (none, Ty) = [Ty ; nil] .

  ceq term2string ((T, TL)) = string (getName (T)) + term2string (TL) if TL =/= empty /\ T :: Variable .
  eq term2string (empty) = "" .
  ceq term2string (T) = string (getName (T)) if T :: Variable .
  eq term2string ((T, TL)) = term2string (TL) [owise] .

  eq buildObsSuccValue (MTTS) = buildObsSuccValueAux (MTTS, empty) .
  eq buildObsSuccValueAux (empty, MTTS) = MTTS .
  eq buildObsSuccValueAux (MTT, MTTS) = (setSuccVal (MTT, initialObsSuccValue (getSuccVal (MTT), (MTT MTTS))) MTTS) .
  ceq buildObsSuccValueAux ((MTT MTTS), MTTS') =
    buildObsSuccValueAux (MTTS, (MTT' MTTS'))
    if MTTS =/= empty /\
     MTT' := setSuccVal (MTT, initialObsSuccValue (getSuccVal (MTT), (MTT MTTS MTTS'))) /\
     MTT' :: MetaTermTriple .
  eq buildObsSuccValueAux (MTTS, MTTS') = MTTS' [owise] .

  eq buildRHS (< OP [T, TL], OP', BV, SV >) = (OP' [TL, SV]) .
  ceq buildRHS (< OP [T, TL], OP', BV, SV > MTTS) = '__ [OP' [TL, SV], buildRHSAux (MTTS)] if MTTS =/= empty .
  eq buildRHSAux (MTT MTTS) = (buildRHS (MTT), buildRHSAux (MTTS)) .
  eq buildRHSAux (empty) = empty .

  eq buildLHS (< OP [T, TL], OP', BV, SV >) = (OP' [TL, BV]) .
  ceq buildLHS (< OP [T, TL], OP', BV, SV > MTTS) = '__ [OP' [TL, BV], buildLHSAux (MTTS)] if MTTS =/= empty .
  eq buildLHSAux (MTT MTTS) = (buildLHS (MTT), buildLHSAux (MTTS)) .
  eq buildLHSAux (empty) = empty .

  ceq initialObsSuccValue (T, MTTS) = getObsVal (MTT) if MTT := getMTT (MTTS, T) /\ MTT =/= empty .
  ceq initialObsSuccValue (OP [TL], MTTS) = (OP [initialObsSuccValueAux (TL, MTTS)]) if not hasCafeTerm (MTTS, OP [TL]) .
  eq initialObsSuccValue (T, MTTS) = T [owise] .
  eq initialObsSuccValueAux (empty, MTTS) = empty .
  eq initialObsSuccValueAux ((T, TL), MTTS) = (initialObsSuccValue (T, MTTS), initialObsSuccValueAux (TL, MTTS)) .

  eq getMTT ((< OT, OP, BV, SV > MTTS), OT) = < OT, OP, BV, SV > .
  eq getMTT (MTTS, OT) = empty [owise] .

  ceq getNewCafeTerm (BOPL, (T, TL), Ty, MTTS) =
    (getNewCafeTerm (BOPL, T, Ty, MTTS), getNewCafeTerm (BOPL, TL, Ty, MTTS)) if TL =/= empty .
  eq getNewCafeTerm (BOPL, empty, Ty, MTTS) = empty .
  ceq getNewCafeTerm (BOPL, OP [T, TL], Ty, MTTS) =
    getNewCafeTermAux (BOPL, OP [T, TL], MTTS) if (T :: Constant or T :: Variable) /\ getType (T) == Ty .
  ceq getNewCafeTermAux (BOPL, OP [T, TL], MTTS) = empty if hasCafeTerm (MTTS, OP [T, TL]) .
  ceq getNewCafeTermAux (BOPL, OP [T, TL], MTTS) =
    (OP [T, TL]) if not hasCafeTerm (MTTS, OP [T, TL]) /\ BOP2OP := getBOP2OP (BOPL, OP) /\ BOP2OP =/= nil .
  eq getNewCafeTermAux (BOPL, T, MTTS) = empty [owise] .
  ceq getNewCafeTerm (BOPL, T, Ty, MTTS) = empty if T :: Constant or T :: Variable .
  eq getNewCafeTerm (BOPL, OP [T, TL], Ty, MTTS) =
    (getNewCafeTerm (BOPL, T, Ty, MTTS), getNewCafeTerm (BOPL, TL, Ty, MTTS)) [owise] .

  eq getCafeTerm (< OT, OP, BV, SV >) = OT .
  eq getObsOP (< OT, OP, BV, SV >) = OP .
  eq getObsVal (< OT, OP, BV, SV >) = BV .
  eq getSuccVal (< OT, OP, BV, SV >) = SV .
  eq setCafeTerm (< OT, OP, BV, SV >, OT') = < OT', OP, BV, SV > .
  eq setObsOP (< OT, OP, BV, SV >, OP') = < OT, OP', BV, SV > .
  eq setObsVal (< OT, OP, BV, SV >, BV') = < OT, OP, BV', SV > .
  eq setSuccVal (< OT, OP, BV, SV >, SV') = < OT, OP, BV, SV' > .
  eq hasCafeTerm ((< OT, OP, BV, SV > MTTS), OT) = true .
  eq hasCafeTerm (MTTS, OT) = false [owise] .
endfm

***(%
\end{comment}
}

\subsection{Parsing\label{subsec:parsing}}

The module \verb"CafeDECL-PARSING" is in charge of parsing a term built following
the syntactical constructions presented above:

{\codesize
\begin{verbatim}
%)

view SortSet from TRIV to META-LEVEL is
 sort Elt to SortSet .
endv

fmod CafeDECL-PARSING is
  inc UNIT-DECL-PARSING .
  inc OPERATOR-Cafe .
  pr SCORE-INFO-MAP .
  pr MAP{Qid, Qid} * (sort Map{Qid, Qid} to SortMap,
                      op undefined to undefinedQQ) .
  pr MAP{Qid, SortSet} * (op _|->_ to _->_,
                          sort Map{Qid, SortSet} to TheorySortMap) .

***(%
\end{verbatim}
}

It defines the sort \verb"CafeParseResult" to return the result of the parsing process.
The is composed of:
\begin{itemize}
\item
A term of sort \verb"ParseDeclResult". This sort, defined in Full Maude, keeps
the module obtained thus far, another module still containing bubbles, and a set of
operator declarations standing for the declaration of variables on the fly.

\item
A list of quoted identifiers, that will propagate the errors found during the
parsing process.

\item
A database, that will be updated with the new module or view if the parsing is
successful.
\end{itemize}

{\codesize
\begin{verbatim}
%)

  sort CafeParseResult .
  op <_,_,_,_> : ParseDeclResult QidList SortSet Database -> CafeParseResult [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  vars T T' T'' T''' T3 T4 TV TS TOTF TOTF' TOTF'' : Term .
  vars S S' S'' : Term .
  vars TL TL' TL'' : TermList .
  var  CafeM : CafeModule .
  vars VDS VDS' : OpDeclSet .
  var  PDR : ParseDeclResult .
  vars F O QI Q Q' Q'' : Qid .
  var  H : Header .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RIS : RuleSet .
  var  IL : ImportList .
  vars SS SS' : SortSet .
  vars QIL' QIL QL QL' QL'' : QidList .
  vars PU U PU' U' M M' : Module .
  var  M? : Module .
  vars HS Srt Srt' : Sort .
  var  CafeDS : CafeDeclSet .
  var  CafeD  : CafeDecl .
  var  TyL : TypeList .
  vars Ty Ty' : Type .
  vars DB DB' DB'' : Database .
  var  RP : [ResultPair] .
  var  N : Nat .
  var  B : Bool .
  var  PDL : ParameterDeclList .
  var  ME : ModuleExpression .
  vars SM SM' VM VM' PSM PSM' : SortMap .
  var  HSM HSM' : TheorySortMap .
  var  V : Variable .
  var  C : Constant .
  vars St St' St'' St''' : String .
  var  TSM : TheorySortMap .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}

The function \verb"unfoldCafeOpDecl" ``unfolds'' the operator names defined in a
multiple definition by means of \verb"ops" or \verb"bops":
%)

  op unfoldCafeOpDecl : QidList TypeList Sort -> CafeOpDeclSet .
  eq unfoldCafeOpDecl((QI QIL), TyL, Ty) = (op QI : TyL -> Ty)
                                           unfoldCafeOpDecl(QIL, TyL, Ty) .
  eq unfoldCafeOpDecl(nil, TyL, Ty) = none .

  op unfoldCafe : QidList TypeList Sort -> CafeDeclSet .
  ceq unfoldCafe((QL QIL), TyL , Ty) = CafeD unfoldCafe(QIL, TyL, Ty)
   if CafeD := (bop QL : TyL -> Ty ) .
  eq unfoldCafe(nil, TyL, Ty) = none .

***(%
\end{comment}
}

{\codesize
\begin{comment}
%)

  ***parse imported expression
  op parseCafeDecl : Term CafeModule -> CafeModule .
  ceq parseCafeDecl('protecting`(_`)[T], CafeM) = addImports((protecting parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('pr`(_`)[T], CafeM) = addImports((protecting parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('extending`(_`)[T], CafeM) = addImports((extending parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('ex`(_`)[T], CafeM) = addImports((extending parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('including`(_`)[T], CafeM) = addImports((including parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('inc`(_`)[T], CafeM) = addImports((including parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('using`(_`)[T], CafeM) = addImports((including parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('us`(_`)[T], CafeM) = addImports((including parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .

***(%
\end{comment}
}

\begin{comment}

In the same way, the function \verb"parseCafeModExp" transforms the CafeOBJ syntax
for module expressions into Maude syntax. Note that the syntax for tokens is also
translated when required:

{\codesize
\begin{verbatim}
%)

  op parseCafeModExp : Term -> ModuleExpression .
  eq parseCafeModExp('CafeToken[T]) = 'token[T] .
  eq parseCafeModExp('token[T]) = 'token[T] .
  ceq parseCafeModExp('_`(_`)[T, T']) = '_`{_`}[T'', T''']
   if T'' := parseCafeModExp(T) /\
      T''' := parseCafeViewExp(T') .
  ceq parseCafeModExp('_*`{_`}[T, T']) = '_*`(_`)[T'', T''']
   if T'' := parseCafeModExp(T) /\
      T''' := parseCafeRen(T') .
  ceq parseCafeModExp('_+_[T, T']) = '_+_[T'', T''']
   if T'' := parseCafeModExp(T) /\
      T''' := parseCafeModExp(T') .

***(%
\end{verbatim}
}

\end{comment}

The function \verb"parseCafeRen" translates CafeOBJ renamings. Note that
the renaming for hidden sorts is translated as a renaming for standard sorts, since
there is no hidden sorts in Maude:

{\codesize
\begin{verbatim}
%)

  op parseCafeRen : Term -> Term .
  ceq parseCafeRen('__[T, T']) = '_`,_[T'', T3]
   if T'' := parseCafeRen(T) /\
      T3 := parseCafeRen(T') .
  ceq parseCafeRen('sort_->_.[T, T']) = 'sort_to_[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .
  ceq parseCafeRen('hsort_->_.[T, T']) = 'sort_to_[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .
  eq parseCafeRen('op_->_.['CafeBubble[T], 'CafeBubble[T']]) =
                                    'op_to_['token[T], 'token[T']] .
  eq parseCafeRen('bop_->_.['CafeBubble[T], 'CafeBubble[T']]) =
                                    'op_to_['token[T], 'token[T']] .
  eq parseCafeRen(T) = T [owise] .

***(%
\end{verbatim}
}

The function \verb"sort2sort" translates CafeOBJ tokens into Maude tokens
for sorts, while \verb"parseCafeViewExp" translates view tokens:

{\codesize
\begin{verbatim}
%)

  op sort2sort : Term -> Term .
  eq sort2sort('CafeToken[T]) = 'sortToken[T] .
  eq sort2sort(T) = T [owise] .

  op parseCafeViewExp : Term -> ViewExp .
  eq parseCafeViewExp('token[T]) = 'viewToken[T] .
  eq parseCafeViewExp(T) = T [owise] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  *** parse hiddensort and sort
  ceq parseCafeDecl('*`[_`]*[T], CafeM) = addHiddenSortDecl((*[ HS ]*), CafeM)
   if HS := parseHiddenSort(T) .
  eq parseCafeDecl('`[_`]['neCafeTokenList[T]], CafeM) = addSorts(parseSortSet(addSortToken(T)), CafeM) .
  eq parseCafeDecl('`[_`]['CafeToken[T]], CafeM) =
         addSorts(parseSortSet('sortToken[T]), CafeM) .
  eq  parseCafeDecl('op_:`->_`{_`}.['CafeToken[T], 'CafeToken[T'], T''],  CafeM) =
        addOps((op downQid(T) : nil -> parseType('sortToken[T'])), CafeM) .
  eq  parseCafeDecl('op_:`->_`{_`}.['__[TL], 'CafeToken[T'], T''],  CafeM) =
        addOps((op tokenList2token(TL) : nil -> parseType('sortToken[T'])), CafeM) .

  ***parse normal operators
  eq parseCafeDecl('op_:`->_.['CafeToken[T], 'CafeToken[T']], CafeM) =
          addOps((op downQid(T) : nil -> parseType(cafeType2maudeType(T')) ), CafeM) .

  eq parseCafeDecl('ops_:`->_.['neCafeTokenList[T], 'CafeToken[T']], CafeM) =
      addOps(unfoldCafeOpDecl(downTypes(T), nil, parseType('sortToken[T'])), CafeM) .

  ceq parseCafeDecl('op_:_->_.['CafeToken[T], T', 'CafeToken[T'']], CafeM ) =
       addOps((op downQid(T) : parseTypeList(T4) -> parseType('sortToken[T''])), CafeM)
   if T4 := addSortToken(T') .

  ceq parseCafeDecl('pred_:_.['CafeToken[T], T'], CafeM ) =
        addOps((op downQid(T) : parseTypeList(T4) -> 'Bool), CafeM)
   if T4 := addSortToken(T') .

  ceq parseCafeDecl('ops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], CafeM) =
        addOps(unfoldCafeOpDecl(downTypes(T), parseTypeList(T4), parseType('sortToken[T''])), CafeM)
   if T4 := addSortToken(T') .

  ***ceq parseCafeDecl('op_:_->_`{_`}.['CafeToken[T], T', 'CafeToken[T''], T'''], CafeM) =
  ***    addOps((op downQid(T) : parseTypeList(T4) -> parseType('sortToken[T''])
  ***    [parsePreAttrs(T''', size(parseTypeList(T4)))] .), CafeM) if T4 := addSortToken(T') .

  ***parse behavioral operations
  eq parseCafeDecl('bop_:_->_.['CafeToken[T], T', T''], CafeM) =
       parseCafeDecl('bops_:_->_.['neCafeTokenList[T], T', T''], CafeM) .
  eq parseCafeDecl('bop_:_->_`{_`}.['CafeToken[T], T', T'', T'''], CafeM) =
       parseCafeDecl('bops_:_->_.['neCafeTokenList[T], T', T''], CafeM) .
  ceq parseCafeDecl('bops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], CafeM) =
       addCafeDeclSet(unfoldCafe(downTypes(T), parseTypeList(T4), parseType('sortToken[T''])), CafeM)
   if T4 := addSortToken(T') .
  ceq parseCafeDecl('bops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''], CafeM) =
       addCafeDeclSet(unfoldCafe(downTypes(T), parseTypeList(T4), parseType('sortToken[T''])), CafeM)
   if T4 := addSortToken(T') .

  ***parse equations at meta-level
  eq parseCafeDecl('eq_=_.['CafeBubble[T], 'CafeBubble[T']], CafeM) = CafeM . ***addEqs((eq 'T = T' [none] .), CafeM) .
  eq parseCafeDecl('cq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], CafeM) = CafeM .
  eq parseCafeDecl('ceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], CafeM) = CafeM .
   *** addEqs((ceq T = T' if T'' = ''true.Bool [none] .), CafeM) .
   ***to be handled
  eq parseCafeDecl('bceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], CafeM) = CafeM .
  eq parseCafeDecl('bcq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], CafeM) = CafeM .

  eq parseCafeDecl('var_:_.['neCafeTokenList[T], T'], CafeM) = CafeM .
  eq parseCafeDecl('vars_:_.['neCafeTokenList[T], T'], CafeM) = CafeM .

  **************************************
  ***convert to Functional Module
  **************************************

***(%
\end{comment}
}

The function \verb"parseCafeDecl" uses the function \texttt{parseCafeModExp}
to parse de module expression. Once this expression is obtained it uses the
Full Maude function

{\codesize
\begin{verbatim}
%)

  op parseCafeDecl : Term Module Module OpDeclSet SortMap TheorySortMap Database
     -> CafeParseResult .
  ceq parseCafeDecl('protecting`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('protecting_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('pr`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('protecting_.[T'], PU, U, VDS) .

***(%
  ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('extending`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('extending_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('ex`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('extending_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('inc`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('including`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('using`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('us`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB' >
   if TS := changeTheoryByModule(T, isATheory(U), DB) /\
      < T', DB' > := parseCafeModExp(TS, PSM, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .

  op changeTheoryByModule : Term Bool Database -> Term .
  ceq changeTheoryByModule(Q[TL], B, DB) = Q[TL']
   if Q =/= 'token /\
      TL' := changeTheoryByModule*(TL, B, DB) .
  ceq changeTheoryByModule('token[T], B, DB) = T'
   if Q := downQid(T) /\
      Q' := qid(string(Q) + "-MODCAFE") /\
      T' := 'token[upTerm(Q')] /\
      not B /\
      M := getTopModule(Q, DB) /\
      isATheory(M) .
  eq changeTheoryByModule(T, B, DB) = T [owise] .

  op changeTheoryByModule* : TermList Bool Database -> TermList .
  eq changeTheoryByModule*(empty, B, DB) = empty .
  eq changeTheoryByModule*((T, TL), B, DB) = changeTheoryByModule(T, B, DB),
                                             changeTheoryByModule*(TL, B, DB) .

  op isATheory : [Module] -> Bool .
  eq isATheory(fth Q is IL sorts SS . SSDS OPDS MAS EqS endfth) = true .
  eq isATheory(th Q is IL sorts SS . SSDS OPDS MAS EqS RIS endth) = true .
  eq isATheory(emptyFTheory) = true .
  eq isATheory(emptySTheory) = true .
  eq isATheory(M?) = false [owise] .

***(%
\end{comment}
}

The function \verb"parseCafeModExp" returns a term of sort \verb"ParseResult".
This sort contains a database and, depending the context where it is applied,
a module expression, a view expression, or a list of terms:

{\codesize
\begin{verbatim}
%)

  sort ParseResult .
  op <_,_> : ModuleExpression Database -> ParseResult [ctor] .
  op <_,_> : ViewExp Database -> ParseResult [ctor] .
  op <_,_> : TermList Database -> ParseResult [ctor] .

***(%
\end{verbatim}
}

Parsing simple module expressions, summations, and expressions with renamings is
straightforward:

{\codesize
\begin{verbatim}
%)

  op parseCafeModExp : Term SortMap Database -> ParseResult .
  eq parseCafeModExp('CafeToken[T], PSM, DB) = < 'token[T], DB > .
  eq parseCafeModExp('token[T], PSM, DB) = < 'token[T], DB > .
  ceq parseCafeModExp('_+_[T, T'], PSM, DB) = < '_+_[T'', T'''], DB'' >
   if < T'', DB' > := parseCafeModExp(T, PSM, DB) /\
      < T''', DB'' > := parseCafeModExp(T', PSM, DB') .
  ceq parseCafeModExp('_*`{_`}[T, T'], PSM, DB) = < '_*`(_`)[T'', T'''], DB' >
   if < T'', DB' > := parseCafeModExp(T, PSM, DB) /\
      T''' := parseCafeRen(T') .

***(%
\end{verbatim}
}

Parsing a module expression involving view expression requires the database, because
we need the list of parameters to deal with on-the-fly view declarations:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeModExp('_`(_`)[T, T'], PSM, DB) = < '_`{_`}[T'', T'''], DB'' >
   if < T'', DB' > := parseCafeModExp(T, PSM, DB) /\
      M := getTopModule(parseModExp(T''), DB') /\
      PDL := getPDL(M) /\
      < T''', DB'' > := parseCafeViewExp(PDL, sortViewId(PDL, T'), PSM, DB') .

***(%
\end{verbatim}
}

Parsing a view identifier requires the parameter list of the module being instantiated,
the view identifier itself, and the database.

{\codesize
\begin{verbatim}
%)

  op parseCafeViewExp : ParameterDeclList Term SortMap Database -> ParseResult .
  ceq parseCafeViewExp(PDL, 'token[T], PSM, DB) = < 'viewToken[T], DB >
   if Q := downQid(T) /\
      isParamName(Q, PDL) .
  ceq parseCafeViewExp(PDL, 'token[T], PSM, DB) = < 'viewToken[T], DB >
   if Q := downQid(T) /\
      getView(Q, DB) :: View .
  ceq parseCafeViewExp(Q :: ME, 'token[T], PSM, DB) = < 'viewToken[T], DB' >
   if Q' := downQid(T) /\
      not getView(Q', DB) :: View /\
      M := getTopModule(ME, DB) /\
      M' := getTopModule(Q', DB) /\
      SS := getSorts(M) /\
      SS' := getSorts(M') /\
      Srt := removePredef(SS) /\
      Srt' := removePredef(SS') /\
      T' := 'sort_to_.['sortToken[upTerm(Srt)], 'sortToken[upTerm(Srt')]] /\
      TV := 'view_from_to_is_endv['token[T], 'token[upTerm(ME)], 'token[T], T'] /\
      DB' := procView(TV, DB) .
  ceq parseCafeViewExp(Q :: ME, 'token[T], PSM, DB) = < 'viewToken[T], DB' >
   if Q' := downQid(T) /\
      not getView(Q', DB) :: View /\
      M := getTopModule(ME, DB) /\
      SS := getSorts(M) /\
      Srt := removePredef(SS) /\
      (Q' |-> Srt', PSM') := PSM /\
      T' := 'sort_to_.['sortToken[upTerm(Srt)], 'sortToken[upTerm(Srt')]] /\
      TV := 'view_from_to_is_endv['token[T], 'token[upTerm(ME)], 'token[T], T'] /\
      DB' := procView(TV, DB) .
  *** The names of the sorts and ops are the same, so it is enough to use the module name.
  ceq parseCafeViewExp(Q :: ME, 'token[T], PSM, DB) = < 'viewToken[T''], DB' >
   if Q' := downQid(T) /\
      not getView(Q', DB) :: View /\
      M := getTopModule(Q', DB) /\
      M' := getTopModule(ME, DB) /\
      SS := getSorts(M') /\
      SS' := removePredef(SS) /\
      T'' := upTerm(newName(M, Q')) /\
      T' := createMapsForSorts(SS') /\
      TV := 'view_from_to_is_endv['token[T''], 'token[upTerm(ME)], 'token[T''], T'] /\
      DB' := procView(TV, DB) [owise] .
  eq parseCafeViewExp(PDL, '_<=_[T, T'], PSM, DB) = parseCafeViewExp(PDL, T', PSM, DB) .
  ceq parseCafeViewExp(PDL, '_`,_[TL], PSM, DB) = < '_`,_[TL'], DB' >
   if < TL', DB' > := parseCafeViewExp*(PDL, TL, PSM, DB) .

  op isParamName : Qid ParameterDeclList -> Bool .
  eq isParamName(Q, nil) = false .
  eq isParamName(Q, (Q' :: ME, PDL)) = if Q == Q'
                                       then true
                                       else isParamName(Q, PDL)
                                       fi .

  op newName : Module Qid -> Qid .
  eq newName(M, Q) = if M :: FTheory or M :: STheory
                     then qid(string(Q) + "-MODCAFE")
                     else Q
                     fi .

  op removePredef : SortSet -> SortSet .
  eq removePredef('Bool ; SS) = removePredef(SS) .
  eq removePredef('Nat ; SS) = removePredef(SS) .
  eq removePredef('NzNat ; SS) = removePredef(SS) .
  eq removePredef('Zero ; SS) = removePredef(SS) .
  eq removePredef(SS) = SS [owise] .

  op createMapsForSorts : SortSet ~> Term .
  eq createMapsForSorts(Srt) = 'sort_to_.['sortToken[upTerm(Srt)], 'sortToken[upTerm(Srt)]] .
  ceq createMapsForSorts(Srt ; SS) =
                     '__['sort_to_.['sortToken[upTerm(Srt)], 'sortToken[upTerm(Srt)]],
                         createMapsForSorts(SS)]
   if SS =/= none .

***(%
\end{verbatim}
}

When parsing views declared on the fly we create a new auxiliary view, add it to the
database, and return the new database and the name of the auxiliary view:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeViewExp(Q :: ME, 'view`to_`{_`}['token[T], T'], PSM, DB) =
                                                      < 'viewToken[upTerm(Q')], DB' >
   if Q'' := downQid(T) /\
      M := getTopModule(Q'', DB) /\
      Q' := getNewName(DB, 0) /\
      T'' := 'token[upTerm(Q')] /\
      T''' := 'token[upTerm(newName(M, Q''))] /\
      TV := 'view_from_to_is_endv[T'', 'token[upTerm(ME)], T''', maps2maps(T')] /\
      DB' := procView(TV, DB) .
  ceq parseCafeViewExp(Q :: ME, '_`{_`}['token[T], T'], PSM, DB) = < 'viewToken[upTerm(Q')], DB' >
   if Q'' := downQid(T) /\
      M := getTopModule(Q'', DB) /\
      Q' := getNewName(DB, 0) /\
      T'' := 'token[upTerm(Q')] /\
      T''' := 'token[upTerm(newName(M, Q''))] /\
      TV := 'view_from_to_is_endv[T'', 'token[upTerm(ME)], T''', maps2maps(T')] /\
      DB' := procView(TV, DB) .

***(%
\end{verbatim}
}

The auxiliary functions used thus far are defined as follows:
\begin{itemize}
\item
The function \verb"parseCafeViewExp*" traverses the terms in the list,
pairing them with the parameters from the module being instantiated:

{\codesize
\begin{verbatim}
%)

  op parseCafeViewExp* : ParameterDeclList TermList SortMap Database -> ParseResult .
  eq parseCafeViewExp*(PDL, empty, PSM, DB) = < empty, DB > .
  ceq parseCafeViewExp*((Q :: ME, PDL), (T, TL), PSM, DB) = < (T', TL'), DB'' >
   if < T', DB' > := parseCafeViewExp(Q :: ME, T, PSM, DB) /\
      < TL', DB'' > := parseCafeViewExp(PDL, TL, PSM, DB') .

***(%
\end{verbatim}
}

\item
The function \verb"maps2maps" transforms CafeOBJ mappings into Maude mappings.
This is achieved by first computing the mappings for sorts and variables,
removing the variable declarations, which are not allowed in Maude, and
then applying an auxiliary \verb"maps2maps" function with $3$ arguments:

{\codesize
\begin{verbatim}
%)

  op maps2maps : Term -> Term .
  ceq maps2maps(T) = maps2maps(T', SM, VM)
   if SM := getSortMap(T) /\
      VM := getVarMap(T) /\
      T' := removeVarDecls(T) .

***(%
\end{verbatim}
}

\item
The function \verb"getSortMap" traverses the mappings, transforming them into
Maude mappings:

{\codesize
\begin{verbatim}
%)

  op getSortMap : Term -> SortMap .
  ceq getSortMap('__[T, T']) = SM, SM'
   if SM := getSortMap(T) /\
      SM' := getSortMap(T') .
  eq getSortMap('sort_->_.[T, T']) = getSort(T) |-> getSort(T') .
  eq getSortMap('hsort_->_.[T, T']) = getSort(T) |-> getSort(T') .
  eq getSortMap(T) = empty [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"getSort" just extracts the quoted identifier from the term:

{\codesize
\begin{verbatim}
%)

  op getSort : Term ~> Term .
  eq getSort('CafeToken[T]) = downQid(T) .

***(%
\end{verbatim}
}

\item
Similarly, \verb"getVarMap" traverses the term creating a mapping between variables
and their sort.
%
Note that we use \texttt{vvar} and \texttt{vvars} instead of \texttt{var} and
\texttt{vars}. This is due to a pre-processing step that aims to distinguish
between these variables and the ones in modules:

{\codesize
\begin{verbatim}
%)

  op getVarMap : Term -> SortMap .
  ceq getVarMap('__[T, T']) = VM, VM'
   if VM := getVarMap(T) /\
      VM' := getVarMap(T') .
  ceq getVarMap('vvar_:_.['neCafeTokenList[T], 'CafeToken[T']]) =
                                                          createMap*(QIL, Q)
   if QIL := downQidList(T) /\
      Q := downQid(T') .
  ceq getVarMap('vvars_:_.['neCafeTokenList[T], 'CafeToken[T']]) =
                                                          createMap*(QIL, Q)
   if QIL := downQidList(T) /\
      Q := downQid(T') .
  eq getVarMap(T) = empty [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"createMap*" just maps all the variables in the first argument to the sort
given as second argument:

{\codesize
\begin{verbatim}
%)

  op createMap* : QidList Qid -> SortMap .
  eq createMap*(nil, Q) = empty .
  eq createMap*(Q QIL, Q') = Q |-> Q', createMap*(QIL, Q') .

***(%
\end{verbatim}
}

\item
The function \verb"maps2maps" with $3$ arguments translates CafeOBJ mappings
into Maude mappings. Sort renamings only require changing the syntax:

{\codesize
\begin{verbatim}
%)

  op maps2maps : Term SortMap SortMap -> Term .
  ceq maps2maps('__[T, T'], SM, VM) = '__[T'', T3]
   if T'' := maps2maps(T, SM, VM) /\
      T3 := maps2maps(T', SM, VM) .
  ceq maps2maps('sort_->_.[T, T'], SM, VM) = 'sort_to_.[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .
  ceq maps2maps('hsort_->_.[T, T'], SM, VM) = 'sort_to_.[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .

***(%
\end{verbatim}
}

However, mapping operators might require a more complex translation, because
they can include mappings to terms. We check whether the lefthand side contains
variables. If it does not contain, then it is translated as an operator mapping;
otherwise, it is mapped to a term:

{\codesize
\begin{verbatim}
%)

  ceq maps2maps('op_->_.['CafeBubble[T], 'CafeBubble[T']], SM, VM) =
                        if T == T''
                        then 'op_to_.['token[T], 'token[T3]]
                        else 'op_to`term_.['bubble[T''], 'bubble[T3]]
                        fi
   if T'' := updateTermLHS(T, SM, VM) /\
      T3 := updateTermRHS(T', SM, VM) .

***(%
\end{verbatim}
}

Finally, behavioral operators are transformed into standard operators:

{\codesize
\begin{verbatim}
%)

  ceq maps2maps('bop_->_.['CafeBubble[T], 'CafeBubble[T']], SM, VM) =
                                      'op_to_.['bubble[T''], 'bubble[T3]]
   if T'' := updateTermLHS(T, SM, VM) /\
      T3 := updateTermRHS(T', SM, VM) .
  eq maps2maps(T, SM, VM) = T [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"updateTermLHS" traverses the constants in the term and,
if we find a variable previously defined, its sort is attached:

{\codesize
\begin{verbatim}
%)

  op updateTermLHS : Term SortMap SortMap -> Term .
  eq updateTermLHS(Q[TL], SM, VM) = Q[updateTermLHS*(TL, SM, VM)] .
  eq updateTermLHS(V, SM, VM) = V .
  ceq updateTermLHS(C, SM, VM) = upTerm(Q')
   if Q := downQid(C) /\
      VM[Q] =/= undefined /\
      Q' := qid(string(Q) + ":" + string(VM[Q])) .
  eq updateTermLHS(T, SM, VM) = T [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"updateTermRHS" also attaches the sort of the variables,
but it takes into account that \emph{the names of the sorts might have changed
due to the mappings}. Hence, it looks for the sort name in the sort mapping and
replaces it if required:

{\codesize
\begin{verbatim}
%)

  op updateTermRHS : Term SortMap SortMap -> Term .
  eq updateTermRHS(Q[TL], SM, VM) = Q[updateTermRHS*(TL, SM, VM)] .
  eq updateTermRHS(V, SM, VM) = V .
  ceq updateTermRHS(C, SM, VM) = upTerm(Q')
   if Q := downQid(C) /\
      VM[Q] =/= undefined /\
      SM[VM[Q]] == undefined /\
      Q' := qid(string(Q) + ":" + string(VM[Q])) .
  ceq updateTermRHS(C, SM, VM) = upTerm(Q')
   if Q := downQid(C) /\
      VM[Q] =/= undefined /\
      SM[VM[Q]] =/= undefined /\
      Q' := qid(string(Q) + ":" + string(SM[VM[Q]])) .
  eq updateTermRHS(T, SM, VM) = T [owise] .

***(%
\end{verbatim}
}

\item
The functions \verb"updateTermLHS*" and \verb"updateTermRHS*" just traverse
the list, applying the appropriate function to each element:

{\codesize
\begin{verbatim}
%)

  ops updateTermLHS* : TermList SortMap SortMap -> TermList .
  eq updateTermLHS*(empty, SM, VM) = empty .
  eq updateTermLHS*((T, TL), SM, VM) = updateTermLHS(T, SM, VM),
                                       updateTermLHS*(TL, SM, VM) .

  op updateTermRHS* : TermList SortMap SortMap -> TermList .
  eq updateTermRHS*(empty, SM, VM) = empty .
  eq updateTermRHS*((T, TL), SM, VM) = updateTermRHS(T, SM, VM),
                                       updateTermRHS*(TL, SM, VM) .

***(%
\end{verbatim}
}

\item
The function \verb"removeVarDecls" removes the variable declarations
from the term, by first removing them and then creating a new term with
the rest of the declarations:

{\codesize
\begin{verbatim}
%)

  op removeVarDecls : Term -> Term .
  eq removeVarDecls(T) = buildNotVarDecl(getNotVarDecl(T)) .

***(%
\end{verbatim}
}

\item
The function \verb"getNotVarDecl" checks that the operator at the top
is not a variable declaration:

{\codesize
\begin{verbatim}
%)

  op getNotVarDecl : Term -> TermList .
  ceq getNotVarDecl('__[Q[TL], Q'[TL']]) = T, T'
   if Q =/= 'vvar_:_. /\
      Q =/= 'vvars_:_. /\
      Q' =/= 'vvar_:_. /\
      Q' =/= 'vvars_:_. /\
      T := getNotVarDecl(Q[TL]) /\
      T' := getNotVarDecl(Q'[TL']) .
  ceq getNotVarDecl('__[Q[TL], Q'[TL']]) = T
   if Q == 'vvar_:_. or-else Q == 'vvars_:_. /\
      Q' =/= 'vvarrs_:_. /\
      Q' =/= 'vvars_:_. /\
      T := getNotVarDecl(Q'[TL']) .
  ceq getNotVarDecl('__[Q[TL], Q'[TL']]) = T
   if Q =/= 'vvarrs_:_. /\
      Q =/= 'vvars_:_. /\
      Q' == 'vvar_:_. or-else Q' == 'vvars_:_. /\
      T := getNotVarDecl(Q[TL]) .
  eq getNotVarDecl(T) = T [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"buildNotVarDecl" distinguishes whether the argument is
a singleton list or not, in order to use the \verb"__" operator:

{\codesize
\begin{verbatim}
%)

  op buildNotVarDecl : TermList ~> Term .
  eq buildNotVarDecl(T) = T .
  ceq buildNotVarDecl((T, TL)) = '__[T, buildNotVarDecl(TL)]
   if TL =/= empty .

***(%
\end{verbatim}
}

\item
The function \verb"sortViewId" is in charge of sorting the parameters, so they
do not rely on the naming features of CafeOBJ. If only one parameter is used or
the term does not use syntactic sugar, then it is kept the same way. Otherwise
an alternative function is used:

{\codesize
\begin{verbatim}
%)

  op sortViewId : ParameterDeclList Term -> Term .
  ceq sortViewId(PDL, Q[T, TL]) = Q[T, TL]
   if Q =/= '_`,_ or-else not usesSugar(T) .
  eq sortViewId(PDL, Q[TL]) = sortViewIdAux(PDL, TL) .

***(%
\end{verbatim}
}

\noindent
where \verb"sortViewIdAux" looks for the appropriate view identifiers by traversing the
list of parameters:

{\codesize
\begin{verbatim}
%)

  op sortViewIdAux : ParameterDeclList TermList -> TermList .
  eq sortViewIdAux(nil, TL) = empty .
  ceq sortViewIdAux((Q :: ME, PDL), TL) = find(Q, TL), sortViewIdAux(PDL, TL)
   if PDL == nil .
  eq sortViewIdAux((Q :: ME, PDL), TL) = '_`,_[find(Q, TL),
                                         sortViewIdAux(PDL, TL)] [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"getPDL" extracts the parameter list from a module:

{\codesize
\begin{verbatim}
%)

  op getPDL : Module ~> ParameterDeclList .
  eq getPDL(fmod Q{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm) = PDL .
  eq getPDL(mod Q{PDL} is IL sorts SS . SSDS OPDS MAS EqS RIS endm) = PDL .

***(%
\end{verbatim}
}

\item
\verb"getNewName" checks in the database whether there already
exists a view with name created by \verb"createViewName". If true, then we try with
the next natural number, otherwise this name is used:

{\codesize
\begin{verbatim}
%)

  op getNewName : Database Nat -> Qid .
  ceq getNewName(DB, N) = if getView(Q, DB) :: View
                          then getNewName(DB, s(N))
                          else Q
                          fi
   if Q := createViewName(N) .

***(%
\end{verbatim}
}

\noindent
where \verb"createViewName" just creates a new name starting by
\texttt{OTF-VIEW}~\cite{cafeOBJ2maudeUG}, which stands for ``on the fly view'',
and followed by a natural number:

{\codesize
\begin{verbatim}
%)

  op createViewName : Nat -> Qid .
  eq createViewName(N) = qid("OTF-VIEW" + string(N, 10)) .

***(%
\end{verbatim}
}

\item
The function \verb"find" looks for the given quoted identifier, standing for a
parameter, inside a list of terms:

{\codesize
\begin{verbatim}
%)

  op find : Qid TermList -> Term .
  eq find(Q, ('_`,_[T, T'], TL)) = find(Q, (T, T', TL)) .
  eq find(Q, ('_<=_['token[T], T'], TL)) = if Q == downQid(T)
                                           then T'
                                           else find(Q, TL)
                                           fi .

***(%
\end{verbatim}
}

\item
Finally, \verb"usesSugar" checks whether the notation \verb"_<=_", used to state
the name of the parameter corresponding to the view identifier, is being used:

{\codesize
\begin{verbatim}
%)

  op usesSugar : Term -> Bool .
  eq usesSugar('_<=_[TL]) = true .
  eq usesSugar(T) = false [owise] .

***(%
\end{verbatim}
}

\end{itemize}

The parsing process continues by parsing sorts. Hidden sorts are translated
as standard Maude sorts:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('*`[_`]*['CafeToken[T]], PU, U, VDS, PSM, TSM, DB) =
                                                        < PDR, nil, downQid(T), DB >
   if PDR := parseDecl('sort_.['sortToken[T]], PU, U, VDS) .

***(%
\end{verbatim}
}

We distinguish the operator at the top when dealing with sort declarations.
\begin{itemize}
\item
When only one sort is declared it is parsed and added to the temporal
modules with the Full Maude function \verb"parseDecl":

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('`[_`]['CafeToken[T]], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if T' := addSortToken('CafeToken[T]) /\
      PDR := parseDecl('sorts_.[T'], PU, U, VDS) .

***(%
\end{verbatim}
}

\item
When we have a list of sorts without subsort declaration they are just parsed
and added to the current module:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('`[_`]['__[T, T']], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if T'' := addSortToken(T) /\
      T''' := addSortToken(T') /\
      PDR := parseDecl('sorts_.['__[T'', T''']], PU, U, VDS) .

***(%
\end{verbatim}
}

\item
Finally, when we find a subsort relation both terms, the sorts are add to the
sort and the subsort relation (which might be multiple) is added to the module
thus obtained:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('`[_`]['_<_[T, T']], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if T'' := addSortToken(T) /\
      T''' := addSortToken(T') /\
      TS := sub2sort('_<_[T, T']) /\
      < PU' ; U' ;  VDS' > := parseDecl('sorts_.[TS], PU, U, VDS) /\
      PDR := parseDecl('subsorts_.['_<_[T'', T''']], PU', U', VDS') .

***(%
\end{verbatim}
}

\end{itemize}

The auxiliary functions used for parsing sorts are:
\begin{itemize}
\item
\verb"addSortToken", which transforms CafeOBJ tokens into Maude tokens for sorts:

{\codesize
\begin{verbatim}
%)

  op addSortToken : Term -> Term .
  eq addSortToken('__[T, T']) = ('__[addSortToken(T), addSortToken(T')]) .
  eq addSortToken('_<_[T, T']) = ('_<_[addSortToken(T), addSortToken(T')]) .
  eq addSortToken('CafeToken[T]) = ('sortToken[T]) .

***(%
\end{verbatim}
}

\item
\verb"sub2sort", which flattens a subsort relation to add all the sorts to
the current module:

{\codesize
\begin{verbatim}
%)

  op sub2sort : Term -> Term .
  eq sub2sort('_<_[T, T']) = combine2sort(sub2sort(T), sub2sort(T')) .
  eq sub2sort('__['CafeToken[T], T']) = ('__['sortToken[T], sub2sort(T')]) .
  eq sub2sort('CafeToken[T]) = ('sortToken[T]) .

***(%
\end{verbatim}
}

\item
\verb"combine2sort", which puts together two terms:

{\codesize
\begin{verbatim}
%)

  op combine2sort : Term Term -> Term .
  eq combine2sort('sortToken[T], T') = '__['sortToken[T], T'] .
  eq combine2sort('__[T, T''], T''') = combine2sort(T'', '__[T, T''']) .

***(%
\end{verbatim}
}

\end{itemize}

We show now how to parse operator declarations. For the declaration of a single operator
with attributes we transform the list of sorts in the arity with \verb"addSortToken",
and then add the operator declaration with \verb"parseDecl":

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('op_:_->_`{_`}.['CafeToken[T], T', 'CafeToken[T''], T'''],  PU, U,
                    VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[T], T4, 'sortToken[T''],
                       map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('op_:_->_`{_`}.['__[TL], T', 'CafeToken[T''], T'''],  PU, U, VDS,
                    PSM, TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[upTerm(tokenList2token(TL))], T4,
                       'sortToken[T''], map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('op_:_->_.['CafeToken[T], T', 'CafeToken[T'']],  PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_.['token[T], T4, cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('op_:_->_.['__[TL], T', 'CafeToken[T'']],  PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_.['token[upTerm(tokenList2token(TL))], T4,
                                                cafeType2maudeType(T'')], PU, U, VDS) .

***(%
\end{comment}
}

The declaration of constants simplifies the task, since the arity does not appear:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('op_:`->_`{_`}.['CafeToken[T], 'CafeToken[T''], T'''],  PU, U, VDS,
                    PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := parseDecl('op_:`->_`[_`].['token[T], cafeType2maudeType(T''),
                                       map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('op_:`->_.['CafeToken[T], 'CafeToken[T'']],  PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if PDR := parseDecl('op_:`->_.['token[T], cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('ops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''], PU,
                    U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_`[_`].['neTokenList[T], T4, cafeType2maudeType(T''),
                                        map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{comment}
}

Multiple operators with the same arity and coarity are just transformed into a nonempty
list of Maude tokens, and then introduced into the current module:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('ops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], PU, U, VDS,
                    PSM, TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_.['neTokenList[T], T4, cafeType2maudeType(T'')],
                       PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('ops_:`->_`{_`}.['neCafeTokenList[T], 'CafeToken[T''], T'''],  PU, U,
                    VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := parseDecl('ops_:`->_`[_`].['neTokenList[T], cafeType2maudeType(T''),
                                        map2MaudeAttr(T''')], PU, U, VDS) .

  ceq parseCafeDecl('ops_:`->_.['neCafeTokenList[T], 'CafeToken[T'']], PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if PDR := parseDecl('ops_:`->_.['neTokenList[T], cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('bop_:_->_.['CafeToken[T], T', 'CafeToken[T'']],  PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[T], T4, cafeType2maudeType(T''),
                                       behavioral], PU, U, VDS) .

  op behavioral : -> Term .
  eq behavioral = 'metadata_['token[''"behavioral".Sort]] .

  op addBehavioral : Term -> Term .
  eq addBehavioral('__[TL]) = '__[TL, behavioral] .
  eq addBehavioral(T) = '__[T, behavioral] [owise] .

  ceq parseCafeDecl('bop_:_->_`{_`}.['CafeToken[T], T', 'CafeToken[T''], T'''], PU, U,
                    VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[T], T4, cafeType2maudeType(T''),
                                       addBehavioral(map2MaudeAttr(T'''))], PU, U, VDS) .

  ceq parseCafeDecl('bops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], PU, U, VDS,
                    PSM, TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_`[_`].['neTokenList[T], T4, cafeType2maudeType(T''),
                                        behavioral], PU, U, VDS) .

  ceq parseCafeDecl('ops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''], PU,
                    U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_`[_`].['neTokenList[T], T4, cafeType2maudeType(T''),
                                        map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{comment}
}

Predicates are parsed in a similar way, since they are transformed into operators
with coarity \verb"Bool", which must be meta-represented as a token:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('pred_:_`{_`}.['CafeToken[T], T', T'''],  PU, U, VDS, PSM, TSM, DB) =
                                                                  < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[T], T4, 'sortToken[''Bool.Qid],
                       map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('pred_:_.['CafeToken[T], T'],  PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_.['token[T], T4, 'sortToken[''Bool.Qid]], PU, U, VDS) .

***(%
\end{comment}
}

The auxiliary functions used here are:
\begin{itemize}

\item
The function \verb"tokenList2token" transforms operator defintions of the
form \verb"_ _", which are not allowed by Maude, into the equivalent \verb"__"
operator:

{\codesize
\begin{verbatim}
%)

  op tokenList2token : TermList -> Qid .
  op tokenList2token : TermList String -> Qid .

  eq tokenList2token(TL) = tokenList2token(TL, "") .
  eq tokenList2token(('CafeToken[T], TL), St) =
                       tokenList2token(TL, St + string(downQid(T))) .
  eq tokenList2token(empty, St) = qid(St) .

***(%
\end{verbatim}
}

\item
The function \verb"map2MaudeAttr" translates a list of terms written using CafeOBJ
syntax into the same list using Maude syntax. The first equation deals with the
yuxtaposition operator at the top:

{\codesize
\begin{verbatim}
%)

  op map2MaudeAttr : TermList -> TermList .
  eq map2MaudeAttr('__[TL]) = '__[map2MaudeAttr(TL)] .

***(%
\end{verbatim}
}

While the rest of equations just translates the attribute and continue with the rest
of the list, until the empty list is reached:

{\codesize
\begin{verbatim}
%)

  eq map2MaudeAttr(('constr.@CafeAttr@, TL)) = 'ctor.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('associative.@CafeAttr@, TL)) = 'assoc.@Attr@,
                                                    map2MaudeAttr(TL) .
  eq map2MaudeAttr(('assoc.@CafeAttr@, TL)) = 'assoc.@Attr@, map2MaudeAttr(TL) .

***(%
  ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  eq map2MaudeAttr(('l-assoc.@CafeAttr@, TL)) =
               'gather`(_`)['neTokenList['__[''E.Sort,''e.Sort]]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('r-assoc.@CafeAttr@, TL)) =
               'gather`(_`)['neTokenList['__[''e.Sort,''E.Sort]]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('commutative.@CafeAttr@, TL)) = 'comm.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('comm.@CafeAttr@, TL)) = 'comm.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('idempotent.@CafeAttr@, TL)) = 'idem.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('idem.@CafeAttr@, TL)) = 'idem.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('nonexec.@CafeAttr@, TL)) = 'nonexec.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr((':nonexec.@CafeAttr@, TL)) = 'nonexec.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('owise.@CafeAttr@, TL)) = 'owise.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('id:`(_`)['CafeBubble[T]], TL)) = 'id:_['bubble[T]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('id:_['CafeBubble[T]], TL)) = 'id:_['bubble[T]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('idr:`(_`)['CafeBubble[T]], TL)) = 'id:_['bubble[T]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('prec:_['CafeToken[T]], TL)) = 'prec_['token[T]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('metadata['CafeToken[T]], TL)) = 'metadata_['token[T]], map2MaudeAttr(TL) .

***(%
\end{comment}
}

{\codesize
\begin{verbatim}
%)

  eq map2MaudeAttr(empty) = empty .

***(%
\end{verbatim}
}

\item
The function \verb"cafeType2maudeType" transforms CafeOBJ error types into
Maude kinds:

{\codesize
\begin{verbatim}
%)

  op cafeType2maudeType : Term -> Term .
  eq cafeType2maudeType('__[TL]) = '__[cafeTypes2maudeTypes(TL)] .
  ceq cafeType2maudeType(T) = '`[_`]['sortToken[upTerm(Q')]]
   if Q := downQid(T) /\
      St := string(Q) /\
      0 == find(St, "?", 0) /\
      St' := substr(St, 1, length(St)) /\
      Q' := qid(St') .
  eq cafeType2maudeType(T) = 'sortToken[T] [owise] .

***(%
\end{verbatim}
}

\noindent
where the function \verb"cafeTypes2maudeTypes" just traverses the list
of terms, applying the function \texttt{cafeType2maudeType} to each term:

{\codesize
\begin{verbatim}
%)

  op cafeTypes2maudeTypes : TermList -> TermList .
  eq cafeTypes2maudeTypes(empty) = empty .
  eq cafeTypes2maudeTypes((T, TL)) = cafeType2maudeType(T),
                                     cafeTypes2maudeTypes(TL) .

***(%
\end{verbatim}
}

\end{itemize}

{\codesize
\begin{comment}
%)

  op parseHiddenSort : Term ~> Sort .
  eq parseHiddenSort('CafeToken[T]) =
     if downQid(T) :: Type
     then downQid(T)
     else qidError('\y 'Warning: '\o downQid(T) 'is 'not 'a 'valid 'sort. '\n)
     fi .
  eq parseHiddenSort(T) = qidError('\y 'Warning: '\o 'invalid 'sort. '\n) [owise] .

***(%
\end{comment}
}

Variables declared with the keyword \verb"var" are just translated as \verb"vars"
declarations.

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('var_:_.['neCafeTokenList[T], T'], PU, U, VDS, PSM, TSM, DB) =
                                                          < PDR, QIL, none, DB' >
   if < PDR, QIL, none, DB' > := parseCafeDecl('vars_:_.['neCafeTokenList[T], T'],
                                         PU, U, VDS, PSM, TSM, DB) .

***(%
\end{verbatim}
}

Otherwise, variables are parsed by adding them, with their sort, to the set of operators
used to parse terms in the current module:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('vars_:_.['neCafeTokenList[T], 'CafeToken[T']], PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS parseVars(downQidList(T), parseType('sortToken[T'])) > .

***(%
\end{verbatim}
}

Equations and transitions are parsed in a similar way, so we do not show all
the variations. An unconditional equation is parsed by adding the on-the-fly
variables in the righthand side to the set of current variables, and transforming
the attributes and then using \verb"parseDecl":

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('eq_=_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, PSM, TSM, DB) =
                                              < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(upTerm(QIL), VDS') /\
      TOTF' := renameOnTheFly(cafeEqAtS2maudeEqAts(T'), VDS') /\
      PDR := parseDecl('eq_=_.['bubble[TOTF], 'bubble[TOTF']], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('beq_=_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, PSM, TSM, DB) =
                                              < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := behavioralEq(renameOnTheFly(cafeEqAtS2maudeEqAts(T'), VDS')) /\
      PDR := parseDecl('eq_=_.['bubble[TOTF], 'bubble[TOTF']], PU, U, VDS) .

***(%
\end{comment}
}

Conditional equations are parsed in the same way, since the condition is dealt inside
the \verb"parseDecl" function:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('ceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS') /\
      PDR := parseDecl('ceq_=_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('cq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], PU, U,
                    VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS') /\
      PDR := parseDecl('ceq_=_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS) .

  ceq parseCafeDecl('bceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], PU, U,
                    VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := behavioralEq(renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS')) /\
      PDR := parseDecl('ceq_=_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS) .

  ceq parseCafeDecl('bcq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], PU, U,
                    VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := behavioralEq(renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS')) /\
      PDR := parseDecl('ceq_=_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS) .

***(%
\end{comment}
}

Transitions follow the same approach, although in this case the statement parsed
by \verb"parseDecl" is a Maude rule:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('trans_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U,
                    VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(cafeEqAtS2maudeEqAts(T'), VDS') /\
      PDR := parseDecl('rl_=>_.['bubble[TOTF], 'bubble[TOTF']], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('trns_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(cafeEqAtS2maudeEqAts(T'), VDS') /\
      PDR := parseDecl('rl_=>_.['bubble[TOTF], 'bubble[TOTF']], PU, U, VDS) .

  ceq parseCafeDecl('ctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := improveLabel(downQidList(T)) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS') /\
      PDR := parseDecl('crl_=>_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS) .

  ceq parseCafeDecl('ctrns_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS') /\
      PDR := parseDecl('crl_=>_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS') .

  ceq parseCafeDecl('btrans_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if QIL := downQidList(T) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := behavioralEq(renameOnTheFly(cafeEqAtS2maudeEqAts(T'), VDS')) /\
      PDR := parseDecl('rl_=>_.['bubble[TOTF], 'bubble[TOTF']], PU, U, VDS) .

  ceq parseCafeDecl('btrns_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, PSM,
                    TSM, DB) = < PDR, nil, none, DB >
   if QIL := downQidList(T) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := behavioralEq(renameOnTheFly(cafeEqAtS2maudeEqAts(T'), VDS')) /\
      PDR := parseDecl('rl_=>_.['bubble[TOTF], 'bubble[TOTF']], PU, U, VDS) .

  ceq parseCafeDecl('bctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := downQidList(T) /\
      VDS' := opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := behavioralEq(renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS')) /\
      PDR := parseDecl('crl_=>_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS) .

  ceq parseCafeDecl('bctrns_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      TOTF := renameOnTheFly(T, VDS') /\
      TOTF' := renameOnTheFly(T', VDS') /\
      TOTF'' := behavioralEq(renameOnTheFly(cafeEqAtS2maudeEqAts(T''), VDS')) /\
      PDR := parseDecl('crl_=>_if_.['bubble[TOTF], 'bubble[TOTF'], 'bubble[TOTF'']], PU, U, VDS) .

***(%
\end{comment}
}

The auxiliary functions for parsing equations and transitions are:

\begin{itemize}
\item
\verb"cafeEqAtS2maudeEqAts", which just applies \texttt{cafeEqAtS2maudeEqAts*}
if it finds any attribute:

{\codesize
\begin{verbatim}
%)

  op cafeEqAtS2maudeEqAts : Term -> Term .
  eq cafeEqAtS2maudeEqAts('__[TL]) = '__[cafeEqAtS2maudeEqAts*(TL)] .
  eq cafeEqAtS2maudeEqAts(T) = T [owise] .

***(%
\end{verbatim}
}

\noindent
where \texttt{cafeEqAtS2maudeEqAts} traverses the list and transforms
the possible attributes appearing in equations and transitions:

{\codesize
\begin{verbatim}
%)

  op cafeEqAtS2maudeEqAts* : TermList -> TermList .
  eq cafeEqAtS2maudeEqAts*((TL, ''`{.Qid, ''owise.Qid, TL'', ''`}.Qid)) =
                      TL, ''`[.Qid, ''owise.Qid, TL'', ''`].Qid .
  eq cafeEqAtS2maudeEqAts*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) =
                      TL, ''`[.Qid, ''nonexec.Qid, TL'', ''`].Qid .
  eq cafeEqAtS2maudeEqAts*((TL, ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid)) =
                      TL, ''`[.Qid, ''metadata.Qid, TL'', ''`].Qid .
  eq cafeEqAtS2maudeEqAts*(TL) = TL [owise] .

  op behavioralEq : Term -> TermList .
  eq behavioralEq('__[TL]) = '__[behavioralEq*(TL)] .
  eq behavioralEq(T) = '__[T, ''`[.Qid, ''metadata.Qid, ''"behavioral".Sort, ''`].Qid] [owise] .

  op behavioralEq* : TermList -> TermList .
  eq behavioralEq*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) =
                      TL, ''`[.Qid, ''nonexec.Qid, TL'', ''metadata.Qid, ''"behavioral".Sort,''`].Qid .
  eq behavioralEq*((TL, ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid)) =
                      TL, ''`[.Qid, ''metadata.Qid, TL'', ''metadata.Qid, ''"behavioral".Sort,''`].Qid .
  eq behavioralEq*(TL) = TL, ''`[.Qid, ''metadata.Qid, ''"behavioral".Sort,''`].Qid [owise] .


***(%
\end{verbatim}
}

\item
\verb"improveLabel", which removes spaces from the label and introduces a letter if
it starts with another character:

{\codesize
\begin{verbatim}
%)

  var STR : String .

  op improveLabel : QidList -> QidList .
  ceq improveLabel('`[ Q Q' QIL '`] ': QIL') = improveLabel('`[ Q'' QIL '`] ': QIL')
   if Q' =/= '`] /\
      Q'' := qid(string(Q) + "-" + string(Q')) .
  eq improveLabel('`[ Q '`] ': QIL) = '`[ startsByLetterOrNumber(Q) '`] ': QIL .
  eq improveLabel(QIL) = QIL [owise] .

  op startsByLetterOrNumber : Qid -> Qid .
  ceq startsByLetterOrNumber(Q) = startsByLetterOrNumber(STR)
   if STR := string(Q) .
  eq startsByLetterOrNumber(Q) = Q [owise] .

  op startsByLetterOrNumber : String -> Qid .
  ceq startsByLetterOrNumber(STR) =
            if (N >= 65 and N <= 90) or (N >= 97 and N <= 122)
            then qid(STR)
            else qid("cafe-label-" + STR)
            fi
   if N := ascii(substr(STR, 0, 1)) .

***(%
\end{verbatim}
}

\item
\verb"opDeclSetFromQidList", which extracts an \verb"OpDeclSet" from a list of quoted
identifiers to extend the variable set with the variables defined on the fly in CafeOBJ:

{\codesize
\begin{verbatim}
%)

  op opDeclSetFromQidList : QidList -> OpDeclSet .
  eq opDeclSetFromQidList(nil) = none .
  ceq opDeclSetFromQidList(Q QL) = op qid(St') : nil -> qid(St'') [none] .
                                   opDeclSetFromQidList(QL)
   if Q =/= ': /\
      St := string(Q) /\
      N := find(St, ":", 0) /\
      St' := substr(St, 0, N) /\
      St'' := substr(St, s(N), length(St)) /\
      St'' =/= "" .
  eq opDeclSetFromQidList(Q QL) = opDeclSetFromQidList(QL) [owise] .

  op renameOnTheFly : Term OpDeclSet -> Term .
  eq renameOnTheFly('__[TL], VDS) = '__[renameOnTheFly*(TL, VDS)] .
  ceq renameOnTheFly(C, VDS) = upTerm(Q')
   if Q := downQid(C) /\
      op Q : nil -> Ty [none] . VDS' := VDS /\
      St := string(Q) /\
      St' := string(Ty) /\
      St'' := St + ":" + St' /\
      Q' := qid(St'') .
  eq renameOnTheFly(T, VDS) = T [owise] .


  op renameOnTheFly* : TermList OpDeclSet -> TermList .
  eq renameOnTheFly*(empty, VDS) = empty .
  eq renameOnTheFly*((T, TL), VDS) = renameOnTheFly(T, VDS), renameOnTheFly*(TL, VDS) .
***(%
\end{verbatim}
}

\end{itemize}

% The reduction and induction commands are just skipped when parsing a module.
% We will deal with them separately in the open-close environment:

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('reduce_.[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl('red_.[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':goal`{_`}[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':ind`on`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':apply`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':sel`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':postpone`..@CafeInductiveComm@, PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':imp`[_`].[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':imp`[_`]by`{_`}[T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:ctf`{_`}[T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:ctf`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:cvss`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:cvvs`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:cvsv`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:cevss`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:cvs`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:csv`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':def_=`:csvs`[_`][T, T'], PU, U, VDS, PSM, TSM, DB) =
                                                                < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':show`proof.@CafeInductiveComm@, PU, U, VDS, PSM, TSM, DB) =
                                                               < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':desc`proof.@CafeInductiveComm@, PU, U, VDS, PSM, TSM, DB) =
                                                               < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':desc`..@CafeInductiveComm@, PU, U, VDS, PSM, TSM, DB) =
                                                               < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':id`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':proof`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .
  ceq parseCafeDecl(':infer`(_`)[T], PU, U, VDS, PSM, TSM, DB) = < PDR, nil, none, DB >
   if PDR := < PU ; U ; VDS > .

***(%
\end{comment}
}

{\codesize
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
}

%)