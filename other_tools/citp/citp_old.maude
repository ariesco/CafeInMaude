
***(

Updated on 16-7-2015 
1. to be compatible with Maude 2.7 and Full Maude 2.7 

  Updated on 01-11-2014

  1. fix some bugs on pretty print multiple lemmas 
  2. add a new command "lred". lred is used to reduce a given term with the module in the current goal.  
     This is particularly helpful to find lemmas. 


  Updated on 30-10-2013
  1. support CafeOBJ language as input (integrating the code developed by Adrian) 
  2. automatically labeling added equations rules  
  3. some bugs are fixed 

  Updated on 08-10-2013
  1. support case analysis on condition 
     by CA-1 

  Updated on 01-09-2013

  1. support intializing lemmas with equations or rules being given on the fly. 
  2. support discarding critical pairs with equations being given on the fly. 
  3. support discarding critical pairs of equations with specified labels. 
  4. fix the bug about initializing lemmas (reported by Adrian) 
  

  Updated on 26-08-2013

  1. support handling non-confluence case by critical pairs 
  2. support initializing induction hypothesis 
  3. fix a bug about handling bad goal set (reported by Adrian) 

  Updated on 06-20-2013 
  
  1. to support the mix of equations, rewrite rules, and memberships in a single goal. 
  2. to support "red" function which reduces ground terms in goals to their normal forms. 
  
      
  new features:
  modified on 2013.02.26
  1. support rules and memberships in goals 
  2. add new prove strategy 

  NEW FEATURES:
  1. support rollback to an intermediate goal from which you can re-prove 
  2. add an option to show all contents or only added parts in modules of goals.      

  modified in 2013.01.04
   new functions:
   1. roll back to previous goal by (go back .) command 
   2. specify the rule to be applied to a goal by (apply ruleName [to goalID] .) command 
   3. all files are integrated into a single file. 

  todo list 
   1. to add lemmas to a goal 
 )
    
in full-maude.maude 

*** cafeOBJ2maude.maude by Adrian 

***(%

We present in this section the main modules required for dealing with CafeOBJ
specifications~\cite{cafe-report}. First, we will see how to define the syntax,
and how to parse the terms to obtain the Maude modules~\cite{maude-book}. Then,
we will show how to pretty print these terms and how to create new commands and
rules and will be added in addition to the ones already defined in Full Maude.

{\codesize
\begin{comment}
%)

******************************************************
***predefined modules
******************************************************
***for HS

fmod COMPONENTS is
  sorts AComp OComp State .
  subsort AComp OComp < State .

  op empty-state : -> State .
  op __ : State State -> State [assoc comm id: empty-state format(o nt o)] .
endfm

*****************************************************
***for translation
*****************************************************

***(%
\end{comment}
}

\subsection{Syntax\label{subsec:syntax}}

The module \verb"CafeBUBBLES" defines the sorts \verb"@CafeBubble@" for bubbles (that is,
terms that can take any form, like the lefthand side of an equation), \verb"@CafeBubble@"
for tokens (like sorts), and \verb"@NeCafeTokenList@" for nonempty lists of tokens:

{\codesize
\begin{verbatim}
%)

fmod CafeBUBBLES is
  including QID-LIST .

  sorts @CafeBubble@ @CafeToken@ @NeCafeTokenList@ .

  op CafeBubble : QidList -> @CafeBubble@ [special (id-hook Bubble (1 -1 ( ))
                            op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                            op-hook qidSymbol (<Qids> : ~> Qid))] .

  op CafeToken : Qid -> @CafeToken@ [special (id-hook Bubble (1 1)
                            op-hook qidSymbol (<Qids> : ~> Qid)
                            id-hook Exclude(. [] < { } ( )))] .

  op neCafeTokenList : QidList -> @NeCafeTokenList@ [special (id-hook Bubble (1 -1)
                            op-hook qidListSymbol (__ : QidList QidList ~> QidList)
                            op-hook qidSymbol (<Qids> : ~> Qid)
                            id-hook Exclude(. { } ))] .
endfm

***(%
\end{verbatim}
}

The module \verb"Cafe-ATTRIBUTES" defines the possible attributes that can be used
in operators and equations:

{\codesize
\begin{verbatim}
%)

fmod Cafe-ATTRIBUTES is
  pr CafeBUBBLES .

***(%
\end{verbatim}
}

It defines the sorts \verb"@CafeAttr@" for a single attribute and
\verb"@CafeAttrList@" for lists of attributes:

{\codesize
\begin{verbatim}
%)

  sorts @CafeAttr@ @CafeAttrList@ .
  subsorts @CafeAttr@ < @CafeAttrList@ .

***(%
\end{verbatim}
}

The attributes are defined following the CafeOBJ syntax. The unary attributes
are all defined in the same way, the identity attributes require take a bubble as
argument, while the precedence attribute takes a token:

{\codesize
\begin{verbatim}
%)

  op __ : @CafeAttrList@ @CafeAttrList@ -> @CafeAttrList@ [ctor assoc] .
  ops assoc associative l-assoc r-assoc comm commutative constr nonexec
      idem idempotent : -> @CafeAttr@ [ctor] .
  op id:`(_`) : @CafeBubble@ -> @CafeAttr@ [ctor] .
  op idr:`(_`) : @CafeBubble@ -> @CafeAttr@ [ctor] .
  op prec:_ : @CafeToken@ -> @CafeAttr@ [ctor] .

***(%
\end{verbatim}
}

Although the \verb"metadata" attribute is not currently available for CafeOBJ
specifications, it might be useful, so we support it by defining the appropriate
operator. However, it can also be defined in a comment, as explained
in~\cite{cafeOBJ2maudeUG}:

{\codesize
\begin{verbatim}
%)

  op metadata_ : @CafeToken@ -> @CafeAttr@ [ctor] .
endfm

***(%
\end{verbatim}
}

The syntax must also include the commands that we want to use for CafeOBJ specifications.
These commands are defined in the \verb"TRANSLATION-COMMANDS" module, which imports the
\verb"COMMANDS" module from Full Maude. To add new commands the user must define them
here and then specify their behavior in the module \texttt{CAFE2MAUDE-DATABASE-HANDLING}
described in Section~\ref{subsec:cafe:commands}:

{\codesize
\begin{verbatim}
%)

fmod TRANSLATION-COMMANDS is
  inc COMMANDS .

***(%
\end{verbatim}
}

We have defined three commands:
\begin{itemize}
\item
The first one will force the translation to be done without using the modifications
presented in~\cite{cafeOBJ2maudeUG}, that drop some requirements from the importations
modes and on the usage of theories to allow a wider range of CafeOBJ specifications to
be translated:

{\codesize
\begin{verbatim}
%)

  op strict`translation`on`. : -> @Command@ .

***(%
\end{verbatim}
}

\item
Analogously, the second one will allow these modifications:

{\codesize
\begin{verbatim}
%)

  op strict`translation`off`. : -> @Command@ .

***(%
\end{verbatim}
}

\item
The third one will require a CafeOBJ module to be shown:

{\codesize
\begin{verbatim}
%)

  op original`CafeOBJ`module_. : @Token@ -> @Command@ .
endfm

***(%
\end{verbatim}
}

\end{itemize}

The module \verb"CafeMETA-SIGN" defines the syntax for CafeOBJ modules:

{\codesize
\begin{verbatim}
%)

fmod CafeMETA-SIGN is
  including FULL-MAUDE-SIGN .
  including Cafe-ATTRIBUTES .

***(%
\end{verbatim}
}

It first defines all the required sorts, and the subsort relations between them:

{\codesize
\begin{verbatim}
%)

  sorts @CafeMODULE@ @HiddenSortDecl@ @VisibleSortDecl@ @CafeOpDecl@
        @CafeImportDecl@ @CafeType@ @CafeTypeList@ @CafeSortList@ @CafeSort@
        @BehaviorEquationDecl@ @CafeDeclList@ @CafeEqDecl@ @CafeVarDecl@
        @CafeSubSortRel@ @CafeLDeclList@ @CafeModExp@ @CafeParameter@ @CafeParameters@
        @CafeInterface@ @CafeViewDecl@ @CafeViewDeclList@ @CafeTransDecl@ @CafeViewId@
        @CafeViewIdList@ @ReductionDecl@ .

  subsort @CafeToken@ < @CafeSort@ < @CafeType@ .

***(%
  ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  subsort @CafeSort@ < @CafeSortList@ .
  subsort @CafeType@ < @CafeTypeList@ .
  subsorts @CafeImportDecl@ @CafeVarDecl@ @CafeEqDecl@ @VisibleSortDecl@ @CafeOpDecl@
           @CafeTransDecl@ @ReductionDecl@ < @CafeLDeclList@ .
  subsorts @HiddenSortDecl@ @BehaviorEquationDecl@ @CafeLDeclList@
           < @CafeDeclList@ .
  subsort @ModExp@ < @CafeModExp@ . *** !!!!
  subsort @ModExp@ < @CafeViewId@ .
  subsort @CafeViewId@ < @CafeViewIdList@ .
  *** !!!! subsort @CafeToken@ < @CafeModExp@ .
  subsort @CafeParameter@ < @CafeParameters@ .
  subsort @CafeToken@  < @CafeInterface@ .
  subsort @CafeViewDecl@ < @CafeViewDeclList@ .

  subsort @CafeMODULE@ < @Input@ .

  op __ : @CafeDeclList@ @CafeDeclList@ -> @CafeDeclList@ [assoc prec 10] .
  op __ : @CafeLDeclList@ @CafeLDeclList@ -> @CafeLDeclList@ [assoc prec 10] .
  op __ : @CafeTypeList@ @CafeTypeList@ -> @CafeTypeList@ [assoc prec 10] .
  op _,_ : @CafeParameters@ @CafeParameters@ -> @CafeParameters@ [assoc prec 45] .
  op none : -> @CafeViewDeclList@ [ctor] .
  op __ : @CafeViewDeclList@ @CafeViewDeclList@ -> @CafeViewDeclList@ [assoc id: none] .

  op _::_ : @CafeToken@ @CafeModExp@ -> @CafeParameter@ [prec 5 gather (e &)] .

  op _`(_`) : @CafeToken@ @CafeParameters@ -> @CafeInterface@ .

***(%
\end{comment}
}

Then it defines the syntax of every possible construction in CafeOBJ. For example,
we can define the syntax for:
\begin{itemize}
\item
Hidden sorts, which receive a token and create a \verb"@HiddenSortDecl@":

{\codesize
\begin{verbatim}
%)

  op *`[_`]* : @CafeToken@ -> @HiddenSortDecl@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  *** cafe module expressions !!!!
  *** op _+_ : @CafeModExp@ @CafeModExp@ -> @CafeModExp@ [ctor assoc prec 42] .
  op _`(_`) : @CafeModExp@ @CafeViewId@ -> @CafeModExp@ [ctor prec 40] .
  op _*`{_`} : @CafeModExp@ @CafeViewDeclList@ -> @CafeModExp@ [ctor prec 43] .

***(%
\end{comment}
}

\item
View identifiers, which can be either:
\begin{itemize}
\item
On the fly view declarations, receiving a module expression and a declaration
list:

{\codesize
\begin{verbatim}
%)

  op view`to_`{_`} : @CafeModExp@ @CafeViewDeclList@ -> @CafeViewId@ [ctor] .

***(%
\end{verbatim}
}

\item
The abbreviated version of the previous declaration, which does not require the
\verb"view to" keywords:

{\codesize
\begin{verbatim}
%)

  op _`{_`} : @CafeModExp@ @CafeViewDeclList@
              -> @CafeViewId@ [ctor prec 15] .

***(%
\end{verbatim}
}

\item
A view identifier assigned to a specific module expression:

{\codesize
\begin{verbatim}
%)

  op _<=_ : @CafeModExp@ @CafeViewId@
            -> @CafeViewId@ [ctor prec 20] .

***(%
\end{verbatim}
}

\item
Finally, lists of view identifiers are created by using the operator \verb"_,_".
Note that this operator is the one with the lower precedence, since it must not
interfer with the previous declarations:

{\codesize
\begin{verbatim}
%)

  op _,_ : @CafeViewIdList@ @CafeViewIdList@
           -> @CafeViewIdList@ [ctor assoc prec 25] .

***(%
\end{verbatim}
}

\end{itemize}

\item
Importations, including all the possible variants:

{\codesize
\begin{verbatim}
%)

  op protecting`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op pr`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op extending`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op ex`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op including`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op inc`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op using`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .
  op us`(_`) : @CafeModExp@ -> @CafeImportDecl@ [ctor] .

***(%
\end{verbatim}
}

\item
Sort and subsort declarations:

{\codesize
\begin{verbatim}
%)

  op `[_`] : @CafeSortList@ -> @VisibleSortDecl@ [ctor prec 5] .
  op `[_`] : @CafeSubSortRel@ -> @VisibleSortDecl@ [ctor prec 5] .

***(%
\end{verbatim}
}

\item
Subsort relations:

{\codesize
\begin{verbatim}
%)

  op _<_ : @CafeSortList@ @CafeSortList@ -> @CafeSubSortRel@ [ctor] .
  op _<_ : @CafeSortList@ @CafeSubSortRel@ -> @CafeSubSortRel@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  op var_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeVarDecl@ [ctor] .
  op vars_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeVarDecl@ [ctor] .

***(%
\end{comment}
}

\item
Equations. Note that the label or the possible attributes are not included
into the operator definition. Instead, we will deal with the bubble defining
the lefthand side to check whether there is a label. Similarly, we will
analyze the last bubble looking for attributes, such as \verb"nonexec":

{\codesize
\begin{verbatim}
%)

  op eq_=_. : @CafeBubble@ @CafeBubble@ -> @CafeEqDecl@ [ctor] .
  op ceq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ -> @CafeEqDecl@ [ctor] .
  op cq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ -> @CafeEqDecl@ [ctor] .

***(%
\end{verbatim}
}

\item
Transitions. Analogously to the case above, we do not declare explicitly the label
or the attributes of the transitions:

{\codesize
\begin{verbatim}
%)

  op trans_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op trns_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op ctrans_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                      -> @CafeTransDecl@ [ctor] .
  op ctrns_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                     -> @CafeTransDecl@ [ctor] .
  op btrans_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op btrns_=>_. : @CafeBubble@ @CafeBubble@ -> @CafeTransDecl@ [ctor] .
  op bctrans_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                       -> @CafeTransDecl@ [ctor] .
  op bctrns_=>_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@
                      -> @CafeTransDecl@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  *** Operator definitions
  op op_:`->_`{_`}. : @CafeToken@ @CafeType@ @CafeAttrList@ -> @CafeOpDecl@ [ctor] .
  op op_:_->_`{_`}. : @CafeToken@ @CafeTypeList@ @CafeSort@ @CafeAttrList@
                      -> @CafeOpDecl@ [ctor] .
  op op_:`->_. : @CafeToken@ @CafeType@ -> @CafeOpDecl@ [ctor] .
  op op_:_->_. : @CafeToken@ @CafeTypeList@ @CafeType@ -> @CafeOpDecl@ [ctor] .
  op ops_:`->_`{_`}. : @NeCafeTokenList@ @CafeType@ @CafeAttrList@ -> @CafeOpDecl@ [ctor] .
  op ops_:_->_`{_`}. : @NeCafeTokenList@ @CafeTypeList@ @CafeType@ @CafeAttrList@
                       -> @CafeOpDecl@ [ctor] .
  op ops_:`->_. : @NeCafeTokenList@ @CafeType@ -> @CafeOpDecl@ [ctor] .
  op ops_:_->_. : @NeCafeTokenList@ @CafeTypeList@ @CafeType@  -> @CafeOpDecl@ [ctor] .

***(%
\end{comment}
}

\item
Predicates. In this case the sorts for the definition are more specific than in the
cases above (where we just used bubbles), so we distinguish whether attributes are
declared or not:

{\codesize
\begin{verbatim}
%)

  op pred_:_`{_`}. : @CafeToken@ @CafeTypeList@ @CafeAttrList@
                     -> @CafeOpDecl@ [ctor] .
  op pred_:_. : @CafeToken@ @CafeTypeList@ -> @CafeOpDecl@ [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ***observer declaration
  op bop_:_->_. : @CafeToken@ @CafeTypeList@ @CafeSort@  -> @CafeOpDecl@ [ctor] .
  op bops_:_->_. : @NeCafeTokenList@ @CafeTypeList@ @CafeSort@ -> @CafeOpDecl@ [ctor] .
  op bop_:_->_`{_`}. : @CafeToken@ @CafeTypeList@ @CafeSort@ @CafeAttrList@
                       -> @CafeOpDecl@ [ctor] .
  op bops_:_->_`{_`}. : @NeCafeTokenList@ @CafeTypeList@ @CafeType@ @CafeAttrList@
                        -> @CafeOpDecl@ [ctor] .
  op bceq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ ->
                   @BehaviorEquationDecl@ [ctor] .
  op bcq_=_if_. : @CafeBubble@ @CafeBubble@ @CafeBubble@ ->
                  @BehaviorEquationDecl@ [ctor] .

  *** View declarations
  op vvar_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeViewDecl@ [ctor] .
  op vvars_:_. : @NeCafeTokenList@ @CafeType@ -> @CafeViewDecl@ [ctor] .
  op sort_->_. : @CafeToken@ @CafeToken@ -> @CafeViewDecl@ [ctor] .
  op hsort_->_. : @CafeToken@ @CafeToken@ -> @CafeViewDecl@ [ctor] .
  op op_->_. : @CafeBubble@ @CafeBubble@ -> @CafeViewDecl@ [ctor] .
  op bop_->_. : @CafeBubble@ @CafeBubble@ -> @CafeViewDecl@ [ctor] .

  *** Reduction declarations
  op reduce_. : @CafeBubble@ -> @ReductionDecl@ [ctor] .
  op red_. : @CafeBubble@ -> @ReductionDecl@ [ctor] .

***(%
\end{comment}
}

\item
Module and view declarations. Note that they do not have the exact syntax used
by CafeOBJ. This distinction is obtained after a pre-processing stage that makes sure
that there is no clash with the Maude syntax for modules and views:

{\codesize
\begin{verbatim}
%)

  op cmod*_`{_`} : @CafeInterface@ @CafeDeclList@ -> @CafeMODULE@ [ctor] .
  op cmod!_`{_`} : @CafeInterface@ @CafeLDeclList@ -> @CafeMODULE@ [ctor] .
  op cview_from_to_`{_`} : @CafeToken@ @CafeModExp@ @CafeModExp@
                           @CafeViewDeclList@ -> @CafeMODULE@ [ctor] .

***(%
\end{verbatim}
}

\item
Open-close environment. This block is composed by a module expression and a list of
declarations, possibly including reduction commands. Note that we have introduced an
extra dot to ease the parsing; this dot will be added during the preprocessing stage,
so the user is not required to type it:

{\codesize
\begin{verbatim}
%)

  op copen_._close : @CafeModExp@ @CafeLDeclList@ -> @CafeMODULE@ [ctor] .
endfm

***(%
\end{verbatim}
}

\end{itemize}

The module \verb"META-CAFE2MAUDE-SIGNATURE" contains the metapresented signature
required by CafeOBJ, which extends the one for Full Maude:

{\codesize
\begin{verbatim}
%)

fmod META-CAFE2MAUDE-SIGNATURE is
 including META-FULL-MAUDE-SIGN .

 op CafeGRAMMAR : -> FModule .
 eq CafeGRAMMAR = addImports((including 'CafeMETA-SIGN .)
                             (including 'TRANSLATION-COMMANDS .), GRAMMAR ) .
endfm

***(%
\end{verbatim}
}

The modules \verb"CafeSIGN" and \verb"OPERATOR-Cafe", just describe auxiliary functions
for dealing with CafeOBJ modules, like functions for adding new sorts, equations, or
transitions, or for obtaining these values.

{\codesize
\begin{comment}
%)

fmod CafeSIGN is
  including EXT-SORT .

  sorts HiddenSortDecl CafeDecl CafeDeclSet BehaviorEquation CafeEquation CafeEquationSet
        CafeOpDecl CafeOpDeclSet CafeModExp .

  subsort BehaviorEquation CafeEquation < CafeEquationSet .
  subsort CafeOpDecl < CafeOpDeclSet .
  subsort CafeDecl < CafeDeclSet .
  sort CafeModule .

  op *`[_`]* : SortSet -> HiddenSortDecl .
  op (bop_:_->_) : Qid TypeList Type -> CafeDecl [ctor format(g o g o g o o )] .
  op (bops_:_->_) : QidList TypeList Type -> CafeDecl [ctor format(g o g o g o o )] .
  op none : -> CafeDeclSet [ctor] .
  op __ : CafeDeclSet CafeDeclSet -> CafeDeclSet [ctor assoc comm id: none format(d ni d)] .
  op none : -> CafeEquationSet [ctor] .
  op __ : CafeEquationSet CafeEquationSet -> CafeEquationSet [ctor assoc comm id: none format(d ni d)] .
  op none : -> CafeOpDeclSet [ctor] .
  op __ : CafeOpDeclSet CafeOpDeclSet -> CafeOpDeclSet [ctor assoc comm id: none format(d ni d)] .

  op op_:_->_ : Qid TypeList Type -> CafeOpDecl [ctor format(g o g o g o o )] .
  op eq_=_. : Term Term -> CafeEquation [ctor format(g o g o g o )] .
  op ceq_=_if_. : Term Term EqCondition -> CafeEquation [ctor format(g o g o g o o o )] .
  op bceq_=_if_. : Term Term EqCondition -> BehaviorEquation [ctor format(g o g o g o o o)] .
  op pr`(_`) : ModuleExpression -> Import [ctor] .
  op ex`(_`) : ModuleExpression -> Import [ctor] .
  op inc`(_`) : ModuleExpression -> Import [ctor] .
  op us`(_`) : ModuleExpression -> Import [ctor] .
  op none : -> HiddenSortDecl [ctor] .
  op cmod*_`{_____`} : Header ImportList HiddenSortDecl CafeOpDeclSet CafeDeclSet
                       CafeEquationSet -> CafeModule
                       [ctor gather(& & & & & &) format(d d s n++i ni d d ni n--i d)] .
  op emptyCafeModule : -> CafeModule .
endfm

fmod OPERATOR-Cafe is
  including CafeSIGN .
  including UNIT .

  sorts Bop2op Bop2opList DoubleResultPair TypeConstants TypeConstantsList
        Combine4TupleResult RuleConditionPair MetaTermTriple MetaTermTripleSet .
  subsorts Bop2op < Bop2opList .
  subsorts TypeConstants < TypeConstantsList .
  subsorts MetaTermTriple < MetaTermTripleSet .

  op `[_;_`] : CafeDecl OpDecl -> Bop2op [ctor format (o o r o o o)] .
  op nil : -> Bop2opList [ctor] .
  op __ : Bop2opList Bop2opList -> Bop2opList [assoc comm id: nil ctor prec 121 gather (e E)] .
  op <_;_> : Bop2opList SModule -> DoubleResultPair [ctor] .
  op getBOP2OP : [Bop2opList] [Qid] -> [Bop2op] .
  op getBOP : Bop2op -> Qid .
  op getOP : Bop2op -> Qid .
  op getObvdType : Bop2op -> Type .
  op getTransitions : CafeDeclSet -> CafeDeclSet .
  op getHiddenSortDecl : CafeModule -> HiddenSortDecl .
  op getCafeDeclSet : CafeModule -> CafeDeclSet .
  op getSort : HiddenSortDecl -> Sort .
  op getName : CafeModule -> Header .
  op getImports : CafeModule -> ImportList .
  op getSorts : CafeModule -> SortSet .
  op getEqs : CafeModule -> CafeEquationSet .
  op getPars : CafeModule -> ParameterDeclList .
  op getOps : CafeModule -> CafeOpDeclSet .
  op getInitialState : CafeModule -> Constant .
  op getConditionOps : CafeModule -> QidList .
  op getConditionOpsAux : CafeOpDeclSet Type -> QidList .
  op setHiddenSortDecl : CafeModule HiddenSortDecl -> CafeModule .
  op setCafeDeclSet : CafeModule CafeDeclSet -> CafeModule .
  op setName : CafeModule Header -> CafeModule .
  op setImports : CafeModule ImportList -> CafeModule .
  op setOps : CafeModule CafeOpDeclSet -> CafeModule .
  op setEqs : CafeModule CafeEquationSet -> CafeModule .
  op setPars : CafeModule ParameterDeclList -> CafeModule .
  op setSubsorts : CafeModule SubsortDeclSet -> CafeModule .
  op setSorts : CafeModule SortSet -> CafeModule .
  op addHiddenSortDecl : HiddenSortDecl CafeModule -> CafeModule .
  op addCafeDeclSet : CafeDeclSet CafeModule -> CafeModule .
  op addImports : ImportList CafeModule -> CafeModule .
  op addEqs : CafeEquationSet CafeModule -> CafeModule .
  op addSorts : SortSet CafeModule -> CafeModule .
  op addOps : CafeOpDeclSet CafeModule -> CafeModule .
  op empty : CafeModule -> CafeModule .

  vars H H' : Header .
  vars IL IL' : ImportList .
  vars HSD HSD' : HiddenSortDecl .
  vars CafeOPDS CafeOPDS' : CafeOpDeclSet .
  vars OPDS OPDS' : OpDeclSet .
  vars CafeDS CafeDS' : CafeDeclSet .
  vars EqS EqS' EqCS : EquationSet .
  vars CafeEqS CafeEqS' : CafeEquationSet .
  var SS : SortSet .
  vars S HS : Sort .
  var RIS? : [RuleSet] .
  vars U CafeM : CafeModule .
  vars U' U'' M : Module .
  var ME' : ModuleExpression .
  var PDL : ParameterDeclList .
  var MAS : MembAxSet .
  var SSDS : SubsortDeclSet .
  var FM : FModule .
  vars OPS QL CS CS' : QidList .
  vars TCL TCL' : TypeConstantsList .
  var GTL : GroundTermList .
  vars TL TL' TL'' : TermList .
  vars T T' T'' T3 OT BV SV OT' BV' SV' : Term .
  vars Attr AttrS AttrS' : AttrSet .
  vars V V' : Variable .
  vars EqC EqC' : EqCondition .
  var CON : Constant .
  var RlC : Condition .
  var Rl : Rule .
  var RlS : RuleSet .
  var RP : ResultPair .
  var Eq : Equation .
  vars MTTS MTTS' : MetaTermTripleSet .
  var BOP2OP : Bop2op .
  vars MTT MTT' : MetaTermTriple .
  vars Ty Ty' Ty'' : Type .
  vars TyL TyL' : TypeList .
  vars OP OP' OP'' C C'   : Qid .
  var BOPL : Bop2opList .

  op nil : -> TypeConstants .
  op __ : TypeConstantsList TypeConstantsList -> TypeConstantsList [assoc comm id: nil] .
  op `[_;_`] : Type QidList -> TypeConstants [ctor format (o o r o o o)] .
  op add2TypeConstants : Qid TypeConstants -> TypeConstants .
  op getConstants : Type TypeConstantsList -> QidList .
  op <_;_;_> : TermList TermList AttrSet -> Combine4TupleResult .
  op <_;_> : EqCondition RuleSet -> RuleConditionPair .
  op none : -> RuleConditionPair .
  op getVariables : Term -> TermList .
  op getVariables : TermList -> TermList .
  op getVariables : Equation -> TermList .
  op getVariables : EqCondition -> TermList .
  op combineVariables : TermList TermList -> TermList .
  op inVars : Variable TermList -> Bool .
  op substitute : Qid Variable Equation -> Equation .
  op substitute : Qid Variable Term -> Term .
  op substitute : Qid Variable TermList -> TermList .
  op substitute : Qid Variable EqCondition -> EqCondition .
  op getEquations : Constant EquationSet -> EquationSet .
  op getEquations : Term EquationSet -> EquationSet .
  op contains : Term Constant -> Bool .
  op contains : TermList Constant -> Bool .
  op removeConditionEqs : EquationSet EquationSet -> EquationSet .
  op removeConditionEqC : EquationSet EqCondition -> EqCondition .
  op replaceConditionParts : EquationSet FModule -> EquationSet .

  op getConditionEqs : QidList EquationSet -> EquationSet .
  op combineRules : RuleConditionPair -> Rule .
  op combineLRA : RuleSet -> Combine4TupleResult .
  op replaceTerm : Term Term Term -> Term .
  op replaceTermList : TermList Term Term -> TermList .
  op replaceCondition : EqCondition Term Term -> EqCondition .
  op buildVar : Type TermList -> Qid .
  op buildVarAux : TermList -> Qid .
  op <_`,_`,_`,_> : Term Qid Term Term -> MetaTermTriple [ctor] .
  op empty : -> MetaTermTripleSet [ctor] .
  op __ : MetaTermTripleSet MetaTermTripleSet -> MetaTermTripleSet [assoc comm id: empty] .
  op getCafeTerm : MetaTermTriple -> Term .
  op getObsOP : MetaTermTriple -> Qid .
  op getObsVal : MetaTermTriple -> Term .
  op getSuccVal : MetaTermTriple -> Term .
  op hasCafeTerm : MetaTermTripleSet Term -> Bool .
  op getMTT : MetaTermTripleSet Term -> MetaTermTriple .
  op setCafeTerm : MetaTermTriple Term -> MetaTermTriple .
  op setObsOP : MetaTermTriple Qid -> MetaTermTriple .
  op setObsVal : MetaTermTriple Term -> MetaTermTriple .
  op setSuccVal : MetaTermTriple Term -> MetaTermTriple .
  op term2string : TermList -> String .
  op getConstantsList : Module TypeList -> TypeConstantsList .
  op getConstantsListAux1 : OpDeclSet TypeList -> TypeConstantsList .
  op getConstantsListAux2 : OpDeclSet Type -> TypeConstants .
  op add2TypeList : TypeList TypeList -> TypeList .
  op getNewCafeTerm : Bop2opList TermList Type MetaTermTripleSet -> TermList .
  op getNewCafeTermAux : Bop2opList Term MetaTermTripleSet -> TermList .
  op initialObsSuccValue : Term MetaTermTripleSet -> Term .
  op initialObsSuccValueAux : TermList MetaTermTripleSet -> TermList .
  op buildLHS : MetaTermTripleSet -> Term .
  op buildLHSAux : MetaTermTripleSet -> TermList .
  op buildRHS : MetaTermTripleSet -> Term .
  op buildRHSAux : MetaTermTripleSet -> TermList .
  op buildObsSuccValue : MetaTermTripleSet -> MetaTermTripleSet .
  op buildObsSuccValueAux : MetaTermTripleSet MetaTermTripleSet -> MetaTermTripleSet .
  op isSetExp : Type -> Bool .
  op isOccurs : Type TypeList -> Bool .

  eq getBOP2OP (([(bop OP : TyL -> Ty ) ; (op OP' : TyL' -> Ty' [Attr] .)] BOPL), OP) =
      [(bop OP : TyL -> Ty ) ; (op OP' : TyL' -> Ty' [Attr] .)] .
  eq getBOP ([(bop OP : TyL -> Ty ) ; (op OP' : TyL' -> Ty' [Attr] .)]) = OP .
  eq getOP ([(bop OP : TyL -> Ty ) ; (op OP' : TyL' -> Ty' [Attr] .)]) = OP' .
  eq getObvdType ([(bop OP : TyL -> Ty ) ; (op OP' : TyL' -> Ty' [Attr] .)]) = Ty .
  eq getBOP2OP (BOPL, OP) = nil [owise] .

  eq getConditionOps (CafeM) =
      getConditionOpsAux (getOps (CafeM), getSort (getHiddenSortDecl (CafeM))) .
  eq getConditionOpsAux ((op OP : S TyL -> 'Bool ) CafeOPDS, S) = OP getConditionOpsAux (CafeOPDS, S) .
  eq getConditionOpsAux (CafeOPDS, S) = nil [owise] .

  eq emptyCafeModule = cmod* nullHeader {nil none none none none} .
  eq getInitialState (cmod* H {IL * [S] * CafeOPDS CafeDS CafeEqS}) = qid ("init." + string (S)) .
  eq getSort ((* [S] *)) = S .
  eq getHiddenSortDecl (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = HSD .
  eq getCafeDeclSet (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = CafeDS .
  eq getName (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = H .
  eq getImports (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = IL .
  eq getSorts (cmod* H {IL * [SS] * CafeOPDS CafeDS CafeEqS}) = SS .
  eq getSorts (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = none [owise] .
  eq getOps (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = CafeOPDS .
  eq getEqs (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = CafeEqS .
  eq getPars (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}) = nil .
  eq getTransitions ((bop OP : Ty TyL -> Ty ) CafeDS) = (bop OP : Ty TyL -> Ty ) getTransitions (CafeDS) .
  eq getTransitions (none) = none .
  ceq getTransitions ((bop OP : Ty TyL -> Ty' ) CafeDS) = getTransitions (CafeDS) if Ty =/= Ty' .

  eq setHiddenSortDecl (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, HSD') = cmod* H {IL HSD' CafeOPDS CafeDS CafeEqS} .
  eq setName (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, ME') = cmod* ME' {IL HSD CafeOPDS CafeDS CafeEqS} .
  eq setCafeDeclSet (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, CafeDS') = cmod* H {IL HSD CafeOPDS CafeDS' CafeEqS} .
  eq setImports (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, IL') = cmod* H {IL' HSD CafeOPDS CafeDS CafeEqS} .
  eq setSorts (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, SS) =
                cmod* H {IL * [SS] * CafeOPDS CafeDS CafeEqS} .
  eq setOps (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, CafeOPDS') = cmod* H {IL HSD CafeOPDS' CafeDS CafeEqS} .
  eq setEqs (cmod* H {IL HSD CafeOPDS CafeDS CafeEqS}, CafeEqS') = cmod* H {IL HSD CafeOPDS CafeDS CafeEqS'} .
  eq setPars (CafeM, PDL) = CafeM .

  eq empty (CafeM) = emptyCafeModule .
  eq setSubsorts (CafeM, SSDS) = CafeM .

  eq addHiddenSortDecl (HSD, CafeM) = setHiddenSortDecl (CafeM, HSD) .
  eq addCafeDeclSet (CafeDS, CafeM) = setCafeDeclSet (CafeM, (CafeDS getCafeDeclSet (CafeM))) .
  eq addEqs (CafeEqS, CafeM) = setEqs (CafeM, CafeEqS getEqs (CafeM)) .
  eq addImports (IL, CafeM) = setImports (CafeM, IL getImports (CafeM)) .
  eq addOps (CafeOPDS, CafeM) = setOps (CafeM, CafeOPDS getOps (CafeM)) .
  eq addSorts (SS, CafeM) = setSorts (CafeM, SS ; getSorts (CafeM)) .
  eq add2TypeConstants (OP, [Ty ; OPS]) = [Ty ; OP OPS] .

  eq getConstants (Ty, [Ty ; OPS] TCL) = OPS .
  eq getConstants (Ty, TCL) = nil [owise] .

  eq replaceCondition ((T = T'), T'', T3) = (replaceTerm (T, T'', T3) = replaceTerm (T', T'', T3)) .
  eq replaceCondition ((T : Ty), T', T'') = (replaceTerm (T, T', T'') : Ty) .
  eq replaceCondition ((T := T'), T'', T3) = (replaceTerm (T, T'', T3) := replaceTerm (T', T'', T3)) .
  eq replaceCondition ((EqC /\ EqC'), T, T') = (replaceCondition (EqC, T, T') /\ replaceCondition (EqC', T, T')) .
  eq replaceCondition (nil, T, T') = nil .

  eq buildVar (Ty, TL) = if TL =/= empty then qid (string (Ty) + string (buildVarAux (TL))) else qid (string (Ty) + "@") fi .
  ceq buildVarAux ((T, TL)) = qid (string (getName (T)) + string (buildVarAux (TL))) if TL =/= empty .
  eq buildVarAux (T) = getName (T) .
  eq buildVarAux (empty) = nil .

  eq replaceTerm (T, T, T'') = T'' .
  ceq replaceTerm (T, T', T'') = OP [replaceTermList (TL, T', T'')] if OP [TL] := T .
  eq replaceTerm (T, T', T'') = T [owise] .
  eq replaceTermList ((T, TL), T', T'') = (replaceTerm (T, T', T''), replaceTermList (TL, T', T'')) .
  eq replaceTermList (empty, T, T') = empty .

  ceq combineRules (< EqC ; RlS >) = if TL'' :: NeTermList then (crl '__ [TL] => '__ [TL'] if EqC [AttrS] .) else (crl TL => TL' if EqC [AttrS] .) fi
    if < TL ; TL' ; AttrS > := combineLRA (RlS) /\ (T, TL'') := TL .
  eq combineRules (none) = none .
  ceq combineLRA ((rl T => T' [AttrS] .) RlS) = < (T, TL) ; (T', TL') ; (AttrS AttrS') > if < TL ; TL' ; AttrS' > := combineLRA (RlS) .
  eq combineLRA (none) = < empty ; empty ; none > .

  ceq getConditionEqs (OP QL, EqS) = getConditionEqs (OP, EqS) getConditionEqs (QL, EqS) if QL =/= (nil) .TypeList .
  eq getConditionEqs (OP, (eq OP [TL] = T' [AttrS] .) EqS) = (eq OP [TL] = T' [AttrS] .) getConditionEqs (OP, EqS) .
  eq getConditionEqs (OP, none) = none .
  eq getConditionEqs (OP, EqS) = none [owise] .
  eq getConditionEqs (nil, EqS) = none .

  eq removeConditionEqs (EqCS, (ceq T = T' if EqC [AttrS] .) EqS) =
      (ceq T = T' if removeConditionEqC (EqCS, EqC) [AttrS] .) removeConditionEqs (EqCS, EqS) .
  eq removeConditionEqs (EqCS, none) = none .
  eq removeConditionEqs (EqCS, EqS) = EqS [owise] .
  eq removeConditionEqC (((eq T = T'' [AttrS] .) EqCS), (T = T')) = (T'' = T') .
  eq removeConditionEqC (((eq T = T'' [AttrS] .) EqCS), (T := T')) = (T'' := T') .
  eq removeConditionEqC (((eq T = T'' [AttrS] .) EqCS), (T : S)) = (T'' : S) .
  eq removeConditionEqC (EqCS, (EqC /\ EqC')) = removeConditionEqC (EqCS, EqC) /\ removeConditionEqC (EqCS, EqC) .
  eq removeConditionEqC (EqCS, EqC) = EqC [owise] .

  ceq replaceConditionParts (((ceq T = T' if T'' = 'true.Bool [AttrS] .) EqS), FM) =
    ((ceq T = T' if getTerm (RP) = 'true.Bool [AttrS] .) replaceConditionParts (EqS, FM))
   if RP := metaReduce (FM, T'') /\ RP :: ResultPair .
  eq replaceConditionParts (none, FM) = none .
  eq replaceConditionParts (EqS, FM) = EqS [owise] .

  eq contains (OP [TL], CON) = contains (TL, CON) .
  eq contains (CON, CON) = true .
  eq contains (T, CON) = false [owise] .
  ceq contains ((T, TL), CON) = contains (T, CON) or contains (TL, CON) if TL =/= (empty) .EmptyCommaList .
  eq contains (empty, CON) = false .

  eq getEquations (CON, (eq T = T' [AttrS] .) EqS) =
      if contains (T, CON) then ((eq T = T' [AttrS] .) getEquations (CON, EqS)) else getEquations (CON, EqS) fi .
  eq getEquations (CON, EqS) = none [owise] .

  eq substitute (C, V, (eq T = T' [AttrS] .)) = (eq substitute (C, V, T) = substitute (C, V, T') [AttrS] .) .
  eq substitute (C, V, (ceq T = T' if EqC [AttrS] .)) = (ceq substitute (C, V, T) = substitute (C, V, T') if substitute (C, V, EqC) [AttrS] .) .
  eq substitute (C, V, OP [TL]) = if TL :: GroundTermList then OP [TL] else OP [substitute (C, V, TL)] fi .
  eq substitute (C, V, T) = if T == V then qid (string (C) + "." + string (getType (V))) else T fi .
  eq substitute (C, V, (T, TL)) = (substitute (C, V, T), substitute (C, V, TL)) .
  eq substitute (C, V, empty) = empty .
  ceq substitute (C, V, (EqC /\ EqC')) =
    (substitute (C, V, EqC) /\ substitute (C, V, EqC'))
   if EqC' =/= (nil) .EqCondition and EqC =/= (nil).EqCondition .
  eq substitute (C, V, (T := T')) = (substitute (C, V, T) := substitute (C, V, T')) .
  eq substitute (C, V, (T = T')) = (substitute (C, V, T) = substitute (C, V, T')) .
  eq substitute (C, V, (T : S)) = (substitute (C, V, T) := S) .
  eq substitute (C, V, (nil) .EqCondition) = (nil) .EqCondition .

  ceq getVariables ((EqC /\ EqC')) =
    combineVariables (getVariables (EqC), getVariables (EqC'))
   if EqC' =/= (nil) .EqCondition and EqC =/= (nil).EqCondition .
  eq getVariables ((T := T')) = getVariables (T) .
  eq getVariables ((T = T')) = getVariables (T) .
  eq getVariables ((T : S)) = getVariables (T) .
  eq getVariables ((nil) .EqCondition) = empty .

  eq inVars (V, (V', TL)) = if V == V' then true else inVars (V, TL) fi .
  eq inVars (V, empty) = false .

  eq combineVariables ((V, TL), TL') =
      if inVars (V, TL') then combineVariables (TL, TL') else combineVariables (TL, (V, TL')) fi .
  eq combineVariables (empty, TL) = TL .

  eq getVariables (OP [TL]) = if TL :: GroundTermList then empty else getVariables (TL) fi .
  eq getVariables (T) = if T :: Variable then T else empty fi .
  eq getVariables ((T, TL)) = combineVariables (getVariables (T), getVariables (TL)) .
  eq getVariables (empty) = empty .
  eq getVariables (eq T = T' [AttrS] .) = getVariables (T) .
  eq getVariables (ceq T = T' if EqC [AttrS] .) = combineVariables (getVariables (T), getVariables (EqC)) .

  eq isOccurs (Ty, (Ty' TyL)) = if Ty == Ty' then true else isOccurs (Ty, TyL) fi .
  eq isOccurs (Ty, nil) = false .

  ceq add2TypeList ((Ty TyL), TyL') =
     if not isOccurs (Ty, TyL') then add2TypeList (TyL, (Ty TyL')) else add2TypeList (TyL, TyL') fi
    if TyL =/= nil .
  eq add2TypeList (Ty, TyL) = if not isOccurs (Ty, TyL) then (Ty TyL) else TyL fi .
  eq add2TypeList (nil, TyL) = TyL .

  eq isSetExp (Ty) = false [owise] .
  ceq isSetExp (Ty) = true if length (string (Ty)) > 3 and substr (string (Ty), sd (length (string (Ty)), 3), length (string (Ty))) == "Set" .

  eq getConstantsList (M, TyL) = getConstantsListAux1 (getOps(M), TyL) .
  eq getConstantsListAux1 (OPDS, Ty TyL) = (getConstantsListAux2 (OPDS, Ty)) getConstantsListAux1 (OPDS, TyL) .
  eq getConstantsListAux1 (OPDS, nil) = nil .
  ceq getConstantsListAux2 ((op OP : TyL' -> Ty [Attr] .) OPDS, Ty') =
    if Ty == Ty' and TyL' == nil then
     add2TypeConstants (OP, getConstantsListAux2(OPDS, Ty')) else getConstantsListAux2 (OPDS, Ty') fi
   if not isSetExp (Ty') .
  ceq getConstantsListAux2 ((op OP : TyL' -> Ty  [Attr] .) OPDS, Ty') =
    if Ty == Ty'' and TyL' == nil then
     add2TypeConstants (OP, getConstantsListAux2 (OPDS, Ty')) else
     getConstantsListAux2 (OPDS, Ty') fi
    if isSetExp (Ty') /\ Ty'' := qid (substr (string (Ty'), 0, sd (length (string (Ty')), 3))) .
  eq getConstantsListAux2 (none, Ty) = [Ty ; nil] .

  ceq term2string ((T, TL)) = string (getName (T)) + term2string (TL) if TL =/= empty /\ T :: Variable .
  eq term2string (empty) = "" .
  ceq term2string (T) = string (getName (T)) if T :: Variable .
  eq term2string ((T, TL)) = term2string (TL) [owise] .

  eq buildObsSuccValue (MTTS) = buildObsSuccValueAux (MTTS, empty) .
  eq buildObsSuccValueAux (empty, MTTS) = MTTS .
  eq buildObsSuccValueAux (MTT, MTTS) = (setSuccVal (MTT, initialObsSuccValue (getSuccVal (MTT), (MTT MTTS))) MTTS) .
  ceq buildObsSuccValueAux ((MTT MTTS), MTTS') =
    buildObsSuccValueAux (MTTS, (MTT' MTTS'))
    if MTTS =/= empty /\
     MTT' := setSuccVal (MTT, initialObsSuccValue (getSuccVal (MTT), (MTT MTTS MTTS'))) /\
     MTT' :: MetaTermTriple .
  eq buildObsSuccValueAux (MTTS, MTTS') = MTTS' [owise] .

  eq buildRHS (< OP [T, TL], OP', BV, SV >) = (OP' [TL, SV]) .
  ceq buildRHS (< OP [T, TL], OP', BV, SV > MTTS) = '__ [OP' [TL, SV], buildRHSAux (MTTS)] if MTTS =/= empty .
  eq buildRHSAux (MTT MTTS) = (buildRHS (MTT), buildRHSAux (MTTS)) .
  eq buildRHSAux (empty) = empty .

  eq buildLHS (< OP [T, TL], OP', BV, SV >) = (OP' [TL, BV]) .
  ceq buildLHS (< OP [T, TL], OP', BV, SV > MTTS) = '__ [OP' [TL, BV], buildLHSAux (MTTS)] if MTTS =/= empty .
  eq buildLHSAux (MTT MTTS) = (buildLHS (MTT), buildLHSAux (MTTS)) .
  eq buildLHSAux (empty) = empty .

  ceq initialObsSuccValue (T, MTTS) = getObsVal (MTT) if MTT := getMTT (MTTS, T) /\ MTT =/= empty .
  ceq initialObsSuccValue (OP [TL], MTTS) = (OP [initialObsSuccValueAux (TL, MTTS)]) if not hasCafeTerm (MTTS, OP [TL]) .
  eq initialObsSuccValue (T, MTTS) = T [owise] .
  eq initialObsSuccValueAux (empty, MTTS) = empty .
  eq initialObsSuccValueAux ((T, TL), MTTS) = (initialObsSuccValue (T, MTTS), initialObsSuccValueAux (TL, MTTS)) .

  eq getMTT ((< OT, OP, BV, SV > MTTS), OT) = < OT, OP, BV, SV > .
  eq getMTT (MTTS, OT) = empty [owise] .

  ceq getNewCafeTerm (BOPL, (T, TL), Ty, MTTS) =
    (getNewCafeTerm (BOPL, T, Ty, MTTS), getNewCafeTerm (BOPL, TL, Ty, MTTS)) if TL =/= empty .
  eq getNewCafeTerm (BOPL, empty, Ty, MTTS) = empty .
  ceq getNewCafeTerm (BOPL, OP [T, TL], Ty, MTTS) =
    getNewCafeTermAux (BOPL, OP [T, TL], MTTS) if (T :: Constant or T :: Variable) /\ getType (T) == Ty .
  ceq getNewCafeTermAux (BOPL, OP [T, TL], MTTS) = empty if hasCafeTerm (MTTS, OP [T, TL]) .
  ceq getNewCafeTermAux (BOPL, OP [T, TL], MTTS) =
    (OP [T, TL]) if not hasCafeTerm (MTTS, OP [T, TL]) /\ BOP2OP := getBOP2OP (BOPL, OP) /\ BOP2OP =/= nil .
  eq getNewCafeTermAux (BOPL, T, MTTS) = empty [owise] .
  ceq getNewCafeTerm (BOPL, T, Ty, MTTS) = empty if T :: Constant or T :: Variable .
  eq getNewCafeTerm (BOPL, OP [T, TL], Ty, MTTS) =
    (getNewCafeTerm (BOPL, T, Ty, MTTS), getNewCafeTerm (BOPL, TL, Ty, MTTS)) [owise] .

  eq getCafeTerm (< OT, OP, BV, SV >) = OT .
  eq getObsOP (< OT, OP, BV, SV >) = OP .
  eq getObsVal (< OT, OP, BV, SV >) = BV .
  eq getSuccVal (< OT, OP, BV, SV >) = SV .
  eq setCafeTerm (< OT, OP, BV, SV >, OT') = < OT', OP, BV, SV > .
  eq setObsOP (< OT, OP, BV, SV >, OP') = < OT, OP', BV, SV > .
  eq setObsVal (< OT, OP, BV, SV >, BV') = < OT, OP, BV', SV > .
  eq setSuccVal (< OT, OP, BV, SV >, SV') = < OT, OP, BV, SV' > .
  eq hasCafeTerm ((< OT, OP, BV, SV > MTTS), OT) = true .
  eq hasCafeTerm (MTTS, OT) = false [owise] .
endfm

***(%
\end{comment}
}

\subsection{Parsing\label{subsec:parsing}}

The module \verb"CafeDECL-PARSING" is in charge of parsing a term built following
the syntactical constructions presented above:

{\codesize
\begin{verbatim}
%)

fmod CafeDECL-PARSING is
  inc UNIT-DECL-PARSING .
  inc OPERATOR-Cafe .
  pr MAP{Qid, Qid} * (sort Map{Qid, Qid} to SortMap) .

***(%
\end{verbatim}
}

It defines the sort \verb"CafeParseResult" to return the result of the parsing process.
The is composed of:
\begin{itemize}
\item
A term of sort \verb"ParseDeclResult". This sort, defined in Full Maude, keeps
the module obtained thus far, another module still containing bubbles, and a set of
operator declarations standing for the declaration of variables on the fly.

\item
A list of quoted identifiers, that will propagate the errors found during the
parsing process.

\item
A database, that will be updated with the new module or view if the parsing is
successful.
\end{itemize}

{\codesize
\begin{verbatim}
%)

  sort CafeParseResult .
  op <_,_,_> : ParseDeclResult QidList Database -> CafeParseResult [ctor] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  vars T T' T'' T''' T3 T4 TV TS : Term .
  vars S S' S'' : Term .
  vars TL TL' TL'' : TermList .
  vars CafeM : CafeModule .
  vars VDS VDS' : OpDeclSet .
  var  PDR : ParseDeclResult .
  vars F O : Qid .
  vars H : Header .
  vars SSDS : SubsortDeclSet .
  vars OPDS : OpDeclSet .
  vars MAS : MembAxSet .
  vars EqS : EquationSet .
  vars RIS : RuleSet .
  vars IL : ImportList .
  vars SS : SortSet .
  vars QIL' QIL QL QL' QL'' : QidList .
  vars PU U PU' U' : Module .
  var  HS : Sort .
  var  CafeDS : CafeDeclSet .
  var  CafeD  : CafeDecl .
  var  TyL : TypeList .
  var  Ty : Type .
  vars QI Q Q' : Qid .
  vars M M' : Module .
  vars DB DB' DB'' : Database .
  var  RP : [ResultPair] .
  var  N : Nat .
  var  B : Bool .
  var  PDL : ParameterDeclList .
  var  ME : ModuleExpression .
  vars SM SM' VM VM' : SortMap .
  var  V : Variable .
  var  C : Constant .
  vars St St' St'' St''' : String .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}

The function \verb"unfoldCafeOpDecl" ``unfolds'' the operator names defined in a
multiple definition by means of \verb"ops" or \verb"bops":
%)

  op unfoldCafeOpDecl : QidList TypeList Sort -> CafeOpDeclSet .
  eq unfoldCafeOpDecl((QI QIL), TyL, Ty) = (op QI : TyL -> Ty)
                                           unfoldCafeOpDecl(QIL, TyL, Ty) .
  eq unfoldCafeOpDecl(nil, TyL, Ty) = none .

  op unfoldCafe : QidList TypeList Sort -> CafeDeclSet .
  ceq unfoldCafe((QL QIL), TyL , Ty) = CafeD unfoldCafe(QIL, TyL, Ty)
   if CafeD := (bop QL : TyL -> Ty ) .
  eq unfoldCafe(nil, TyL, Ty) = none .

***(%
\end{comment}
}

{\codesize
\begin{comment}
%)

  ***parse imported expression
  op parseCafeDecl : Term CafeModule -> CafeModule .
  ceq parseCafeDecl('protecting`(_`)[T], CafeM) = addImports((protecting parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('pr`(_`)[T], CafeM) = addImports((protecting parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('extending`(_`)[T], CafeM) = addImports((extending parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('ex`(_`)[T], CafeM) = addImports((extending parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('including`(_`)[T], CafeM) = addImports((including parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('inc`(_`)[T], CafeM) = addImports((including parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('using`(_`)[T], CafeM) = addImports((including parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .
  ceq parseCafeDecl('us`(_`)[T], CafeM) = addImports((including parseModExp(T') .), CafeM)
   if T' := parseCafeModExp(T) .

***(%
\end{comment}
}

\begin{comment}

In the same way, the function \verb"parseCafeModExp" transforms the CafeOBJ syntax
for module expressions into Maude syntax. Note that the syntax for tokens is also
translated when required:

{\codesize
\begin{verbatim}
%)

  op parseCafeModExp : Term -> ModuleExpression .
  eq parseCafeModExp('CafeToken[T]) = 'token[T] .
  eq parseCafeModExp('token[T]) = 'token[T] .
  ceq parseCafeModExp('_`(_`)[T, T']) = '_`{_`}[T'', T''']
   if T'' := parseCafeModExp(T) /\
      T''' := parseCafeViewExp(T') .
  ceq parseCafeModExp('_*`{_`}[T, T']) = '_*`(_`)[T'', T''']
   if T'' := parseCafeModExp(T) /\
      T''' := parseCafeRen(T') .
  ceq parseCafeModExp('_+_[T, T']) = '_+_[T'', T''']
   if T'' := parseCafeModExp(T) /\
      T''' := parseCafeModExp(T') .

***(%
\end{verbatim}
}

\end{comment}

The function \verb"parseCafeRen" translates CafeOBJ renamings. Note that
the renaming for hidden sorts is translated as a renaming for standard sorts, since
there is no hidden sorts in Maude:

{\codesize
\begin{verbatim}
%)

  op parseCafeRen : Term -> Term .
  ceq parseCafeRen('__[T, T']) = '_`,_[T'', T3]
   if T'' := parseCafeRen(T) /\
      T3 := parseCafeRen(T') .
  ceq parseCafeRen('sort_->_.[T, T']) = 'sort_to_[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .
  ceq parseCafeRen('hsort_->_.[T, T']) = 'sort_to_[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .
  eq parseCafeRen('op_->_.['CafeBubble[T], 'CafeBubble[T']]) =
                                    'op_to_['token[T], 'token[T']] .
  eq parseCafeRen('bop_->_.['CafeBubble[T], 'CafeBubble[T']]) =
                                    'op_to_['token[T], 'token[T']] .
  eq parseCafeRen(T) = T [owise] .

***(%
\end{verbatim}
}

The function \verb"sort2sort" translates CafeOBJ tokens into Maude tokens
for sorts, while \verb"parseCafeViewExp" translates view tokens:

{\codesize
\begin{verbatim}
%)

  op sort2sort : Term -> Term .
  eq sort2sort('CafeToken[T]) = 'sortToken[T] .
  eq sort2sort(T) = T [owise] .

  op parseCafeViewExp : Term -> ViewExp .
  eq parseCafeViewExp('token[T]) = 'viewToken[T] .
  eq parseCafeViewExp(T) = T [owise] .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  *** parse hiddensort and sort
  ceq parseCafeDecl('*`[_`]*[T], CafeM) = addHiddenSortDecl((*[ HS ]*), CafeM)
   if HS := parseHiddenSort(T) .
  eq parseCafeDecl('`[_`]['neCafeTokenList[T]], CafeM) = addSorts(parseSortSet(addSortToken(T)), CafeM) .
  eq parseCafeDecl('`[_`]['CafeToken[T]], CafeM) =
         addSorts(parseSortSet('sortToken[T]), CafeM) .
  eq  parseCafeDecl('op_:`->_`{_`}.['CafeToken[T], 'CafeToken[T'], T''],  CafeM) =
        addOps((op downQid(T) : nil -> parseType('sortToken[T'])), CafeM) .
  eq  parseCafeDecl('op_:`->_`{_`}.['__[TL], 'CafeToken[T'], T''],  CafeM) =
        addOps((op tokenList2token(TL) : nil -> parseType('sortToken[T'])), CafeM) .

  ***parse normal operators
  eq parseCafeDecl('op_:`->_.['CafeToken[T], 'CafeToken[T']], CafeM) =
          addOps((op downQid(T) : nil -> parseType(cafeType2maudeType(T')) ), CafeM) .

  eq parseCafeDecl('ops_:`->_.['neCafeTokenList[T], 'CafeToken[T']], CafeM) =
      addOps(unfoldCafeOpDecl(downTypes(T), nil, parseType('sortToken[T'])), CafeM) .

  ceq parseCafeDecl('op_:_->_.['CafeToken[T], T', 'CafeToken[T'']], CafeM ) =
       addOps((op downQid(T) : parseTypeList(T4) -> parseType('sortToken[T''])), CafeM)
   if T4 := addSortToken(T') .

  ceq parseCafeDecl('pred_:_.['CafeToken[T], T'], CafeM ) =
        addOps((op downQid(T) : parseTypeList(T4) -> 'Bool), CafeM)
   if T4 := addSortToken(T') .

  ceq parseCafeDecl('ops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], CafeM) =
        addOps(unfoldCafeOpDecl(downTypes(T), parseTypeList(T4), parseType('sortToken[T''])), CafeM)
   if T4 := addSortToken(T') .

  ***ceq parseCafeDecl('op_:_->_`{_`}.['CafeToken[T], T', 'CafeToken[T''], T'''], CafeM) =
  ***    addOps((op downQid(T) : parseTypeList(T4) -> parseType('sortToken[T''])
  ***    [parsePreAttrs(T''', size(parseTypeList(T4)))] .), CafeM) if T4 := addSortToken(T') .

  ***parse behavioral operations
  eq parseCafeDecl('bop_:_->_.['CafeToken[T], T', T''], CafeM) =
       parseCafeDecl('bops_:_->_.['neCafeTokenList[T], T', T''], CafeM) .
  eq parseCafeDecl('bop_:_->_`{_`}.['CafeToken[T], T', T'', T'''], CafeM) =
       parseCafeDecl('bops_:_->_.['neCafeTokenList[T], T', T''], CafeM) .
  ceq parseCafeDecl('bops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], CafeM) =
       addCafeDeclSet(unfoldCafe(downTypes(T), parseTypeList(T4), parseType('sortToken[T''])), CafeM)
   if T4 := addSortToken(T') .
  ceq parseCafeDecl('bops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''], CafeM) =
       addCafeDeclSet(unfoldCafe(downTypes(T), parseTypeList(T4), parseType('sortToken[T''])), CafeM)
   if T4 := addSortToken(T') .

  ***parse equations at meta-level
  eq parseCafeDecl('eq_=_.['CafeBubble[T], 'CafeBubble[T']], CafeM) = CafeM . ***addEqs((eq 'T = T' [none] .), CafeM) .
  eq parseCafeDecl('cq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], CafeM) = CafeM .
  eq parseCafeDecl('ceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], CafeM) = CafeM .
   *** addEqs((ceq T = T' if T'' = ''true.Bool [none] .), CafeM) .
   ***to be handled
  eq parseCafeDecl('bceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], CafeM) = CafeM .
  eq parseCafeDecl('bcq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], CafeM) = CafeM .

  eq parseCafeDecl('var_:_.['neCafeTokenList[T], T'], CafeM) = CafeM .
  eq parseCafeDecl('vars_:_.['neCafeTokenList[T], T'], CafeM) = CafeM .


  **************************************
  ***convert to Functional Module
  **************************************

***(%
\end{comment}
}

The function \verb"parseCafeDecl" uses the function \texttt{parseCafeModExp}
to parse de module expression. Once this expression is obtained it uses the
Full Maude function

{\codesize
\begin{verbatim}
%)

  op parseCafeDecl : Term Module Module OpDeclSet Database -> CafeParseResult .
  ceq parseCafeDecl('protecting`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('protecting_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('pr`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('protecting_.[T'], PU, U, VDS) .

***(%
  ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('extending`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('extending_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('ex`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('extending_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('inc`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('including`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('using`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .
  ceq parseCafeDecl('us`(_`)[T], PU, U, VDS, DB) = < PDR, nil, DB' >
   if < T', DB' > := parseCafeModExp(T, DB) /\
      PDR := parseDecl('including_.[T'], PU, U, VDS) .

***(%
\end{comment}
}

The function \verb"parseCafeModExp" returns a term of sort \verb"ParseResult".
This sort contains a database and, depending the context where it is applied,
a module expression, a view expression, or a list of terms:

{\codesize
\begin{verbatim}
%)

  sort ParseResult .
  op <_,_> : ModuleExpression Database -> ParseResult [ctor] .
  op <_,_> : ViewExp Database -> ParseResult [ctor] .
  op <_,_> : TermList Database -> ParseResult [ctor] .

***(%
\end{verbatim}
}

Parsing simple module expressions, summations, and expressions with renamings is
straightforward:

{\codesize
\begin{verbatim}
%)

  op parseCafeModExp : Term Database -> ParseResult .
  eq parseCafeModExp('CafeToken[T], DB) = < 'token[T], DB > .
  eq parseCafeModExp('token[T], DB) = < 'token[T], DB > .
  ceq parseCafeModExp('_+_[T, T'], DB) = < '_+_[T'', T'''], DB'' >
   if < T'', DB' > := parseCafeModExp(T, DB) /\
      < T''', DB'' > := parseCafeModExp(T', DB') .
  ceq parseCafeModExp('_*`{_`}[T, T'], DB) = < '_*`(_`)[T'', T'''], DB' >
   if < T'', DB' > := parseCafeModExp(T, DB) /\
      T''' := parseCafeRen(T') .

***(%
\end{verbatim}
}

Parsing a module expression involving view expression requires the database, because
we need the list of parameters to deal with on-the-fly view declarations:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeModExp('_`(_`)[T, T'], DB) = < '_`{_`}[T'', T'''], DB'' >
   if < T'', DB' > := parseCafeModExp(T, DB) /\
      M := getTopModule(parseModExp(T''), DB') /\
      PDL := getPDL(M) /\
      < T''', DB'' > := parseCafeViewExp(PDL, sortViewId(PDL, T'), DB') .

***(%
\end{verbatim}
}

Parsing a view identifier requires the parameter list of the module being instantiated,
the view identifier itself, and the database.

{\codesize
\begin{verbatim}
%)

  op parseCafeViewExp : ParameterDeclList Term Database -> ParseResult .
  eq parseCafeViewExp(PDL, 'token[T], DB) = < 'viewToken[T], DB > .
  eq parseCafeViewExp(PDL, '_<=_[T, T'], DB) = parseCafeViewExp(PDL, T', DB) .
  ceq parseCafeViewExp(PDL, '_`,_[TL], DB) = < '_`,_[TL'], DB' >
   if < TL', DB' > := parseCafeViewExp*(PDL, TL, DB) .

***(%
\end{verbatim}
}

When parsing views declared on the fly we create a new auxiliary view, add it to the
database, and return the new database and the name of the auxiliary view:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeViewExp(Q :: ME, 'view`to_`{_`}[T, T'], DB) =
                                                      < 'viewToken[upTerm(Q')], DB' >
   if Q' := getNewName(DB, 0) /\
      T'' := 'token[upTerm(Q')] /\
      TV := 'view_from_to_is_endv[T'', 'token[upTerm(ME)], T, maps2maps(T')] /\
      DB' := procView(TV, DB) .
  ceq parseCafeViewExp(Q :: ME, '_`{_`}[T, T'], DB) = < 'viewToken[upTerm(Q')], DB' >
   if Q' := getNewName(DB, 0) /\
      T'' := 'token[upTerm(Q')] /\
      TV := 'view_from_to_is_endv[T'', 'token[upTerm(ME)], T, maps2maps(T')] /\
      DB' := procView(TV, DB) .

***(%
\end{verbatim}
}

The auxiliary functions used thus far are defined as follows:
\begin{itemize}
\item
The function \verb"parseCafeViewExp*" traverses the terms in the list,
pairing them with the parameters from the module being instantiated:

{\codesize
\begin{verbatim}
%)

  op parseCafeViewExp* : ParameterDeclList TermList Database -> ParseResult .
  eq parseCafeViewExp*(PDL, empty, DB) = < empty, DB > .
  ceq parseCafeViewExp*((Q :: ME, PDL), (T, TL), DB) = < (T', TL'), DB'' >
   if < T', DB' > := parseCafeViewExp(Q :: ME, T, DB) /\
      < TL', DB'' > := parseCafeViewExp(PDL, TL, DB') .

***(%
\end{verbatim}
}

\item
The function \verb"maps2maps" transforms CafeOBJ mappings into Maude mappings.
This is achieved by first computing the mappings for sorts and variables,
removing the variable declarations, which are not allowed in Maude, and
then applying an auxiliary \verb"maps2maps" function with $3$ arguments:

{\codesize
\begin{verbatim}
%)

  op maps2maps : Term -> Term .
  ceq maps2maps(T) = maps2maps(T', SM, VM)
   if SM := getSortMap(T) /\
      VM := getVarMap(T) /\
      T' := removeVarDecls(T) .

***(%
\end{verbatim}
}

\item
The function \verb"getSortMap" traverses the mappings, transforming them into
Maude mappings:

{\codesize
\begin{verbatim}
%)

  op getSortMap : Term -> SortMap .
  ceq getSortMap('__[T, T']) = SM, SM'
   if SM := getSortMap(T) /\
      SM' := getSortMap(T') .
  eq getSortMap('sort_->_.[T, T']) = getSort(T) |-> getSort(T') .
  eq getSortMap('hsort_->_.[T, T']) = getSort(T) |-> getSort(T') .
  eq getSortMap(T) = empty [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"getSort" just extracts the quoted identifier from the term:

{\codesize
\begin{verbatim}
%)

  op getSort : Term ~> Term .
  eq getSort('CafeToken[T]) = downQid(T) .

***(%
\end{verbatim}
}

\item
Similarly, \verb"getVarMap" traverses the term creating a mapping between variables
and their sort.
%
Note that we use \texttt{vvar} and \texttt{vvars} instead of \texttt{var} and
\texttt{vars}. This is due to a pre-processing step that aims to distinguish
between these variables and the ones in modules:

{\codesize
\begin{verbatim}
%)

  op getVarMap : Term -> SortMap .
  ceq getVarMap('__[T, T']) = VM, VM'
   if VM := getVarMap(T) /\
      VM' := getVarMap(T') .
  ceq getVarMap('vvar_:_.['neCafeTokenList[T], 'CafeToken[T']]) =
                                                          createMap*(QIL, Q)
   if QIL := downQidList(T) /\
      Q := downQid(T') .
  ceq getVarMap('vvars_:_.['neCafeTokenList[T], 'CafeToken[T']]) =
                                                          createMap*(QIL, Q)
   if QIL := downQidList(T) /\
      Q := downQid(T') .
  eq getVarMap(T) = empty [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"createMap*" just maps all the variables in the first argument to the sort
given as second argument:

{\codesize
\begin{verbatim}
%)

  op createMap* : QidList Qid -> SortMap .
  eq createMap*(nil, Q) = empty .
  eq createMap*(Q QIL, Q') = Q |-> Q', createMap*(QIL, Q') .

***(%
\end{verbatim}
}

\item
The function \verb"maps2maps" with $3$ arguments translates CafeOBJ mappings
into Maude mappings. Sort renamings only require changing the syntax:

{\codesize
\begin{verbatim}
%)

  op maps2maps : Term SortMap SortMap -> Term .
  ceq maps2maps('__[T, T'], SM, VM) = '__[T'', T3]
   if T'' := maps2maps(T, SM, VM) /\
      T3 := maps2maps(T', SM, VM) .
  ceq maps2maps('sort_->_.[T, T'], SM, VM) = 'sort_to_.[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .
  ceq maps2maps('hsort_->_.[T, T'], SM, VM) = 'sort_to_.[T'', T3]
   if T'' := sort2sort(T) /\
      T3 := sort2sort(T') .

***(%
\end{verbatim}
}

However, mapping operators might require a more complex translation, because
they can include mappings to terms. We check whether the lefthand side contains
variables. If it does not contain, then it is translated as an operator mapping;
otherwise, it is mapped to a term:

{\codesize
\begin{verbatim}
%)

  ceq maps2maps('op_->_.['CafeBubble[T], 'CafeBubble[T']], SM, VM) =
                        if T == T''
                        then 'op_to_.['token[T], 'token[T3]]
                        else 'op_to`term_.['bubble[T''], 'bubble[T3]]
                        fi
   if T'' := updateTermLHS(T, SM, VM) /\
      T3 := updateTermRHS(T', SM, VM) .

***(%
\end{verbatim}
}

Finally, behavioral operators are transformed into standard operators:

{\codesize
\begin{verbatim}
%)

  ceq maps2maps('bop_->_.['CafeBubble[T], 'CafeBubble[T']], SM, VM) =
                                      'op_to_.['bubble[T''], 'bubble[T3]]
   if T'' := updateTermLHS(T, SM, VM) /\
      T3 := updateTermRHS(T', SM, VM) .
  eq maps2maps(T, SM, VM) = T [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"updateTermLHS" traverses the constants in the term and,
if we find a variable previously defined, its sort is attached:

{\codesize
\begin{verbatim}
%)

  op updateTermLHS : Term SortMap SortMap -> Term .
  eq updateTermLHS(Q[TL], SM, VM) = Q[updateTermLHS*(TL, SM, VM)] .
  eq updateTermLHS(V, SM, VM) = V .
  ceq updateTermLHS(C, SM, VM) = upTerm(Q')
   if Q := downQid(C) /\
      VM[Q] =/= undefined /\
      Q' := qid(string(Q) + ":" + string(VM[Q])) .
  eq updateTermLHS(T, SM, VM) = T [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"updateTermRHS" also attaches the sort of the variables,
but it takes into account that \emph{the names of the sorts might have changed
due to the mappings}. Hence, it looks for the sort name in the sort mapping and
replaces it if required:

{\codesize
\begin{verbatim}
%)

  op updateTermRHS : Term SortMap SortMap -> Term .
  eq updateTermRHS(Q[TL], SM, VM) = Q[updateTermRHS*(TL, SM, VM)] .
  eq updateTermRHS(V, SM, VM) = V .
  ceq updateTermRHS(C, SM, VM) = upTerm(Q')
   if Q := downQid(C) /\
      VM[Q] =/= undefined /\
      SM[VM[Q]] == undefined /\
      Q' := qid(string(Q) + ":" + string(VM[Q])) .
  ceq updateTermRHS(C, SM, VM) = upTerm(Q')
   if Q := downQid(C) /\
      VM[Q] =/= undefined /\
      SM[VM[Q]] =/= undefined /\
      Q' := qid(string(Q) + ":" + string(SM[VM[Q]])) .
  eq updateTermRHS(T, SM, VM) = T [owise] .

***(%
\end{verbatim}
}

\item
The functions \verb"updateTermLHS*" and \verb"updateTermRHS*" just traverse
the list, applying the appropriate function to each element:

{\codesize
\begin{verbatim}
%)

  ops updateTermLHS* : TermList SortMap SortMap -> TermList .
  eq updateTermLHS*(empty, SM, VM) = empty .
  eq updateTermLHS*((T, TL), SM, VM) = updateTermLHS(T, SM, VM),
                                       updateTermLHS*(TL, SM, VM) .

  op updateTermRHS* : TermList SortMap SortMap -> TermList .
  eq updateTermRHS*(empty, SM, VM) = empty .
  eq updateTermRHS*((T, TL), SM, VM) = updateTermRHS(T, SM, VM),
                                       updateTermRHS*(TL, SM, VM) .

***(%
\end{verbatim}
}

\item
The function \verb"removeVarDecls" removes the variable declarations
from the term, by first removing them and then creating a new term with
the rest of the declarations:

{\codesize
\begin{verbatim}
%)

  op removeVarDecls : Term -> Term .
  eq removeVarDecls(T) = buildNotVarDecl(getNotVarDecl(T)) .

***(%
\end{verbatim}
}

\item
The function \verb"getNotVarDecl" checks that the operator at the top
is not a variable declaration:

{\codesize
\begin{verbatim}
%)

  op getNotVarDecl : Term -> TermList .
  ceq getNotVarDecl('__[Q[TL], Q'[TL']]) = T, T'
   if Q =/= 'vvar_:_. /\
      Q =/= 'vvars_:_. /\
      Q' =/= 'vvar_:_. /\
      Q' =/= 'vvars_:_. /\
      T := getNotVarDecl(Q[TL]) /\
      T' := getNotVarDecl(Q'[TL']) .
  ceq getNotVarDecl('__[Q[TL], Q'[TL']]) = T
   if Q == 'vvar_:_. or-else Q == 'vvars_:_. /\
      Q' =/= 'vvarrs_:_. /\
      Q' =/= 'vvars_:_. /\
      T := getNotVarDecl(Q'[TL']) .
  ceq getNotVarDecl('__[Q[TL], Q'[TL']]) = T
   if Q =/= 'vvarrs_:_. /\
      Q =/= 'vvars_:_. /\
      Q' == 'vvar_:_. or-else Q' == 'vvars_:_. /\
      T := getNotVarDecl(Q[TL]) .
  eq getNotVarDecl(T) = T [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"buildNotVarDecl" distinguishes whether the argument is
a singleton list or not, in order to use the \verb"__" operator:

{\codesize
\begin{verbatim}
%)

  op buildNotVarDecl : TermList ~> Term .
  eq buildNotVarDecl(T) = T .
  ceq buildNotVarDecl((T, TL)) = '__[T, buildNotVarDecl(TL)]
   if TL =/= empty .

***(%
\end{verbatim}
}

\item
The function \verb"sortViewId" is in charge of sorting the parameters, so they
do not rely on the naming features of CafeOBJ. If only one parameter is used or
the term does not use syntactic sugar, then it is kept the same way. Otherwise
an alternative function is used:

{\codesize
\begin{verbatim}
%)

  op sortViewId : ParameterDeclList Term -> Term .
  ceq sortViewId(PDL, Q[T, TL]) = Q[T, TL]
   if Q =/= '_`,_ or-else not usesSugar(T) .
  eq sortViewId(PDL, Q[TL]) = sortViewIdAux(PDL, TL) .

***(%
\end{verbatim}
}

\noindent
where \verb"sortViewIdAux" looks for the appropriate view identifiers by traversing the
list of parameters:

{\codesize
\begin{verbatim}
%)

  op sortViewIdAux : ParameterDeclList TermList -> TermList .
  eq sortViewIdAux(nil, TL) = empty .
  ceq sortViewIdAux((Q :: ME, PDL), TL) = find(Q, TL), sortViewIdAux(PDL, TL)
   if PDL == nil .
  eq sortViewIdAux((Q :: ME, PDL), TL) = '_`,_[find(Q, TL),
                                         sortViewIdAux(PDL, TL)] [owise] .

***(%
\end{verbatim}
}

\item
The function \verb"getPDL" extracts the parameter list from a module:

{\codesize
\begin{verbatim}
%)

  op getPDL : Module ~> ParameterDeclList .
  eq getPDL(fmod Q{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm) = PDL .
  eq getPDL(mod Q{PDL} is IL sorts SS . SSDS OPDS MAS EqS RIS endm) = PDL .

***(%
\end{verbatim}
}

\item
\verb"getNewName" checks in the database whether there already
exists a view with name created by \verb"createViewName". If true, then we try with
the next natural number, otherwise this name is used:

{\codesize
\begin{verbatim}
%)

  op getNewName : Database Nat -> Qid .
  ceq getNewName(DB, N) = if getView(Q, DB) :: View
                          then getNewName(DB, s(N))
                          else Q
                          fi
   if Q := createViewName(N) .

***(%
\end{verbatim}
}

\noindent
where \verb"createViewName" just creates a new name starting by
\texttt{OTF-VIEW}~\cite{cafeOBJ2maudeUG}, which stands for ``on the fly view'',
and followed by a natural number:

{\codesize
\begin{verbatim}
%)

  op createViewName : Nat -> Qid .
  eq createViewName(N) = qid("OTF-VIEW" + string(N, 10)) .

***(%
\end{verbatim}
}

\item
The function \verb"find" looks for the given quoted identifier, standing for a
parameter, inside a list of terms:

{\codesize
\begin{verbatim}
%)

  op find : Qid TermList -> Term .
  eq find(Q, ('_`,_[T, T'], TL)) = find(Q, (T, T', TL)) .
  eq find(Q, ('_<=_['token[T], T'], TL)) = if Q == downQid(T)
                                           then T'
                                           else find(Q, TL)
                                           fi .

***(%
\end{verbatim}
}

\item
Finally, \verb"usesSugar" checks whether the notation \verb"_<=_", used to state
the name of the parameter corresponding to the view identifier, is being used:

{\codesize
\begin{verbatim}
%)

  op usesSugar : Term -> Bool .
  eq usesSugar('_<=_[TL]) = true .
  eq usesSugar(T) = false [owise] .

***(%
\end{verbatim}
}

\end{itemize}

The parsing process continues by parsing sorts. Hidden sorts are translated
as standard Maude sorts:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('*`[_`]*['CafeToken[T]], PU, U, VDS, DB) = < PDR, nil, DB >
   if PDR := parseDecl('sort_.['sortToken[T]], PU, U, VDS) .

***(%
\end{verbatim}
}

We distinguish the operator at the top when dealing with sort declarations.
\begin{itemize}
\item
When only one sort is declared it is parsed and added to the temporal
modules with the Full Maude function \verb"parseDecl":

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('`[_`]['CafeToken[T]], PU, U, VDS, DB) = < PDR, nil, DB >
   if T' := addSortToken('CafeToken[T]) /\
      PDR := parseDecl('sorts_.[T'], PU, U, VDS) .

***(%
\end{verbatim}
}

\item
When we have a list of sorts without subsort declaration they are just parsed
and added to the current module:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('`[_`]['__[T, T']], PU, U, VDS, DB) = < PDR, nil, DB >
   if T'' := addSortToken(T) /\
      T''' := addSortToken(T') /\
      PDR := parseDecl('sorts_.['__[T'', T''']], PU, U, VDS) .

***(%
\end{verbatim}
}

\item
Finally, when we find a subsort relation both terms, the sorts are add to the
sort and the subsort relation (which might be multiple) is added to the module
thus obtained:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('`[_`]['_<_[T, T']], PU, U, VDS, DB) = < PDR, nil, DB >
   if T'' := addSortToken(T) /\
      T''' := addSortToken(T') /\
      TS := sub2sort('_<_[T, T']) /\
      < PU' ; U' ;  VDS' > := parseDecl('sorts_.[TS], PU, U, VDS) /\
      PDR := parseDecl('subsorts_.['_<_[T'', T''']], PU', U', VDS') .

***(%
\end{verbatim}
}

\end{itemize}

The auxiliary functions used for parsing sorts are:
\begin{itemize}
\item
\verb"addSortToken", which transforms CafeOBJ tokens into Maude tokens for sorts:

{\codesize
\begin{verbatim}
%)

  op addSortToken : Term -> Term .
  eq addSortToken('__[T, T']) = ('__[addSortToken(T), addSortToken(T')]) .
  eq addSortToken('_<_[T, T']) = ('_<_[addSortToken(T), addSortToken(T')]) .
  eq addSortToken('CafeToken[T]) = ('sortToken[T]) .

***(%
\end{verbatim}
}

\item
\verb"sub2sort", which flattens a subsort relation to add all the sorts to
the current module:

{\codesize
\begin{verbatim}
%)

  op sub2sort : Term -> Term .
  eq sub2sort('_<_[T, T']) = combine2sort(sub2sort(T), sub2sort(T')) .
  eq sub2sort('__['CafeToken[T], T']) = ('__['sortToken[T], sub2sort(T')]) .
  eq sub2sort('CafeToken[T]) = ('sortToken[T]) .

***(%
\end{verbatim}
}

\item
\verb"combine2sort", which puts together two terms:

{\codesize
\begin{verbatim}
%)

  op combine2sort : Term Term -> Term .
  eq combine2sort('sortToken[T], T') = '__['sortToken[T], T'] .
  eq combine2sort('__[T, T''], T''') = combine2sort(T'', '__[T, T''']) .

***(%
\end{verbatim}
}

\end{itemize}

We show now how to parse operator declarations. For the declaration of a single operator
with attributes we transform the list of sorts in the arity with \verb"addSortToken",
and then add the operator declaration with \verb"parseDecl":

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('op_:_->_`{_`}.['CafeToken[T], T', 'CafeToken[T''], T'''],  PU, U,
                    VDS, DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[T], T4, 'sortToken[T''],
                       map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('op_:_->_`{_`}.['__[TL], T', 'CafeToken[T''], T'''],  PU, U, VDS,
                    DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[upTerm(tokenList2token(TL))], T4,
                       'sortToken[T''], map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('op_:_->_.['CafeToken[T], T', 'CafeToken[T'']],  PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_.['token[T], T4, cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('op_:_->_.['__[TL], T', 'CafeToken[T'']],  PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_.['token[upTerm(tokenList2token(TL))], T4,
                                                cafeType2maudeType(T'')], PU, U, VDS) .

***(%
\end{comment}
}

The declaration of constants simplifies the task, since the arity does not appear:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('op_:`->_`{_`}.['CafeToken[T], 'CafeToken[T''], T'''],  PU, U, VDS,
                    DB) = < PDR, nil, DB >
   if PDR := parseDecl('op_:`->_`[_`].['token[T], cafeType2maudeType(T''),
                                       map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('op_:`->_.['CafeToken[T], 'CafeToken[T'']],  PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if PDR := parseDecl('op_:`->_.['token[T], cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('ops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''], PU,
                    U, VDS, DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_`[_`].['neTokenList[T], T4, cafeType2maudeType(T''),
                                        map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{comment}
}

Multiple operators with the same arity and coarity are just transformed into a nonempty
list of Maude tokens, and then introduced into the current module:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('ops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], PU, U, VDS,
                    DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_.['neTokenList[T], T4, cafeType2maudeType(T'')],
                       PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('ops_:`->_`{_`}.['neCafeTokenList[T], 'CafeToken[T''], T'''],  PU, U,
                    VDS, DB) = < PDR, nil, DB >
   if PDR := parseDecl('ops_:`->_`[_`].['neTokenList[T], cafeType2maudeType(T''),
                                        map2MaudeAttr(T''')], PU, U, VDS) .

  ceq parseCafeDecl('ops_:`->_.['neCafeTokenList[T], 'CafeToken[T'']], PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if PDR := parseDecl('ops_:`->_.['neTokenList[T], cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('bop_:_->_.['CafeToken[T], T', 'CafeToken[T'']],  PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_.['token[T], T4, cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('bop_:_->_`{_`}.['CafeToken[T], T', 'CafeToken[T''], T'''], PU, U,
                    VDS, DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[T], T4, cafeType2maudeType(T''),
                                       map2MaudeAttr(T''')], PU, U, VDS) .

  ceq parseCafeDecl('bops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']], PU, U, VDS,
                    DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_.['neTokenList[T], T4, cafeType2maudeType(T'')], PU, U, VDS) .

  ceq parseCafeDecl('ops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''], PU,
                    U, VDS, DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('ops_:_->_`[_`].['neTokenList[T], T4, cafeType2maudeType(T''),
                                        map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{comment}
}

Predicates are parsed in a similar way, since they are transformed into operators
with coarity \verb"Bool", which must be meta-represented as a token:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('pred_:_`{_`}.['CafeToken[T], T', T'''],  PU, U, VDS, DB) =
                                                                  < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_`[_`].['token[T], T4, 'sortToken[''Bool.Qid],
                       map2MaudeAttr(T''')], PU, U, VDS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('pred_:_.['CafeToken[T], T'],  PU, U, VDS, DB) = < PDR, nil, DB >
   if T4 := addSortToken(T') /\
      PDR := parseDecl('op_:_->_.['token[T], T4, 'sortToken[''Bool.Qid]], PU, U, VDS) .

***(%
\end{comment}
}

The auxiliary functions used here are:
\begin{itemize}

\item
The function \verb"tokenList2token" transforms operator defintions of the
form \verb"_ _", which are not allowed by Maude, into the equivalent \verb"__"
operator:

{\codesize
\begin{verbatim}
%)

  op tokenList2token : TermList -> Qid .
  op tokenList2token : TermList String -> Qid .

  eq tokenList2token(TL) = tokenList2token(TL, "") .
  eq tokenList2token(('CafeToken[T], TL), St) =
                       tokenList2token(TL, St + string(downQid(T))) .
  eq tokenList2token(empty, St) = qid(St) .

***(%
\end{verbatim}
}

\item
The function \verb"map2MaudeAttr" translates a list of terms written using CafeOBJ
syntax into the same list using Maude syntax. The first equation deals with the
yuxtaposition operator at the top:

{\codesize
\begin{verbatim}
%)

  op map2MaudeAttr : TermList -> TermList .
  eq map2MaudeAttr('__[TL]) = '__[map2MaudeAttr(TL)] .

***(%
\end{verbatim}
}

While the rest of equations just translates the attribute and continue with the rest
of the list, until the empty list is reached:

{\codesize
\begin{verbatim}
%)

  eq map2MaudeAttr(('constr.@CafeAttr@, TL)) = 'ctor.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('associative.@CafeAttr@, TL)) = 'assoc.@Attr@,
                                                    map2MaudeAttr(TL) .
  eq map2MaudeAttr(('assoc.@CafeAttr@, TL)) = 'assoc.@Attr@, map2MaudeAttr(TL) .

***(%
  ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  eq map2MaudeAttr(('l-assoc.@CafeAttr@, TL)) =
               'gather`(_`)['neTokenList['__[''E.Sort,''e.Sort]]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('r-assoc.@CafeAttr@, TL)) =
               'gather`(_`)['neTokenList['__[''e.Sort,''E.Sort]]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('commutative.@CafeAttr@, TL)) = 'comm.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('comm.@CafeAttr@, TL)) = 'comm.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('idempotent.@CafeAttr@, TL)) = 'idem.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('idem.@CafeAttr@, TL)) = 'idem.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('nonexec.@CafeAttr@, TL)) = 'nonexec.@Attr@, map2MaudeAttr(TL) .
  eq map2MaudeAttr(('id:`(_`)['CafeBubble[T]], TL)) = 'id:_['bubble[T]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('idr:`(_`)['CafeBubble[T]], TL)) = 'id:_['bubble[T]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('prec:_['CafeToken[T]], TL)) = 'prec_['token[T]], map2MaudeAttr(TL) .
  eq map2MaudeAttr(('metadata['CafeToken[T]], TL)) = 'metadata_['token[T]], map2MaudeAttr(TL) .

***(%
\end{comment}
}

{\codesize
\begin{verbatim}
%)

  eq map2MaudeAttr(empty) = empty .

***(%
\end{verbatim}
}

\item
The function \verb"cafeType2maudeType" transforms CafeOBJ error types into
Maude kinds:

{\codesize
\begin{verbatim}
%)

  op cafeType2maudeType : Term -> Term .
  eq cafeType2maudeType('__[TL]) = '__[cafeTypes2maudeTypes(TL)] .
  ceq cafeType2maudeType(T) = '`[_`]['sortToken[upTerm(Q')]]
   if Q := downQid(T) /\
      St := string(Q) /\
      0 == find(St, "?", 0) /\
      St' := substr(St, 1, length(St)) /\
      Q' := qid(St') .
  eq cafeType2maudeType(T) = 'sortToken[T] [owise] .

***(%
\end{verbatim}
}

\noindent
where the function \verb"cafeTypes2maudeTypes" just traverses the list
of terms, applying the function \texttt{cafeType2maudeType} to each term:

{\codesize
\begin{verbatim}
%)

  op cafeTypes2maudeTypes : TermList -> TermList .
  eq cafeTypes2maudeTypes(empty) = empty .
  eq cafeTypes2maudeTypes((T, TL)) = cafeType2maudeType(T),
                                     cafeTypes2maudeTypes(TL) .

***(%
\end{verbatim}
}

\end{itemize}

{\codesize
\begin{comment}
%)

  op parseHiddenSort : Term ~> Sort .
  eq parseHiddenSort('CafeToken[T]) =
     if downQid(T) :: Type
     then downQid(T)
     else qidError('\y 'Warning: '\o downQid(T) 'is 'not 'a 'valid 'sort. '\n)
     fi .
  eq parseHiddenSort(T) = qidError('\y 'Warning: '\o 'invalid 'sort. '\n) [owise] .

***(%
\end{comment}
}

Variables declared with the keyword \verb"var" are just translated as \verb"vars"
declarations.

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('var_:_.['neCafeTokenList[T], T'], PU, U, VDS, DB) =
                                                          < PDR, QIL, DB' >
   if < PDR, QIL, DB' > := parseCafeDecl('vars_:_.['neCafeTokenList[T], T'],
                                         PU, U, VDS, DB) .

***(%
\end{verbatim}
}

Otherwise, variables are parsed by adding them, with their sort, to the set of operators
used to parse terms in the current module:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('vars_:_.['neCafeTokenList[T], 'CafeToken[T']], PU, U, VDS, DB) =
                                                                     < PDR, nil, DB >
   if PDR := < PU ; U ; VDS parseVars(downQidList(T), parseType('sortToken[T'])) > .

***(%
\end{verbatim}
}

Equations and transitions are parsed in a similar way, so we do not show all
the variations. An unconditional equation is parsed by adding the on-the-fly
variables in the righthand side to the set of current variables, and transforming
the attributes and then using \verb"parseDecl":

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('eq_=_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, DB) =
                                              < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T'' := cafeEqAtS2maudeEqAts(T') /\
      PDR := parseDecl('eq_=_.['bubble[T], 'bubble[T'']], PU, U, VDS') .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('beq_=_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, DB) =
                                              < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T'' := cafeEqAtS2maudeEqAts(T') /\
      PDR := parseDecl('eq_=_.['bubble[T], 'bubble[T'']], PU, U, VDS') .

***(%
\end{comment}
}

Conditional equations are parsed in the same way, since the condition is dealt inside
the \verb"parseDecl" function:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('ceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('ceq_=_if_.['bubble[T], 'bubble[T'], 'bubble[T''']],
                       PU, U, VDS') .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('cq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], PU, U,
                    VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('ceq_=_if_.['bubble[T], 'bubble[T'], 'bubble[T''']], PU, U, VDS') .

  ceq parseCafeDecl('bceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], PU, U,
                    VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('ceq_=_if_.['bubble[T], 'bubble[T'], 'bubble[T''']], PU, U, VDS') .

  ceq parseCafeDecl('bcq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']], PU, U,
                    VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('ceq_=_if_.['bubble[T], 'bubble[T'], 'bubble[T''']], PU, U, VDS') .

***(%
\end{comment}
}

Transitions follow the same approach, although in this case the statement parsed
by \verb"parseDecl" is a Maude rule:

{\codesize
\begin{verbatim}
%)

  ceq parseCafeDecl('trans_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U,
                    VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T'' := cafeEqAtS2maudeEqAts(T') /\
      PDR := parseDecl('rl_=>_.['bubble[T], 'bubble[T'']], PU, U, VDS') .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('trns_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T'' := cafeEqAtS2maudeEqAts(T') /\
      PDR := parseDecl('rl_=>_.['bubble[T], 'bubble[T'']], PU, U, VDS') .

  ceq parseCafeDecl('ctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('crl_=>_if_.['bubble[T], 'bubble[T'], 'bubble[T''']], PU, U, VDS') .

  ceq parseCafeDecl('ctrns_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('crl_=>_if_.['bubble[T], 'bubble[T'], 'bubble[T''']], PU, U, VDS') .

  ceq parseCafeDecl('btrans_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T'' := cafeEqAtS2maudeEqAts(T') /\
      PDR := parseDecl('rl_=>_.['bubble[T], 'bubble[T'']], PU, U, VDS') .

  ceq parseCafeDecl('btrns_=>_.['CafeBubble[T], 'CafeBubble[T']], PU, U, VDS, DB) =
                                                                          < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T'' := cafeEqAtS2maudeEqAts(T') /\
      PDR := parseDecl('rl_=>_.['bubble[T], 'bubble[T'']], PU, U, VDS') .

  ceq parseCafeDecl('bctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('crl_=>_if_.['bubble[T], 'bubble[T'], 'bubble[T''']], PU, U, VDS') .

  ceq parseCafeDecl('bctrns_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    PU, U, VDS, DB) = < PDR, nil, DB >
   if QIL := downQidList(T) /\
      VDS' := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      PDR := parseDecl('crl_=>_if_.['bubble[T], 'bubble[T'], 'bubble[T''']], PU, U, VDS') .

***(%
\end{comment}
}

The auxiliary functions for parsing equations and transitions are:

\begin{itemize}
\item
\verb"cafeEqAtS2maudeEqAts", which just applies \texttt{cafeEqAtS2maudeEqAts*}
if it finds any attribute:

{\codesize
\begin{verbatim}
%)

  op cafeEqAtS2maudeEqAts : Term -> Term .
  eq cafeEqAtS2maudeEqAts('__[TL]) = '__[cafeEqAtS2maudeEqAts*(TL)] .
  eq cafeEqAtS2maudeEqAts(T) = T [owise] .

***(%
\end{verbatim}
}

\noindent
where \texttt{cafeEqAtS2maudeEqAts} traverses the list and transforms
the possible attributes appearing in equations and transitions:

{\codesize
\begin{verbatim}
%)

  op cafeEqAtS2maudeEqAts* : TermList -> TermList .
  eq cafeEqAtS2maudeEqAts*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) =
                      TL, ''`[.Qid, ''nonexec.Qid, TL'', ''`].Qid .
  eq cafeEqAtS2maudeEqAts*((TL, ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid)) =
                      TL, ''`[.Qid, ''metadata.Qid, TL'', ''`].Qid .
  eq cafeEqAtS2maudeEqAts*(TL) = TL [owise] .

***(%
\end{verbatim}
}

\item
\verb"opDeclSetFromQidList", which extracts an \verb"OpDeclSet" from a list of quoted
identifiers to extend the variable set with the variables defined on the fly in CafeOBJ:

{\codesize
\begin{verbatim}
%)

  op opDeclSetFromQidList : QidList -> OpDeclSet .
  eq opDeclSetFromQidList(nil) = none .
  ceq opDeclSetFromQidList(Q QL) = op qid(St') : nil -> qid(St'') [none] .
                                   opDeclSetFromQidList(QL)
   if Q =/= ': /\
      St := string(Q) /\
      N := find(St, ":", 0) /\
      St' := substr(St, 0, N) /\
      St'' := substr(St, s(N), length(St)) .
  eq opDeclSetFromQidList(Q QL) = opDeclSetFromQidList(QL) [owise] .

***(%
\end{verbatim}
}

\end{itemize}

% The reduction commands are just skipped when parsing a module. We will deal with them
% separately in the open-close environment:

{\codesize
\begin{comment}
%)

  ceq parseCafeDecl('reduce_.[T], PU, U, VDS, DB) = < PDR, nil, DB >
   if PDR := < PU ; U ; VDS > .

  ceq parseCafeDecl('red_.[T], PU, U, VDS, DB) = < PDR, nil, DB >
   if PDR := < PU ; U ; VDS > .

***(%
\end{comment}
}

{\codesize
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
}

The module \verb"CafePARSER" is in charge of parsing complete modules and views:

{\codesize
\begin{verbatim}
%)

mod CafePARSER is
  inc CafeDECL-PARSING .
  pr DATABASE-HANDLING .

***(%
\end{verbatim}
}

It builds a new term of sort \verb"CafeParseResult" returning the updated database and
a list of quoted identifiers reporting the errors found during the parsing process:

{\codesize
\begin{verbatim}
%)

  op <_,_> : Database QidList -> CafeParseResult [ctor] .

***(%
\end{verbatim}
}

% We also define other constructor for \verb"CafeParseResult", that will be
% used in open-close environments. Since these environments do not change the
% database, it is composed of a list of quoted identifiers pointing out the
% errors found during the parsing, and another list showing the results of the
% reduction commands:

{\codesize
\begin{comment}
%)

  op <_|_|_> : Database QidList QidList -> CafeParseResult [ctor] .

***(%
\end{comment}
}

{\codesize
\begin{comment}
%)

  vars T T' T'' T1 T2 T3 T4 : Term .
  vars TL PL PL' : TermList .
  var  V : Variable .
  var  C : Constant .
  vars DB DB' : Database .
  vars F Q Q' QI QI' : Qid .
  vars QIL QIL' : QidList .
  vars S S' S'' S''' St St' St'' St''' : String .
  vars CafeM CafeM' : CafeModule .
  var  VDS : OpDeclSet .
  vars PDR PDR' : ParseDeclResult .
  vars PU PU' U U' M : Module .
  var  Ty : Type .
  vars N N' : Nat .

***(%
\end{comment}
}

The constants \verb"errModName" and \texttt{paramThWarn} will report specific
errors:

{\codesize
\begin{verbatim}
%)

  op errModName : -> QidList .
  eq errModName = '\n '\r 'ERROR: '\o 'The 'module 'name 'is 'not 'a
                  'valid 'identifier. .

  op paramThWarn : -> QidList .
  eq paramThWarn = '\n '\r 'Warning: '\o 'Parameterized 'theories 'are 'not 'allowed
                   'in 'Maude. '\n 'The 'module 'was 'introduced 'with '\g 'tight '\o
                   'semantics. '\n .

***(%
\end{verbatim}
}

The function in charge of parsing modules is \verb"procCafeMod". It receives as
arguments the term to be parsed and the current Full Maude database. It just duplicates
the term to be parsed and calls to \verb"procCafeMod2":

{\codesize
\begin{verbatim}
%)

  op procCafeMod : Term Database -> CafeParseResult .
  eq procCafeMod(T, DB) = procCafeMod2(T, T, DB) .

***(%
\end{verbatim}
}

The function \verb"procCafeMod2" distinguishes between modules with loose and
tight semantics. Modules with tight semantics, will be translated as Maude modules,
and hence we just use the function \verb"procCafeMod3", propagating the parameters
if required. Note that we use an empty module, \verb"emptyFModule", indicating that
it has tight semantics:

{\codesize
\begin{verbatim}
%)

  op procCafeMod2 : Term Term Database -> CafeParseResult .
  eq procCafeMod2(T, 'cmod!_`{_`}['CafeToken[T'], T''], DB) =
                      procCafeMod3(T, 'CafeToken[T'], empty, T'',
                                   emptyFModule, DB) .
  eq procCafeMod2(T, 'cmod!_`{_`}['_`(_`)[T', T''], T3], DB) =
                      procCafeMod3(T, T', T'', T3, emptyFModule, DB) .

***(%
\end{verbatim}
}

When parsing modules with loose semantics first introduce them as a theory but,
in order to accept a wider range of CafeOBJ modules, we also introduce it into the
database as a module, adding the suffix \verb"-MODCAFE" to its name.
Note that we do not allow parameterized theories, so we use the \verb"paramThWarn"
message when they are used.
%
Also note that we use an empty module or thery depending of the semantics we
want to use:

{\codesize
\begin{verbatim}
%)

  ceq procCafeMod2(T, 'cmod*_`{_`}['CafeToken[T'], T''], DB) =
        if QIL == nil
        then procCafeMod3(T, T3, empty, T'', emptyFModule, DB')
        else < DB', QIL >
        fi
   if < DB', QIL > := procCafeMod3(T, 'CafeToken[T'], empty, T'',
                                   emptyFTheory, DB) /\
      QI := downQid(T') /\
      QI' := qid(string(QI) + "-MODCAFE") /\
      T3 := 'CafeToken[upTerm(QI')] .
  ceq procCafeMod2(T, 'cmod*_`{_`}['_`(_`)['CafeToken[T'], T''], T3], DB) =
        if QIL == nil
        then < DB', paramThWarn >
        else < DB', QIL >
        fi
   if < DB', QIL > := procCafeMod3(T, 'CafeToken[T'], T'', T3, emptyFModule, DB) .

***(%
\end{verbatim}
}

In other case an error is returned:

{\codesize
\begin{verbatim}
%)

  eq procCafeMod2(T, Q[T', T''], DB) = < DB, errModName > [owise] .

***(%
\end{verbatim}
}

The function \verb"procCafeMod3" deals with parameterized modules. If the current
modules is not parameterized we just set the name of the module and apply the
\texttt{procCafeMod4} function:

{\codesize
\begin{verbatim}
%)

  op procCafeMod3 : Term Term Term Term Module Database -> CafeParseResult .
  ceq procCafeMod3(T, 'CafeToken[T'], empty, T'', U, DB) =
         procCafeMod4(T, T'', setName(U, QI), setName(U, QI), none, DB)
   if QI := downQid(T') .

***(%
\end{verbatim}
}

When the module is parameterized we set the name of the module and then parse
the parameters to introduce them into the current module.
We use the \texttt{parseParList} function from Full Maude, which returns a
parameter list from a term.

{\codesize
\begin{verbatim}
%)

  ceq procCafeMod3(T, 'CafeToken[T'], PL, T'', U, DB) =
         procCafeMod4(T, T3, setPars(setName(U, QI), parseParList(PL')),
                      setName(U, QI), none, DB)
   if PL =/= empty /\
      PL' := cafeParam2maudeParam(PL) /\
      QI := downQid(T') /\
      QIL := cafeParamNames(PL) /\
      T3 := paramSortsMap(T'', QIL) .

***(%
\end{verbatim}
}

In other case an error is returned:

{\codesize
\begin{verbatim}
%)

  eq procCafeMod3(T, T', PL, T'', U, DB) = < DB, errModName > [owise] .

***(%
\end{verbatim}
}

The auxiliary functions required to deal with parameters are:
\begin{itemize}
\item
\verb"cafeParam2maudeParam", which translates the parameter declaration to Maude syntax:

{\codesize
\begin{verbatim}
%)

  op cafeParam2maudeParam : Term -> Term .
  eq cafeParam2maudeParam('_::_['CafeToken[T], T']) = '_::_['token[T], T'] .
  ceq cafeParam2maudeParam('_`,_[T, T']) = '_`,_[T'', T3]
   if T'' := cafeParam2maudeParam(T) /\
      T3 := cafeParam2maudeParam(T') .

***(%
\end{verbatim}
}

\item
\verb"cafeParamNames", which extracts the name of the parameters:

{\codesize
\begin{verbatim}
%)

  op cafeParamNames : Term -> QidList .
  eq cafeParamNames('_::_['CafeToken[T], T']) = downQid(T) .
  ceq cafeParamNames('_`,_[T, T']) = QIL QIL'
   if QIL := cafeParamNames(T) /\
      QIL' := cafeParamNames(T') .

***(%
\end{verbatim}
}

\item
\verb"paramSortsMap", which transforms the qualified sorts in CafeOBJ syntax into
qualified sorts in Maude syntax. It renames constants (which includes the
metarepresentation of variables) by using the names of the parameters obtained with
\texttt{cafeParamNames}. If the function is a composed term, it applies
\texttt{paramSortsMap*}:

{\codesize
\begin{verbatim}
%)

  op paramSortsMap : Term QidList -> Term .
  eq paramSortsMap(Q[TL], QIL) = Q[paramSortsMap*(TL, QIL)] .

***(%
\end{verbatim}
}

Variables are not modified:

{\codesize
\begin{verbatim}
%)

  eq paramSortsMap(V, QIL) = V .

***(%
\end{verbatim}
}

For constants, we distinguish whether they stand for a constant (including sorts)
or for a variable. When they stand for a constant, (i.e., the String \verb@":"@ cannot
be found) we split the term looking for the \verb@"."@ String, which is used in CafeOBJ
to qualify sorts, and built it again by using the \verb@"$"@ used by Maude:

{\codesize
\begin{verbatim}
%)

  ceq paramSortsMap(C, QIL) = upTerm(QI)
   if Q := downQid(C) /\
      St := string(Q) /\
      find(St, ":", 0) == notFound /\
      N := find(St, ".", 0) /\
      St' := substr(St, 0, N) /\
      St'' := substr(St, N + 1, length(St)) /\
      Q' := qid(St'') /\
      Q' in QIL /\
      QI := qid(St'' + "$" + St') .

***(%
\end{verbatim}
}

When the constant stands for a variable, we proceed in a similar way but taking into
account that the name of the variable must be placed first in both cases:

{\codesize
\begin{verbatim}
%)

  ceq paramSortsMap(C, QIL) = upTerm(QI)
   if Q := downQid(C) /\
      St := string(Q) /\
      N := find(St, ":", 0) /\
      N' := find(St, ".", 0) /\
      St' := substr(St, 0, N + 1) /\
      St'' := substr(St, N + 1, _-_(N', N + 1)) /\
      St''' := substr(St, N' + 1, length(St)) /\
      Q' := qid(St''') /\
      Q' in QIL /\
      QI := qid(St' + St''' + "$" + St'') .

***(%
\end{verbatim}
}

In other case, the constant is not modified:

{\codesize
\begin{verbatim}
%)

  eq paramSortsMap(C, QIL) = C [owise] .

***(%
\end{verbatim}
}

\item
\verb"paramSortsMap*", which just traverses the list, applying
\texttt{paramSortsMap} to each element:

{\codesize
\begin{verbatim}
%)

  op paramSortsMap* : TermList QidList -> TermList .
  eq paramSortsMap*(empty, QIL) = empty .
  eq paramSortsMap*((T, TL), QIL) = paramSortsMap(T, QIL), paramSortsMap*(TL, QIL) .

***(%
\end{verbatim}
}

\item
\verb"_in_", which looks for a quoted identifier in a list:

{\codesize
\begin{verbatim}
%)

  op _in_ : Qid QidList -> Bool .
  eq Q in nil = false .
  eq Q in Q QIL = true .
  eq Q in QIL = false [owise] .

***(%
\end{verbatim}
}

\end{itemize}

The function \verb"procCafeMod4" traverses the module, applying the function
\verb"parseCafeDecl" shown above to each statement:

{\codesize
\begin{verbatim}
%)

  op procCafeMod4 : Term Term Module Module OpDeclSet Database
                    -> CafeParseResult .
  ceq procCafeMod4(T, '__[T', T''], PU, U, VDS, DB) =
        if QIL == nil
        then procCafeMod4(T, T'', preModule(PDR), unit(PDR), vars(PDR), DB')
        else < DB,  QIL >
        fi
   if < PDR, QIL, DB' > := parseCafeDecl(T', PU, U, VDS, DB) .

***(%
\end{verbatim}
}

When only one statement remains it is parsed and the module is evaluated by means
of the \verb"evalPreModule" function:

{\codesize
\begin{verbatim}
%)

  ceq procCafeMod4(T, F[TL], PU, U, VDS, DB) =
       if QIL == nil
       then < evalPreModule(preModule(PDR), unit(PDR), vars(PDR),
                            insTermModule(getName(U), T, DB')), nil >
       else < DB, QIL >
       fi
   if F =/= '__ /\
      < PDR, QIL, DB' > := parseCafeDecl(F[TL], PU, U, VDS, DB) .

***(%
\end{verbatim}
}

The function \verb"procCafeView" is in charge of processing views. It just
translates the view and introduces it into the database:

{\codesize
\begin{verbatim}
%)

  op procCafeView : Term Database -> CafeParseResult .
  ceq procCafeView(T, DB) = < DB', nil >
   if T' := view2view(T) /\
      DB' := procView(T', DB) .

***(%
\end{verbatim}
}

\noindent
where the auxiliary functions behave as follows:
\begin{itemize}
\item
\verb"view2view" translates the term to Maude syntax, and then applies
the \verb"maps2maps" function shown above to the body:

{\codesize
\begin{verbatim}
%)

  op view2view : Term -> Term .
  eq view2view('cview_from_to_`{_`}[T, T', T'', T3]) =
        'view_from_to_is_endv[token2token(T), T', T'', maps2maps(T3)] .

***(%
\end{verbatim}
}

\item
\verb"token2token" translates a CafeOBJ token into a Maude token:

{\codesize
\begin{verbatim}
%)

  op token2token : Term -> Term .
  eq token2token('CafeToken[T]) = 'token[T] .
  eq token2token(T) = T [owise] .

***(%
\end{verbatim}
}
\end{itemize}

{\codesize
\begin{comment}
%)

  op openCloseModNameUp : -> Constant .
  eq openCloseModNameUp = ''OPEN_CLOSE.Qid .

  op openCloseModName : -> Qid .
  eq openCloseModName = 'OPEN_CLOSE .

  op procOpenCloseEnv : Term Term Database -> CafeParseResult .
  ceq procOpenCloseEnv(T, T', DB) = < DB' | QIL | QIL' >
   if T1 := 'CafeToken[openCloseModNameUp] /\
      T2 := '__['inc`(_`)[T], T'] /\
      < DB', QIL > := procCafeMod('cmod!_`{_`}[T1, T2], DB) /\
      M := getFlatModule(openCloseModName, DB') /\
      TL := getRedCommands(T') /\
      QIL' := processRedCommands(M, DB', TL) .

  op getRedCommands : Term -> TermList .
  eq getRedCommands('__[T, T']) = getRedCommands(T), getRedCommands(T') .
  eq getRedCommands(T) = getRedCommand(T) [owise] .

  op getRedCommand : Term -> TermList .
  eq getRedCommand('reduce_.['CafeBubble[T]]) = 'red_.['bubble[T]] .
  eq getRedCommand('red_.['CafeBubble[T]]) = 'red_.['bubble[T]] .
  eq getRedCommand(T) = empty [owise] .

  op processRedCommands : Module Database TermList -> QidList .
  eq processRedCommands(M, DB, empty) = nil .
  ceq processRedCommands(M, DB, ('red_.['bubble[T]], TL)) = QIL
                                                   processRedCommands(M, DB, TL)
   if *** T' := solveBubbles(T, M, false, none, DB) /\
      T' := getTerm(metaParse(M, downQidList(T), anyType)) /\
      {T'', Ty} := metaReduce(M, T') /\
      QIL := printRedRes(M, T', T'', Ty) .

  op po : -> PrintOptionSet .
  eq po = mixfix number rat format .

  op printRedRes : Module Term Term Type -> QidList .
  eq printRedRes(M, T, T', Ty) = '\n 'reduce metaPrettyPrint(M, T, po) '. '\n
                                 '\g 'Result: '\o metaPrettyPrint(M, T', po) ': Ty
                                 '\n .

***(%
\end{comment}
}
{\codesize
\begin{verbatim}
%)

endm

***(%
\end{verbatim}
}

\subsection{Pretty printing\label{subsec:pretty}}

Once the modules are parsed, it might be interesting to print them. However, we
cannot print them from the corresponding Maude module, since we have lost information
about things like hidden sorts, behavioral equations, etc. For this reason, we will
show how to print the term standing for the original CafeOBJ specification.
%
The module \verb"CAFE-PRETTY-PRINT" is in charge of printing:

{\codesize
\begin{verbatim}
%)

mod CAFE-PRETTY-PRINT is
  pr CafePARSER .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  vars QIL QIL' QIL'' QIL1 QIL2 QIL3 QIL4 QILL QILA PL : QidList .
  vars T T' T'' T''' T1 T2 T3 TW TW' : Term .
  vars ODS ODS' ODS'' VDS : OpDeclSet .
  vars St St' St'' St''' : String .
  vars ME ME' : ModuleExpression .
  vars EqS EqS' : EquationSet .
  vars TL TL' TL'' : TermList .
  var  SSDS : SubsortDeclSet .
  vars AtS AtS' : AttrSet .
  vars Q Q' GID QI : Qid .
  vars RS RS' : RuleSet .
  var  COND : Condition .
  vars M M' FM : Module .
  var  RP : ResultPair .
  var  IL : ImportList .
  var  MAS : MembAxSet .
  var  DB : Database .
  var  Ct : Constant .
  var  C : Condition .
  var  V : Variable .
  var  SS : SortSet .
  vars B B' : Bool .
  vars N N' : Nat .
  var  H : Header .
  var  S : Sort .

***(%
\end{comment}
}

We fix the Maude options for printing in the \verb"printOpts" constant:

{\codesize
\begin{verbatim}
%)

  op printOpts : -> PrintOptionSet .
  eq printOpts = mixfix number rat format .

***(%
\end{verbatim}
}

The character preceding or following a scape character is usually printed without
separation, which worsens the legibility. To prevent the system from doing it, we
use the function \verb"addSpace", which adds extra space if required:

{\codesize
\begin{verbatim}
%)

  op addSpace : QidList -> QidList .
  eq addSpace(QIL) = addSpaceL(addSpaceR(QIL)) .

***(%
\end{verbatim}
}

\noindent
where the auxiliary functions \verb"addSpaceL" and \verb"addSpaceR"
add a space at the left and the right of the list, respectively:

{\codesize
\begin{verbatim}
%)

  op addSpaceL : QidList -> QidList .
  eq addSpaceL('`( QIL) = ' '`( QIL .
  eq addSpaceL('`[ QIL) = ' '`[ QIL .
  eq addSpaceL('`{ QIL) = ' '`{ QIL .
  eq addSpaceL(QIL) = QIL [owise] .

  op addSpaceR : QidList -> QidList .
  eq addSpaceR(QIL '`)) = QIL '`) ' .
  eq addSpaceR(QIL '`]) = QIL '`] ' .
  eq addSpaceR(QIL '`}) = QIL '`} ' .
  eq addSpaceR(QIL) = QIL [owise] .

***(%
\end{verbatim}
}

The function \verb"printCond" prints a condition. It traverses each
specific condition until \verb"nil" is reached. We just show the
equality case, where both terms are printed by using the
\texttt{printOpts} constant above:

{\codesize
\begin{verbatim}
%)

  op printCond : Module Condition -> QidList .
  eq printCond(M, nil) = nil .
  eq printCond(M, T = T' /\ C) = metaPrettyPrint(M, T, printOpts) '=
                                 metaPrettyPrint(M, T', printOpts)
                                 if C == nil
                                 then nil
                                 else '/\ printCond(M, C)
                                 fi .

***(%
   ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  eq printCond(M, T := T' /\ C) = metaPrettyPrint(M, T, printOpts) ':=
                                  metaPrettyPrint(M, T', printOpts)
                                  if C == nil
                                  then nil
                                  else '/\ printCond(M, C)
                                  fi .
  eq printCond(M, T => T' /\ C) = metaPrettyPrint(M, T, printOpts) '=>
                                  metaPrettyPrint(M, T', printOpts)
                                  if C == nil
                                  then nil
                                  else '/\ printCond(M, C)
                                  fi .
  eq printCond(M, T : S /\ C) = metaPrettyPrint(M, T, printOpts) ': S
                                if C == nil
                                then nil
                                else '/\ printCond(M, C)
                                fi .

  op printCafeAtS : AttrSet -> QidList .
  eq printCafeAtS(label(Q) AtS) = printCafeAtS(AtS) .
  eq printCafeAtS(metadata("added") AtS) = printCafeAtS(AtS) .
  eq printCafeAtS(none) = nil .
  eq printCafeAtS(AtS) = '\g ' '`{ '\o printCafeAtSAux(AtS) '\g '`} '\o .

  op printCafeAtSAux : AttrSet -> QidList .
  eq printCafeAtSAux(none) = nil .
  eq printCafeAtSAux(nonexec AtS) = 'nonexec printCafeAtSAux(AtS) .
  eq printCafeAtSAux(metadata(St) AtS) = 'metadata: qid(St) printCafeAtSAux(AtS) .
  eq printCafeAtSAux(AtS) = 'No 'print 'specified. [owise] .

  op printLabel : AttrSet -> QidList .
  ceq printLabel(label(Q) AtS) = ' '`[ Q '`] ' ':
   if substr(string(Q), 0, 5) =/= "lemma" .
  eq printLabel(AtS) = nil [owise] .

***(%
  **************************
  *** Print CafeOBJ Term ***
  **************************
\end{comment}
}

The function \verb"printCafeModule" is in charge of printing CafeOBJ modules.
We only distinguish cases to print the appropriate keyword, but the rest of the
methods are common for both kinds of modules:

{\codesize
\begin{verbatim}
%)

  op printCafeModule : Term Module Database Bool -> QidList .
  ceq printCafeModule('cmod!_`{_`}[T, T'], M, DB, B) =
                      '\n 'mod! printCafeName(DB, M, T) '`{
                      '\n first(printCafeBody*(paramSortsMap(T', PL), M, DB, none, PL))
                      '\n '`}
   if PL := paramNames(T) .
  ceq printCafeModule('cmod*_`{_`}[T, T'], M, DB, B) =
                      '\n 'mod* printCafeName(DB, M, T) '`{
                      '\n first(printCafeBody*(paramSortsMap(T', PL), M, DB, none, PL))
                      '\n '`}
   if PL := paramNames(T) .

***(%
\end{verbatim}
}

\noindent
where the function \verb"paramNames" just extracts the parameter names from
the term:

{\codesize
\begin{verbatim}
%)

  op paramNames : Term -> QidList .
  eq paramNames('_`(_`)[T, T']) = cafeParamNames(T') .

***(%
\end{verbatim}
}

The function \verb"printCafeName" is in charge of printing the header
of the module. It distinguishes between all the possible module expressions:

{\codesize
\begin{verbatim}
%)

  op printCafeName : Database Module Term -> QidList .
  eq printCafeName(DB, M, 'CafeToken[T]) = downQid(T) .
  eq printCafeName(DB, M, 'token[T]) = downQid(T) .
  ceq printCafeName(DB, M, '_`(_`)[T, T']) = QIL '`( QIL' '`) '
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeViewExp(DB, M, T') .
  ceq printCafeName(DB, M, '_*`{_`}[T, T']) = QIL '* ' '`{ QIL' '`}
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeRen(T') .
  ceq printCafeName(DB, M, '_+_[T, T']) = QIL '+ QIL'
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeName(DB, M, T') .

***(%
\end{verbatim}
}

The following auxiliary functions are required by \texttt{printCafeName}:
\begin{itemize}
\item
\verb"printCafeViewExp", which prints any view expression:

{\codesize
\begin{verbatim}
%)

  op printCafeViewExp : Database Module Term -> QidList .
  eq printCafeViewExp(DB, M, 'token[T]) = downQid(T) .
  ceq printCafeViewExp(DB, M, '_`,_[T, T']) = QIL '`, ' QIL'
   if QIL := printCafeViewExp(DB, M, T) /\
      QIL' := printCafeViewExp(DB, M, T') .
  ceq printCafeViewExp(DB, M, '_::_[T, T']) = QIL ':: QIL'
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeName(DB, M, T') .
  ceq printCafeViewExp(DB, M, '_<=_[T, T']) = QIL '<= QIL'
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeViewExp(DB, M, T') .
  ceq printCafeViewExp(DB, M, 'view`to_`{_`}[T, T']) =
                                     'view 'to QIL ' '`{ ' QIL' ' '`}
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeMaps(DB, M, T') .
  ceq printCafeViewExp(DB, M, '_`{_`}[T, T']) = QIL ' '`{ ' QIL' ''`}
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeMaps(DB, M, T') .

***(%
\end{verbatim}
}

\item
\verb"printCafeMaps", which prints the possible mappings appearing in views:

{\codesize
\begin{verbatim}
%)

  op printCafeMaps : Database Module Term -> QidList .
  ceq printCafeMaps(DB, M, '__[T, T']) = QIL QIL'
   if QIL := printCafeMaps(DB, M, T) /\
      QIL' := printCafeMaps(DB, M, T') .
  ceq printCafeMaps(DB, M, 'sort_->_.[T, T']) = 'sort Q 'to Q'
   if Q := printCafeName(DB, M, T) /\
      Q' := printCafeName(DB, M, T') .
  ceq printCafeMaps(DB, M, 'hsort_->_.[T, T']) = 'hsort Q 'to Q'
   if Q := printCafeName(DB, M, T) /\
      Q' := printCafeName(DB, M, T') .
  ceq printCafeMaps(DB, M, 'op_->_.['CafeBubble[T], 'CafeBubble[T']]) =
                                                          'op QIL '-> QIL'
   if QIL := metaPrettyPrint(M, T, printOpts) /\
      QIL' := metaPrettyPrint(M, T', printOpts) .

***(%
\end{verbatim}
}

\item
\verb"printCafeRen", which is in charge of printing renamings:

{\codesize
\begin{verbatim}
%)

  op printCafeRen : Term -> QidList .
  ceq printCafeRen('__[T, T']) = QIL '`, ' QIL'
   if QIL := printCafeRen(T) /\
      QIL' := printCafeRen(T') .
  ceq printCafeRen('sort_->_.[T, T']) = 'sort QIL '-> QIL'
   if QIL := printCafeSort(T) /\
      QIL' := printCafeSort(T') .
  ceq printCafeRen('hsort_->_.[T, T']) = 'hsort QIL '-> QIL'
   if QIL := printCafeSort(T) /\
      QIL' := printCafeSort(T') .
  ceq printCafeRen('op_->_.[T, T']) = 'op QIL '-> QIL'
   if QIL := printCafeTerm(T) /\
      QIL' := printCafeTerm(T') .
  ceq printCafeRen('bop_->_.[T, T']) = 'op QIL '-> QIL'
   if QIL := printCafeTerm(T) /\
      QIL' := printCafeTerm(T') .

***(%
\end{verbatim}
}

\item
\verb"printCafeTerm", which prints a token or a singleton bubble:

{\codesize
\begin{verbatim}
%)

  op printCafeTerm : Term -> QidList .
  eq printCafeTerm('token[T]) = downQid(T) .
  eq printCafeTerm('CafeToken[T]) = downQid(T) .
  eq printCafeTerm('CafeBubble[T]) = downQid(T) .

***(%
\end{verbatim}
}

\item
\verb"printCafeSort", which just prints a token or a quoted identifier:

{\codesize
\begin{verbatim}
%)

  op printCafeSort : Term -> QidList .
  eq printCafeSort('CafeToken[T]) = downQid(T) .
  eq printCafeSort(T) = downQid(T) [owise] .

***(%
\end{verbatim}
}

\end{itemize}

We define the sort \verb"PrintCafePair" to return a pair consisting of
the list of quoted identifier computed thus far and the set of variables
defined in the module:

{\codesize
\begin{verbatim}
%)

  sort PrintCafePair .
  op <_,_> : QidList OpDeclSet -> PrintCafePair [ctor] .

***(%
\end{verbatim}
}

We also define methods \verb"first" and \verb"second" to obtain the
corresponding components:

{\codesize
\begin{verbatim}
%)

  op first : PrintCafePair -> QidList .
  eq first(< QIL, ODS >) = QIL .

  op second : PrintCafePair -> OpDeclSet .
  eq second(< QIL, ODS >) = ODS .

***(%
\end{verbatim}
}

The function \verb"printCafeBody*" receives the term standing for the original
CafeOBJ specification, the obtained Maude module, the current database, a set of
variables, and a list of parameters and returns a term of sort containing the
representation of the module and the whole set of variables. It just traverses
all the sentences in the module applying \texttt{printCafeBody} to each of them:

{\codesize
\begin{verbatim}
%)

  op printCafeBody* : Term Module Database OpDeclSet QidList -> PrintCafePair .
  ceq printCafeBody*('__[T, T'], M, DB, ODS, PL) = <
                     if QIL =/= nil
                     then '\t QIL '\n
                     else nil
                     fi QIL', ODS'' >
   if < QIL, ODS' > := printCafeBody(T, M, DB, ODS, PL) /\
      < QIL', ODS'' > := printCafeBody*(T', M, DB, ODS', PL) .
  ceq printCafeBody*(T, M, DB, ODS, PL) = < '\t QIL, ODS' >
   if < QIL, ODS' > := printCafeBody(T, M, DB, ODS, PL) .

***(%
\end{verbatim}
}

The function \verb"printCafeBody" receives a specific CafeOBJ statement and prints it.
When dealing with importations, we just use the \texttt{printCafeName} shown above:

%  *************************
%  *** Importing modules ***
%  *************************

{\codesize
\begin{verbatim}
%)

  op printCafeBody : Term Module Database OpDeclSet QidList -> PrintCafePair .
  ceq printCafeBody('protecting`(_`)[T], M, DB, ODS, PL) =
                                                   < 'protecting '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('pr`(_`)[T], M, DB, ODS, PL) = < 'pr '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('extending`(_`)[T], M, DB, ODS, PL) =
                                                   < 'extending '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('ex`(_`)[T], M, DB, ODS, PL) = < 'ex '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('including`(_`)[T], M, DB, ODS, PL) =
                                                   < 'including '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('inc`(_`)[T], M, DB, ODS, PL) = < 'inc '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('using`(_`)[T], M, DB, ODS, PL) = < 'using '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('us`(_`)[T], M, DB, ODS, PL) = < 'us '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .

***(%
\end{verbatim}
}

Printing sorts requires to modify them in order to qualify the terms following the
CafeOBJ syntax:

%  ************************
%  *** Sort definitions ***
%  ************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('*`[_`]*[T], M, DB, ODS, PL) = < '* '`[ QIL '`] '*, ODS >
   if QIL := prettyprintParams(printCafeSort(T), PL) .
  ceq printCafeBody('`[_`]['__[T, T']], M, DB, ODS, PL) = < '`[ QIL QIL' '`], ODS >
   if QIL := prettyprintParams(printCafeSort(T), PL) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) .
  ceq printCafeBody('`[_`]['CafeToken[T]], M, DB, ODS, PL) = < '`[ QIL '`], ODS >
   if QIL := prettyprintParams(printCafeSort(T), PL) .
  ceq printCafeBody('`[_`]['_<_[T, T']], M, DB, ODS, PL) = < '`[ QIL '< QIL' '`], ODS >
   if QIL := prettyprintParams*(printCafeSortList(T), PL) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) .

***(%
\end{verbatim}
}

The auxiliary function required by this function are:
\begin{itemize}
\item
\verb"prettyprintParams", which translates sorts from Maude syntax
to CafeOBJ syntax. As we decribed in Section~\ref{subsec:parsing}, we distinguish
whether the character stands for a variable or a constant. If it is a constant, we
have to reorder the term:

{\codesize
\begin{verbatim}
%)

  op prettyprintParams : Qid QidList -> Qid .
  ceq prettyprintParams(Q, PL) = QI
   if St := string(Q) /\
      find(St, ":", 0) == notFound /\
      N := find(St, "$", 0) /\
      St' := substr(St, 0, N) /\
      Q' := qid(St') /\
      Q' in PL /\
      St'' := substr(St, N + 1, length(St)) /\
      QI := qid(St'' + "." + St') .

***(%
\end{verbatim}
}

If it is a variable, we have to mantain the variable name at the beginning of
the character:

{\codesize
\begin{verbatim}
%)

  ceq prettyprintParams(Q, PL) = QI
   if St := string(Q) /\
      N := find(St, ":", 0) /\
      N' := find(St, "$", 0) /\
      St' := substr(St, 0, N) /\
      St'' := substr(St, N + 1, sd(N', N + 1)) /\
      Q' := qid(St'') /\
      Q' in PL /\
      St''' := substr(St, N' + 1, length(St)) /\
      QI := qid(St' + ":" + St''' + "." + St'') .
  eq prettyprintParams(Q, PL) = Q [owise] .

***(%
\end{verbatim}
}

\noindent
and \verb"prettyprintParams*" just traverses the list, applying
\texttt{prettyprintParams} to each element:

{\codesize
\begin{verbatim}
%)

  op prettyprintParams* : QidList QidList -> QidList .
  eq prettyprintParams*(nil, PL) = nil .
  eq prettyprintParams*(Q QIL, PL) =
                 prettyprintParams(Q, PL)
                 prettyprintParams*(QIL, PL) .

***(%
\end{verbatim}
}

\item
\verb"printCafeSortList", which prints all the subterms of the given term by
traversing the flattened list:

{\codesize
\begin{verbatim}
%)

  op printCafeSortList : Term -> QidList .
  ceq printCafeSortList('__[TL]) = QIL
   if QIL := printCafeSortList*(flatten(TL)) .
  eq printCafeSortList(T) = printCafeSort(T) [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"printCafeSortList*" just traverses the list, applying
\verb"printCafeSort" to each element:

{\codesize
\begin{verbatim}
%)

  op printCafeSortList* : TermList -> QidList .
  eq printCafeSortList*(empty) = nil .
  eq printCafeSortList*((T, TL)) = printCafeSort(T) printCafeSortList*(TL) .

***(%
\end{verbatim}
}

\noindent
and \verb"flatten" just removes the juxtaposition operator from a list:

{\codesize
\begin{verbatim}
%)

  op flatten : TermList -> TermList .
  eq flatten(empty) = empty .
  eq flatten(('__[TL], TL')) = flatten((TL, TL')) .
  eq flatten((T, TL)) = T, flatten(TL) [owise] .

***(%
\end{verbatim}
}

\end{itemize}

The printing function does not print variables, since the parsing to compute the
structure of the terms eliminates the syntactic sugar. Instead, we add the variables
to the set of operators:

%  *****************************
%  *** Variable declarations ***
%  *****************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('var_:_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                                       < nil, ODS ODS' >
   if ODS' := parseVars(downQidList(T), downQid(T')) .
  ceq printCafeBody('vars_:_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                                       < nil, ODS ODS' >
   if ODS' := parseVars(downQidList(T), downQid(T')) .

***(%
\end{verbatim}
}

Although several cases are distinguished for printing operators, most of them
work in the same way. We just show the case for basic operator declarations,
where the head and the coarity are printed:

%  *****************************
%  *** Operator declarations ***
%  *****************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('op_:`->_.[T, 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'op QIL ': '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := downQid(T') .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq printCafeBody('op_:`->_`{_`}.[T, 'CafeToken[T'], T''], M, DB, ODS, PL) =
                                        < 'op QIL ': '-> Q' ' '`{ QIL' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('bop_:`->_.[T, 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'bop QIL ': '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := prettyprintParams(downQid(T'), PL) .
  ceq printCafeBody('bop_:`->_`{_`}.[T, 'CafeToken[T'], T''], M, DB, ODS, PL) =
                                        < 'bop QIL ': '-> Q' ' '`{ QIL' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('ops_:`->_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'ops QIL ': '-> Q, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) .
  ceq printCafeBody('ops_:`->_`{_`}.['neCafeTokenList[T], 'CafeToken[T'], T''],
                    M, DB, ODS, PL) = < 'ops QIL ': '-> Q ' '`{ QIL' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('bops_:`->_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'bops QIL ': '-> Q, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) .
  ceq printCafeBody('bops_:`->_`{_`}.['neCafeTokenList[T], 'CafeToken[T'], T''],
                    M, DB, ODS, PL) = < 'bops QIL ': '-> Q ' '`{ QIL' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('op_:_->_.[T, T', 'CafeToken[T'']], M, DB, ODS, PL) =
                                        < 'op QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('op_:_->_`{_`}.[T, T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'op QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .
  ceq printCafeBody('bop_:_->_.[T, T', 'CafeToken[T'']], M, DB, ODS, PL) =
                                        < 'bop QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('bop_:_->_`{_`}.[T, T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'bop QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .
  ceq printCafeBody('ops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']],
                    M, DB, ODS, PL) = < 'ops QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('ops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'ops QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .
  ceq printCafeBody('bops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']],
                    M, DB, ODS, PL) = < 'bops QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('bops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'bops QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .

***(%
\end{comment}
}

\noindent
and for predicates, where we take care of parameters in the arity:

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('pred_:_.[T, T'], M, DB, ODS, PL) =
                                        < 'pred QIL ': QIL' '., ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq printCafeBody('pred_:_`{_`}.[T, T', T''], M, DB, ODS, PL) =
                                        < 'pred QIL ': QIL' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      QIL'' := printCafeAttS(T'', M, DB) .

***(%
\end{comment}
}

The auxiliary function \verb"printCafeOperatorHead" just puts together all the
characters in the operator name:

{\codesize
\begin{verbatim}
%)

  op printCafeOperatorHead : Term -> QidList .
  eq printCafeOperatorHead('CafeToken[T]) = downQid(T) .
  ceq printCafeOperatorHead('__[T, T']) = QIL QIL'
   if QIL := printCafeOperatorHead(T) /\
      QIL' := printCafeOperatorHead(T') .

***(%
\end{verbatim}
}

The printing function for equations and rules are also very similar, so we will
only describe an unconditional equation and a conditional rule. Since we are interested
in each part of the equation the parsing in this case is complicated, so we explain
it in detail:
\begin{itemize}
\item
We check whether the term has a label by parsing the term after trying to extract it.
If the parsing succeeds, then we keep in the \texttt{TW} the term after removing the
label; otherwise, we keep the same term.

\item
Similarly, we extract the attributes from the righthand side. However, this function
cannot fail, so it is not necessary to parse the obtained term.

\item
We compute the list of quoted identifiers standing for the new lefthand side. It will
be use to compute the new variables, kept in \verb"ODS'".

\item
We solve the bubbles in the lefthand side and keep the result in \verb"T1".

\item
We solve the bubbles in the righthand side and keep the obtained term in \verb"T2".
Solving this term requires a special function that takes into account the new
variables that appeared in the lefthand side.

\item
The representation of these terms is kept in \verb"QIL'" and \verb"QIL''", respectively.

\item
The representation of the label is stored in \verb"QILL", while the representation of
the attributes is kept in \verb"QILA".

\item
Finally, the equation is built and returned.

\end{itemize}

%  *****************************
%  *** Equation declarations ***
%  *****************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('eq_=_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'eq QILL QIL' '= QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq printCafeBody('beq_=_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'eq QILL QIL' '= QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[TW'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('ceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ceq QILL QIL' '= QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[T'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                       solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .
  ceq printCafeBody('bceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ceq QILL QIL' '= QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[T'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                       solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .
  ceq printCafeBody('cq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'cq QILL QIL1 '= QIL2 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[T'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL1 := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL2 := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                        solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .
  ceq printCafeBody('bcq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'cq QILL QIL1 '= QIL2 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[T'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL1 := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL2 := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                        solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

  *************************
  *** Rule declarations ***
  *************************
  ceq printCafeBody('trans_=>_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'trans QILL QIL' '=> QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[TW'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('btrans_=>_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'trans QILL QIL' '=> QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[TW'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('trns_=>_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'trans QILL QIL' '=> QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('ctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ctrans QILL QIL' '=> QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                         solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

  ceq printCafeBody('bctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ctrans QILL QIL' '=> QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                         solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

***(%
\end{comment}
}

Regarding conditional transitions, we have to extended the operations we performed for
unconditional statements by:
\begin{itemize}
\item
Extracting the attributes from the term standing for the condition, since this is now
the last term.

\item
Extending the module with information about sorts, required by the operators defined
with the sort \verb"Universal", to parse the condition. This is performed by applying
the Full Maude function \verb"addInfoConds" to the module extended with the variables
defined in the lefthand side.

\item
Using this extended module to solve the bubbles in the condition, and then printing
it in \verb"QIL3".

\item
The printed transition is finally composed and returned.
\end{itemize}

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('ctrns_=>_if_.['CafeBubble[T], 'CafeBubble[T'],
                    'CafeBubble[T'']], M, DB, ODS, PL) =
                           < 'ctrns QILL QIL' '=> QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                    solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

***(%
\end{verbatim}
}

The auxiliary functions used in this case are:
\begin{itemize}
\item
\verb"solveSecondTerm", which add a special operator \verb"_=_" on a new sort
\verb"@@@". We then solve the bubbles in this new sort by using the new operator.
Finally, the constants used in the parsing process are transformed back into variables
if they appear in the operator set:

{\codesize
\begin{verbatim}
%)

  op solveSecondTerm : Module Term Term OpDeclSet Database -> Term .
  ceq solveSecondTerm(M, 'bubble[T], 'bubble[T'], ODS, DB) = T2
   if M' := addOps((ODS op '_=_ : 'Universal 'Universal -> '@@@ [poly(1 2)] .),
               addSorts('@@@, M)) /\
      QIL := downQidList(T) /\
      QIL' := downQidList(T') /\
      RP := metaParse(M', '`( QIL '`) '= '`( QIL' '`), '@@@) /\
      '_=_[T1, T2] := constsToVars(getTerm(RP), ODS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  *** TODO: quitar cuando acaben las pruebas
  op asd : Term -> QidList .

  eq printCafeBody(T, M, DB, ODS, PL) = < '\r '\! 'Print 'error. asd(T) '\o, ODS > [owise] .

***(%
\end{comment}
}

\item
\verb"extractLabel", which extracts a label at the beggining of the term:

{\codesize
\begin{verbatim}
%)

  op extractLabel : Term -> Term .
  ceq extractLabel('__[''`[.Qid, T, ''`].Qid, '':.Qid, TL]) = '__[TL]
   if TL =/= empty /\
      Q := downTerm(T) .
  eq extractLabel(T) = T [owise] .

***(%
\end{verbatim}
}

\item
\verb"printLabel", which transforms a term into a list of quoted identifiers.
If the term does not correspond with a label, it is not printed:

{\codesize
\begin{verbatim}
%)

  op printLabel : Term -> QidList .
  ceq printLabel('__[''`[.Qid, T, ''`].Qid, '':.Qid, TL]) = ' '`[ Q '`] ' ':
   if TL =/= empty /\
      Q := downTerm(T) .
  eq printLabel(T) = nil [owise] .

***(%
\end{verbatim}
}

\item
\verb"removeEqAtS", which traverses the list of terms, looking for possible
attributes:

{\codesize
\begin{verbatim}
%)

  op removeEqAtS : Term -> Term .
  ceq removeEqAtS('__[TL]) = if sizeTL(TL') > 1
                             then '__[TL']
                             else TL'
                             fi
   if TL' := removeEqAts*(TL) .
  eq removeEqAtS(TL) = TL [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"removeEqAts*" removes the \verb"nonexec" and \verb"metadata" attributes:

{\codesize
\begin{verbatim}
%)

  op removeEqAts* : TermList -> TermList .
  eq removeEqAts*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) = TL .
  eq removeEqAts*((TL, ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid)) = TL .
  eq removeEqAts*(TL) = TL [owise] .

***(%
\end{verbatim}
}

\noindent
and \verb"sizeTL" just computes the size of a list of terms:

{\codesize
\begin{verbatim}
%)

  op sizeTL : TermList -> Nat .
  eq sizeTL(empty) = 0 .
  eq sizeTL((T, TL)) = s(sizeTL(TL)) .

***(%
\end{verbatim}
}

\item
Analogously, \verb"getEqAtS" returns the terms standing for the attributes:

{\codesize
\begin{verbatim}
%)

  op getEqAtS : Term -> TermList .
  eq getEqAtS('__[TL]) = getEqAtS*(TL) .
  eq getEqAtS(T) = empty [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"getEqAtS*" just looks for the \verb"nonexec" or \verb"metadata" attributes:

{\codesize
\begin{verbatim}
%)

  op getEqAtS* : Term -> TermList .
  eq getEqAtS*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) =
                                   ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid .
  eq getEqAtS*((TL, ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid)) =
                                   ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid .
  eq getEqAtS*(TL) = empty [owise] .

***(%
\end{verbatim}
}

\item
Finally, \verb"printAtS" prints the list by placing spaces at both sides (since
the attributes are placed inside curly braces):

{\codesize
\begin{verbatim}
%)

  op printAtS : TermList -> QidList .
  eq printAtS(empty) = nil .
  eq printAtS(TL) = ' downQidList(TL) ' [owise] .

***(%
\end{verbatim}
}

\end{itemize}

{\codesize
\begin{comment}

The function \verb"printCafeAttS" is used to print the attributes in operator
declarations:
%)

  op printCafeAttS : Term Module Database -> QidList .
  ceq printCafeAttS('__[T, T'], M, DB) = QIL QIL'
   if QIL := printCafeAttS(T, M, DB) /\
      QIL' := printCafeAttS(T', M, DB) .
  eq printCafeAttS('constr.@CafeAttr@, M, DB) = 'constr .
  eq printCafeAttS('associative.@CafeAttr@, M, DB) = 'associative .
  eq printCafeAttS('assoc.@CafeAttr@, M, DB) = 'assoc .
  eq printCafeAttS('l-assoc.@CafeAttr@, M, DB) = 'l-assoc .
  eq printCafeAttS('r-assoc.@CafeAttr@, M, DB) = 'r-assoc .
  eq printCafeAttS('commutative.@CafeAttr@, M, DB) = 'commutative .
  eq printCafeAttS('comm.@CafeAttr@, M, DB) = 'comm .
  eq printCafeAttS('idempotent.@CafeAttr@, M, DB) = 'idempotent .
  eq printCafeAttS('idem.@CafeAttr@, M, DB) = 'idem .
  eq printCafeAttS('nonexec.@CafeAttr@, M, DB) = 'nonexec .
  ceq printCafeAttS('prec:_['CafeToken[T]], M, DB) = 'prec: Q
   if Q := downQid(T) .
  ceq printCafeAttS('id:`(_`)['CafeBubble[T]], M, DB) = 'id: '`( QIL '`) '
   if T1 := solveBubbles('bubble[T], M, false, none, DB) /\
      QIL := metaPrettyPrint(M, T1, printOpts) .
  ceq printCafeAttS('idr:`(_`)['CafeBubble[T]], M, DB) = 'idr: '`( QIL '`) '
   if T1 := solveBubbles('bubble[T], M, false, none, DB) /\
      QIL := metaPrettyPrint(M, T1, printOpts) .

***(%
\end{comment}
}
{\codesize
\begin{verbatim}
%)

endm

***(%
\end{verbatim}
}

\subsection{Defining commands for CafeOBJ specifications\label{subsec:cafe:commands}}

We present here how to define the behavior of the commands specified for CafeOBJ
specifications. To add any other command the programmer must define it in the module
\texttt{TRANSLATION-COMMANDS} described in Section~\ref{subsec:syntax} and then define
its behavior in
the \texttt{CAFE2MAUDE-DATABASE-HANDLING} module:

{\codesize
\begin{verbatim}
%)

mod CAFE2MAUDE-DATABASE-HANDLING is
  pr CAFE-PRETTY-PRINT .
  pr CafePARSER .

***(%
\end{verbatim}
}

This module define the \verb"CafeDatabaseClass" sort, which will be used in all
the rules involving CafeOBJ specifications. Since we also want the rest of rules
from Full Maude to work, we add a subsort declaration stating that our class is
a subclass of \verb"DatabaseClass", defined in Full Maude. Finally, we define a
constant \texttt{CafeDatabase} for creating new objects:

{\codesize
\begin{verbatim}
%)

  sort CafeDatabaseClass .
  subsort CafeDatabaseClass < DatabaseClass .
  op CafeDatabase : -> CafeDatabaseClass [ctor] .

***(%
\end{verbatim}
}

We also define a new attribute, that will store whether the user wants the system
to perform a strict translation:

{\codesize
\begin{verbatim}
%)

  op strict :_ : Bool -> Attribute [ctor] .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  var  N : Nat .
  var  X@Database : CafeDatabaseClass .
  var  CafeM : CafeModule .
  var  O : Oid .
  vars Q QI F : Qid .
  vars QIL QIL' QIL'' : QidList .
  vars T T' T'' : Term .
  var  TL : TermList .
  vars H H' : Header .
  vars DB DB' DB'' : Database .
  vars MD SM SM' SM'' : SModule .
  var  Atts : AttributeSet .
  vars RP RP' : ResultPair? .
  vars ME ME' ME'' : ModuleExpression .
  var  B : Bool .
  var  ODS : OpDeclSet .
  vars M M' : Module .

***(%
\end{comment}
}

The rule \verb"load-CafeLOOSE" is in charge of loading a module with loose semantics.
It uses the function \verb"procCafeMod" from Section~\ref{subsec:parsing} to parse the
terms. If there is no errors (i.e., the variable \verb"QIL" is equals to \verb"nil")
then the database is updated and a message indicating that the module has been introduced
is shown.
If \verb"QIL" we check whether it contains an error that can be solved by translating
theories as modules. If this is the case and the user does not need a strict translation
(the boolean variable \verb"B" in the attribute \verb"strict" is set to \verb"false")
then the database is updated and a warning message is shown. Otherwise, the database
is not modified and a message is printed:

{\codesize
\begin{verbatim}
%)

  crl [load-CafeLOOSE] :
      < O : X@Database | input : ('cmod*_`{_`}[T, T']), db : DB, output : nil,
                         default : ME, strict : B, Atts >
   => if QIL == nil
      then
      < O : X@Database | input : nilTermList, db : DB',
                         output : ('Introduced 'Loose 'Cafe 'Module:
                                   '\g header2Qid(parseHeader(getHeader(T))) '\o '\n),
                         default : parseHeader(getHeader(T)), strict : B, Atts >
      else if QIL == paramThWarn
           then if B then
                     < O : X@Database | input : nilTermList, db : DB, output : QIL,
                                        default : ME, strict : B, Atts >
                else
                     < O : X@Database | input : nilTermList, db : DB', output : QIL,
                                        default : parseHeader(getHeader(T)),
                                        strict : B, Atts >
                fi
           else
                < O : X@Database | input : nilTermList, db : DB, output : QIL,
                                   default : ME, strict : B, Atts >
           fi
      fi
   if < DB', QIL > := procCafeMod('cmod*_`{_`}[T, T'], DB) .

***(%
\end{verbatim}
}

The auxiliary function \verb"getHeader" just returns the module name without parameters
and using a Maude token constructor:

{\codesize
\begin{verbatim}
%)

  op getHeader : Term -> Term .
  eq getHeader('CafeToken[T]) = 'token[T] .
  eq getHeader('_`(_`)['CafeToken[T], T']) = 'token[T] .

***(%
\end{verbatim}
}

Similarly to the previous rule, \verb"load-CafeTIGHT" is in charge of loading modules
with tight semantics. In this case we do not have to take into account whether the
message contains a warning message, because parameterized modules are allowed in Maude.
Hence, we just parse the terms with \verb"procCafeMod" and update the database if no
errors are found:

{\codesize
\begin{verbatim}
%)

   crl [load-CafeTIGHT] :
       < O : X@Database | input : ('cmod!_`{_`}[T, T']), db : DB, output : nil,
                          default : ME, strict : B, Atts >
    => if QIL == nil
       then
       < O : X@Database | input : nilTermList, db : DB',
                          output : ('Introduced 'Tight 'Cafe 'Module: '\g
                                header2Qid(parseHeader(getHeader(T))) '\o '\n),
                          default : parseHeader(getHeader(T)), strict : B, Atts >
       else
       < O : X@Database | input : nilTermList, db : DB, output : QIL,
                          default : ME, strict : B, Atts >
       fi
    if < DB', QIL > := procCafeMod('cmod!_`{_`}[T, T'], DB) .

***(%
\end{verbatim}
}

Finally, the rule \verb"load-CafeVIEW" loads a CafeOBJ view into the database.
It uses the \verb"procCafeView" function to parse the view and, if no errors are
found, then the database is updated:

{\codesize
\begin{verbatim}
%)

  crl [load-CafeVIEW] :
      < O : X@Database | input : ('cview_from_to_`{_`}[T, TL]), db : DB,
                         output : nil, Atts >
   => if QIL == nil
      then
      < O : X@Database | input : nilTermList, db : DB',
                         output : ('Introduced 'Cafe 'View: '\g
                                   header2Qid(parseHeader(getHeader(T))) '\o '\n),
                         Atts >
      else
      < O : X@Database | input : nilTermList, db : DB, output : QIL, Atts >
      fi
   if < DB', QIL > := procCafeView('cview_from_to_`{_`}[T, TL], DB) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  crl [load-open-close-block] :
      < O : X@Database | input : ('copen_._close[T, T']), db : DB,
                         output : nil, Atts >
   => if QIL == nil
      then
      < O : X@Database | input : nilTermList, db : DB,
                         output : ('\n 'Processing 'open-close 'environment:
                                   '\n QIL' '\n),
                         Atts >
      else
      < O : X@Database | input : nilTermList, db : DB, output : QIL, Atts >
      fi
   if < DB' | QIL | QIL' > := procOpenCloseEnv(T, T', DB) .

***(%
\end{comment}
}

The rule \verb"original-cafe-module" displays the CafeOBJ module originally
introduced by the user. It just obtains the module name from the command,
looks for the module in the database and prints it with \texttt{printCafeModule}:

%  ************************************************************************
%  ************************* ORIGINAL CAFE MODULE *************************
%  ************************************************************************

{\codesize
\begin{verbatim}
%)

  crl [original-cafe-module] :
      < O : X@Database | input : ('original`CafeOBJ`module_.['token[T]]),
                         output : nil, db : DB, Atts >
   => < O : X@Database | input : nilTermList, output : QIL,
                         db : DB, Atts >
   if Q := downQid(T) /\
      < T' ; ODS ; M > := getTermModule(Q, DB) /\
      M' := getFlatModule(Q, DB) /\
      QIL := printCafeModule(T', M', DB, false) .

***(%
\end{verbatim}
}

Alternatively, the rule \verb"original-cafe-module-error" is applied when
the module cannot be found:

{\codesize
\begin{verbatim}
%)

  crl [original-cafe-module-error] :
      < O : X@Database | input : ('original`CafeOBJ`module_.['token[T]]),
                         output : nil, db : DB, Atts >
   => < O : X@Database | input : nilTermList, output : ('\n '\r 'ERROR: '\o
                                              'The 'module 'cannot 'be 'found. '\n),
                         db : DB, Atts >
   if Q := downQid(T) /\
      not getTermModule(Q, DB) :: Tuple{Term,OpDeclSet,Module} .

***(%
\end{verbatim}
}

The rule \verb"strict-on" sets the value in \verb"strict" to \verb"true", and
prints a message indicating that the operation was successful:

%  **********************************************************************
%  ************************* SEMANTICS COMMANDS *************************
%  **********************************************************************

{\codesize
\begin{verbatim}
%)

  rl [strict-on] :
     < O : X@Database | input : ('strict`translation`on`..@Command@), strict : B,
                        output : nil, Atts >
  => < O : X@Database | input : nilTermList, strict : true,
                        output : ('\n '\b 'The 'modules 'will 'be 'introduced
                                  'as 'originally 'written. '\o '\n), Atts > .

***(%
\end{verbatim}
}

Similarly, the rule \verb"strict-off" sets the value in \verb"strict" to \verb"false"
and prints the corresponding message:

{\codesize
\begin{verbatim}
%)

  rl [strict-off] :
     < O : X@Database | input : ('strict`translation`off`..@Command@), strict : B,
                        output : nil, Atts >
  => < O : X@Database | input : nilTermList, strict : false,
                        output : ('\n '\b 'The 'translation 'will 'adapt 'CafeOBJ
                                  'specifications 'to 'meet 'Maude 'requirements 'when
                                  'possible. '\o '\n), Atts > .
endm

***(%
\end{verbatim}
}

The module \verb"LOOP-PRE-PROCESSING" performs some normalization actions on
the modules to simplify the parsing functions and the use of the \verb"metaParse"
command. This is specially important due to the use of bubbles, that do not delimit
the terms. Hence the functions in this module:
\begin{itemize}
\item
Add a dot at the end of the statements that do not require it and are not ``closed''
by themselves (e.g.\ the sort declaration constructor \verb"[_]" is closed, while
view mappings are not closed).

\item
Modify some characters that might cause ambiguity, such as the \verb"mod" keyword
at the beginning of a module and is also used by Maude modules.
\end{itemize}

Although the functions distinguish several cases all of them are basically implemented
in the same way, so we do not show the details here:

{\codesize
\begin{verbatim}
%)

mod LOOP-PRE-PROCESSING is
  pr LOOP-MODE .
  pr EXT-BOOL .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  vars Q Q' : Qid .
  vars QIL QIL' QIL'' QIL2 QIL3 : QidList .
  var  S : State .
  var  N : Nat .

***(%
\end{comment}
}

{\codesize
\begin{comment}

The function \verb"normalizeCafeOBJ" add a final \verb"." to delimit each possible
CafeOBJ statement:
%)

  op normalizeCafeOBJ : QidList -> QidList .
  ceq normalizeCafeOBJ(QIL Q Q' QIL') = normalizeCafeOBJ(QIL Q '. Q' QIL')
   if Q =/= '. /\ Q =/= '`, /\ Q =/= '`] /\ Q =/= '* /\ Q =/= '`) /\
     (Q' == 'eq or-else Q' == 'ceq or-else Q' == 'cq or-else
      Q' == 'op or-else Q' == 'ops or-else Q' == 'bop or-else
      Q' == 'bops or-else Q' == 'var or-else
      Q' == 'vars or-else Q' == 'beq or-else Q' == 'bceq or-else
      Q' == 'bcq or-else Q' == 'trans or-else Q' == 'btrans or-else
      Q' == 'ctrans or-else Q' == 'bctrans or-else Q' == 'trns or-else
      Q' == 'ctrns or-else Q' == 'btrns or-else Q' == 'bctrns or-else
      Q' == 'pred or-else Q' == 'red or-else Q' == 'reduce) .
  eq normalizeCafeOBJ(QIL Q '`}) = if Q =/= '. and Q =/= '`] and
                                      Q =/= '* and Q =/= '`)
                                   then normalizeImports(QIL Q '. '`})
                                   else normalizeImports(QIL Q '`})
                                   fi [owise] .
  eq normalizeCafeOBJ(QIL) = normalizeImports(QIL) [owise] .

  op normalizeImports : QidList -> QidList .
  eq normalizeImports(QIL) = normalizeImports(QIL, nil) .

  op normalizeImports : QidList QidList -> QidList .
  eq normalizeImports(nil, QIL) = QIL .
  ceq normalizeImports('protecting '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'pr '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('pr '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'pr '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('including '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'inc '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('inc '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'inc '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('extending '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'ex '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('ex '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'ex '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('using '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'us '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('us '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'us '`( QIL2)
   if < QIL2, QIL3 > := normalizeImp(QIL, nil, 0) .
  eq normalizeImports(Q QIL, QIL') = normalizeImports(QIL, QIL' Q) [owise] .

  sort NormRes .
  op <_,_> : QidList QidList -> NormRes [ctor] .

  op normalizeImp : QidList QidList Nat -> NormRes .
  eq normalizeImp('`) QIL, QIL', 0) = < QIL' '`), QIL > .
  eq normalizeImp('`) QIL, QIL', s(N)) = normalizeImp(QIL, QIL' '`), N) .
  eq normalizeImp('`( QIL, QIL', N) = normalizeImp(QIL, QIL' '`(, s(N)) .
  ceq normalizeImp('`{ QIL, QIL', N) = normalizeImp(QIL3, QIL' '`{ QIL2, N)
   if < QIL2, QIL3 > := otfView(QIL, 0) .
  eq normalizeImp(Q QIL, QIL', N) = normalizeImp(QIL, QIL' Q, N) [owise] .


  op normalizeCafeOBJView : QidList -> QidList .
  ceq normalizeCafeOBJView(QIL '`, Q QIL') = normalizeCafeOBJView(QIL '. Q QIL')
   if Q == 'sort or-else Q == 'hsort or-else Q == 'op or-else
      Q == 'bop or-else Q == 'vvar or-else Q == 'vvars .
  eq normalizeCafeOBJView(QIL 'var QIL') = normalizeCafeOBJView(QIL 'vvar QIL') .
  eq normalizeCafeOBJView(QIL 'vars QIL') = normalizeCafeOBJView(QIL 'vvars QIL') .
  eq normalizeCafeOBJView(QIL) = QIL [owise] .

  op otfView : QidList Nat -> NormRes .
  eq otfView(QIL, N) = otfView(QIL, nil, N) .

  op otfView : QidList QidList Nat -> NormRes .
  eq otfView('`} QIL, QIL', 0) = < normalizeCafeOBJView(QIL' '. '`}), QIL > .
  eq otfView('`} QIL, QIL', s(N)) = otfView(QIL, QIL' '`}, N) .
  eq otfView('`{ QIL, QIL', N) = otfView(QIL, QIL' '`{, s(N)) .
  eq otfView(Q QIL, QIL', N) = otfView(QIL, QIL' Q, N) [owise] .

  op normalizeOpenClose : QidList -> QidList .
  *** We look for the end of the module expression to place the dot
  ceq normalizeOpenClose(Q Q' QIL) = Q '. normOpenCloseAux(Q' QIL)
   if Q' == '`[ or-else Q == '* or-else
      Q' == 'eq or-else Q' == 'ceq or-else Q' == 'cq or-else
      Q' == 'op or-else Q' == 'ops or-else Q' == 'bop or-else
      Q' == 'bops or-else Q' == 'var or-else
      Q' == 'vars or-else Q' == 'beq or-else Q' == 'bceq or-else
      Q' == 'bcq or-else Q' == 'trans or-else Q' == 'btrans or-else
      Q' == 'ctrans or-else Q' == 'bctrans or-else Q' == 'trns or-else
      Q' == 'ctrns or-else Q' == 'btrns or-else Q' == 'bctrns or-else
      Q' == 'pred or-else Q' == 'red or-else Q' == 'reduce .
  eq normalizeOpenClose(Q Q' QIL) = Q normalizeOpenClose(Q' QIL) [owise] .


  op normOpenCloseAux : QidList -> QidList .
  ceq normOpenCloseAux(QIL Q Q' QIL') = normOpenCloseAux(QIL Q '. Q' QIL')
   if Q =/= '. /\ Q =/= '`, /\ Q =/= '`] /\ Q =/= '* /\ Q =/= '`) /\
     (Q' == 'eq or-else Q' == 'ceq or-else Q' == 'cq or-else
      Q' == 'op or-else Q' == 'ops or-else Q' == 'bop or-else
      Q' == 'bops or-else Q' == 'var or-else
      Q' == 'vars or-else Q' == 'beq or-else Q' == 'bceq or-else
      Q' == 'bcq or-else Q' == 'trans or-else Q' == 'btrans or-else
      Q' == 'ctrans or-else Q' == 'bctrans or-else Q' == 'trns or-else
      Q' == 'ctrns or-else Q' == 'btrns or-else Q' == 'bctrns or-else
      Q' == 'pred or-else Q' == 'red or-else Q' == 'reduce) .
  eq normOpenCloseAux(QIL Q 'close) = if Q =/= '. and Q =/= '`] and
                                         Q =/= '* and Q =/= '`)
                                      then QIL Q '. 'close
                                      else QIL Q 'close
                                      fi [owise] .

  eq ['mod! QIL '`}, S, QIL'] = [normalizeCafeOBJ('cmod! QIL '`}), S, QIL'] .
  eq ['module! QIL '`}, S, QIL'] = ['mod! QIL '`}, S, QIL'] .
  eq ['mod* QIL '`}, S, QIL'] = [normalizeCafeOBJ('cmod* QIL '`}), S, QIL'] .
  eq ['module* QIL '`}, S, QIL'] = ['mod* QIL '`}, S, QIL'] .
  eq ['open QIL 'close, S, QIL'] = ['copen normalizeOpenClose(QIL 'close), S, QIL'] .
  eq ['view QIL '`}, S, QIL'] = [normalizeCafeOBJView('cview QIL '. '`}), S, QIL'] .
  eq ['make Q QIL, S, QIL'] = ['mod! Q '`{ 'pr QIL '`}, S, QIL'] .
  ceq [QIL 'eq '`[ Q '`] Q' QIL', S, QIL''] = [QIL 'eq '`[ Q '`] ': Q' QIL', S, QIL'']
   if Q' =/= ': .

***(%
\end{comment}
}
{\codesize
\begin{verbatim}
  ...
%)

endm

***(%
\end{verbatim}
}

Finally, the \verb"CAFE2MAUDE" module is the standard module dealing with input/output
through the Loop Mode~\cite[Chapter~17]{maude-book}. Basically, this module uses a tuple
built with the operator \verb"[_,_,_]", where the first argument corresponds to the
input introduced by the user, the third one the output shown to the user, and the second
one is a term of sort \verb"State" that can be defined by the user for each application:

{\codesize
\begin{verbatim}
%)

mod CAFE2MAUDE is
  ex LOOP-PRE-PROCESSING .
  pr META-CAFE2MAUDE-SIGNATURE .
  pr CAFE2MAUDE-DATABASE-HANDLING .

***(%
\end{verbatim}
}

We will use the sort \verb"Object" for the current state, which means that we will
store the values in a term built with the operator \verb"<_:_|_>", with the first
argument the name of the object, the second one the name of the class, and the third
one a set of attributes.
%
We also define a constant \verb"o" of sort \verb"Oid" to define the name of the initial
state:

{\codesize
\begin{verbatim}
%)

  subsort Object < State .
  op o : -> Oid .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  var  H : Header .
  var  O : Oid .
  var  X@Database : CafeDatabaseClass .
  vars Q Q' QI : Qid .
  vars QIL QIL' QIL'' : QidList .
  var  TL : TermList .
  var  DB : Database .
  var  Atts : AttributeSet .
  var  S : State .

***(%
\end{comment}
}

We define the constant \verb"cafe2maude-init" as the initial system. The user has to
rewrite it with the special command \verb"loop" to start the input/output loop.

%  ---------------------------------------------------------------------------------------
%  --------------------------------------- IN --------------------------------------------
%  ---------------------------------------------------------------------------------------

{\codesize
\begin{verbatim}
%)

  op cafe2maude-init : -> System .

***(%
\end{verbatim}
}

When the user types that command the system will apply the rule \verb"init" below.
It creates the whole sytem, with an empty list of quoted identifiers in the input
(the first \verb"nil"), another one in the output (the second \verb"nil"), and an
object with name \verb"o", class \verb"CafeDatabase", and attributes for the database
(verb"db"), the parsed \verb"input", the messages we want to print (\verb"output"),
the \verb"default" modules (all these attributes are inherited from Full Maude),
and for indicating whether the translation is \verb"strict", which is initially
set to \verb"false":

{\codesize
\begin{verbatim}
%)

  rl [init] :
     cafe2maude-init
  => [nil, < o : CafeDatabase | db : initialDatabase, input : nilTermList,
                                output : ('\n '\t '\b 'CafeOBJ2Maude '1.0 '\o
                                          'started. '\n 'CafeOBJ 'specifications
                                          'can 'be 'introduced 'now 'into 'the
                                          'Full 'Maude 'database. '\n),
                                 default : 'CONVERSION, strict : false >, nil] .

***(%
\end{verbatim}
}

The rule \verb"input" moves the list of quoted identifiers in the first argument of the
tuple to the \verb"input" attribute, trying to parse it first. We use the
\verb"CafeGRAMMAR" module to parse this input since this module, as explained in
Section~\ref{subsec:syntax}, contains the syntax of all our programs and commands,
as well as the syntax inherited from Full Maude:

{\codesize
\begin{verbatim}
%)

  rl [input] :
     [QI QIL, < O : X@Database | input : nilTermList, output : nil, Atts >, QIL' ]
  => if metaParse(CafeGRAMMAR, QI QIL, '@Input@) :: ResultPair
     then [nil,
           < O : X@Database | input : getTerm(metaParse(CafeGRAMMAR, QI QIL, '@Input@)),
                              output : nil, Atts >,
          QIL']
     else [nil,
           < O : X@Database | input : nilTermList,
                              output : ('\r 'WARNING: '\o printSyntaxError(metaParse(
                                        CafeGRAMMAR, QI QIL, '@Input@), QI QIL) '\n
                                        'ERROR: 'No 'parse 'for 'input.), Atts >,
           QIL' ]
     fi .

***(%
\end{verbatim}
}

On the other hand, the rule \verb"output" moves the output from the attribute
\verb"output" to the third element of the tuple:

{\codesize
\begin{verbatim}
%)

  rl [output] :
     [QIL, < O : X@Database | output : (QI QIL'), Atts >, QIL'']
  => [QIL, < O : X@Database | output : nil, Atts >, (QI QIL' QIL'')] .
endm

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

set print conceal on .

print conceal mod_is_sorts_._____endm .
*** print conceal fmod_is_sorts_.____endfm .
print conceal db .


*** trace exclude CAFE2MAUDE .
set show loop stats off .
set show loop timing off .

***(%

\end{comment}
}
%)




*** in cafeOBJ2maude.maude
*** Adrian



in tool.maude 


fmod PROOF-TREE is 
    including #LIBRARY# .
    sorts PTree PTreeSet .
    subsort PTree < PTreeSet .
    op empty : -> PTreeSet [ctor] .
    op __ : PTreeSet PTreeSet -> PTreeSet [ctor assoc comm id: empty] .

    op null : -> PTree [ctor] .
    op [_;_;_;_] : Qid Goal Bool PTreeSet -> PTree [ctor] .
    
    --- basic operations 
    op getPTree : PTree Qid ~> PTree .
    op getPTreeAux : PTreeSet Qid ~> PTree .
    op ptreeErr : QidList ~> PTree .
    op setGoalinTree : PTree Qid Goal -> PTree .
    op setGoalinTreeAux : PTreeSet Qid Goal -> PTree .
    op getGoalinTree : PTree Qid ~> Goal .
    op getGoalinTreeAux : PTree Qid ~> Goal .
    op setModuleinGoal : Goal Module -> Goal .
    op getModuleinGoal : Goal -> Module .

    op goalErr : QidList ~> Goal .

    
    vars TID TID' : Qid .
    vars G G' : Goal .
    var B : Bool .
    vars PS PS' : PTreeSet . 
    var PT? : [PTree] .
    vars PT PT' PT'' : PTree .
    var N : Nat .
    var GS : GoalSet .
    var G? : [Goal] .
    vars M M' : Module .
    var SS : SentenceSet .
    var La : Label .
 

    eq setGoalinTree([ TID' ; G ; B ; PS ], TID, G') = 
	(if TID == TID' then [ TID' ; G' ; B ; PS ] else [ TID' ; G ; B ; setGoalinTreeAux(PS,TID,G') ] fi) .

    eq setGoalinTreeAux(empty, TID, G) = empty . 

    ceq setGoalinTreeAux((PT PS), TID, G) = 
	(if PT == PT' then (PT setGoalinTreeAux(PS, TID, G)) else PT' PS fi )
      if PT' := setGoalinTree(PT, TID, G) .
    
    eq getGoalinTree([ TID' ; G ; B ; PS ], TID) = (if TID == TID' then G else getGoalinTreeAux(PS, TID) fi ) .
    eq getGoalinTreeAux(empty, TID) = goalErr('Goal TID 'does 'not 'exist!) .
    ceq getGoalinTreeAux((PT PS), TID) = (if G? :: Goal then G? else getGoalinTreeAux(PS,TID) fi ) 
      if G? := getGoalinTree(PT, TID) .

    eq getModuleinGoal( < M , SS , La >) = M .
    eq setModuleinGoal( < M , SS , La > , M') = < M' , SS , La > .
    

    
    eq getPTree(null, TID) = ptreeErr('Goal TID 'does 'not 'exist!).
    eq getPTree([ TID' ; G ; B ; PS ], TID) = (if TID == TID' then [ TID' ; G ; B ; PS ] else getPTreeAux(PS,TID) fi) .

    eq getPTreeAux(empty, TID) = ptreeErr('Goal TID 'does 'not 'exist!) .
    ceq getPTreeAux((PT PS), TID) = (if PT? :: PTree then PT? else getPTreeAux(PS,TID) fi )
      if PT? := getPTree(PT,TID) . 
      

    *** indexGoals --> initPTreeSet 
    op initPTreeSet : GoalSet Qid Nat -> PTreeSet .
    eq initPTreeSet(emptyGoalSet, TID, N) = empty .
    eq initPTreeSet((G GS), TID, N) = [ qid( string(TID) + "-" + string(N,10)) ; G ; false ; empty ] initPTreeSet(GS, TID, N + 1) . 
    
    *** 
    op getDefaultGoalIndex : PTreeSet -> Qid .
    eq getDefaultGoalIndex([ TID ; G ; B ; PS ] PS') = TID .
    eq getDefaultGoalIndex(empty) = 'nil .
    eq getDefaultGoalIndex(null) = 'nil .
    
    *** goalIndex 
    op goalIndex : PTreeSet GoalSet -> Qid .
    eq goalIndex([ TID ; G ; B ; PS ], GS) = TID .
    eq goalIndex([ TID ; G ; B ; PS ] PS', emptyGoalSet) = TID .
    ceq goalIndex([ TID ; G ; B ; PS ] PS', (G GS)) = goalIndex(PS', GS) if PS' =/= empty .
    eq goalIndex([ TID ; G ; B ; PS ] PS', GS) = TID [owise] .

    *** 
    op addPTreeSet : PTree Qid PTreeSet -> PTree . 
    op addPTreeSetAux : PTree Qid PTreeSet -> PTree . 
    eq addPTreeSet([ TID ; G ; B ; PS ], TID', PS') = 
	(if TID == TID' then [ TID ; G ; B ; PS' ] else [ TID ; G ; B ; addPTreeSetAux(PS, TID', PS') ] fi ) .
    eq addPTreeSetAux(empty, TID, PS) = empty .
    ceq addPTreeSetAux((PT PS), TID, PS') =  (if PT' =/= PT then (PT' PS) else (PT addPTreeSetAux(PS, TID, PS')) fi ) 
	  if PT' := addPTreeSet(PT, TID, PS') .

      *** set a labeled node's treeset emtpy and Boolean value false 
    op initPTree : PTree Qid -> PTree .
    op initPTreeAux : PTreeSet Qid -> PTreeSet .

    eq initPTree([ TID ; G ; B ; PS ], TID') = 
	(if TID == TID' then [ TID ; G ; false ; empty ] else  [ TID ; G ; B ; initPTreeAux(PS, TID') ] fi ) . 
    eq initPTreeAux(empty, TID) = empty .
    ceq initPTreeAux((PT PS'), TID) = 
	(if PT' =/= PT then (PT' PS') else (PT initPTreeAux(PS', TID)) fi ) 
      if PT' := initPTree(PT, TID) . 
    
    op containsGoal : PTree Qid -> Bool .
    op containsGoalAux : PTreeSet Qid -> Bool .
    
    eq containsGoal([ TID ; G ; B ; PS ], TID') = (if TID == TID' then true else containsGoalAux(PS, TID') fi ) .
    eq containsGoalAux(empty, TID) = false .
    eq containsGoalAux((PT PS), TID) = (if containsGoal(PT, TID) then true else containsGoalAux(PS, TID) fi ) .
    
    op setGoalProved : PTree Qid -> PTree .
    op setGoalProvedAux : PTreeSet Qid -> PTreeSet .

    eq setGoalProved([ TID ; G ; B ; PS ], TID') = 
	(if TID == TID' then [ TID ; G ; true ; PS ] else 
	    [ TID ; G ; B ; setGoalProvedAux(PS,TID') ] fi ) .
    eq setGoalProvedAux(empty, TID) = empty .
    ceq setGoalProvedAux((PT PS), TID) = 
	(if PT' =/= PT then (PT' PS) else (PT setGoalProvedAux(PS, TID)) fi ) 
      if PT' := setGoalProved(PT, TID) .

    op replacePTree : PTree Qid PTree -> PTree .
    op replacePTreeAux : PTreeSet Qid PTree -> PTree .

    eq replacePTree([ TID ; G ; B ; PS ], TID', PT') = 
	(if TID == TID' then PT' else [ TID ; G ; B ; replacePTreeAux(PS, TID', PT')  ] fi ) .
    ceq replacePTreeAux((PT PS), TID, PT') = 
	( if PT'' =/= PT then (PT'' PS) else (PT replacePTreeAux(PS, TID, PT')) fi )
      if PT'' := replacePTree(PT, TID, PT') . 
    eq replacePTreeAux(empty, TID, PT) = empty .


    op unprovedGoals : PTree -> PTreeSet .
    op unprovedGoalsAux : PTreeSet -> PTreeSet .
    eq unprovedGoals(null) = empty .
    eq unprovedGoals([ TID ; G ; B ; PS ]) = 
	( if PS =/= empty then unprovedGoalsAux(PS) else (if B then empty else [ TID ; G ; B ; PS ] fi ) fi ) .
    eq unprovedGoalsAux(empty) = empty .
    eq unprovedGoalsAux((PT PS)) = unprovedGoals(PT) unprovedGoalsAux(PS) .

    *** num 
    op num : PTreeSet -> Nat .
    eq num(empty) = 0 . 
    eq num(PT PS) = 1 + num(PS) .

    op rmChild : PTree Qid -> PTree .
    op rmChildAux : PTreeSet Qid -> PTreeSet .

    eq rmChild([ TID ; G ; B ; PS ], TID') = 
	(if TID == TID' then  [ TID ; G ; false ; empty ] else [ TID ; G ; B ;  rmChildAux(PS, TID') ] fi ) .
    ceq rmChildAux((PT PS), TID) = (if PT' == PT then (PT rmChildAux(PS,TID)) else (PT' PS) fi )
      if PT' := rmChild(PT,TID) .
    eq rmChildAux(empty,TID) = empty .
    
    
    

endfm 



fmod THM-BANNER is
    protecting STRING .
    protecting EXT-QID-LIST .

    op thm-banner : -> String .
    eq thm-banner = " --- A Constructor-based Theorem Prover (2013.10.30)! ---" .
    op help-list : -> QidList .
    eq help-list = (string2qidList("Command lists:") '\n 
	  '\t    string2qidList("load *.maude .") '\t '\t  '\t string2qidList("-- load modules into database")'\n '\n 
	  '\t string2qidList("(goal") '\s string2qidList("ModuleName |-") '\s string2qidList("Equations/Rules/Memberships )") '\n 
		'\t string2qidList("(set ind on Vars .)")  '\t '\t string2qidList("-- specify the variables for induction")'\n 
		'\t string2qidList("(init LEMMA by V <- c .)") '\t string2qidList("-- initialize a lemma by substitution.")'\n 
		'\t string2qidList("(auto goal GoalID .)")  '\t '\t string2qidList("-- prove a subgoal")'\n 
		'\t string2qidList("(auto .)") '\t '\t  '\t  string2qidList("-- try to prove the current goal")'\n 
		'\t string2qidList("(roll back .)")  '\t '\t '\t string2qidList("-- go back to the previous goal") '\n
		'\t string2qidList("(apply RuleName .)") '\t '\t   string2qidList("-- apply a given rule to default goal") '\n 
		'\t string2qidList("(apply RuleName to GoalId .)")  '\t string2qidList("-- apply a rule to a goal") '\n
		'\t string2qidList("(cp EQ >< EQ)") '\t '\t '\t   string2qidList("-- check critical pairs") '\n
		'\t string2qidList("(cp Label >< Label .)")  '\t '\t string2qidList("-- check critical pairs") '\n
		'\t string2qidList("(rule .)") '\t '\t '\t string2qidList("-- add a critical pair as a rule") '\n
		'\t string2qidList("(backward rule .)") '\t '\t  string2qidList("-- rule in inverse direction") '\n
		'\t string2qidList("(equation .)") '\t '\t '\t  string2qidList("-- add a critical pair as an equation ") '\n
		'\t string2qidList("(backward equation .)") '\t '\t  string2qidList("-- equation in inverse direction ") '\n
	  '\t string2qidList("(show unproved goals .)") '\t '\t  string2qidList("-- show all unproved goals") '\n
		'\t string2qidList("(show goal GoalID .)") '\t  '\t string2qidList("-- show a goal and set it as default") '\n 
		'\t string2qidList("(show goal .)") '\t '\t   '\t string2qidList("-- show the current goal") '\n 
	  '\t string2qidList("(show tactics .)") '\t '\t  string2qidList("-- show all tactics") '\n 
		'\t string2qidList("(set tactic PROOF STRATEGY .)") '\t string2qidList("-- specify customized proof strategy") '\n
		'\t string2qidList("(select tactic NAT .)") '\t '\t string2qidList("-- to use customized proof strategy") '\n
		'\t string2qidList("(set module off .)") '\t '\t string2qidList("-- only show added contents in module") '\n
		'\t string2qidList("(set module on .)") '\t '\t string2qidList("-- display all content in modules") '\n
'\t string2qidList("(lred <Term> .)") '\t '\t '\t string2qidList("-- reduce term in current goal") '\n
		'\t string2qidList("(help me .)") '\t '\t '\t string2qidList("-- show all commands") ) .
    
endfm

--- constructor-based theorem prover 

fmod PROVE-COMMANDS is 
    including COMMANDS .
    including VIEWS .

    --- op prove_. : @Bubble@ -> @Command@ .

    *** in the new version 

    sort @Sentence@ @SentenceSet@ .
    subsort @Sentence@ < @SentenceSet@ .
    op __ : @SentenceSet@ @SentenceSet@ -> @SentenceSet@ [assoc comm] .

    sort @Subst@ @SubstList@ .
    subsort @Subst@ < @SubstList@ .
    op _<-_; : @Token@ @Bubble@ -> @Subst@ .
    op __ : @SubstList@ @SubstList@ -> @SubstList@ [assoc] .

    op eq_=_; : @Bubble@ @Bubble@ -> @Sentence@ .
    op ceq_=_if_; : @Bubble@ @Bubble@ @Bubble@ -> @Sentence@ .
    op rl_=>_; : @Bubble@ @Bubble@ -> @Sentence@ .
    op crl_=>_if_; : @Bubble@ @Bubble@ @Bubble@ -> @Sentence@ .
    op mb_:_; : @Bubble@ @Bubble@ -> @Sentence@ .
    op cmb_:_if_; : @Bubble@ @Bubble@ @Bubble@ -> @Sentence@ .

    op trans_=>_; : @Bubble@ @Bubble@ -> @Sentence@ .
    op ctrans_=>_if_; : @Bubble@ @Bubble@ @Bubble@ -> @Sentence@ .
    op trns_=>_; : @Bubble@ @Bubble@ -> @Sentence@ .
    op ctrns_=>_if_; : @Bubble@ @Bubble@ @Bubble@ -> @Sentence@ .
    *** Adrian

    op trans_=>_. : @Bubble@ @Bubble@ -> @RlDecl@ .
    op trns_=>_. : @Bubble@ @Bubble@ -> @RlDecl@ .
    op ctrans_=>_if_. : @Bubble@ @Bubble@ @Bubble@ -> @RlDecl@ .
    op ctrns_=>_if_. : @Bubble@ @Bubble@ @Bubble@ -> @RlDecl@ .
    *** Adrian



    op goal_|-_ : @Token@ @SentenceSet@ -> @Command@ .
    

    op init_by_. : @Token@ @SubstList@ -> @Command@ . 
    op init_by_. : @EqDecl@ @SubstList@ -> @Command@ . 
    op init_by_. : @RlDecl@ @SubstList@ -> @Command@ . 

    op set`tactic_. : @Bubble@ -> @Command@ .
    op show`tactics`. : -> @Command@ .
    op select`tactic_. : @Token@ -> @Command@ .
    op set`ind`on_. : @Bubble@ -> @Command@ .
    op set`label_. : @Token@ -> @Command@ .

    op show`goal_. : @Token@ -> @Command@ .
    op show`goal`. : ->  @Command@ .
    op auto`. : ->  @Command@ .
    op auto`goal_. : @Token@ ->  @Command@ .
    op show`unproved`goals`. : -> @Command@ .
    op apply_. : @Bubble@ -> @Command@ .
    op help`me`. : -> @Command@ .
    op apply_to_. : @Bubble@ @Token@ -> @Command@ .
    op set`module`on`. : -> @Command@ .
    op set`module`off`. : -> @Command@ .
    op roll`back`. : -> @Command@ .

    op cp_><_ : @EqDecl@ @EqDecl@ -> @Command@ .

    op cp_><_. : @Token@ @Token@ -> @Command@ .

    op discard`critical`pair`. : -> @Command@ .
    op equation`.  : -> @Command@ .
    op rule`. : -> @Command@ .
    op backward`equation`.  : -> @Command@ .
    op backward`rule`. : -> @Command@ .
    op ignore`. : -> @Command@ .
    *** to do next 
    op lred_. : @Bubble@ -> @Command@ .

    *** Adrian
    op transition`. : -> @Command@ .
    op backward`transition`.  : -> @Command@ .


    *** Adrian
    op maude`language`. : -> @Command@ .
    op cafeOBJ`language`. : -> @Command@ .

endfm 

--- jump instruction 

fmod META-THM-SIGN is 
    including META-FULL-MAUDE-SIGN .
    inc META-CAFE2MAUDE-SIGNATURE .

    op thm-Grammar : -> FModule .
    eq thm-Grammar = addImports((including 'PROVE-COMMANDS .), CafeGRAMMAR) .
endfm 


fmod TACTIC is 
    including QID-LIST .
    including NAT .

    sorts Tactic Tactics .
    subsort QidList < Tactic < Tactics .
    op _@_ : Tactics Tactics -> Tactics [assoc id: nil] .
    
    op getTactic : Tactics Nat -> Tactic .
    op num : Tactics -> Nat .

    var TA : Tactic .
    var TAS : Tactics .
    var N : Nat .

    eq getTactic(nil, N) = nil .
    ceq getTactic(TA @ TAS, 0) = TA if TA =/= nil .
    ceq getTactic(TA @ TAS, N) = getTactic(TAS, sd(N,1)) if TA =/= nil .

    eq num(nil) = 0 .
    ceq num(TA @ TAS) = num( TAS) + 1 if TA =/= nil .
    
endfm 


fmod MODULE-OPERATION is 
    including UNIT .
    including MOVE-DOWN .

    protecting #LIBRARY# .
    op _-_ : EquationSet EquationSet -> EquationSet .
    op _-_ : OpDeclSet OpDeclSet -> OpDeclSet .
    
    var Eq : Equation .
    vars EqS EqS' : EquationSet .
    eq (Eq EqS) - (Eq EqS') = (EqS - EqS') .
    eq (EqS - EqS') = EqS [owise] .
    
    var OD : OpDecl .
    vars OPD OPD' : OpDeclSet .
    eq (OD OPD) - (OD OPD')  = (OPD - OPD') .
    eq OPD - OPD' = OPD [owise] .




    *** Function: getEqLemmas
    *** Description: to get the all the equations used as lemmas 
    vars T1 T2 : Term .
    vars AS : AttrSet .
    vars EqSet : EquationSet .
    var EC : EqCondition .
    vars E E' : Equation .
    var Str : String .



    op getEqLemmas : EquationSet -> EquationSet .
    eq getEqLemmas(none) = none .
    ceq getEqLemmas((eq T1 = T2 [label(Lab) AS] .) EqSet) = 
	(eq T1 = T2 [label(Lab) AS] .) getEqLemmas(EqSet) 
      if substr(string(Lab),0,5) = "lemma"  .
    ceq getEqLemmas((ceq T1 = T2 if EC [label(Lab) AS] .) EqSet) = 
	  (ceq T1 = T2 if EC [label(Lab) AS] .) getEqLemmas(EqSet) 
	  if substr(string(Lab),0,5) = "lemma" .
    eq getEqLemmas(E EqSet) = getEqLemmas(EqSet) [owise] .


    *** Function: getRlLemmas
    *** Description: to get the all the rules used as lemmas 
    
    op getRlLemmas : RuleSet -> RuleSet .
    eq getRlLemmas(none) = none .
    ceq getRlLemmas((rl T1 => T2 [label(Lab) AS] .) RS) = 
	(rl T1 => T2 [label(Lab) AS] .) getRlLemmas(RS) 
      if substr(string(Lab),0,5) = "lemma"  .
    ceq getRlLemmas((crl T1 => T2 if Co [label(Lab) AS] .) RS) = 
	  (crl T1 => T2 if Co [label(Lab) AS] .) getRlLemmas(RS) 
	  if substr(string(Lab),0,5) = "lemma" .
    eq getRlLemmas(R RS) = getRlLemmas(RS) [owise] .
    

    *** Function: getEqbyLabel 
    *** Description: to get an equation with a given label 
    op getEqbyLabel : Module Qid ~> Equation .
    op getEqbyLabelAux : EquationSet Qid ~> Equation .
    vars Lab Lab' : Qid .
    var M : Module .
    var Q Q' : Qid .
    var V : Variable .
    var TL : TermList .
    var RP : ResultPair? . 
    var T : Term .
    var QIL' : QidList .

    eq getEqbyLabel(M, Lab) = getEqbyLabelAux(getEqs(M), Lab) .
    eq getEqbyLabelAux(eq T1 = T2 [ label(Lab) AS]. EqSet, Lab) = (eq T1 = T2 [ label(Lab) rmNonexecAttr(AS)]. ) . 
    eq getEqbyLabelAux(ceq T1 = T2 if EC [ label(Lab) AS]. EqSet, Lab) = (ceq T1 = T2 if EC [ label(Lab) rmNonexecAttr(AS)].) . 
    eq getEqbyLabelAux(EqSet, Lab) = equationError(Lab 'is 'not 'in 'the 'module) [owise] . 


    *** Function: getRlbyLabel 
    *** Description: to get an equation with a given label 
    op getRlbyLabel : Module Qid ~> Rule .
    op getRlbyLabelAux : RuleSet Qid ~> Rule .
    var Co : Condition .
    var RS : RuleSet .
    var R : Rule .

    eq getRlbyLabel(M,Lab) = getRlbyLabelAux(getRls(M),Lab) .
    eq getRlbyLabelAux(rl T1 => T2 [label(Lab) AS] . RS, Lab) = (rl T1 => T2 [label(Lab) rmNonexecAttr(AS)] .) . 
    eq getRlbyLabelAux(crl T1 => T2  if Co [label(Lab) AS] . RS, Lab) = (crl T1 => T2  if Co [label(Lab) rmNonexecAttr(AS)] .) .
    eq getRlbyLabelAux(RS, Lab) = ruleError(Lab 'is 'not 'in 'the 'module.) .


    *** Function: constructSubst
    *** Description: to construct substitutions from the given substitution pairs 

    op constructSubstList : Module TermList TermList ~> Substitution .
    op constructSubst : Module TermList Term ~> Substitution .
    op constructSubstAux : Module TermList Qid Term ~> Substitution .    

    op subErr : QidList ~> Substitution .
    var SB : Substitution .
---    eq (subErr(QIL) ; SB) = subErr(QIL) .
    ceq SB ; subErr(QIL) = subErr(QIL) if not SB == none .
    
    var Subst : Substitution .
    var QIL : QidList .
    var Ty : Type .
    var T' : Term .
    var TL' : TermList .

    eq constructSubst(M,TL,T) = 
	subErr('\r 'ERROR: '\o 'bad 'substitution! '\n 'Example: 'a '<- 'A '; 'b '<- 'B '\n) [owise] .

    eq constructSubst(M,TL, '_<-_;['token[T], 'bubble[T']]) = 
	constructSubstAux(M,TL,downQidList(T),downQidList(T')) .

    eq constructSubst(M,TL, '__[TL']) = 
	constructSubstList(M, TL, TL') .
    
    eq constructSubstList(M, TL, (T, TL')) = 
	constructSubst(M, TL, T) ; constructSubstList(M, TL, TL') .

    eq constructSubstList(M, TL, empty) = none .

    
    ceq constructSubstAux(M, TL, Q, QIL) = 
	(if sortLeq(M,Ty,getType(RP)) then 
	  (if getTerm(RP) :: Variable then 
	      if in?(getTerm(RP), TL) then 
		  getTerm(RP) <- T 
		else 
		  subErr('\r 'ERROR: '\o Q 'not 'in 'the 'lemma!)
		fi 
	    else subErr('\r 'ERROR: '\o Q 'is 'not 'a 'variable!) fi )
	  else 
	    subErr('\r 'ERROR: '\o Q 'and QIL 'are 'of 'different 'types!) 
	  fi )
	if {T, Ty} :=  metaParse(M, QIL,anyType) /\ 
	    RP := metaParse(M, Q, anyType) /\
	  RP :: ResultPair .

    eq constructSubstAux(M,TL,Q,QIL) = subErr('\r 'ERROR: '\o Q '<- QIL 'cannot 'be 'parsed! '\n
	  '\g 'Hint: '\o 'type 'of 'variable 'should 'be 'provided '\n '\o '\s '\s '\s 'each 'substitution 'should 'be 'enclosed 'by 'parenthesis) [owise] . 

    op in? : Variable TermList -> Bool .
    eq in?(V, empty) = false .
    eq in?(V, (T, TL)) = (if T :: Variable and V == T then true else in?(V, TL) fi ) .

    op addAddedAttr : Equation -> Equation .

    ceq addAddedAttr(eq T1 = T2 [AtS] .) = (eq T1 = T2 [AtS] .)
      if metadata("added") AtS' := AtS .
    eq addAddedAttr(eq T1 = T2 [AtS] .) = (eq T1 = T2 [metadata("added") AtS] .) [owise] .
  
    ceq addAddedAttr(ceq T1 = T2 if EC [AtS] .) = (ceq T1 = T2 if EC [AtS] .)
	  if metadata("added") AtS' := AtS .
    eq addAddedAttr(ceq T1 = T2 if EC [AtS] .) = (ceq T1 = T2 if EC [metadata("added") AtS] .) [owise].

    op addAddedAttr : Rule -> Rule .

    ceq addAddedAttr(rl T1 => T2 [AtS] .) = (rl T1 => T2 [AtS] .)
      if metadata("added") AtS' := AtS .
    eq addAddedAttr(rl T1 => T2 [AtS] .) = (rl T1 => T2 [metadata("added") AtS] .) [owise] .
  
    ceq addAddedAttr(crl T1 => T2 if Cond [AtS] .) = (crl T1 => T2 if Cond [AtS] .)
	  if metadata("added") AtS' := AtS .
    eq addAddedAttr(crl T1 => T2 if Cond [AtS] .) = (crl T1 => T2 if Cond [metadata("added") AtS] .) [owise].
	  
	    
    op newLabel : Module Qid -> Qid .
    op getEqNumByLabel : EquationSet Qid -> Nat .
    op getRlNumByLabel : RuleSet Qid -> Nat .
 
    eq getEqNumByLabel((none).EquationSet,Q) = 0 .
    eq getEqNumByLabel((eq T = T' [label(Q) AtS] .) EqSet, Q') =
	(if find(string(Q),string(Q'),0) == 0 then getEqNumByLabel(EqSet, Q') + 1 else getEqNumByLabel(EqSet, Q') fi ) .
    eq getEqNumByLabel((ceq T = T' if Cond [label(Q) AtS] .) EqSet, Q') =
	(if find(string(Q),string(Q'),0) == 0 then getEqNumByLabel(EqSet, Q') + 1 else getEqNumByLabel(EqSet, Q') fi ) .
    eq getEqNumByLabel(E EqSet,Q) = getEqNumByLabel(EqSet,Q) [owise] .

    eq getRlNumByLabel((none).RuleSet,Q) = 0 .
    eq getRlNumByLabel((rl T => T' [label(Q) AtS] .) RS, Q') =
	(if find(string(Q),string(Q'),0) == 0 then getRlNumByLabel(RS, Q') + 1 else getRlNumByLabel(RS, Q') fi ) .
    eq getRlNumByLabel((crl T => T' if Cond [label(Q) AtS] .) RS, Q') =
	  (if find(string(Q),string(Q'),0) == 0 then getRlNumByLabel(RS, Q') + 1 else getRlNumByLabel(RS, Q') fi ) .    
    eq getRlNumByLabel(R RS,Q) = getRlNumByLabel(RS,Q) [owise] .

    eq newLabel(M,Q) = 
	if Q == 'no-label then 
	qid("added-" + string(getEqNumByLabel(getEqs(M),'added-) + getRlNumByLabel(getRls(M),'added-) + 1, 10))
	else 
	  qid(string(Q) + string(getEqNumByLabel(getEqs(M),Q) + getRlNumByLabel(getRls(M),Q) + 1, 10))
	  fi .


    *** Function: changeLabel
    *** Description: to change the label of an equation or a rule 

    op changeLabel : Equation Qid -> Equation .
    op changeLabel : Rule Qid -> Rule .

    eq changeLabel(eq T1 = T2 [AtS] ., Q') = (eq T1 = T2 [changeLabel(AtS,Q')] .) .
    eq changeLabel(ceq T1 = T2 if EC [AtS] ., Q') = (ceq T1 = T2 if EC [changeLabel(AtS,Q')] .) .
    
    var Cond : Condition .
    eq changeLabel(rl T1 => T2 [AtS] ., Q') = (rl T1 => T2 [changeLabel(AtS,Q')] .) .
    eq changeLabel(crl T1 => T2 if Cond [AtS] ., Q') = (crl T1 => T2 if Cond [changeLabel(AtS,Q')] .) .

    *** 
    op changeLabel : AttrSet Qid -> AttrSet .
    ceq changeLabel(AtS, Q) = 	label(Q) AtS' if label(Q') AtS' := AtS .
    eq changeLabel(AtS, Q) = label(Q) AtS [owise] .  

    *** Function: rmNonexecAttr 
    *** Description: to remove the nonexec attribute from the attribute set. 
    vars AtS AtS' : AttrSet .
    op rmNonexecAttr : AttrSet -> AttrSet .
    eq rmNonexecAttr(nonexec AtS) = AtS .
    eq rmNonexecAttr(AtS) = AtS [owise] .


*** Function: getAddedEqs
*** Description: to get the all the equations that are added during the proof. 

    op getAddedEqs : EquationSet -> EquationSet .
    eq getAddedEqs(none) = none .
    eq getAddedEqs((eq T1 = T2 [metadata("added") AS] .) EqSet) = (eq T1 = T2 [metadata("added") AS] .) getAddedEqs(EqSet) .
    eq getAddedEqs((ceq T1 = T2 if EC [metadata("added") AS] .) EqSet) = (ceq T1 = T2 if EC [metadata("added") AS] .) getAddedEqs(EqSet) .
    eq getAddedEqs(E EqSet) = getAddedEqs(EqSet) [owise] .

    op getAddedExecutableEqs : EquationSet -> EquationSet .
    op getAddedExecutableEqsAux : EquationSet -> EquationSet .
    eq getAddedExecutableEqs(EqSet) = getAddedExecutableEqsAux(getAddedEqs(EqSet)) .

    eq getAddedExecutableEqsAux(none) = none .
    eq getAddedExecutableEqsAux((eq T1 = T2 [ nonexec AS] .) EqSet) = getAddedExecutableEqsAux(EqSet) .
    eq getAddedExecutableEqsAux((ceq T1 = T2 if EC [ nonexec AS] .) EqSet) = getAddedExecutableEqsAux(EqSet) .
    eq getAddedExecutableEqsAux(Eq EqSet) = Eq getAddedExecutableEqsAux(EqSet) [owise] .

    


    op getAddedRls : RuleSet -> RuleSet .
    eq getAddedRls(none) = none .
    eq getAddedRls((rl T1 => T2 [metadata("added") AS] .) RS) = (rl T1 => T2 [metadata("added") AS] .) getAddedRls(RS) .
    eq getAddedRls((crl T1 => T2 if Co [metadata("added") AS] .) RS) = (crl T1 => T2 if Co [metadata("added") AS] .) getAddedRls(RS) .
    eq getAddedRls(R RS) = getAddedRls(RS) [owise] .


    op getAddedMbs : MembAxSet -> MembAxSet .
    var MBS : MembAxSet .
    var MB : MembAx .
    var So : Sort .

    eq getAddedMbs(none) = none .
    eq getAddedMbs((mb T1 : So [metadata("added") AS] .) MBS) = (mb T1 : So [metadata("added") AS] .) getAddedMbs(MBS) .
    eq getAddedMbs((cmb T1 : So if Co [metadata("added") AS] .) MBS) = (cmb T1 : So if Co [metadata("added") AS] .) getAddedMbs(MBS) .
    eq getAddedMbs(MB MBS) = getAddedMbs(MBS) [owise] .
    
endfm 

fmod CRITICAL-PAIR is
    pr EXT-TERM .
    
    sort CritPair .
    op cp : Qid Qid Term Term -> CritPair .
    op ccp : Qid Qid Term Term Condition -> CritPair .
    ops lhs rhs : CritPair -> Term .
    
    vars L L' : Qid .
    vars T T' : Term .
    var Cd : Condition .
    eq lhs(cp(L, L', T, T')) = T .
    eq lhs(ccp(L, L', T, T', Cd)) = T .
    eq rhs(cp(L, L', T, T')) = T' .
    eq rhs(ccp(L, L', T, T', Cd)) = T' .
    
    sort CritPairSet .
    subsort CritPair < CritPairSet .
    op none : -> CritPairSet .
    op __ : CritPairSet CritPairSet -> CritPairSet [assoc comm id: none] .
    
    var  CP : CritPair .
    eq CP CP = CP .
    
    op eq : CritPair Bool -> Equation .
    op rl :  CritPair Bool -> Rule .
        
    eq eq(cp(L,L',T,T'),true) = (eq T = T' [ label(qid("cp-" + string(L) + "-" + string(L')))  metadata("added")] .) .
    eq eq(ccp(L,L',T,T',Cd),true) = (ceq T = T' if Cd [label(qid("cp-" + string(L)  + "-" + string(L'))) metadata("added")] .) .
    eq rl(cp(L,L',T,T'),true) = (rl T => T' [label(qid("cp-" + string(L) + "-" + string(L'))) metadata("added")] .) .
    eq rl(ccp(L,L',T,T',Cd),true) = (crl T => T' if Cd [label(qid("cp-" + string(L) + "-" + string(L'))) metadata("added")] .) .

    eq eq(cp(L,L',T,T'),false) = (eq T' = T [label(qid("cp-" + string(L) + "-" + string(L'))) metadata("added")] .) .
    eq eq(ccp(L,L',T,T',Cd),false) = (ceq T' = T if Cd [label(qid("cp-" + string(L) + "-" + string(L'))) metadata("added")] .) .
    eq rl(cp(L,L',T,T'),false) = (rl T' => T [label(qid("cp-" + string(L) + "-" + string(L'))) metadata("added")] .) .
    eq rl(ccp(L,L',T,T',Cd),false) = (crl T' => T if Cd [label(qid("cp-" + string(L) + "-" + string(L'))) metadata("added")] .) .
   
endfm 


view CritPairSet from TRIV to CRITICAL-PAIR is
  sort Elt to CritPairSet .
endv



fmod CONFLUENCE-CHECK is
    pr UNIT .
  pr CRITICAL-PAIR .
  pr 2TUPLE{CritPairSet, CritPairSet} .
  pr 2TUPLE{Module, QidSet} * (op p1_ to getModule, op p2_ to getCts) .
---  pr AUXILIARY-FUNCTIONS .
  inc META-NARROWING-SEARCH * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) . 
  
  vars M M' : Module .
  vars T T' T'' T''' T'''' T1 T1' T2 T2' T1'' T2'' LHS RHS : Term .
  vars CP CP' : CritPair .
  vars CPS CPS' : CritPairSet .
  vars Eq Eq' : Equation .
  vars EqS EqS' EqS'' : EquationSet .
  var  Subst : Substitution .
  var  SubstS : SubstitutionSet .
  vars AtS AtS' : AttrSet .
  var  N : Nat .
  vars X F S L L' L1 L1' L2 L2' : Qid .
  vars TL TL' : TermList .
  vars Cd Cd1 Cd2 Cond : EqCondition .
  vars Sb Sb' : Substitution .
  var  Ct : Constant .
  var  V : Variable . 
  vars Cx Cx' : Context .
  var  Fgs : Flags .
  var  RTS : ResultTripleSet .
  ----var  RCS : ResultContextSet .
  var  TpL : TypeList .
  var  Tp : Type .
  var  NeNL : NeNatList . 
  var  ODS : OpDeclSet .
  var  VS : QidSet .

  op crcCritPairs : Module Equation Equation -> CritPairSet .

  eq crcCritPairs(M, Eq, Eq')
    = prepNarrowingSols(M, getLabel(Eq), getLabel(Eq'), getCts(makeNarrowingModule(M, Eq, Eq')), 
        metaNarrowSearch(
          getModule(makeNarrowingModule(M, Eq, Eq')), 
          '#_#_#_#[lhs(Eq'), rhs(Eq'), makeNarrowingCond(cond(Eq'))],
          qid("#V:" + string(getKind(M, leastSort(M, lhs(Eq'))))), 
          none, '+, 1, unbounded, unbounded)) .

  op makeNarrowingModule : Module Equation Equation -> Tuple{Module, QidSet} . 

 ceq makeNarrowingModule(M, Eq, Eq')
    = (setRls(
         setEqs(
           addOps(
             (op '#_#_# : leastSort(M, lhs(Eq)) '#EqCondition -> leastSort(M, lhs(Eq)) [none] .
              op '#_#_#_# : leastSort(M, lhs(Eq')) leastSort(M, rhs(Eq')) '#EqCondition -> leastSort(M, lhs(Eq')) [frozen(2 3)] .
              op 'nil : nil -> '#EqCondition [none] .
              op '_/\_ : '#EqCondition '#EqCondition -> '#EqCondition [assoc id('nil.#EqCondition)] .
              opEqCondition(M, cond(Eq) /\ cond(Eq'))
              opNewCts(VS)),
             addSorts('#EqCondition, removeFrozen(M))),
           none),
         rl T' => '#_#_#[vars2narrowCts(T'', VS), vars2narrowCts(T, VS)] [none] .),
       vars2narrowCts(VS)) 
     if T := makeNarrowingCond(cond(Eq))
     /\ T' := getTerm(metaNormalize(M, lhs(Eq)))
     /\ T'' := getTerm(metaNormalize(M, rhs(Eq)))
     /\ VS := (vars(T'') ; vars(T)) \ vars(T') . ---- vars to be made constants

  op vars2narrowCts : Term QidSet -> Term .
  eq vars2narrowCts(V, VS) 
    = if V in VS 
      then qid("#" + string(getName(V)) + "#." + string(getType(V)))
      else V
      fi . 
  eq vars2narrowCts(Ct, VS) = Ct . 
  eq vars2narrowCts(F[TL], VS) = F[vars2narrowCts(TL, VS)] .
  eq vars2narrowCts((T, TL), VS) = (vars2narrowCts(T, VS), vars2narrowCts(TL, VS)) .
  eq vars2narrowCts(empty, VS) = empty .
        
  op vars2narrowCts : QidSet -> QidSet .
  eq vars2narrowCts(V ; VS) = qid("#" + string(getName(V)) + "#." + string(getType(V))) ; vars2narrowCts(VS) .
  eq vars2narrowCts(none) = none .

  op opNewCts : QidSet -> OpDeclSet .
  eq opNewCts(V ; VS) = (op qid("#" + string(getName(V)) + "#") : nil -> getType(V) [none] .) opNewCts(VS) .
  eq opNewCts(none) = none .

  op opEqCondition : Module EqCondition -> OpDeclSet .
  eq opEqCondition(M, T = T' /\ Cond)
    = (op '_=_ : getKind(M, leastSort(M, T)) getKind(M, leastSort(M, T')) -> '#EqCondition [none] .)
      opEqCondition(M, Cond) .
  eq opEqCondition(M, T := T' /\ Cond)
    = (op '_:=_ : getKind(M, leastSort(M, T)) getKind(M, leastSort(M, T')) -> '#EqCondition [none] .)
      opEqCondition(M, Cond) .
  eq opEqCondition(M, T : S /\ Cond)
    = (op '_:_ : getKind(M, leastSort(M, T)) 'Sort -> '#EqCondition [none] .)
      opEqCondition(M, Cond) .
  eq opEqCondition(M, nil) = none .
    
  op prepNarrowingSols : Module Qid Qid QidSet ResultTripleSet -> CritPairSet .
  eq prepNarrowingSols(M, L, L', VS, {'#_#_#_#[T, T', T''], Tp, Sb} | RTS)
    = ccp(L, L', getTerm(metaReduce(M,getCPTerm(substitute(M, T, Sb), VS))), getTerm(metaReduce(M,T')), makeCond(T'') /\ makeCond(getCPCond(substitute(M, T, Sb), VS)))
      prepNarrowingSols(M, L, L', VS, RTS) .
  
 eq prepNarrowingSols(M, L, L', VS, empty) = none .
  
  eq ccp(L, L', T, T', nil) = cp(L, L', T, T') .

  op getCPTerm : Term QidSet -> Term .
  op getCPTerm : TermList QidSet -> TermList .
  op getCPCond : Term QidSet -> Term .
  op getCPCond : TermList QidSet -> TermList .
  op restoreVars : TermList QidSet -> TermList .
  
  eq getCPTerm((Ct, TL), VS) = (Ct, getCPTerm(TL, VS)) .
  eq getCPTerm((V, TL), VS) = (V, getCPTerm(TL, VS)) .
  eq getCPTerm(('#_#_#[T, T'], TL), VS) = (restoreVars(T, VS), getCPTerm(TL, VS)) .
  eq getCPTerm((F[TL], TL'), VS) = (F[getCPTerm(TL, VS)], getCPTerm(TL', VS)) [owise] .
  eq getCPTerm(empty, VS) = empty .
  
  eq getCPCond((Ct, TL), VS) = 'nil.#EqCondition .
  eq getCPCond((V, TL), VS) = 'nil.#EqCondition .
  eq getCPCond(('#_#_#[T, T'], TL), VS) = restoreVars(T', VS) .
  eq getCPCond((F[TL], TL'), VS) 
    = if getCPCond(TL, VS) =/= 'nil.#EqCondition then getCPCond(TL, VS) else getCPCond(TL', VS) fi 
    [owise] .
  eq getCPCond(empty, VS) = 'nil.#EqCondition .

  eq restoreVars((Ct, TL), VS) 
    = (if Ct in VS then qid(string(getName(Ct)) + ":" + string(getType(Ct))) else Ct fi, restoreVars(TL, VS)) .
  eq restoreVars((V, TL), VS) = (V, restoreVars(TL, VS)) .
  eq restoreVars((F[TL], TL'), VS) = (F[restoreVars(TL, VS)], restoreVars(TL', VS)) .
  eq restoreVars(empty, VS) = empty .

  op makeNarrowingCond : EqCondition -> Term .
  op makeCond : Term -> EqCondition .
  op makeCondAux : TermList -> EqCondition .
  
  eq makeNarrowingCond(T = T') = '_=_[T, T'] .
  eq makeNarrowingCond(T := T') = '_:=_[T, T'] .
 ceq makeNarrowingCond(T = T' /\ Cond) = '_/\_['_=_[T, T'], makeNarrowingCond(Cond)] if Cond =/= nil .
 ceq makeNarrowingCond(T := T' /\ Cond) = '_/\_['_:=_[T, T'], makeNarrowingCond(Cond)] if Cond =/= nil .
  eq makeNarrowingCond(nil) = 'nil.#EqCondition .
  
  eq makeCond('_/\_[TL]) = makeCondAux(TL) .
  eq makeCond('_=_[T, T']) = T = T' .
  eq makeCond('_:=_[T, T']) = T := T' .
  eq makeCond('nil.#EqCondition) = nil .

  eq makeCondAux(('_/\_[TL], TL')) = makeCondAux((TL, TL')) .
  eq makeCondAux(('_=_[T, T'], TL)) = T = T' /\ makeCondAux(TL) .
  eq makeCondAux(('_:=_[T, T'], TL)) = T := T' /\ makeCondAux(TL) .
  eq makeCondAux(('nil.#EqCondition, TL)) = makeCondAux(TL) .
  eq makeCondAux(empty) = nil .
  
  op getLabel : Equation -> Qid .
    op getLabel : Rule -> Qid .
    var RCond : Condition .
    eq getLabel(eq LHS = RHS [AtS] .) = getLabel(AtS) .
  eq getLabel(ceq LHS = RHS if Cond [AtS] .) = getLabel(AtS) .
  eq getLabel(rl LHS => RHS [AtS] .) = getLabel(AtS) .
  eq getLabel(crl LHS => RHS if RCond [AtS] .) = getLabel(AtS) .

  op getLabel : AttrSet -> Qid .
  eq getLabel(label(L) AtS) = L .
  eq getLabel(AtS) = 'no-label [owise] .
  
  ---- removes frozen attributes
  op removeFrozen : Module -> Module .
  op removeFrozen : OpDeclSet -> OpDeclSet .
  eq removeFrozen(M) = setOps(M, removeFrozen(getOps(M))) .
  eq removeFrozen(op F : TpL -> Tp [frozen(NeNL) AtS] . ODS) 
    = op F : TpL -> Tp [AtS] . removeFrozen(ODS) .
  eq removeFrozen(ODS) = ODS .
  
endfm


fmod PRETTY-PRINT is 
    including DATABASE .
    including NAT .
    including TACTIC .
    including MODULE-OPERATION .
    including UNIT-META-PRETTY-PRINT .
    including PROOF-TREE .
    including CRITICAL-PAIR .

    op prettyPrintProofTree : PTree Database Bool -> QidList .
    op prettyPrintProofTreeAux : PTreeSet  Database Bool -> QidList .
    op prettyPrintGoal : Goal Database Bool -> QidList .
    op prettyPrintTrace : Trace Database Bool -> QidList .
    op prettyPrintTactics : Tactics Nat -> QidList .
    op prettyPrintTacticsAux : Tactics Nat Nat -> QidList .

    vars B B' : Bool .
    vars DB DB' : Database .
    var Q : Qid .
    var G : Goal .
    vars PS PS' : PTreeSet  .
    vars FM' FM FM'' : Module .
    var E : Equation .
    var La : Label .
    var ME : ModuleExpression .
    var PT : PTree .
    var Mx : MembAx .

    var TA : Tactic .
    var TAS : Tactics .
    var N' : Nat .
    var EqS : EquationSet .

    var ScS : SentenceSet .
    
    eq prettyPrintTactics(TAS,N) = prettyPrintTacticsAux(TAS, N,0) .
    eq prettyPrintTacticsAux(nil, N,N') = nil .
    ceq prettyPrintTacticsAux(TA @ TAS, N,N') = 
	( '`[ (if (N == N') then ('\g) else nil fi ) qid(string(N',10)) '\o '`] '\t TA '\n) prettyPrintTacticsAux(TAS, N, s N') if TA =/= nil . 
    

    eq prettyPrintProofTree([ Q ; G ; B' ; PS' ], DB, B) = 
	'============================ '\s 'GOAL Q '============================ '\n (prettyPrintGoal(G, DB, B)  '\b  (if B' then 'proved else 'unproved fi ) '\o '\n ) .
    
    
    --- commented. Child trees will not show 
    ---	  (if PS' =/= empty then '\n '\b '`[ '\o  prettyPrintProofTreeAux(PS', DB, B) '\b '`] '\o '\n  else nil fi )
    
    eq prettyPrintProofTreeAux(empty, DB, B) = nil .
    eq prettyPrintProofTreeAux(PT PS, DB, B) = 	prettyPrintProofTree(PT, DB, B) prettyPrintProofTreeAux(PS, DB, B) . 

    ceq prettyPrintGoal( < FM, ScS, La > , DB, B) = 
	('< (if B then eMetaPrettyPrint(FM', FM) 
	    else ('Module '\g getName(FM) '\o 'is 'concealed '\n '\s '\s '... '\n 
		eMetaPrettyPrint(FM', getOps(FM) - getOps(getFlatModule(getName(FM),DB)))  '\s '\s '... '\n 
		eMetaPrettyPrintAddedER(FM', getAddedEqs(getEqs(FM)) getEqLemmas(getEqs(FM)))
		eMetaPrettyPrintAddedER(FM', getAddedRls(getRls(FM)) getRlLemmas(getRls(FM)))		
		eMetaPrettyPrint(FM', getAddedMbs(getMbs(FM)))		
		'\n '\n '\s '\s 'End 'of 'the 'module '\o ) fi ) '`, '\n 
	  eMetaPrettyPrint(FM', ScS) '\n '>  '\n )
      if DB' := evalModule(FM, none, DB) /\
	  FM' := getFlatModule(getName(FM),DB')  .

    
    eq prettyPrintGoal( G, DB, B) = ('Bad 'GOAL) [owise]  .

    op eMetaPrettyPrintAddedER : Module EquationSet -> QidList .
    op eMetaPrettyPrintAddedER : Module RuleSet -> QidList .
    
    var RS : RuleSet .

    eq eMetaPrettyPrintAddedER(M, (none).EquationSet) = nil .
    eq eMetaPrettyPrintAddedER(M, (none).RuleSet) = nil .
    eq eMetaPrettyPrintAddedER(M, (eq T = T' [metadata("added") AtS] . EqS)) = 
	  ('\n '\s '\s '\b 'eq '\o eMetaPrettyPrint(M,T) '\s '\b '= '\o 
	    eMetaPrettyPrint(M, T') '\s  (if AtS == (none).AttrSet then '\s
	      else ('`[ eMetaPrettyPrint(M, AtS) '`]) fi)  '. 
	    '\m '--> 'added 'by 'prover! '\o ) eMetaPrettyPrintAddedER(M, EqS) .
    eq eMetaPrettyPrintAddedER(M, (ceq T = T' if Cond [metadata("added") AtS] . EqS)) =
	    ('\n '\s '\s '\b 'ceq '\o eMetaPrettyPrint(M,T) '\s '\b '= '\o 
	      eMetaPrettyPrint(M, T') '\n '\s '\s '\s  '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M,Cond)
		'\s  (if AtS =/= none then  ('`[ eMetaPrettyPrint(M, AtS) '`])  else '\s fi) '. 
		'\m '--> 'added 'by 'prover! '\o ) eMetaPrettyPrintAddedER(M, EqS) .
    eq eMetaPrettyPrintAddedER(M, (rl T => T' [metadata("added") AtS] . RS)) = 
	  ('\n '\s '\s '\b 'rl '\o eMetaPrettyPrint(M,T) '\s '\b '=> '\o 
	    eMetaPrettyPrint(M, T') '\s  (if AtS =/= none then 
	      ('`[ eMetaPrettyPrint(M, AtS) '`])	    else '\s fi) '. 
	    '\m '--> 'added 'by 'prover! '\o ) eMetaPrettyPrintAddedER(M, RS) .
    eq eMetaPrettyPrintAddedER(M, (crl T => T' if Cond [metadata("added") AtS] . RS)) =
	    ('\n '\s '\s '\b 'crl '\o eMetaPrettyPrint(M,T) '\s '\b '=> '\o 
	      eMetaPrettyPrint(M, T') '\n '\s  '\s '\s   '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M,Cond)
		'\s (if AtS =/= none then   ('`[ eMetaPrettyPrint(M, AtS) '`])	    else '\s fi)  '. 
		'\m '--> 'added 'by 'prover! '\o ) eMetaPrettyPrintAddedER(M, RS) .

    *** revised on 2014-01-08
    *** fix the bug of printing multiple equations or rules 
    eq eMetaPrettyPrintAddedER(M, E EqS) = '\n eMetaPrettyPrint(M,E) eMetaPrettyPrintAddedER(M,EqS) [owise] .
    eq eMetaPrettyPrintAddedER(M, R RS) = '\n eMetaPrettyPrint(M,R) eMetaPrettyPrintAddedER(M,RS) [owise] .
    
    op eMetaPrettyPrint : Module SentenceSet -> QidList .
    var AtS : AttrSet .
    var Cond : Condition .
    var M : Module .

    eq eMetaPrettyPrint(M, (none).SentenceSet) = nil . 


    eq eMetaPrettyPrint(M, (eq T = T'  [AtS]) ScS) = 
	('\n '\s '\s '\b 'eq '\s '\o eMetaPrettyPrint(M, T)
	  '\s '\b '= '\s '\o eMetaPrettyPrint(M, T')
          '\s  (if AtS == none then '\s else '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\o fi)  '\m '--> 'to 'be 'proved! '\o
	  eMetaPrettyPrint(M, ScS)) .
    eq eMetaPrettyPrint(M, (ceq T = T' if Cond  [AtS]) ScS) = 
	  ('\n '\s '\s '\b 'ceq '\s '\o eMetaPrettyPrint(M, T)
	   '\s '\b '= '\s '\o eMetaPrettyPrint(M, T')
	  '\n '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond)
            '\s  (if AtS == none then '\s else '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\o fi) '\m '--> 'to 'be 'proved! '\o
	    eMetaPrettyPrint(M, ScS)) .
      
    eq eMetaPrettyPrint(M, (rl T => T'  [AtS]) ScS) = 
	('\n '\s '\s '\b 'rl '\s '\o eMetaPrettyPrint(M, T)
	  '\s '\b '=> '\s '\o eMetaPrettyPrint(M, T')
          '\s  (if AtS == none then '\s else '\b '`[ '\o eMetaPrettyPrint(M, AtS)  '\b '`] '\o fi) '\m '--> 'to 'be 'proved! '\o
	  eMetaPrettyPrint(M, ScS)) .
    eq eMetaPrettyPrint(M, (crl T => T' if Cond  [AtS]) ScS) = 
	  ('\n '\s '\s '\b 'crl '\s '\o eMetaPrettyPrint(M, T)
	   '\s '\b '=> '\s '\o eMetaPrettyPrint(M, T')
	  '\n '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond)
            '\s  (if AtS == none then '\s else '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\o fi) '\m '--> 'to 'be 'proved! '\o
	    eMetaPrettyPrint(M, ScS)) .

    var So : Sort .
    
    eq eMetaPrettyPrint(M, (mb T : So  [AtS]) ScS) = 
	('\n '\s '\s '\b 'mb '\s '\o eMetaPrettyPrint(M, T)
	   '\s '\b ': '\s '\o So
          '\s  (if AtS == none then '\s else '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\o fi) '\m '--> 'to 'be 'proved! '\o
	  eMetaPrettyPrint(M, ScS)) .
    eq eMetaPrettyPrint(M, (cmb T : So if Cond  [AtS]) ScS) = 
	  ('\n '\s '\s '\b 'cmb '\s '\o eMetaPrettyPrint(M, T)
	   '\s '\b ': '\s '\o  So
	  '\n '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond)
            '\s (if AtS == none then '\s else '\b '`[ '\o  eMetaPrettyPrint(M, AtS) '\b '`] '\o fi) '\m '--> 'to 'be 'proved! '\o
	    eMetaPrettyPrint(M, ScS)) .


    *** to fix a bug in FullMaude for downAttr 
    vars T T' : Term .
    eq downAttr('metadata[T]) = metadata(downString(getName(T))) .

    var TR : Trace .
    var N : Nat .
    var TRS : TraceStep .

    eq prettyPrintTrace(TR, DB, B) = prettyPrintTraceAux(TR, DB, B, 1) .

    op prettyPrintTraceAux : Trace Database Bool Nat -> QidList .
    op prettyPrintTraceStep : TraceStep Term Database Bool Nat -> QidList .

    eq prettyPrintTraceAux((TRS {T,Ty,R} TR), DB,B ,N) = 
	prettyPrintTraceStep(TRS,T,DB,B,N)  
	prettyPrintTraceAux(({T,Ty,R} TR),DB,B, N + 1) . 
    
    eq prettyPrintTraceAux(TRS, DB,B , N) = 	
	(prettyPrintTraceStep(TRS, 'emptyGoalSet.GoalSet, DB, B, N) 
	  '\n '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '\r 'DEPTH qid(string(N + 1,10)) '\o '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '\n '\n 'emptyGoalSet '\n)
 .
    var R : Rule .
    var Ty : Type .
    var GS : GoalSet .

    ceq prettyPrintTraceStep( { T, Ty, R }, T', DB, B, N) = 
	('\n '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '\r 'DEPTH qid(string(N,10)) '\o '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '\n '\n 
	  prettyPrintProofTreeAux(PS, DB, B)
	  '\n '~~~~~~~~~~~~~~~~~~ 'Rule 'applied 'to '\r 'Goal goalIndex(PS, downTerm(T', emptyGoalSet)) '\o '~~~~~~~~~~~~~~~~~~~ '\n 
	  eMetaPrettyPrint(upModule('TOOL, false), R) '\n )
      if GS := downTerm(T, emptyGoalSet) /\ 
	  PS := initPTreeSet(GS, qid(string(N,10)),1) . 
    
    eq prettyPrintTraceStep( { T, Ty, R }, T', DB, B, N) = ('BAD 'GOAL) [owise] .


    op eMetaPrettyPrint : Module Qid CritPairSet -> QidList .
    vars QI L L' : Qid .
    var QIL : QidList .
    var Cd : Condition .
    var CPS : CritPairSet .

    eq eMetaPrettyPrint(M, QI, cp(L, L', T, T') CPS)
      = ('\n '\s '\s '\b 'cp '\o
	  (if L =/= 'no-label and L' =/= 'no-label 
            then '\b 'for '\o L '\b 'and '\o L' '\n '\s '\s '\s 
            else nil
              fi)
	  '\s metaPrettyPrint(M, T) 
	  '\n '\s '\s '\s '\s QI '\o metaPrettyPrint(M, T') '. '\o 
	  eMetaPrettyPrint(M, QI, CPS)) .
    eq eMetaPrettyPrint(M, QI, ccp(L, L', T, T', Cd) CPS)
      = ('\n '\s '\s '\b 'ccp '\o
	  (if L =/= 'no-label and L' =/= 'no-label 
            then '\b 'for '\o L '\b 'and '\o L' '\n '\s '\s '\s
            else nil
              fi)
	  '\s metaPrettyPrint(M, T) 
	  '\n '\s '\s '\s '\s '\b QI '\o metaPrettyPrint(M, T') 
	  '\n '\s '\s '\s '\s '\b 'if '\o eMetaPrettyPrint(M, Cd) '\b '. '\o 
	    eMetaPrettyPrint(M, QI, CPS)) .
    eq eMetaPrettyPrint(M, QI, (none).CritPairSet) = nil .
    eq eMetaPrettyPrint(unitError(QIL), QI, CPS:[CritPairSet]) = QIL .
    
endfm 




*** in procCommands.maude 

fmod PROVE-COMMANDS-PROC is 
    protecting UNIT-DECL-PARSING .
    protecting PROOF-TREE .
    protecting DATABASE .
    protecting MOVE-DOWN .
    protecting PRETTY-PRINT .
    protecting META-LEVEL .
    protecting CONFLUENCE-CHECK .

    sort ProveResult . 
    sort ApplyResult .

    op <<_;_;_;_>> : Database PTreeSet QidList CritPairSet -> ProveResult .

    op <<_;_;_>> : Database PTreeSet QidList -> ProveResult .
    op <<_;_>> : PTreeSet Rule -> ApplyResult .
    op applyError : QidList ~> PTreeSet .
    
    op procGoals : Database ModuleExpression Term -> ProveResult . 
    op procGoalsAux : Database ModuleExpression Term -> ProveResult . 

    op procGoalCmd : Database ModuleExpression SentenceSet -> ProveResult .
    op procGoalCmdAux : Database ModuleExpression SentenceSet -> ProveResult .

    op setGoal : Database Module SentenceSet -> ProveResult .

    ***op setGoal : Database Module EquationSet -> ProveResult .
    ***op setGoal : Database Module RuleSet -> ProveResult .
    ***op setGoal : Database Module MembAxSet -> ProveResult .

    op appendType : QidList TermList -> QidList .
    op getVarbyName : Qid TermList -> Qid .

    op procIndVars : Database PTree Term -> ProveResult .
    op checkVars : QidList TermList -> Bool .
    op checkVarsAux : Qid TermList -> Bool .
    op getBadVars : QidList TermList -> QidList .
    op rmInduVars : AttrSet -> AttrSet .


    vars T T' T'' T3 T4 T5 : Term .
    vars ME ME' : ModuleExpression .
    var E? : [Equation] .
    vars B B' : Bool .
    vars RP1 RP2 RP3 : [ResultPair] . 
    vars DB DB' : Database .
    vars QLHS QRHS QCON QIND QSTR : QidList .
    vars FM FM' : Module .
    vars Q GID : Qid .
    var QIL : QidList .
    var E : Equation .
    vars La   : Label .
    vars L L' : Qid .
    var Cd : Condition .
    var DT : Default{Term} .
    var VDS : OpDeclSet .
    var U : Module .
    var E' : Equation .
    vars PT PT' : PTree .
    var AtS : AttrSet .
    var EqC : EqCondition .
    vars T1 T2 : Term .
    var TL : TermList .
    var At : Attr . 
    var Str : String .
    vars G' : Goal .
    var GS : GoalSet .
    vars R : Rule .
    var Mx  : MembAx .
    var Mx' : MembAx .
    var R' : Rule .

    var ASet : AttrSet .
    var EC : EqCondition .
    var St : Sort .
    var RT : [ResultTriple] .
    var G : Goal .
    var PS : PTreeSet .
    var QIL' : QidList .
    var Co : Condition .


    var RP : [ResultPair] .
    var M : Module .
    vars EqS EqS' : EquationSet .
    vars RlS RlS' : RuleSet .
    vars MbS MbS' : MembAxSet .

    ---
    op metaRed : Module Term -> Term .
    ceq metaRed(M,T) = if RP :: ResultPair 
	then getTerm(RP) 
	else T fi     
      if RP := metaReduce(M,T) .

    --- equation
    op metaRedEq : Module EquationSet -> EquationSet .
    eq metaRedEq(M,none) = none .
    eq metaRedEq(M,eq T = T' [ASet]. EqS) = 
	(eq metaRed(M,T) = metaRed(M,T') [ASet] .) metaRedEq(M,EqS) .
    eq metaRedEq(M,ceq T = T' if EC [ASet]. EqS) = 
	  (ceq metaRed(M,T) = metaRed(M,T') if metaRed(M,EC) [ASet].) metaRedEq(M,EqS) .

	--- membership
    op metaRedMb : Module MembAxSet -> MembAxSet .
    eq metaRedMb(M,none) = none .
    eq metaRedMb(M,mb T : St [ASet]. MbS) = 
	(mb metaRed(M,T) : St [ASet] .) metaRedMb(M,MbS) .
    eq metaRedMb(M,cmb T : St if EC [ASet]. MbS ) = 
	  (cmb metaRed(M,T) : St if metaRed(M,EC) [ASet].) metaRedMb(M,MbS) .
	    
	    --- rule
    op metaRedRl : Module RuleSet -> RuleSet .
    eq metaRedRl(M,none) = none .
    eq metaRedRl(M,rl T => T' [ASet]. RlS) = 
	(rl metaRed(M,T) => metaRed(M,T')[ASet].) metaRedRl(M,RlS) .
    eq metaRedRl(M,crl T => T' if Co [ASet]. RlS) = 
	  (crl metaRed(M,T) => metaRed(M,T') if metaRed(M,Co)[ASet].) metaRedRl(M,RlS) .
	
	    --- condition
    op metaRed : Module Condition -> Condition .
    eq metaRed(M,(nil).EqCondition) = (nil).EqCondition .
    eq metaRed(M,T = T' /\ Co) = 
	(metaRed(M,T) = metaRed(M,T') /\ metaRed(M,Co)).
    eq metaRed(M,T := T' /\ Co) = 
	(metaRed(M,T) := metaRed(M,T') /\ metaRed(M,Co)).
    eq metaRed(M,T : St /\ Co) = 
	(metaRed(M,T) : St /\ metaRed(M,Co)).
    eq metaRed(M,T => T' /\ Co) = 
	(metaRed(M,T) => metaRed(M,T') /\ metaRed(M,Co)).      

    op evalCondition : Module Condition -> Bool .
    eq evalCondition(M, (nil).Condition) = true .
    eq evalCondition(M, T = T' /\ Co) = 
	(T :: GroundTerm and T' :: GroundTerm and  metaRed(M, T) == metaRed(M, T') and evalCondition(M,Co)) .
    eq evalCondition(M, T := T' /\ Co) = 
      if T :: GroundTerm and T' :: GroundTerm and metaMatch(M, T, T', nil, 0) :: Substitution then evalCondition(M, Co) else false fi .
    eq evalCondition(M, T => T' /\ Co) = 
      if T :: GroundTerm and T' :: GroundTerm and metaSearch(M, T, T', nil, '*, unbounded, 0) :: ResultTriple then evalCondition(M, Co) else false fi .
    ceq evalCondition(M, T : St /\ Co) = 
	(if sortLeq(M, getType(metaReduce(M,T)),St) then evalCondition(M,Co) else false fi)
      if T :: GroundTerm /\
	  metaReduce(M,T) :: ResultPair .
    eq evalCondition(M, T : St /\ Co) = false [owise] .

    
	

	*** Function: procSetTactic 
	*** Description: to construct a new module to support customized proof strategy 

    op procSetTactic : Database QidList ~> Database .
    op dbErr : QidList ~> Database .
    
    ceq procSetTactic(DB, QIL) = 
	evalModule(M, none, insTermModule(getName(M),M, DB))
      if M := buildModule(QIL) . 
      
    ceq procSetTactic(DB, QIL) = 
	dbErr(QL) 
      if mdErr(QL) := buildModule(QIL) . 

    op buildModule : QidList -> Module .
    op cusStraModule : -> Module .
    eq cusStraModule = 
	(
          mod 'CUS-STRATEGY is 
              including 'TOOL .
              sorts none .
              none none
              none none none
          endm 
	  ) .

    op mdErr : QidList ~> Module .

    op getInvalidTac : QidList -> QidList .
    ceq getInvalidTac(Q QIL) = 
	getInvalidTac(QIL) 
      if (Q == 'SI or Q == 'CA or Q == 'CA-1 or Q == 'TC or Q == 'IP or Q == 'TL or Q == 'CT) . 
    eq getInvalidTac(nil) = nil .
    eq getInvalidTac(Q QIL) = Q getInvalidTac(QIL) [owise] .


    ceq buildModule(QIL) = 
	if QL == nil then  addRls(genRls(QIL),cusStraModule)
	else mdErr('\r 'ERROR: '\o 'Invalid 'proof 'rules: '\g QL '\o '\n) fi 
    if QL := getInvalidTac(QIL) . 
    
    op genRls : QidList -> RuleSet .
    op getFun : Qid -> Qid .
    eq getFun('SI) = 'ind . 
    eq getFun('CA) = 'ca .
    eq getFun('CA-1) = 'ca-1 .
    eq getFun('TC) = 'tc .
    eq getFun('IP) = 'imp .

    vars Q' Q'' Q3 Q4 : Qid .

    ceq genRls(Q Q' Q4 QIL) = 
	(rl '<_`,_`,_>['M:Module,'E:Equation,Q''] =>
          getFun(Q)['<_`,_`,_>['M:Module,'E:Equation,Q3]] [label(string2qidList(Str + "e"))] .
    rl '<_`,_`,_>['M:Module,'R:Rule,Q''] =>
        getFun(Q)['<_`,_`,_>['M:Module,'R:Rule,Q3]] [label(string2qidList(Str + "r"))] .
    rl '<_`,_`,_>['M:Module,'Mx:MembAx,Q''] =>
        getFun(Q)['<_`,_`,_>['M:Module,'Mx:MembAx,Q3]] [label(string2qidList(Str + "m"))] .)      genRls(Q' Q4 QIL)
    if Q =/= 'TL /\ Q =/= 'CT /\
	Q'' := string2qidList("C" + string(Q) + ".Label") /\
	Q3 := (if Q' =/= 'TL and Q' =/= 'CT then string2qidList("C" + string(Q') + ".Label") else string2qidList(string(Q') + ".Label") fi ) /\
	Str :=  "C" + string(Q) .

    ceq genRls(Q Q') = 
	(rl '<_`,_`,_>['M:Module,'E:Equation,Q''] =>
          getFun(Q)['<_`,_`,_>['M:Module,'E:Equation,Q3]] [label(string2qidList(Str + "e"))] .
    rl '<_`,_`,_>['M:Module,'R:Rule,Q''] =>
        getFun(Q)['<_`,_`,_>['M:Module,'R:Rule,Q3]] [label(string2qidList(Str + "r"))] .
    rl '<_`,_`,_>['M:Module,'Mx:MembAx,Q''] =>
        getFun(Q)['<_`,_`,_>['M:Module,'Mx:MembAx,Q3]] [label(string2qidList(Str + "m"))] .) 
    if Q =/= 'TL /\ Q =/= 'CT /\
	Q'' := string2qidList("C" + string(Q) + ".Label") /\
	Q3 :=  string2qidList(string(Q') + ".Label") /\
	Str := "C" + string(Q) .
   
    
    eq genRls(nil) = none .
    eq genRls(Q') = none . 

    eq genRls('TL QIL) = genRls(QIL) . 
    eq genRls('CT QIL) = genRls(QIL) . 


    *** Function: procTest
    *** Description: to compute the value of a term in the current goal by reduction

    op procTest : Database Module Term -> QidList .

    ceq procTest(DB, M, T) = QIL 
      if qidError(QIL) := solveBubbles(T,M, false, none, DB) .

      
    ceq procTest(DB, M, T) = 
	if RP :: ResultPair then 
	  ('\g 'Reduction 'result: '\o '\n '\s '\s  eMetaPrettyPrint(M, getTerm(RP)))
	else 
	  getMsg(getTerm(RP))
	fi 
      if T' := solveBubbles(T,M, false, none, DB) /\
	 RP := metaReduce(M,T') .


    

    --- eq 

    *** Function: procInitLemma 
    *** Description: to initialize a lemma 
    op procInitLemma : Database PTree Qid Term -> ProveResult .
    op procInitLemma : Database PTree Equation Term -> ProveResult .
    op procInitLemma : Database PTree Rule Term -> ProveResult .


    op getVar : Equation -> TermList .
    op getVar : MembAx -> TermList .
    op getVar  : Rule -> TermList .

    
    var Cond : Condition .
    var SBS : Substitution .

    eq getVar(eq T = T' [AtS] .) = getVar(eq T = T' [AtS]) .
    eq getVar(ceq T = T' if Cond [AtS] .) = getVar(ceq T = T' if Cond [AtS]) .
    eq getVar(rl T => T' [AtS] .) = getVar(rl T => T' [AtS]) .
    eq getVar(crl T => T' if Cond [AtS] .) = getVar(crl T => T' if Cond [AtS]) .
    eq getVar(mb T : T' [AtS] .) = getVar(mb T : T' [AtS]) .
    eq getVar(cmb T : T' if Cond [AtS] .) = getVar(cmb T : T' if Cond [AtS]) .


    var EQ : [Equation] . 
    vars QL QL' QL'' : QidList .
    var Subst : [Substitution] .
    var Rl : [Rule] .
    var ScS : SentenceSet .
     
    --- by label 
    ceq procInitLemma(DB, [ GID ; < FM, ScS, La > ; B ; PS ], Q, T) = 
      	<< DB ; [ GID ; < FM, ScS, La > ; B ; PS ] ; QL'' >> 
	if equationError(QL') := getEqbyLabel(FM, Q) /\
           ruleError(QL'') := getRlbyLabel(FM,Q)  .
    
    ceq procInitLemma(DB, [ GID ; < FM, ScS, La > ; B ; PS ], Q, T) = 
      	<< DB ; [ GID ; < FM, ScS, La > ; B ; PS ] ; QL'' >> 
	if equationError(QL') := getEqbyLabel(FM, Q) /\
           Rl := getRlbyLabel(FM,Q) /\
           Rl :: Rule /\
	   subErr(QL'') := constructSubst(FM, getVar(Rl), T) .
    
    ceq procInitLemma(DB, [ GID ; < FM, ScS, La > ; B ; PS ], Q, T) = 
      	<< DB ; [ GID ; < FM', ScS, La > ; B ; PS ] ; 'OK >> 
	if equationError(QL') := getEqbyLabel(FM, Q) /\
           Rl := getRlbyLabel(FM,Q) /\
           Rl :: Rule /\
	   Subst := constructSubst(FM, getVar(Rl), T) /\
	   Subst :: Substitution /\
    RL := addAddedAttr(changeLabel(Rl <<< Subst, newLabel(FM, getLabel(Rl)))) /\
	FM' := addRls(RL, FM) .
        
    var EQ' : Equation .
    vars CPS' CPS : CritPairSet .

    ceq procInitLemma(DB, [ GID ; < FM, ScS, La > ; B ; PS ], Q, T) = 
      	    << DB ; [ GID ; < FM' , ScS, La > ; B ; PS ] ; 'OK >> 
      if EQ := getEqbyLabel(FM, Q) /\ 
    EQ :: Equation /\
	Subst := constructSubst(FM, getVar(EQ), T) /\
	Subst :: Substitution /\
	EQ' := addAddedAttr(changeLabel(EQ <<< Subst, newLabel(FM, Q))) /\
	FM' := addEqs(EQ', FM)  .

    ceq procInitLemma(DB, [ GID ; < FM, ScS, La > ; B ; PS ], Q, T) = 
	<< DB ; [ GID ; < FM, ScS, La > ; B ; PS ] ; QL' >> 
      if EQ := getEqbyLabel(FM, Q) /\ 
    EQ :: Equation /\
	subErr(QL') := constructSubst(FM, getVar(EQ), T) .


    *** equation 

    var EQ'' : Equation .

    ceq procInitLemma(DB, [ GID ; < FM, ScS, La > ; B ; PS ], EQ, T) = 
      	    << DB ; [ GID ; < FM' , ScS, La > ; B ; PS ] ; 'OK >> 
      if EQ' := solveBubbles(EQ, FM, addInfoConds(FM), false, none, DB) /\ 
	Subst := constructSubst(FM, getVar(EQ'), T) /\
	Subst :: Substitution /\
	EQ'' := addAddedAttr(changeLabel(EQ' <<< Subst, newLabel(FM,getLabel(EQ')))) /\
	FM' := addEqs(EQ'', FM)  .

    ceq procInitLemma(DB, [ GID ; < FM, ScS, La > ; B ; PS ], EQ, T) = 
      	<< DB ; [ GID ; < FM , ScS, La > ; B ; PS ] ; QL'' >> 
      if EQ' := solveBubbles(EQ, FM, addInfoConds(FM), false, none, DB) /\
	  subErr(QL'') := constructSubst(FM, getVar(EQ'), T) .

    ceq procInitLemma(DB, [ GID ; < FM, ScS, La > ; B ; PS ], EQ, T) = 
	<< DB ; [ GID ; < FM, ScS, La > ; B ; PS ] ; QIL >> 
      if equationError(QIL) := solveBubbles(EQ, FM, addInfoConds(FM), false, none, DB) .

    *** rules 

    vars RL RL' RL'' : Rule .
    ceq procInitLemma(DB, [ GID ; < FM, ScS, La > ; B ; PS ], RL, T) = 
	<< DB ; [ GID ; < FM, ScS, La > ; B ; PS ] ; QIL >> 
      if ruleError(QIL) := solveBubbles(RL, FM, addInfoConds(FM), false, none, DB) .

    eq procInitLemma(DB, [ GID ; < FM, ScS, La > ; B ; PS ], ruleError(QIL), T) = 
      	<< DB ; [ GID ; < FM , ScS, La > ; B ; PS ] ; QIL >> .

    ceq procInitLemma(DB, [ GID ; < FM, ScS, La > ; B ; PS ], RL, T) = 
      	<< DB ; [ GID ; < FM , ScS, La > ; B ; PS ] ; QL'' >> 
      if RL' := solveBubbles(RL, FM, addInfoConds(FM), false, none, DB) /\
	  subErr(QL'') := constructSubst(FM, getVar(RL'), T) .

    ceq procInitLemma(DB, [ GID ; < FM, ScS, La > ; B ; PS ], RL, T) = 
      	    << DB ; [ GID ; < FM' , ScS, La > ; B ; PS ] ; 'OK >> 
      if RL' := solveBubbles(RL, FM, addInfoConds(FM), false, none, DB) /\ 
	Subst := constructSubst(FM, getVar(RL'), T) /\
	Subst :: Substitution /\
	RL'' := addAddedAttr(changeLabel(RL' <<< Subst, newLabel(FM,getLabel(RL')))) /\
	FM' := addRls(RL'', FM)  .


    eq procInitLemma(DB, [ GID ; < FM, ScS, La > ; B ; PS ], Q, T) = 
	<< DB ; [ GID ; < FM, ScS, La > ; B ; PS ] ; ('Please 'check 'the 'existence 'of Q '!) >>  [owise] .
    

    op addSentAttr : SentenceSet AttrSet -> SentenceSet .

    var AtS' : AttrSet .
    var So : Sort .

    eq addSentAttr(none, AtS') = none .
    eq addSentAttr((eq T1 = T2 [AtS]) ScS,AtS') = (eq T1 = T2 [rmInduVars(AtS)AtS']) addSentAttr(ScS,AtS') .
    eq addSentAttr((ceq T1 = T2 if EqC [AtS]) ScS,AtS') = (ceq T1 = T2 if EqC [rmInduVars(AtS)AtS']) addSentAttr(ScS,AtS') .
    eq addSentAttr((rl T1 => T2 [AtS]) ScS,AtS') = (rl T1 => T2 [rmInduVars(AtS)AtS']) addSentAttr(ScS,AtS') .
    eq addSentAttr((crl T1 => T2 if Co [AtS]) ScS,AtS') = (crl T1 => T2 if Co [rmInduVars(AtS)AtS']) addSentAttr(ScS,AtS') .

    eq addSentAttr((mb T1 : So [AtS]) ScS,AtS') = (mb T1 : So [rmInduVars(AtS)AtS']) addSentAttr(ScS,AtS') .
    eq addSentAttr((cmb T1 : So if EqC [AtS]) ScS,AtS') = (cmb T1 : So if EqC [rmInduVars(AtS)AtS']) addSentAttr(ScS,AtS') .


    eq procIndVars(DB, [ GID ; < FM , ScS, La > ; B ; PS ] , T) = 
	<< DB ; [ GID ; < FM, addSentAttr(ScS,  buildMetadata(downQidList(T))), La > ; B ; PS ] ; 'OK >> .
        

    
    eq rmInduVars(none) = none .
    ceq rmInduVars(At AtS) = rmInduVars(AtS) 
      if  metadata(Str) := At /\ "induction-on" = substr(Str, 0,12) .
    eq rmInduVars(At AtS) = (At rmInduVars(AtS)) [owise] .
    
    eq checkVars(nil, TL) = true .
    eq checkVars((Q QIL), TL) = if checkVarsAux(Q,TL) then checkVars(QIL, TL) else false fi .
    eq checkVarsAux(Q, empty) = false .
    eq checkVarsAux(Q, (T,TL)) = if Q == getName(T) or Q == T then true else checkVarsAux(Q, TL) fi .
    
    eq appendType(Q QIL, TL) = 
      if Q :: Variable then (Q appendType(QIL, TL)) else getVarbyName(Q, TL) appendType(QIL, TL) fi .
    eq appendType(nil, TL) = nil .
    eq getVarbyName(Q, (T, TL)) = if Q == getName(T) then T else getVarbyName(Q, TL) fi .
    eq getVarbyName(Q, empty) = 'nil .

    eq getBadVars(nil, TL) = nil .
    eq getBadVars((Q QIL), TL) = if checkVars(Q, TL) then getBadVars(QIL, TL) else (Q getBadVars(QIL, TL)) fi .


    ceq procGoals(DB, ME, T) = 
      if unitInDb(ME', DB') then 
	  procGoalsAux(DB', ME', T) 
	else 
	  << DB' ; null ; ('\r 'Error: '\o 'The 'module eMetaPrettyPrint(ME) 'is 'not 'in 'the 'database '. '\n) >> 
	fi 
      if < DB' ; ME' > := evalModExp(ME, DB) .

    op parseSentence : Term -> SentenceSet .
    op sentErr : QidList ~> SentenceSet .
    var S : Sentence .

    eq sentErr(QIL) sentErr(QIL') = sentErr(QIL QIL') .
    eq sentErr(QIL) S ScS = sentErr(QIL) .

   eq parseSentence('eq_=_;[T, T']) = (eq T = T' [none]) .
    eq parseSentence('ceq_=_if_;[T, T', T'']) = (ceq T = T' if T'' = 'true.Bool [none]) .
   eq parseSentence('rl_=>_;[T, T']) = (rl T => T' [none]) .
    eq parseSentence('crl_=>_if_;[T, T', T'']) = (crl T => T' if T'' = 'true.Bool [none]) .

    eq parseSentence('mb_:_;[T, T']) = 
	(mb T : getSort(breakMb(T',none)) [getAttrSet(breakMb(T',none))] ) .
    eq parseSentence('cmb_:_if_;[T, T', T'']) = 
	  (cmb T : getSort(breakMb(T',none)) if term(pullStmtAttrOut(T'',none)) = 'true.Bool [attrSet(pullStmtAttrOut(T'',none))]) .
    
    ceq parseSentence('__[T,T']) = S ScS 
      if S := parseSentence(T) /\ ScS := parseSentence(T') .

    eq parseSentence('__[T,T']) = sentErr('Bad 'goal)  [owise] .


    op procCPCmd : Database Module Term Term ~> CritPairSet .
    op procCPCmdLabel : Module Qid Qid ~> CritPairSet .
    op cpError : QidList ~> CritPairSet .
    op removeCondCP : Module CritPairSet -> CritPairSet .
    vars E1 E2 : Equation .
    
    eq removeCondCP(M, (cp(L,L',T,T') CPS )) = cp(L,L',T,T') removeCondCP(M, CPS) .
    eq removeCondCP(M, (ccp(L,L',T,T',Cd) CPS )) = 
	(if evalCondition(M,Cd) then 
	    cp(L,L',T,T') removeCondCP(M, CPS) else removeCondCP(M,CPS) fi ) .
    eq removeCondCP(M, none) = none .

    ceq procCPCmd(DB, M, T,T') = cpError(QIL) 
      if   equationError(QIL) := parseEq(T) parseEq(T') .

    ceq procCPCmd(DB, M, T,T') = 
	removeCondCP(M, CPS) 
      if  EqS := parseEq(T) parseEq(T') /\
	  E1 := solveBubbles(parseEq(T), M, addInfoConds(M), false, none, DB) /\
	  E2 := solveBubbles(parseEq(T'), M, addInfoConds(M), false, none, DB) /\ 
	  CPS := crcCritPairs(M, E1, E2) .

    ceq procCPCmd(DB, M, T,T') = 	cpError(QIL) 
      if  EqS := parseEq(T) parseEq(T') /\
	  equationError(QIL) := solveBubbles(parseEq(T), M, addInfoConds(M), false, none, DB) /\
	  E2 := solveBubbles(parseEq(T'), M, addInfoConds(M), false, none, DB) .

    ceq procCPCmd(DB, M, T,T') = 	cpError(QIL) 
      if  EqS := parseEq(T) parseEq(T') /\
	  E1 := solveBubbles(parseEq(T), M, addInfoConds(M), false, none, DB) /\
	  equationError(QIL) := solveBubbles(parseEq(T'), M, addInfoConds(M), false, none, DB) .

    ceq procCPCmd(DB, M, T,T') = 	cpError(QIL '\n QIL') 
      if  EqS := parseEq(T) parseEq(T') /\
	  equationError(QIL) := solveBubbles(parseEq(T), M, addInfoConds(M), false, none, DB) /\
	  equationError(QIL') := solveBubbles(parseEq(T'), M, addInfoConds(M), false, none, DB) .


    ceq procCPCmdLabel(M, Q, Q') = 
	removeCondCP(M,CPS) 
      if E1 := getEqbyLabel(M,Q) /\ E2 := getEqbyLabel(M,Q') /\
	  CPS := crcCritPairs(M, E1, E2) .

    ceq procCPCmdLabel(M, Q, Q') = cpError(QIL) 
      if equationError(QIL) := getEqbyLabel(M,Q) getEqbyLabel(M,Q') .



    eq procCPCmd(DB, M, T,T') = cpError('Not 'valid 'equation 'or 'labels) [owise] .
    

    op parseEq : Term ~> EquationSet .

    eq parseEq('eq_=_.[T, T']) = (eq T = T' [none] .) .
    eq parseEq('ceq_=_if_.[T, T', T'']) = (ceq T = T' if T'' = 'true.Bool [none] .) .
    eq parseEq('cq_=_if_.[T, T', T'']) = (ceq T = T' if T'' = 'true.Bool [none] .) .
    ceq parseEq('__[T,T']) = E EqS 
      if E := parseEq(T) /\ EqS := parseEq(T') .
    eq parseEq('__[T,T']) = equationError('Bad 'equation)  [owise] .
    
    op parseRl : Term ~> RuleSet .
    op parseMb : Term ~> MembAxSet .
    
    
    eq parseRl('rl_=>_.[T, T']) = (rl T => T' [none] .) .
    eq parseRl('crl_=>_if_.[T, T', T'']) = (crl T => T' if T'' = 'true.Bool [none] .) .
    ceq parseRl('__[T,T']) = R RlS 
      if R := parseRl(T) /\ RlS := parseRl(T') .
    eq parseRl('__[T,T']) = ruleError('Bad 'goal)  [owise] .

    eq parseMb('mb_:_.['bubble['__[''`[.Qid, Q, ''`].Qid]], T]) = 
	(mb getTerm(breakMb(T,none)) : getSort(breakMb(T,none)) [label(downQid(Q)) getAttrSet(breakMb(T,none))] .) .
    eq parseMb('mb_:_.[T, T']) = (mb T : getSort(breakMb(T', none)) [getAttrSet(breakMb(T',none))] .) [owise] . 
    eq parseMb('cmb_:_if_.[T, T', T'']) = (cmb T : getSort(breakMb(T', none)) if term(pullStmtAttrOut(T'',none)) = 'true.Bool 
	      [attrSet(pullStmtAttrOut(T'',none))] .) .
    eq parseMb('cmb`[_`]:_:_if_.['token[T3], T, T', T'']) = 
	  (cmb T : getSort(breakMb(T',none)) if term(pullStmtAttrOut(T'',none)) = 'true.Bool 
	      [attrSet(pullStmtAttrOut(T'',none)) label(downQid(T3))] .) .
    ceq parseMb('__[T,T']) = Mx MbS if Mx := parseMb(T) /\ MbS := parseMb(T') .
    eq parseMb('__[T,T']) = membAxError('Bad 'goal) [owise] .

    ceq procGoalsAux(DB, ME, T) = 
    	<< DB ; null ; ('bad 'goal 'specified) >>
    if sentErr(QIL) := parseSentence(T) .

    eq procGoalsAux(DB, ME, T) = 
	procGoalCmd(DB, ME, parseSentence(T)) [owise] .


    ceq procGoalCmd(DB, ME, ScS) = 
      if unitInDb(ME', DB') then 
	  procGoalCmdAux(DB', ME', ScS)
	else 
	  << DB' ; null ; ('\r 'Error: '\o 'The 'module eMetaPrettyPrint(ME) 'is 'not 'in 'the 'database '. '\n) >> 
	fi 
      if < DB' ; ME' > := evalModExp(ME, DB) .



    ceq procGoalCmdAux(DB, ME, ScS) =
	<< DB ; null ; (QIL) >> 
      if M := getFlatModule(ME, DB) /\	  
	  sentErr(QIL) := solveBubbles(ScS, M, addInfoConds(M), false, getVars(ME, DB), DB) .

    ceq procGoalCmdAux(DB, ME, ScS) =
	setGoal(DB, M, ScS'':SentenceSet) 
      if M := getFlatModule(ME, DB) /\
	 ScS'':SentenceSet := solveBubbles(ScS, M, addInfoConds(M), false, getVars(ME, DB), DB).


    op solveBubbles : SentenceSet Module Module Bool OpDeclSet Database ~> SentenceSet .
    var ScS' : [SentenceSet] .
    vars M' : Module .

    *** equations 
    ceq solveBubbles((eq T = T' [none]), M, M', B, VDS, DB) = 
	  sentErr(QIL) 
	if equationError(QIL) := solveBubbles((eq T = T' [none] .), M, M', B, VDS, DB) . 
    ceq solveBubbles((eq T = T' [none]), M, M', B, VDS, DB) = 
	(eq T1 = T2 [AtS])
	if (eq T1 = T2 [AtS] .) := solveBubbles((eq T = T' [none] .), M, M', B, VDS, DB) . 

    ceq solveBubbles((ceq T = T' if T'' = 'true.Bool [none]), M, M', B, VDS, DB) = 
	  sentErr(QIL) 
	if equationError(QIL) := solveBubbles((ceq T = T' if T'' = 'true.Bool [none] .), M, M', B, VDS, DB) .
    ceq solveBubbles((ceq T = T' if T'' = 'true.Bool [none]), M, M', B, VDS, DB) = 
	  (ceq T1 = T2 if Cond [AtS])
	if  (ceq T1 = T2 if Cond [AtS] .) := solveBubbles((ceq T = T' if T'' = 'true.Bool [none] .), M, M', B, VDS, DB) .

    ceq solveBubbles((rl T => T'  [none]), M, M', B, VDS, DB) = 
	sentErr(QIL) 
      if ruleError(QIL) := solveBubbles((rl T => T'  [none] .), M, M', B, VDS, DB) . 
    ceq solveBubbles((rl T => T' [none]), M, M', B, VDS, DB) = 
	(rl T1 => T2  [AtS])
      if  (rl T1 => T2 [AtS] .) := solveBubbles((rl T => T'  [none] .), M, M', B, VDS, DB) .
    

    ceq solveBubbles((crl T => T' if T'' = 'true.Bool [none]), M, M', B, VDS, DB) = 
	  sentErr(QIL) 
	if ruleError(QIL) := solveBubbles((crl T => T' if T'' = 'true.Bool [none] .), M, M', B, VDS, DB) . 
    
    ceq solveBubbles((crl T => T' if T'' = 'true.Bool [none]), M, M', B, VDS, DB) = 
	  (crl T1 => T2 if Cond [AtS])
	if  (crl T1 => T2 if Cond [AtS] .) := solveBubbles((crl T => T' if T'' = 'true.Bool [none] .), M, M', B, VDS, DB) .


   vars So' : Sort .
    
    ceq solveBubbles((mb T : So [none]), M, M', B, VDS, DB) = 
	  sentErr(QIL) 
	if membAxError(QIL) := solveBubbles((mb T : So [none] .), M, M', B, VDS, DB) . 
    ceq solveBubbles((mb T : So [none]), M, M', B, VDS, DB) = 
	(mb T1 : So' [AtS])
	if (mb T1 : So' [AtS] .) := solveBubbles((mb T : So [none] .), M, M', B, VDS, DB) . 

    ceq solveBubbles((cmb T : So if T'' = 'true.Bool [none]), M, M', B, VDS, DB) = 
	  sentErr(QIL) 
	if membAxError(QIL) := solveBubbles((cmb T : So if T'' = 'true.Bool [none] .), M, M', B, VDS, DB) .
    ceq solveBubbles((cmb T : So if T'' = 'true.Bool [none]), M, M', B, VDS, DB) = 
	  (cmb T1 : So' if Cond [AtS])
	if  (cmb T1 : So' if Cond [AtS] .) := solveBubbles((cmb T : So if T'' = 'true.Bool [none] .), M, M', B, VDS, DB) .

    
    vars S' : Sentence .

    ceq solveBubbles(S ScS, M, M', B, VDS, DB) = 
	solveBubbles(S, M, M', B, VDS, DB) solveBubbles(ScS, M, M', B, VDS, DB) 
      if ScS =/= none .
      
    eq solveBubbles((none).SentenceSet, M, M', B, VDS, DB) = none .
    

    eq setGoal(DB, U, ScS) = 
	<< DB ; [ '1-1 ; < U ,ScS, TL  > ; false ; empty ] ; ('OK) >> .
    
   var P : PTree .
       
    op buildMetadata : QidList -> AttrSet .
    eq buildMetadata(nil) = none .
    eq buildMetadata((Q QIL)) = 
      if Q =/= 'nil then 
	  metadata("induction-on-" + string(Q)) buildMetadata(QIL)
	else buildMetadata(QIL) fi .
    

    op ruleList : -> QidList .
    eq ruleList = (
	  'Name '\t '\t 'Meaning  '\n '\n 
	  '\r 'SI '\t '\o 'Simultaneous 'Induction  '\n 
	  '\r 'CA '\t '\o 'Case 'Analysis  '\n
	  '\r 'CA-1 '\t '\o 'Case 'Analysis 'on 'Condition '\n
	  '\r 'TC '\t '\o 'Theorem 'of 'Constant '\n
	  '\r 'IP '\t '\o 'Implication '\n
	  '\r 'CS '\t '\o 'Case 'analysis 'on 'Sequences '\n
	  '\r 'RD '\t '\o 'reduction 'to 'normal 'form '\n) .

    op isValidRule : QidList -> Bool .
    eq isValidRule(nil) = true .
    eq isValidRule(Q QIL) = (Q == 'SI or Q == 'RD or Q == 'CA or Q == 'CA-1 or Q == 'TC or Q == 'IP or Q == 'CS) 
	and isValidRule(QIL)  .
    
    op applyRules : Tactic PTree ~> PTreeSet .

    var TA : Tactic .

    op errorGoalSet : ~> GoalSet .
    var GS? : [GoalSet] .

    ceq applyRules(TA, [ GID ; G ; B ; PS ]) = 
	(if GS? == errorGoalSet then 
	    applyError('An 'error 'occurred 'when 'apply 'proof 'rule '\n 'No 'valid 'goals 'are 'generated. '\n 
	      'Please 'send 'a 'bug 'report 'to 'the 'developer) 
	  else 
	    (if GS?  =/= G then 
		initPTreeSet(GS?, GID, 1)
	      else applyError('No 'new 'goal 'generated!)
		fi)
	    fi)
      if T := buildCmd(TA, upTerm(metaNormGoal(G))) /\
	  RP := metaRewrite(upModule('#TOOL#, false), T, unbounded) /\
	  RP :: ResultPair /\
	  GS? := downTerm(getTerm(RP), errorGoalSet) .
    

    ceq applyRules(TA, [ GID ; G ; B ; PS ]) = 
	applyError('Error 'occurred!)
      if T := buildCmd(TA, upTerm(metaNormGoal(G))) /\
	  RP := metaRewrite(upModule('#TOOL#, false), T, unbounded) /\
	  not (RP :: ResultPair) .

    eq applyRules(TA, [ GID ; G ; B ; PS ]) =
	applyError('unkown 'reason! 'Maybe 'bad 'proof 'rule.)
	[owise] .


    op metaNormGoal : Goal -> Goal .
    op metaNormSen : Module SentenceSet -> SentenceSet .
    op metaNormCond : Module Condition -> Condition .

    eq metaNormGoal( < M, ScS, La > ) = 
	< M, metaNormSen(M, ScS), La > .
    eq metaNormSen(M, none) = none .
    eq metaNormSen(M, (ceq T = T' if Co [AtS]) ScS) = 
	  (ceq getTerm(metaNormalize(M, metaGRed(M,T))) = getTerm(metaNormalize(M, metaGRed(M,T'))) if metaNormCond(M, Co) [AtS]) 
	    metaNormSen(M, ScS) .
    eq metaNormSen(M, (eq T = T' [AtS]) ScS) = 
	  (eq getTerm(metaNormalize(M, metaGRed(M,T))) = getTerm(metaNormalize(M, metaGRed(M,T'))) [AtS]) 
	    metaNormSen(M, ScS) .

    eq metaNormSen(M, (crl T => T' if Co [AtS]) ScS) = 
	  (crl getTerm(metaNormalize(M, metaGRed(M,T))) => getTerm(metaNormalize(M, metaGRed(M,T'))) if metaNormCond(M, Co) [AtS]) 
	    metaNormSen(M, ScS) .
    eq metaNormSen(M, (rl T => T' [AtS]) ScS) = 
	  (rl getTerm(metaNormalize(M, metaGRed(M,T))) => getTerm(metaNormalize(M, metaGRed(M,T'))) [AtS]) 
	    metaNormSen(M, ScS) .

    eq metaNormSen(M, (mb T : So [AtS]) ScS) = 
	  (mb getTerm(metaNormalize(M, metaGRed(M,T))) : So [AtS]) 
	    metaNormSen(M, ScS) .
    eq metaNormSen(M, (cmb T : So if Co [AtS]) ScS) = 
	  (cmb getTerm(metaNormalize(M, metaGRed(M,T))) : So if metaNormCond(M, Co) [AtS]) 
	    metaNormSen(M, ScS) .

    eq metaNormCond(M, nil) = nil .
    eq metaNormCond(M,T = T' /\ Co) = 
	(getTerm(metaNormalize(M, metaGRed(M,T))) = getTerm(metaNormalize(M, metaGRed(M,T'))) /\ metaNormCond(M,Co)).
    eq metaNormCond(M,T := T' /\ Co) = 
	(getTerm(metaNormalize(M, metaGRed(M,T))) := getTerm(metaNormalize(M, metaGRed(M,T'))) /\ metaNormCond(M,Co)).
    eq metaNormCond(M,T : St /\ Co) = 
	(getTerm(metaNormalize(M,metaGRed(M,T))) : St /\ metaNormCond(M,Co)).
    eq metaNormCond(M,T => T' /\ Co) = 
	(getTerm(metaNormalize(M,metaGRed(M,T))) => getTerm(metaNormalize(M,metaGRed(M,T'))) /\ metaNormCond(M,Co)) . 


    


    
    op buildCmd : Tactic Term -> Term .
    eq buildCmd(nil,T) = T .
    eq buildCmd('SI TA, T) = buildCmd(TA, 'ind['red[T]]) .
    eq buildCmd('TC TA, T) = buildCmd(TA, 'tc['red[T]]) .
    eq buildCmd('CA TA, T) = buildCmd(TA, 'ca['red[T]]) .
    eq buildCmd('CA-1 TA, T) = buildCmd(TA, 'ca-1['red[T]]) .
    eq buildCmd('IP TA, T) = buildCmd(TA, 'imp['red[T]]) .
    eq buildCmd('CS TA, T) = buildCmd(TA, 'cs['red[T]]) .
    eq buildCmd('RD TA, T) = buildCmd(TA, 'red[T]) .

    op preGoal : String -> Qid .
    var STR : String .
    ceq preGoal(STR) =  qid(substr(STR,0,rfind(STR,"-",length(STR)))) 
      if rfind(STR,"-",length(STR)) =/= notFound /\
	 rfind(STR,"-",length(STR)) =/= 1 .
    eq preGoal(STR) = qid(STR) [owise] .

    op getLabel : Qid -> Qid .

endfm 



mod THM-DATABASE-HANDLING is 
    including DATABASE-HANDLING .
    including PROVE-COMMANDS-PROC .
    including PRETTY-PRINT .
    including NAT .
    including THM-BANNER .
    inc CAFE2MAUDE-DATABASE-HANDLING .
    *** Adrian


    sort CITPDatabaseClass .
    subsort CITPDatabaseClass < CafeDatabaseClass .
    op CITPDatabase : -> CITPDatabaseClass .
    *** Adrian

    sort Language .
    ops maude cafeobj : -> Language [ctor] .
    *** Adrian


    
    op currentGoal`:_ : Qid -> Attribute .
    op pTree`:_ : PTreeSet  -> Attribute .
    op showMod`:_ : Bool -> Attribute .
    op tactic`:_ : Nat -> Attribute .
    op tacticRec`:_ : Tactics -> Attribute .
    op critPair`:_ : CritPairSet -> Attribute .
    op answerMode`:_ : Bool -> Attribute .

    op language`:_ : Language -> Attribute [ctor] .
    *** Adrian


    vars T T' T'' T3 T4 T5 : Term .
    vars PS PS' : PTreeSet .
    vars P P' : PTree .
    var GID : Qid .
    var O : Oid .
    vars DB DB' : Database .
    var ME : ModuleExpression .
    var X@Database         : CITPDatabaseClass .
    *** Adrian
    var Atts : AttributeSet .
    vars QIL QIL' : QidList .
    vars B B' : Bool .
    var TAS : Tactics .
    var RP : [ResultPair] .

    rl [set-ind-vars-noGoal] :  
	< O         : X@Database | 
				   input   : ('set`ind`on_.['bubble[T]]), 
				   output : nil ,
				   currentGoal : 'nil,
				   Atts > => 
    	< O         : X@Database |
				   input   : nilTermList, 
				   output : ('\r 'ERROR: '\o 'No 'goal 'is 'specified!) ,
				   currentGoal : 'nil,
				   Atts > .

    crl [set-ind-vars] :  
	< O         : X@Database | db : DB,
				   input   : ('set`ind`on_.['bubble[T]]), 
				   output : nil ,
				   default : ME,
				   pTree : P,
				   currentGoal : GID,
				   showMod : B, 
				   Atts > => 
    	< O         : X@Database | db : DB',
				   input   : nilTermList, 
				   output : (if QIL == 'OK then 
				       ('\g 'INFO: '\o 'Induction 'will 'be 'conducted 'on downQidList(T)) 
				     else QIL fi ) ,
				   default : ME,
				   pTree : (if QIL == 'OK then replacePTree(P,GID,P') else P fi ),
				   currentGoal : GID,
				   showMod : B, 
				   Atts > 
      if GID =/= 'nil /\
	  << DB' ; P' ; QIL >> := procIndVars(DB,getPTree(P,GID),T) .
    

    crl [goal-Mod] :         < O         : X@Database | db : DB,
						    input   : ('goal_|-_[T,T']), 
						    output : nil ,
						    default : ME,
						    pTree : P,
							currentGoal : GID,
							showMod : B, 
			  				language : maude,
			  				*** Adrian
						    Atts >   =>
	  < O         : X@Database | db : DB,
				   input   : nilTermList, 
				   output : (if QIL == 'OK then (prettyPrintProofTree(P', DB', B) '\n '\g 'INFO: '\o  'an 'initial 'goal  'generated!)  else QIL fi ),
				   default : ME,
				   pTree : P',
				   currentGoal : getDefaultGoalIndex(P'),
				   showMod : B, 
				     language : maude,
			  	     *** Adrian
				   Atts >
      if << DB' ; P' ; QIL >> := procGoals(DB, parseModExp(T), T') . 



    crl [crit-pair] :         < O         : X@Database | db : DB,
						    input   : ('cp_><_[T,T']), 
						    output : nil ,
						    pTree : P,
						    currentGoal : GID,
							 answerMode : B,
							 critPair : CPS',
			  				 language : maude,
			  				 *** Adrian		 
						    Atts >   =>
	< O         : X@Database | db : DB,
				   input   : nilTermList, 
				   output : ('\g 'INFO: '\o (if CPS == none then ('No 'critical 'pairs) else eMetaPrettyPrint(M,'=>,CPS) fi)),
				   pTree : P,
				   currentGoal : GID,
				   critPair : CPS,
				   answerMode : (if CPS == none then B else true fi ),
				   language : maude,
			  	   *** Adrian				   
				   Atts >
      if M := getModuleinGoal(getGoalinTree(P,GID)) /\
	  CPS := procCPCmd(DB,M,T,T')  .

    crl [crit-pair] :         < O         : X@Database | db : DB,
						    input   : ('cp_><_.['token[T],'token[T']]), 
						    output : nil ,
						    pTree : P,
						    currentGoal : GID,
							 answerMode : B,
							 critPair : CPS',
			  			language : maude,
			  			*** Adrian

						    Atts >   =>
	< O         : X@Database | db : DB,
				   input   : nilTermList, 
				   output : ('\g 'INFO: '\o (if CPS == none then ('No 'critical 'pairs) else eMetaPrettyPrint(M,'=>,CPS) fi)),
				   pTree : P,
				   currentGoal : GID,
				   critPair : CPS,
				   answerMode : (if CPS == none then B else true fi ),
			  			language : maude,
			  			*** Adrian

				   Atts >
      if M := getModuleinGoal(getGoalinTree(P,GID)) /\
	  CPS := procCPCmdLabel(M,downQidList(T),downQidList(T'))  .


    crl [crit-pair] :         < O         : X@Database | db : DB,
						    input   : ('cp_><_.['token[T],'token[T']]), 
						    output : nil ,
						    pTree : P,
						    currentGoal : GID,
			  			language : maude,
			  			*** Adrian

						    Atts >   =>
	< O         : X@Database | db : DB,
				   input   : nilTermList, 
				   output : ('\r 'ERROR: '\o QIL),
				   pTree : P,
				   currentGoal : GID,
			  			language : maude,
			  			*** Adrian
				   Atts >
      if M := getModuleinGoal(getGoalinTree(P,GID)) /\
	  cpError(QIL) := procCPCmdLabel(M,downQidList(T),downQidList(T'))  .



    crl [crit-pair] :         < O         : X@Database | db : DB,
						    input   : ('cp_><_[T,T']), 
						    output : nil ,
						    pTree : P,
						    currentGoal : GID,
			  			language : maude,
			  			*** Adrian

						    Atts >   =>
	< O         : X@Database | db : DB,
				   input   : nilTermList, 
				   output : ('\r 'ERROR: '\o  QIL),
				   pTree : P,
				   currentGoal : GID,
			  			language : maude,
			  			*** Adrian
				   
				   Atts >
      if M := getModuleinGoal(getGoalinTree(P,GID)) /\
	  cpError(QIL) := procCPCmd(DB,M,T,T')  .


    var P? : PTree .
    
    crl [showGoal] : 
        < O         : X@Database | db : DB,
				   input   : ('show`goal_.['token[T]]), 
				   output : nil ,
				   pTree : P, 
				   currentGoal : GID,
				   showMod : B, 
			  			language : maude,
			  			*** Adrian

				   Atts >   => 
	< O         : X@Database | db : DB,
				   input   : nilTermList, 
				   currentGoal : downQidList(T), 
				   output :  (prettyPrintProofTree(P', DB, B)), 
				   pTree : P, 
				   showMod : B, 
			  			language : maude,
			  			*** Adrian

				   Atts >
      if P' := getPTree(P, downQidList(T))  . 

    rl [showGoal] : 
        < O         : X@Database | 
				   input   : ('show`tactics`..@Command@), 
				   output : nil ,
				   tacticRec : TAS,
				   tactic : N,
				   Atts >   => 
	< O         : X@Database | 
				   input   : nilTermList, 
				   output :  (prettyPrintTactics(TAS,N) '\g 'INFO: '\o 'Green 'number 'means 'current 'tactic. ), 
				   tacticRec : TAS,
				   tactic : N,
				   Atts > .
    
    
    crl [showGoal] : 
        < O         : X@Database | db : DB,
				   input   : ('show`goal_.['token[T]]), 
				   output : nil ,
				   pTree : P, 
				   currentGoal : GID,
			  			language : maude,
			  			*** Adrian

				   Atts >   => 
	< O         : X@Database | db : DB,
				   input   : nilTermList, 
				   currentGoal : GID, 
				   output :   ('\r 'WARNING: '\o QIL), 
				   pTree : P, 
			  			language : maude,
			  			*** Adrian
				   
				   Atts > 
      if ptreeErr(QIL) := getPTree(P, downQidList(T)) .


    rl [showGoal] : 
        < O         : X@Database | db : DB,
				   input   : ('show`goal`..@Command@), 
				   output : nil ,
				   pTree : P, 
				   currentGoal : GID,
				   showMod : B, 
			  			language : maude,
			  			*** Adrian

				   Atts >   => 
	< O         : X@Database | db : DB,
				   input   : nilTermList, 
				   currentGoal : GID, 
				   output : (if GID =/= 'nil then prettyPrintProofTree(getPTree(P, GID), DB, B) else ('\r 'WARNING: '\o 'no 'goals 'to 'show!) fi ), 
				   pTree : P, 
				   showMod : B, 
			  			language : maude,
			  			*** Adrian

				   Atts > .
    rl [proveGoal] : 
        < O         : X@Database | db : DB,
				   input   : ('auto`..@Command@), 
				   currentGoal : GID, 
				   Atts >   => 
	< O         : X@Database | db : DB,
				   input   : ('auto`goal_.['token[upTerm(GID)]]), 
				   currentGoal : GID, 
				   Atts > .
    
    
    crl [showUnprovedGoals] : 
        < O         : X@Database | db : DB,
				   input   : ('show`unproved`goals`..@Command@), 
				   output : nil ,
				   pTree : P, 
				   currentGoal : GID, 
				   showMod : B, 
			  			language : maude,
			  			*** Adrian

				   Atts >   => 
	< O         : X@Database | db : DB,
				   input   : nilTermList, 
				   output : 
				   (if PS =/= empty then (prettyPrintProofTreeAux(PS, DB, B) '\n '\g 'INFO: '\o (qid(string(num(PS), 10)) 'goal`(s`) 'unproved! '\n '\g 'INFO: '\o 'Next 'goal 'to 'be 'proved 'is '\r getDefaultGoalIndex(PS) '\o)) else ('\r 'WARNING: 'no 'goals!) fi ), 
				   currentGoal : getDefaultGoalIndex(PS), 
				   pTree : P, 
				   showMod : B, 
			  			language : maude,
			  			*** Adrian

				   Atts >
      if PS := unprovedGoals(P) . 


    var R : Rule .
    var P'' : PTree .
    var N : Nat .

    crl [applyRule] : 
        < O         : X@Database | db : DB,
				   input   : ('apply_.['bubble[T]]), 
				   output : nil ,
				   pTree : P, 
				   currentGoal : GID,
				   tactic : N, 
				   showMod : B,
			  			language : maude,
			  			*** Adrian

				   Atts >   => 
	  < O         : X@Database | db : DB,
				     input   : nilTermList, 
				     output  : ('~~~~~~~~~~~~~~~~~~~~~~~ '\s  '\s '\s '\s  '\s '\s  'Generated 'GOALS '\s  '\s '\s  '\s '\s  '\s  '~~~~~~~~~~~~~~~~~~~~~~~ '\n '\n 
				       prettyPrintProofTreeAux((P'' PS), DB, B) '\n '\g 'INFO: '\o  (qid(string(num(P'' PS), 10)) 'goal`(s`) 'generated! '\n '\g 'INFO: '\o 'Next 'goal 'to 'be 'proved 'is '\r getDefaultGoalIndex(P'') '\o )), 
				     pTree : addPTreeSet(P, GID, (P'' PS)), 
				     currentGoal : getDefaultGoalIndex(P''), 
				     showMod : B,
				     tactic : N, 
			  			language : maude,
			  			*** Adrian

				     Atts >
      if isValidRule(downQidList(T)) /\
	  P' := getPTree(P, GID) /\
	  (P'' PS) := applyRules(downQidList(T), P') .
    
    crl [applyRule] : 
        < O         : X@Database | 
				   input   : ('apply_.['bubble[T]]), 
				   output : nil ,
				   pTree : P, 
				   currentGoal : GID,
			  			language : maude,
			  			*** Adrian

				   Atts >   => 
	  < O         : X@Database |
				     input   : nilTermList, 
				     output : ('\g 'INFO: '\o 'goal GID 'is 'proved '\n '\g 'INFO: '\o (if num(PS) == 0 then ('PROOF 'COMPLETED!) else  ('\r qid(string(num(PS), 10)) '\o 'goal`(s`) 'remained '\n 	   '\g 'INFO: '\o 'Next 'goal 'to 'be 'proved 'is '\r getDefaultGoalIndex(PS) '\o) fi )) , 
				     pTree : P'', 
				     currentGoal : getDefaultGoalIndex(PS), 
			  			language : maude,
			  			*** Adrian

				     Atts >
      if isValidRule(downQidList(T)) /\
	  P' := getPTree(P, GID) /\
	  empty := applyRules(downQidList(T), P') /\ 
	  P'' := setGoalProved(P,GID)  /\
	  PS := unprovedGoals(P'') .
    


    crl [applyRule] : 
	< O         : X@Database | 
				   input   : ('apply_.['bubble[T]]), 
				   output : nil ,
				   pTree : P, 
				   currentGoal : GID,
			  			language : maude,
			  			*** Adrian

				   Atts >   => 
        < O      : X@Database | 
				input   : nilTermList, 
				output : ('\r 'ERROR: '\o QIL),
				pTree : P, 
				currentGoal : GID,
				Atts >
      if isValidRule(downQidList(T)) /\
	  ptreeErr(QIL) := getPTree(P, GID) .

    crl [applyRule] : 
	< O         : X@Database | 
				   input   : ('apply_.['bubble[T]]), 
				   output : nil ,
				   pTree : P, 
				   currentGoal : GID,
				   Atts >   => 
        < O      : X@Database |
				input   : nilTermList, 
				output : ('\r 'ERROR: '\o getInvalidTac(downQidList(T)) 'is 'not 'a 'valid 'proof 'rule '\n 'Valid 'proof 'rules: '\n ruleList),
				pTree : P, 
				currentGoal : GID,
			  			language : maude,
			  			*** Adrian

				Atts >
      if not isValidRule(downQidList(T)) .

    
    crl [applyRule] : 
        < O         : X@Database | 
				   input   : ('apply_.['bubble[T]]), 
				   output : nil ,
				   pTree : P, 
				   currentGoal : GID,
			  			language : maude,
			  			*** Adrian

				   Atts >   => 
        < O         : X@Database | 
				   input   : nilTermList, 
				   output : ('\r 'ERROR: '\o QIL ) ,
				   pTree : P, 
				   currentGoal : GID,
			  			language : maude,
			  			*** Adrian

				   Atts >
      if isValidRule(downQidList(T)) /\
	  P' := getPTree(P,GID) /\
	  applyError(QIL) := applyRules(downQidList(T), P') . 

    var G : Goal .

    crl [applyTo] : 
        < O         : X@Database |
				   input   : ('apply_to_.['token[T],'token[T']]), 
				   output : nil ,
				   pTree : P, 
				   Atts >   => 
	< O         : X@Database | 
				   input : nilTermList, 
				   output : ('\r 'ERROR: '\o QIL),
				   pTree : P, 
				   Atts	 > 
      if ptreeErr(QIL) := getPTree(P, downQidList(T')) . 

    crl [applyTo] : 
        < O         : X@Database |
				   input   : ('apply_to_.['bubble[T],'token[T']]), 
				   pTree : P, 
				   currentGoal : GID,
				   Atts >   => 
	< O         : X@Database | 
				   input : ('apply_.['bubble[T]]), 
				   pTree : P, 
				   currentGoal : downQidList(T'),
				   Atts	 > 
      if P' := getPTree(P, downQidList(T')) . 


    crl [proveGoal-bad] :
        < O         : X@Database | 
				   input   : ('auto`goal_.['token[T]]), 
				   output : nil ,
				   pTree : P, 
				   Atts >   => 
	< O         : X@Database | 
				   input   : nilTermList, 
				   output : ('\r 'ERROR: '\o QIL ),
				   pTree : P, 
				   Atts >
      if ptreeErr(QIL) :=  getPTree(P, downQidList(T)) .

    
    crl [proveGoal] :
        < O         : X@Database | db : DB,
				   input   : ('auto`goal_.['token[T]]), 
				   output : nil ,
				   pTree : P, 
				   currentGoal : GID,
				   tacticRec : TAS, 
				   tactic : N, 
				   Atts >   => 
	  < O         : X@Database | db : DB,
				     input   : nilTermList, 
				     output :  (('\n '\g 'INFO: '\o 'Goal '\g GID' '\o 'was 'sucessfully 'proved '\n 
					 'by 'applying 'tactic: '\g QIL' '\o '\n) (if PS == empty then ('\n '\g 'INFO: '\o 'PROOF 'COMPLETED) else ('\n '\g 'INFO: '\o qid(string(num(PS),10)) 'unproved 'goal`(s`) 'remained '\n  '\g 'INFO: '\o 'Next 'goal 'to 'be 'proved 'is '\r getDefaultGoalIndex(PS) '\o ) fi )),
				     pTree :  P'',
				     currentGoal : ( if PS =/= empty then getDefaultGoalIndex(PS) else 'nil fi ) ,
				     tacticRec : TAS, 
				     tactic : N, 
				     Atts >
      if GID' := downQidList(T) /\ 
	  P' :=  getPTree(P, GID') /\ 
	  QIL' := getTactic(TAS,N) /\
	  applyRules(QIL',P') == empty  /\ 
	  P'' := setGoalProved(P, downQidList(T)) /\ PS := unprovedGoals(P'') .


    var GID' : Qid .
    var GS : GoalSet .

    crl [proveGoal] :
        < O         : X@Database | 
				   input   : ('auto`goal_.['token[T]]), 
				   output : nil ,
				   pTree : P, 
				   currentGoal : GID,
				   tacticRec : TAS,
				   tactic : N,
				   Atts >   => 
	  < O         : X@Database | 
				     input   : nilTermList, 
				     output :  ('\g 'WARNING: '\o 'No 'proof 'found 'for 'goal GID '\n),
				     pTree :  P,
				     currentGoal : downQidList(T),
				     tacticRec : TAS,
				     tactic : N,
				     Atts > 
      if GID' := downQidList(T) /\ 
	  P' :=  getPTree(P, GID') /\ 
	  applyRules(getTactic(TAS,N),P') =/= empty .


    crl [proveGoal] :
        < O         : X@Database | 
				   input   : ('auto`goal_.['token[T]]), 
				   output : nil ,
				   pTree : P, 
				   currentGoal : GID,
				   tacticRec : TAS,
				   tactic : N,
				   Atts >   => 
	  < O         : X@Database | 
				     input   : nilTermList, 
				     output :  ('\g 'WARNING: '\o 'No 'proof 'found 'for 'goal GID '\n),
				     pTree :  P,
				     currentGoal : downQidList(T),
				     tacticRec : TAS,
				     tactic : N,
				     Atts > 
      if GID' := downQidList(T) /\ 
	  P' :=  getPTree(P, GID') /\ 
	  applyError(QIL) := applyRules(getTactic(TAS,N),P') .

    

    rl [badCommand] :
	< O         : X@Database | db : DB,
				   input     : ('bad`input.Qid), 
				   output : nil ,
				   Atts >   =>
    	< O         : X@Database | db : DB,
				   input     : nilTermList, 
				   output : ('\r 'ERROR: '\o string2qidList("Bad input for prove command.")),
				   Atts > .

    crl [setTacticOn] :
	< O         : X@Database | 
				   input     : ('select`tactic_.['token[T]]), 
				   output : nil ,
				   tactic : N, 
				   tacticRec : TAS,
				   Atts >   =>
    	< O         : X@Database | 
				   input     : nilTermList, 
				   output : (if RP :: ResultPair then 
				       (if getTactic(TAS,downTerm(getTerm(RP),0)) =/= nil then 
					   ('\g 'INFO: '\o 'Tactic '\g getTactic(TAS,downTerm(getTerm(RP),0)) '\o 'will 'be 'used '\n)
					 else ('\r 'ERROR: '\o 'bad 'number '\n) fi)
				     else 
				       ('\r 'ERROr: '\o 'no 'parse 'for downQidList(T)) fi),
				   tacticRec : TAS,
				   tactic : (if getTactic(TAS,downTerm(getTerm(RP),0)) =/= nil then downTerm(getTerm(RP),0) else N fi),
				   Atts >
      if RP := metaParse(upModule('NAT,false), downQidList(T),'Nat)  .
    
    rl [setModuleOn] :
	< O         : X@Database | db : DB,
				   input     : ('set`module`on`..@Command@), 
				   output : nil ,
				   showMod : B, 
				   Atts >   =>
    	< O         : X@Database | db : DB,
				   input     : nilTermList, 
				   output : ('\g 'INFO: '\o 'Module 'will 'be 'displayed 'in 'goals),
				   showMod : true, 
				   Atts > .

    rl [goBackCommand] :
	< O         : X@Database | db : DB,
				   input     : ('roll`back`..@Command@), 
				   output : nil,
				   pTree : P,
				   currentGoal : GID,
				   Atts >   =>
    	< O         : X@Database | db : DB,
				   input     : nilTermList, 
				   output : (if preGoal(string(GID)) == GID then 
				       ('\r 'WARNING: '\o 'No 'goal 'or 'Goal GID 'is 'already 'the 'toppest 'one) 
				     else 
				       ('\g 'INFO: '\o 'Goal preGoal(string(GID)) 'is 'set 'as 'the 'current 'goal!) fi),
				   pTree : rmChild(P,preGoal(string(GID))),
				   currentGoal : preGoal(string(GID)),
				   Atts > .


    rl [helpCommand] :
	< O         : X@Database | db : DB,
				   input     : ('set`module`off`..@Command@), 
				   output : nil ,
				   showMod : B, 
				   Atts >   =>
    	< O         : X@Database | db : DB,
				   input     : nilTermList, 
				   output : ('\g 'INFO: '\o 'Module 'will 'be 'concealed 'in 'goals),
				   showMod : false, 
				   Atts > .

    rl [helpCommand] :
	< O         : X@Database | db : DB,
				   input     : ('help`me`..@Command@), 
				   output : nil ,
				   Atts >   =>
    	< O         : X@Database | db : DB,
				   input     : nilTermList, 
				   output : (help-list),
				   Atts > .
    crl [errorInput] :
	< O         : X@Database | db : DB,
				   input     : (Q[TL]), 
				   output : nil ,
				  currentGoal : 'nil,
				   Atts >   =>
    	< O         : X@Database | db : DB,
				   input     : nilTermList, 
				   output : ('\r 'ERROR: '\o 'no 'goal 'specified '\n),
				   currentGoal : 'nil,
				   Atts >
      if Q == 'init_by_. or Q == 'set`ind`on_. or Q == 'show_goal_. or  Q == 'auto`goal_. or Q == 'apply_. or Q == 'apply_to_. or Q == 'cp_><_ or Q == 'cp_><_. . 


    crl [errorInput] :
	< O         : X@Database | db : DB,
				   input     : CMD, 
				   output : nil ,
				  currentGoal : 'nil,
				   Atts >   =>
    	< O         : X@Database | db : DB,
				   input     : nilTermList, 
				   output : ('\r 'ERROR: '\o 'no 'goal 'specified '\n),
				   currentGoal : 'nil,
				   Atts >
      if CMD == 'show`goal`..@Command@ or CMD == 'roll`back`..@Command@ or CMD == 'auto`..@Command@ or CMD == 'show`unproved`goals`..@Command@ . 

 

    rl [init-lemmar-noGoal] :  
	< O         : X@Database | 
				   input   : ('init_by_.['token[T],'bubble[T']]), 
				   output : nil ,
				   currentGoal : 'nil,
			 			language : maude,
			  		*** Adrian
				   Atts > => 
    	< O         : X@Database | 
				   input   : nilTermList, 
				   output : ('\r 'ERROR: '\o 'No 'goal 'is 'specified!) ,
				   currentGoal : 'nil,
				   language : maude,
			  		*** Adrian
				   Atts > .

    crl [set-tactic] :  
	< O         : X@Database | input   : ('set`tactic_.['bubble[T']]), 
				   output : nil ,
				   tactic : N,
				   tacticRec : TAS,
				   Atts > => 
    	< O         : X@Database | input   : nilTermList, 
				   output : (if isValidRule(QIL') then ('New 'tactic '\g QIL' '\o 'will 'be 'used 'by 'default) else 
				       ('\r 'ERROR: '\o 'bad 'proof 'rules: getInvalidTac(QIL') '\n ) fi ),
				   tactic : (if isValidRule(QIL') then num(TAS) else N fi ),
				   tacticRec : (if isValidRule(QIL') then  TAS @ downQidList(T') else TAS fi ),
				   Atts >
    if QIL' := downQidList(T') .

    crl [set-tactic-error] :  
	< O         : X@Database | db : DB,
				   input   : ('set`tactic_.['bubble[T']]), 
				   output : nil ,
				   Atts > => 
    	< O         : X@Database | db : DB,
				   input   : nilTermList, 
				   output : (QIL),
				   Atts > 
      if dbErr(QIL) := procSetTactic(DB, downQidList(T')) .

    crl [init-lemma-label] :  
	< O         : X@Database | db : DB,
				   input   : ('init_by_.['token[T],T']), 
				   output : nil ,
				   pTree : P,
				   currentGoal : GID,
				   language : maude,
			  		*** Adrian
				   Atts > => 
    	< O         : X@Database | db : DB',
				   input   : (if QIL == 'OK then 'show`goal`..@Command@ else nilTermList fi ), 
				   output : (if QIL == 'OK then 
				       ('\g 'INFO: '\o 'Lemma downQidList(T) 'is 'initialized! '\n) 
				     else QIL fi ) ,
				   pTree : (if QIL == 'OK then replacePTree(P,GID,P') else P fi ),
				   currentGoal : GID,
				   language : maude,
			  	   *** Adrian
				   Atts > 
      if GID =/= 'nil /\  
	  << DB' ; P' ; QIL >> := procInitLemma(DB,getPTree(P,GID),downQidList(T),T') .

    crl [test-terms] :  
	< O         : X@Database | db : DB,
				   input   : ('lred_.['bubble[T]]), 
				   output : nil ,
				   pTree : P,
				   currentGoal : GID,
				   language : maude,
			  		*** Adrian
				   Atts > => 
    	< O         : X@Database | db : DB,
				   input   : nilTermList, 
				   output : (QIL) ,
				   pTree : P ,
				   currentGoal : GID,
				   language : maude,
			  	   *** Adrian
				   Atts > 
      if GID =/= 'nil /\  
	  M := getModuleinGoal(getGoalinTree(P,GID)) /\
	  QIL := procTest(DB,M,'bubble[T]) .

    rl [test-terms] :  
	< O         : X@Database | db : DB,
				   input   : ('lred_.['bubble[T]]), 
				   output : nil ,
				   pTree : P,
				   currentGoal : 'nil,
				   language : maude,
			  		*** Adrian
				   Atts > => 
    	< O         : X@Database | db : DB,
				   input   : nilTermList, 
				   output : ('\r 'Error: '\o 'I 'cannot 'find 'any 'goal '\n),
				   pTree : P ,
				   currentGoal : 'nil,
				   language : maude,
			  	   *** Adrian
				   Atts > .



    var Q : Qid .
    var TL : TermList .

    crl [init-lemma-eq] :  
	< O         : X@Database | db : DB,
				   input   : ('init_by_.[Q[TL],T']), 
				   output : nil ,
				   pTree : P,
				   currentGoal : GID,
				   language : maude,
			  		*** Adrian
				   Atts > => 
    	< O         : X@Database | db : DB',
				   input   : (if QIL == 'OK then 'show`goal`..@Command@ else nilTermList fi ), 
				   output : (if QIL == 'OK then 
				       ('\g 'INFO: '\o 'Lemma 'is 'initialized! '\n) 
				     else QIL fi ) ,
				   pTree : (if QIL == 'OK then replacePTree(P,GID,P') else P fi ),
				   currentGoal : GID,
				   language : maude,
			  	   *** Adrian
				   Atts > 
      if (Q == 'eq_=_. or Q == 'ceq_=_if_.) /\ GID =/= 'nil /\  
	  << DB' ; P' ; QIL >> := procInitLemma(DB,getPTree(P,GID),parseEq(Q[TL]),T') .

    crl [init-lemma] :  
	< O         : X@Database | db : DB,
				   input   : ('init_by_.[Q[TL],T']), 
				   output : nil ,
				   pTree : P,
				   currentGoal : GID,
				   language : maude,
			  	   *** Adrian
				   Atts > => 
    	< O         : X@Database | db : DB',
				   input   : (if QIL == 'OK then 'show`goal`..@Command@ else nilTermList fi ), 
				   output : (if QIL == 'OK then 
				       ('\g 'INFO: '\o 'Lemma 'is 'initialized! '\n) 
				     else QIL fi ) ,
				   pTree : (if QIL == 'OK then replacePTree(P,GID,P') else P fi ),
				   currentGoal : GID,
				   language : maude,
			  	   *** Adrian
				   Atts > 
      if (Q == 'rl_=>_. or Q == 'crl_=>_if_.) /\ GID =/= 'nil /\  
	  << DB' ; P' ; QIL >> := procInitLemma(DB,getPTree(P,GID),parseRl(Q[TL]),T') .




    vars CPS CPS' : CritPairSet .

    crl [init-lemma-cp] :  
	< O         : X@Database | db : DB,
				   input   : ('init_by_.['token[T],T']), 
				   output : nil ,
				   pTree : P,
				   currentGoal : GID,
				   critPair : none, 
				   language : maude,
			  	   *** Adrian
				   Atts > => 
    	< O         : X@Database | db : DB',
				   input   : nilTermList, 
				   output : ('\g 'INFO: '\o 'Non-confluence 'occurred 'after 'initializing 'lemma 
				     downQidList(T) '! '\n QIL '\n '\n '\g 'INFO '\o 'use 'command '\r 'discard 'critical 'pair 
				     '\o 'to 'make 'module 'confluent '\n 'or 'command '\r 'ignore '\o 'to 'ignore 'the 
				     'non-confluence '\n) ,
				   pTree : replacePTree(P,GID,P'),
				   critPair : CPS,
				   currentGoal : GID,
				   language : maude,
			  		*** Adrian
				   Atts > 
      if GID =/= 'nil /\  
	  << DB' ; P' ; QIL ; CPS >> := procInitLemma(DB,getPTree(P,GID),downQidList(T),T') .


    --- procCriticalPair 
    
    var CP : CritPair .
    var M : Module .

    crl [critical-pair] :  
	< O         : X@Database | db : DB,
				   input   : ('discard`critical`pair`..@Command@), 
				   critPair : (CP CPS),
				   pTree : P,
				   currentGoal : GID,				  
				   output : nil ,
				   answerMode : B,
				   language : maude,
			  	   *** Adrian
				   Atts > => 
    	< O         : X@Database | db : DB,
				   input   : nilTermList, 
				   critPair : (CP CPS),
				   output : (eMetaPrettyPrint(M,'=>,CP) '\n '\g 'Question: 
				     '\o 'add 'as '\r 'equation '\o 'or '\r 'rule '\o '? ),
				   currentGoal : GID,				  
				   answerMode : true,
				   pTree : P,
				   language : maude,
			  		*** Adrian
				   Atts > 
      if M := getModuleinGoal(getGoalinTree(P,GID)) .
    
    var G' : Goal .

    crl [critical-pair-eq] :  
	< O         : X@Database | db : DB,
				   input   : ('equation`..@Command@), 
				   critPair : (CP CPS),
				   pTree : P,
				   currentGoal : GID,				  
				   output : nil ,
				   answerMode : true,
				   showMod : B,
				   language : maude,
			  		*** Adrian
				   Atts > => 
    	< O         : X@Database | db : DB,
				   input   : if CPS == none then nilTermList else 'discard`critical`pair`..@Command@ fi , 
				   critPair : CPS,
				   output : prettyPrintGoal(G', DB, B),
				   answerMode : (if CPS == none then false else true fi),
				   pTree : setGoalinTree(P,GID,G'),
				   currentGoal : GID,				  
				   showMod : B,
				   language : maude,
			  		*** Adrian
				   Atts > 
      if GID =/= 'nil /\
	  G := getGoalinTree(P,GID) /\
	  M := addEqs(eq(CP,true), getModuleinGoal(G)) /\
	  G' := setModuleinGoal(G,M) .

    crl [critical-pair-eq] :  
	< O         : X@Database | db : DB,
				   input   : ('backward`equation`..@Command@), 
				   critPair : (CP CPS),
				   pTree : P,
				   currentGoal : GID,				  
				   output : nil ,
				   answerMode : true,
				   showMod : B,
				   language : maude,
			  		*** Adrian
				   Atts > => 
    	< O         : X@Database | db : DB,
				   input   : if CPS == none then nilTermList else 'discard`critical`pair`..@Command@ fi , 
				   critPair : CPS,
				   output : (if CPS == none then ('\n '\g 'INFO: '\o 'All 'critical 'pairs 'are 'discarded '\n '\n 
					 prettyPrintGoal(G', DB, B)) else nil fi),
				   answerMode : (if CPS == none then false else true fi),
				   pTree : setGoalinTree(P,GID,G'),
				   currentGoal : GID,				  
				   showMod : B,
				   language : maude,
			  		*** Adrian
				   Atts > 
      if GID =/= 'nil /\
	  G := getGoalinTree(P,GID) /\
	  M := addEqs(eq(CP,false), getModuleinGoal(G)) /\
	  G' := setModuleinGoal(G,M) .


    crl [critical-pair-eq] :  
	< O         : X@Database | db : DB,
				   input   : ('rule`..@Command@), 
				   critPair : (CP CPS),
				   pTree : P,
				   currentGoal : GID,				  
				   output : nil ,
				   answerMode : true,
				   showMod : B,
				   language : maude,
			  		*** Adrian
				   Atts > => 
    	< O         : X@Database | db : DB,
				   input   : if CPS == none then nilTermList else 'discard`critical`pair`..@Command@ fi , 
				   critPair : CPS,
				   output : (if CPS == none then ('\n '\g 'INFO: '\o 'All 'critical 'pairs 'are 'discarded '\n '\n 
					 prettyPrintGoal(G', DB, B)) else nil fi),
				   answerMode : (if CPS == none then false else true fi),
				   pTree : setGoalinTree(P,GID,G'),
				   currentGoal : GID,				  
				   showMod : B,
				   language : maude,
			  		*** Adrian
				   Atts > 
      if GID =/= 'nil /\
	  G := getGoalinTree(P,GID) /\
	  M := addRls(rl(CP,true), getModuleinGoal(G)) /\
	  G' := setModuleinGoal(G,M) .

    crl [critical-pair-eq] :  
	< O         : X@Database | db : DB,
				   input   : ('backward`rule`..@Command@), 
				   critPair : (CP CPS),
				   pTree : P,
				   currentGoal : GID,				  
				   output : nil ,
				   answerMode : true,
				   showMod : B,
				   language : maude,
			  	   *** Adrian
				   Atts > => 
    	< O         : X@Database | db : DB,
				   input   : if CPS == none then nilTermList else 'discard`critical`pair`..@Command@ fi , 
				   critPair : CPS,
				   output : (if CPS == none then ('\n '\g 'INFO: '\o 'All 'critical 'pairs 'are 'discarded '\n '\n 
					 prettyPrintGoal(G', DB, B)) else nil fi),
				   answerMode : (if CPS == none then false else true fi),
				   pTree : setGoalinTree(P,GID,G'),
				   currentGoal : GID,				  
				   showMod : B,
				   language : maude,
			  		*** Adrian
				   Atts > 
      if GID =/= 'nil /\
	  G := getGoalinTree(P,GID) /\
	  M := addRls(rl(CP,false), getModuleinGoal(G)) /\
	  G' := setModuleinGoal(G,M) .

    rl [ignore] :  
	< O         : X@Database | db : DB,
				   input   : ('ignore`..@Command@), 
				   critPair : (CP CPS),
				   output : nil ,
				   answerMode : true,
				   language : maude,
			  		*** Adrian
				   Atts > => 
    	< O         : X@Database | db : DB,
				   input   : if CPS == none then nilTermList else 'discard`critical`pair`..@Command@ fi , 
				   critPair : CPS,
				   output : 
				   (if CPS == none then ('\n '\g 'INFO: '\o 'All 'critical 'pairs 'are 'discarded) else nil fi),
				   answerMode : (if CPS == none then false else true fi),
				   language : maude,
			  		*** Adrian
				   Atts > .
    var CMD : Constant .

    crl [answerMode] : 
	< O         : X@Database |
				   input : CMD, 
				   answerMode : true, 
				   output : nil, 
				   language : maude,
			  		*** Adrian
				   Atts > => 

    	< O         : X@Database |
				   input : nilTermList, 
				   answerMode : true, 
				   output : ('\r 'WARNING: '\o 'please 'answer '\r 'equation '\o  'or '\r 'rule '\o '\n),
				   language : maude,
			  		*** Adrian
				   Atts > 
      if CMD =/= 'rule`..@Command@ /\ CMD =/= 'equation`..@Command@ /\ CMD =/= 'ignore`..@Command@ /\ 
	  CMD =/= 'backward`equation`..@Command@ /\ CMD =/= 'backward`rule`..@Command@ .


    crl [nonAnswerMode] : 
	< O         : X@Database |
				   input : CMD, 
				   answerMode : false, 
				   output : nil, 
				   language : maude,
			  		*** Adrian
				   Atts > => 

    	< O         : X@Database |
				   input : nilTermList, 
				   answerMode : false, 
				   output : ('\r 'ERROR: '\o 'No 'critical 'pair 'to 'discard '\n),
				   language : maude,
			  		*** Adrian
				   Atts > 
      if CMD == 'rule`..@Command@ or CMD == 'equation`..@Command@ or CMD == 'ignore`..@Command@ or 
	  CMD == 'backward`equation`..@Command@ or CMD == 'backward`rule`..@Command@ .
    

   ***************************************
   *** Rules for choosing the language ***
   ***************************************

   var L : Language .
   rl [maude-specs] :
      < O : X@Database | input : ('maude`language`..@Command@), output : nil ,
                         language : L, Atts >
   => < O : X@Database | input : nilTermList, output : ('\n '\b 'Maude 'selected 'as
                                                        'current 'specification
                                                        'language. '\o '\n
                                                        help-list '\n),
                         language : maude, Atts > .

   rl [cafe-specs] :
      < O : X@Database | input : ('cafeOBJ`language`..@Command@), output : nil ,
                         language : L, Atts >
   => < O : X@Database | input : nilTermList, output : ('\n '\b 'CafeOBJ 'selected 'as
                                                        'current 'specification
                                                        'language. '\o '\n
                                                        cafe-help-list),
                         language : cafeobj, Atts > .



  *** Adrian
  op cafe-help-list : -> QidList .
  eq cafe-help-list = ('\n 'Command 'lists: '\n
 	  '\t string2qidList("load *.cafe .") '\t '\t  '\t string2qidList("-- load modules into database")'\n '\n
 	  '\t string2qidList("(goal") '\s string2qidList("ModuleName |-") '\s string2qidList("Equations/Transitions )") '\n
 	 	'\t string2qidList("(set ind on Vars .)")  '\t '\t string2qidList("-- specify the variables for induction")'\n
  		'\t string2qidList("(init LEMMA by V <- c .)") '\t string2qidList("-- initialize a lemma by substitution.")'\n
  		'\t string2qidList("(auto goal GoalID .)")  '\t '\t string2qidList("-- prove a subgoal")'\n
	  	'\t string2qidList("(auto .)") '\t '\t  '\t  string2qidList("-- try to prove the current goal")'\n
  		'\t string2qidList("(roll back .)")  '\t '\t '\t string2qidList("-- go back to the previous goal") '\n
  		'\t string2qidList("(apply RuleName .)") '\t '\t   string2qidList("-- apply a given rule to default goal") '\n
	  	'\t string2qidList("(apply RuleName to GoalId .)")  '\t string2qidList("-- apply a rule to a goal") '\n
		  '\t string2qidList("(cp EQ >< EQ)") '\t '\t '\t   string2qidList("-- check critical pairs") '\n
		  '\t string2qidList("(cp Label >< Label .)")  '\t '\t string2qidList("-- check critical pairs") '\n
	  	'\t string2qidList("(transition .)") '\t '\t '\t string2qidList("-- add a critical pair as a transition") '\n
	  	'\t string2qidList("(backward transition .)") '\t '\t  string2qidList("-- transition in inverse direction") '\n
	  	'\t string2qidList("(equation .)") '\t '\t '\t  string2qidList("-- add a critical pair as an equation ") '\n
	  	'\t string2qidList("(backward equation .)") '\t '\t  string2qidList("-- equation in inverse direction ") '\n
	   '\t string2qidList("(show unproved goals .)") '\t '\t  string2qidList("-- show all unproved goals") '\n
	  	'\t string2qidList("(show goal GoalID .)") '\t  '\t string2qidList("-- show a goal and set it as default") '\n
		  '\t string2qidList("(show goal .)") '\t '\t   '\t string2qidList("-- show the current goal") '\n
 	  '\t string2qidList("(show tactics .)") '\t '\t  string2qidList("-- show all tactics") '\n
	  	'\t string2qidList("(set tactic PROOF STRATEGY .)") '\t string2qidList("-- specify customized proof strategy") '\n
  		'\t string2qidList("(select tactic NAT .)") '\t '\t string2qidList("-- to use customized proof strategy") '\n
		  '\t string2qidList("(set module off .)") '\t '\t string2qidList("-- only show added contents in module") '\n
		  '\t string2qidList("(set module on .)") '\t '\t string2qidList("-- display all content in modules") '\n ) .

    
endm 

***in cafe_interface.maude
*** Adrian

***(%

We present in this section how to integrate the specification shown in the
previous version with any existing tool for Maude specifications implemented
in Full Maude.

\subsection{Extending the tool\label{subsec:ext}}

We first present the new modules required to process the commands from the tool
we want to extend. Note that this part is different for each tool.
%
The module \verb"CAFE-CITP-COMMANDS-PROC" is in charge of processing the commands.

{\codesize
\begin{verbatim}
%)

mod CAFE-CITP-COMMANDS-PROC is
  pr PROVE-COMMANDS-PROC .
  pr CAFE-PRETTY-PRINT .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  vars QIL QIL' QIL'' QIL1 QIL2 QIL3 QIL4 QILL QILA PL : QidList .
  vars T T' T'' T''' T1 T2 T3 TW TW' : Term .
  vars ODS ODS' ODS'' VDS : OpDeclSet .
  vars St St' St'' St''' : String .
  vars ME ME' : ModuleExpression .
  vars ScS ScS' : SentenceSet .
  vars EqS EqS' : EquationSet .
  vars TL TL' TL'' : TermList .
  var  SSDS : SubsortDeclSet .
  vars AtS AtS' : AttrSet .
  vars Q Q' GID QI : Qid .
  vars PS PS' : PTreeSet .
  vars RS RS' : RuleSet .
  var  COND : Condition .
  vars M M' FM : Module .
  var  RP : ResultPair .
  var  IL : ImportList .
  var  MAS : MembAxSet .
  var  Snt : Sentence .
  var  DB : Database .
  var  Ct : Constant .
  var  C : Condition .
  var  V : Variable .
  var  SS : SortSet .
  vars P P' : PTree .
  vars B B' : Bool .
  vars N N' : Nat .
  var  H : Header .
  var  L : Label .
  var  S : Sort .
  var  G : Goal .

***(%
\end{comment}
}

The function \verb"procGoalsCafe" is in charge of processing the initial goal
introduced by the user. It receives the current database, the module expression
standing for the module where the proof will take place, and the term containing
the goal sentences and returns a term of sort \verb"ProveResult", composed of
the updated database, the generated proof tree, and a list of quoted identifiers
propagating errors.
%
If the parsing of the sentences fails, we do not modify the database, the proof
tree is \verb"null", and an error message is sent:

{\codesize
\begin{verbatim}
%)

  op procGoalsCafe : Database ModuleExpression Term -> ProveResult .
  ceq procGoalsCafe(DB, ME, T) = << DB ; null ; ('\r 'ERROR: '\o
                                                 'bad 'goal 'specified) >>
   if sentErr(QIL) := parseSentenceCafe(T) .

***(%
\end{verbatim}
}

Otherwise, the \texttt{procGoalCmdCafe} is applied:

{\codesize
\begin{verbatim}
%)

  eq procGoalsCafe(DB, ME, T) = procGoalCmdCafe(DB, ME, parseSentenceCafe(T)) [owise] .

***(%
\end{verbatim}
}

The auxiliary function \verb"parseSentenceCafe" takes a term as argument and returns
a set of sentences, a special sort defined by the CITP to put together equations and
rules. Thus, we translate equations into equations and transitions into rules:

{\codesize
\begin{verbatim}
%)

  op parseSentenceCafe : Term -> SentenceSet .
  eq parseSentenceCafe('eq_=_;[T, T']) = (eq T = T' [none]) .
  eq parseSentenceCafe('ceq_=_if_;[T, T', T'']) =
                                (ceq T = T' if T'' = 'true.Bool [none]) .
  eq parseSentenceCafe('trans_=>_;[T, T']) = (rl T => T' [none]) .
  eq parseSentenceCafe('trns_=>_;[T, T']) = (rl T => T' [none]) .
  eq parseSentenceCafe('ctrans_=>_if_;[T, T', T'']) =
                                (crl T => T' if T'' = 'true.Bool [none]) .
  eq parseSentenceCafe('ctrns_=>_if_;[T, T', T'']) =
                                (crl T => T' if T'' = 'true.Bool [none]) .
  ceq parseSentenceCafe('__[T, T']) = Snt ScS
   if Snt := parseSentenceCafe(T) /\
      ScS := parseSentenceCafe(T') .
  eq parseSentenceCafe(Q[TL]) = sentErr('Bad 'goal)  [owise] .

***(%
\end{verbatim}
}

The parsing continues with \verb"procGoalCmdCafe". This function extracts the module
from the database and tries to solve the bubbles. If this parsing returns an error,
it is returned to the user, keeping the same database and building the \verb"null"
proof tree:

{\codesize
\begin{verbatim}
%)

    op procGoalCmdCafe : Database ModuleExpression SentenceSet -> ProveResult .
    ceq procGoalCmdCafe(DB, ME, ScS) = << DB ; null ; QIL >>
      if M := getFlatModule(ME, DB) /\
	  sentErr(QIL) := solveBubblesCafe(ScS, M, addInfoConds(M), false,
            getVars(ME, DB), DB) .
      
***(%
\end{verbatim}
}

If the sentences are successfully parsed, the new goal is created with them:

{\codesize
\begin{verbatim}
%)

  ceq procGoalCmdCafe(DB, ME, ScS) = setGoal(DB, M, ScS')
   if M := getFlatModule(ME, DB) /\
      ScS' := solveBubblesCafe(ScS, M, addInfoConds(M), false, getVars(ME, DB), DB) .

***(%
\end{verbatim}
}

Ohterwise, we return a module error:

{\codesize
\begin{verbatim}
%)

  eq procGoalCmdCafe(DB, ME, ScS) = << DB ; null ; ('\r 'ERROR: '\o 'Module 'error.) >> [owise] .

***(%
\end{verbatim}
}

The auxiliary function \verb"solveBubblesCafe" is in charge of building the terms
defined inside bubbles in equations and rules. Since all the equations for this function
are very similar, we only show how they are solved for an equation. In this case, we
only need to extend the set of operators standing for the variables, and use it with
the \verb"solveBubbles" function from Full Maude:

{\codesize
\begin{verbatim}
%)

  op solveBubblesCafe : SentenceSet Module Module Bool OpDeclSet Database
                        ~> SentenceSet .
  ceq solveBubblesCafe((eq 'bubble[T] = T' [none]), M, M', B, VDS, DB) =
                                  eq T1 = T2 [AtS]
   if QIL := downQidList(T) /\
      ODS := VDS opDeclSetFromQidList(QIL) /\
      eq T1 = T2 [AtS] . := solveBubbles(eq 'bubble[T] = T' [none] .,
                                         M, M', B, ODS, DB) .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  ceq solveBubblesCafe(eq 'bubble[T] = 'bubble[T'] [none], M, M', B, VDS, DB) = sentErr(QIL)
   if QIL := downQidList(T) /\
      ODS := VDS opDeclSetFromQidList(QIL) /\
      T'' := cafeEqAtS2maudeEqAts(T') /\
      equationError(QIL) := solveBubbles(eq 'bubble[T] = 'bubble[T''] [none] ., M, M', B, ODS, DB) .

  ceq solveBubblesCafe((ceq 'bubble[T] = 'bubble[T'] if 'bubble[T''] = 'true.Bool [none]), M, M', B, VDS, DB) =
                                  sentErr(QIL)
   if QIL := downQidList(T) /\
      ODS := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      equationError(QIL) := solveBubbles(ceq 'bubble[T] = 'bubble[T'] if 'bubble[T'''] = 'true.Bool [none] .,
                                         addOps(ODS, M), addOps(ODS, M'), B, ODS, DB) .

  ceq solveBubblesCafe((ceq 'bubble[T] = 'bubble[T'] if 'bubble[T''] = 'true.Bool [none]), M, M', B, VDS, DB) =
                                  ceq T1 = T2 if C [AtS]
	if QIL := downQidList(T) /\
	    ODS := VDS opDeclSetFromQidList(QIL) /\
	    T''' := cafeEqAtS2maudeEqAts(T'') /\
	    (ceq T1 = T2 if C [AtS] .) := solveBubbles((ceq 'bubble[T] = 'bubble[T'] if 'bubble[T'''] = 'true.Bool [none] .),
                                                  addOps(ODS, M), addOps(ODS, M'), B, ODS, DB) .

  *** rules
  ceq solveBubblesCafe(rl 'bubble[T] => 'bubble[T'] [none], M, M', B, VDS, DB) = sentErr(QIL)
   if QIL := downQidList(T) /\
      ODS := VDS opDeclSetFromQidList(QIL) /\
      T'' := cafeEqAtS2maudeEqAts(T') /\
      ruleError(QIL) := solveBubbles(rl 'bubble[T] => 'bubble[T''] [none] ., M, M', B, ODS, DB) .

  ceq solveBubblesCafe(rl 'bubble[T] => 'bubble[T'] [none], M, M', B, VDS, DB) =
                                  rl T1 => T2 [AtS]
   if QIL := downQidList(T) /\
      ODS := VDS opDeclSetFromQidList(QIL) /\
      T'' := cafeEqAtS2maudeEqAts(T') /\
      rl T1 => T2 [AtS] . := solveBubbles(rl 'bubble[T] => 'bubble[T''] [none] ., M, M', B, ODS, DB) .

  ceq solveBubblesCafe(crl 'bubble[T] => T' if 'bubble[T''] = 'true.Bool [none], M, M', B, VDS, DB) =
                                  sentErr(QIL)
   if QIL := downQidList(T) /\
      ODS := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      ruleError(QIL) := solveBubbles(crl 'bubble[T] => T' if 'bubble[T'''] = 'true.Bool [none] .,
                                     addOps(ODS, M), addOps(ODS, M'), B, ODS, DB) .

  ceq solveBubblesCafe(crl 'bubble[T] => T' if 'bubble[T''] = 'true.Bool [none], M, M', B, VDS, DB) =
                                  crl T1 => T2 if C [AtS]
   if QIL := downQidList(T) /\
      ODS := VDS opDeclSetFromQidList(QIL) /\
      T''' := cafeEqAtS2maudeEqAts(T'') /\
      crl T1 => T2 if C [AtS] . := solveBubbles(crl 'bubble[T] => T' if 'bubble[T'''] = 'true.Bool [none] .,
                                                addOps(ODS, M), addOps(ODS, M'), B, ODS, DB) .

***(%
\end{comment}
}

Moreover, we also define the equations for dealing with several sentences and with the
empty set of sentences (\verb"none"):

{\codesize
\begin{verbatim}
%)

  ceq solveBubblesCafe(Snt ScS, M, M', B, VDS, DB) =
                                  solveBubblesCafe(Snt, M, M', B, VDS, DB)
                                  solveBubblesCafe(ScS, M, M', B, VDS, DB)
   if ScS =/= none .
  eq solveBubblesCafe(none, M, M', B, VDS, DB) = none .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  op labels2metadataAtS : AttrSet -> AttrSet .
  eq labels2metadataAtS(label(Q) AtS) = label(Q) metadata("#label-" + string(Q)) AtS .
  eq labels2metadataAtS(AtS) = AtS [owise] .

***(%
\end{comment}
}

%  ***************************************
%  ************ PROCESS LEMMA ************
%  ***************************************

The function \verb"procInitLemmaCafe" just applies the general
function \verb"procInitLemma" from the CITP:

{\codesize
\begin{verbatim}
%)

  op procInitLemmaCafe : Database PTree Qid QidList -> ProveResult .
  eq procInitLemmaCafe(DB, P, Q, QIL) = procInitLemma(DB, P, Q, QIL) .

  op procInitLemmaCafe : Database PTree Equation QidList -> ProveResult .
  eq procInitLemmaCafe(DB, P, EqS, QIL) = procInitLemma(DB, P, EqS, QIL) .

  op procInitLemmaCafe : Database PTree Rule QidList -> ProveResult .
  eq procInitLemmaCafe(DB, P, RS, QIL) = procInitLemma(DB, P, RS, QIL) .

***(%
\end{verbatim}
}

We also define several printing functions to print sentences and goals in
CafeOBJ style. We present some of them:
\begin{itemize}
\item
Printing the empty set of sentences returns \verb"nil":

{\codesize
\begin{verbatim}
%)

  op printSentencesCafe : Module SentenceSet -> QidList .
  eq printSentencesCafe(M, none) = nil .

***(%
\end{verbatim}
}

\item
Equations are printed by printing each side, the labels and the attributes:

{\codesize
\begin{verbatim}
%)

  ceq printSentencesCafe(M, (eq T = T' [AtS]) ScS) =
                  ('\n '\t '\s '\s '\g 'eq QILL '\s '\o QIL1
                   '\n '\t '\s '\s '\s '\s '\g '= '\s '\o QIL2
                   '\s QIL3 '.
                   printSentencesCafe(M, ScS))
   if QIL1 := eMetaPrettyPrint(M, T) /\
      QIL2 := eMetaPrettyPrint(M, T') /\
      QIL3 := printCafeAtS(AtS) /\
      QILL := printLabel(AtS) .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  ceq printSentencesCafe(M, (ceq T = T' if C [AtS]) ScS) =
                  ('\n '\t '\s '\s '\g 'ceq QILL '\s '\o QIL1
                   '\n '\t '\s '\s '\s '\s '\g '= '\s '\o QIL2
                   '\n '\t '\s '\s '\s '\s '\g 'if '\o '\s QIL3
                   '\s QIL4 '.
                   printSentencesCafe(M, ScS))
   if QIL1 := eMetaPrettyPrint(M, T) /\
      QIL2 := eMetaPrettyPrint(M, T') /\
      QIL3 := eMetaPrettyPrint(M, C) /\
      QIL4 := printCafeAtS(AtS) /\
      QILL := printLabel(AtS) .

  ceq printSentencesCafe(M, (rl T => T' [AtS]) ScS) =
                  ('\n '\t '\s '\s '\g 'trans QILL '\s '\o QIL1
                   '\n '\t '\s '\s '\s '\s '\g '=> '\s '\o QIL2
                   '\s QIL3 '.
                   printSentencesCafe(M, ScS))
   if QIL1 := eMetaPrettyPrint(M, T) /\
      QIL2 := eMetaPrettyPrint(M, T') /\
      QIL3 := printCafeAtS(AtS) /\
      QILL := printLabel(AtS) .

  ceq printSentencesCafe(M, (crl T => T' if C [AtS]) ScS) =
                  ('\n '\t '\s '\s '\g 'ctrans QILL '\s '\o QIL1
                   '\n '\t '\s '\s '\s '\s '\g '=> '\s '\o QIL2
                   '\n '\t '\s '\s '\s '\s '\g 'if '\o '\s QIL3
                   '\s QIL4 '.
                   printSentencesCafe(M, ScS))
   if QIL1 := eMetaPrettyPrint(M, T) /\
      QIL2 := eMetaPrettyPrint(M, T') /\
      QIL3 := eMetaPrettyPrint(M, C) /\
      QIL4 := printCafeAtS(AtS) /\
      QILL := printLabel(AtS) .

***(%
\end{comment}
}

\item
In some cases the prover adds extra sentences, that we want to print
in a special way. If the option asking to print the module is set to \verb"false"
nothing is printed, but in other case we print these extra sentences:

{\codesize
\begin{verbatim}
%)

  op printExtraStmnts : Module Bool -> QidList .
  eq printExtraStmnts(FM, false) = nil .
  eq printExtraStmnts(FM, true) =
            printAddedEqs(FM, getAddedEqs(getEqs(FM)))
            printAddedRls(FM, getAddedRls(getRls(FM)))
            printAddedEqLemmas(FM, getEqLemmas(getEqs(FM)))
            printAddedRlLemmas(FM, getRlLemmas(getRls(FM))) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  op printAddedEqs : Module EquationSet -> QidList .
  eq printAddedEqs(M, none) = nil .
  ceq printAddedEqs(M, eq T = T' [AtS] . EqS) =
                  ('\n '\t '\s '\s '\g 'eq QILL '\s '\o QIL1
                   '\n '\t '\s '\s '\s '\s '\g '= '\s '\o QIL2
                   '\s QIL3 '. '\b
                   ' '--> 'Equation 'added 'by 'the 'prover. '\o '\n
                   printAddedEqs(M, EqS))
   if QIL1 := eMetaPrettyPrint(M, T) /\
      QIL2 := eMetaPrettyPrint(M, T') /\
      QIL3 := printCafeAtS(AtS) /\
      QILL := printLabel(AtS) .

  ceq printAddedEqs(M, ceq T = T' if C [AtS] . EqS) =
                  ('\n '\t '\s '\s '\g 'ceq QILL '\s '\o QIL1
                   '\n '\t '\s '\s '\s '\s '\g '= '\s '\o QIL2
                   '\n '\t '\s '\s '\s '\s '\g 'if '\o '\s QIL3
                   '\s QIL4 '. '\b
                   ' '--> 'Equation 'added 'by 'the 'prover. '\o '\n
                   printAddedEqs(M, EqS))
   if QIL1 := eMetaPrettyPrint(M, T) /\
      QIL2 := eMetaPrettyPrint(M, T') /\
      QIL3 := eMetaPrettyPrint(M, C) /\
      QIL4 := printCafeAtS(AtS) /\
      QILL := printLabel(AtS) .

  op printAddedRls : Module RuleSet -> QidList .
  eq printAddedRls(M, none) = nil .
  ceq printAddedRls(M, rl T => T' [AtS] . RS) =
                  ('\n '\t '\s '\s '\g 'trans QILL '\s '\o QIL1
                   '\n '\t '\s '\s '\s '\s '\g '=> '\s '\o QIL2
                   '\s QIL3 '. '\b
                   ' '--> 'Transition 'added 'by 'the 'prover. '\o '\n
                   printAddedRls(M, RS))
   if QIL1 := eMetaPrettyPrint(M, T) /\
      QIL2 := eMetaPrettyPrint(M, T') /\
      QIL3 := printCafeAtS(AtS) /\
      QILL := printLabel(AtS) .

  ceq printAddedRls(M, crl T => T' if C [AtS] . RS) =
                  ('\n '\t '\s '\s '\g 'ctrans QILL '\s '\o QIL1
                   '\n '\t '\s '\s '\s '\s '\g '=> '\s '\o QIL2
                   '\n '\t '\s '\s '\s '\s '\g 'if '\o '\s QIL3
                   '\s QIL4 '. '\b
                   ' '--> 'Transition 'added 'by 'the 'prover. '\o '\n
                   printAddedRls(M, RS))
   if QIL1 := eMetaPrettyPrint(M, T) /\
      QIL2 := eMetaPrettyPrint(M, T') /\
      QIL3 := eMetaPrettyPrint(M, C) /\
      QIL4 := printCafeAtS(AtS) /\
      QILL := printLabel(AtS) .

  op printAddedEqLemmas : Module EquationSet -> QidList .
  eq printAddedEqLemmas(M, none) = nil .
  ceq printAddedEqLemmas(M, eq T = T' [AtS] . EqS) =
                  ('\n '\t '\s '\s '\g 'eq QILL '\s '\o QIL1
                   '\n '\t '\s '\s '\s '\s '\g '= '\s '\o QIL2
                   '\s QIL3 '. '\b
                   ' '--> 'Current 'instantiation 'of getLabel(AtS) '\o '\n
                   printAddedEqLemmas(M, EqS))
   if QIL1 := eMetaPrettyPrint(M, T) /\
      QIL2 := eMetaPrettyPrint(M, T') /\
      QIL3 := printCafeAtS(AtS) /\
      QILL := printLabel(AtS) .
  ceq printAddedEqLemmas(M, ceq T = T' if C [AtS] . EqS) =
                  ('\n '\t '\s '\s '\g 'ceq QILL '\s '\o QIL1
                   '\n '\t '\s '\s '\s '\s '\g '= '\s '\o QIL2
                   '\n '\t '\s '\s '\s '\s '\g 'if '\o '\s QIL3
                   '\s QIL4 '. '\b
                   ' '--> 'Current 'instantiation 'of getLabel(AtS) '\o '\n
                   printAddedEqLemmas(M, EqS))
   if QIL1 := eMetaPrettyPrint(M, T) /\
      QIL2 := eMetaPrettyPrint(M, T') /\
      QIL3 := eMetaPrettyPrint(M, C) /\
      QIL4 := printCafeAtS(AtS) /\
      QILL := printLabel(AtS) .

***(%
\end{comment}
}

\item
When printing rule lemmas, besides printing both sides, the label, and
the attributes, we show an extra line indicating that it is a lemma added
by the tool. Note that we print rules using CafeOBJ syntax for transitions:

{\codesize
\begin{verbatim}
%)

  op printAddedRlLemmas : Module RuleSet -> QidList .
  ceq printAddedRlLemmas(M, rl T => T' [AtS] . RS) =
                  ('\n '\t '\s '\s '\g 'trans QILL '\s '\o QIL1
                   '\n '\t '\s '\s '\s '\s '\g '=> '\s '\o QIL2
                   '\s QIL3 '. '\b
                   ' '--> 'Current 'instantiation 'of getLabel(AtS) '\o '\n
                   printAddedRlLemmas(M, RS))
   if QIL1 := eMetaPrettyPrint(M, T) /\
      QIL2 := eMetaPrettyPrint(M, T') /\
      QIL3 := printCafeAtS(AtS) /\
      QILL := printLabel(AtS) .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  ceq printAddedRlLemmas(M, crl T => T' if C [AtS] . RS) =
                  ('\n '\t '\s '\s '\g 'ctrans QILL '\s '\o QIL1
                   '\n '\t '\s '\s '\s '\s '\g '=> '\s '\o QIL2
                   '\n '\t '\s '\s '\s '\s '\g 'if '\o '\s QIL3
                   '\s QIL4 '. '\b
                   ' '--> 'Current 'instantiation 'of getLabel(AtS) '\o '\n
                   printAddedRlLemmas(M, RS))
   if QIL1 := eMetaPrettyPrint(M, T) /\
      QIL2 := eMetaPrettyPrint(M, T') /\
      QIL3 := eMetaPrettyPrint(M, C) /\
      QIL4 := printCafeAtS(AtS) /\
      QILL := printLabel(AtS) .
  eq printAddedRlLemmas(M, none) = nil .

  op getLabel : AttrSet ~> Qid .
  eq getLabel(label(Q) AtS) = Q .

***(%
\end{comment}
}

\item
Modules are printed by combining the functions for extra statements shown above
and the printing functions from Section~\ref{subsec:pretty}:

{\codesize
\begin{verbatim}
%)

  op printCafeModuleGoal : Term Module Database Bool -> QidList .
  ceq printCafeModuleGoal('cmod!_`{_`}[T, T'], M, DB, B) =
              '\n 'mod! printCafeName(DB, M, T) '`{
              '\n first(printCafeBody*(paramSortsMap(T', PL), M, DB, none, PL))
              printExtraStmnts(M, B)
              '\n '`}
   if PL := paramNames(T) .
  ceq printCafeModuleGoal('cmod*_`{_`}[T, T'], M, DB, B) =
              '\n 'mod* printCafeName(DB, M, T) '`{
              '\n first(printCafeBody*(paramSortsMap(T', PL), M, DB, none, PL))
              printExtraStmnts(M, B)
              '\n '`}
   if PL := paramNames(T) .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  op prettyPrintProofTreeAuxCafe : PTreeSet  Database Bool Term -> QidList .
  eq prettyPrintProofTreeAuxCafe(empty, DB, B, T) = nil .
  eq prettyPrintProofTreeAuxCafe(P PS, DB, B, T) =
                          prettyPrintProofTreeCafe(P, DB, B, T)
                          prettyPrintProofTreeAuxCafe(PS, DB, B, T) .

***(%
\end{comment}
}

\item
The proof tree is printed by printing the current goal:

{\codesize
\begin{verbatim}
%)

  op prettyPrintProofTreeCafe : PTree Database Bool Term -> QidList .
  eq prettyPrintProofTreeCafe([ Q ; G ; B' ; PS' ], DB, B, T) =
  '============================ '\s 'GOAL Q '============================ '\n
  (prettyPrintGoalCafe(G, DB, B, T)  '\b  (if B'
                                        then 'proved
                                        else 'unproved
                                        fi ) '\o '\n ) .

***(%
\end{verbatim}
}

\item
Finally, to print the goal we first check whether the whole module must be displayed.
In this case we print it, otherwise only the extra statements are shown. Finally, the
sentences composing the goal are shown:

{\codesize
\begin{verbatim}
%)

  op prettyPrintGoalCafe : Goal Database Bool Term -> QidList .
  eq prettyPrintGoalCafe(< FM, ScS, L >, DB, B, T) =
     ('< (if B then printCafeModuleGoal(T, FM, DB, true)
          else ('Module '\g getName(FM) '\o 'is 'concealed '\n '... '\n
                printAddedEqs(FM, getEqLemmas(getEqs(FM)) getAddedEqs(getEqs(FM)))
                printAddedRls(FM, getRlLemmas(getRls(FM)) getAddedRls(getRls(FM)))
               '\b 'end '\o '\n) fi ) '`, printSentencesCafe(FM, ScS) '>  '\n ) .
  eq prettyPrintGoalCafe(G, DB, B, T) = ('Bad 'GOAL) [owise]  .
endm

***(%
\end{verbatim}
}

\end{itemize}

The module \verb"CAFE-UI" is in charge of implementing the rules required to
execute the CITP commands for CafeOBJ specifications. We will only present the
main rules and some examples of error handling:

{\codesize
\begin{verbatim}
%)

mod CAFE-UI is
  pr CAFE2MAUDE-DATABASE-HANDLING .
  pr CAFE-CITP-COMMANDS-PROC .
  inc THM-DATABASE-HANDLING .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  var  X@Database : CafeDatabaseClass .
  vars ME ME' ME'' : ModuleExpression .
  vars DB DB' DB'' : Database .
  vars CPS CPS' : CritPairSet .
  var  Atts : AttributeSet .
  vars QIL QIL' : QidList .
  vars T T' T'' T1 : Term .
  vars TL TL' : TermList .
  vars P P' P'' : PTree .
  var  ODS : OpDeclSet .
  var  CMD : Constant .
  vars M M' : Module .
  var  PS : PTreeSet .
  var  RS : RuleSet .
  var CP : CritPair .
  vars Q GID : Qid .
  vars G G' : Goal .
  var  R : Rule .
  var  B : Bool .
  var  N : Nat .
  var  O : Oid .

***(%
\end{comment}
}

This module defines a new attribute \verb"originalCafeModule" which is in charge of
storing the original CafeOBJ specification used for the current goal. It is necessary
to store it because the default module can be modified when introducing new modules
during a proving session:

{\codesize
\begin{verbatim}
%)

  op originalCafeModule :_ : TermList -> Attribute [ctor] .

***(%
\end{verbatim}
}

The \verb"goal-Mod-cafe" rule processes a goal introduced by the user. It parses the
module expression and looks for the module in the database. Once it is found, we
check that it is a CafeOBJ specification with \verb"isCafeMod?". Then the sentences
are parsed with the function \verb"procGoalsCafe" shown above and printed with
\verb"prettyPrintProofTreeCafe". It also sets the \texttt{originalCafeModule}
attribute to the selected module.
%
Note that we use an attribute \verb"language" with value \texttt{cafeobj}. It will be
described in Section~\ref{subsec:citp:modifs}, but its behavior is clear: state that
this rule is only applied if CafeOBJ is the selected specification language.

%  ************************************************************
%  ************************* NEW GOAL *************************
%  ************************************************************

{\codesize
\begin{verbatim}
%)

  crl [goal-Mod-cafe] :
      < O : X@Database | db : DB, input : ('goal_|-_[T, T']), output : nil,
                         default : ME, pTree : P, currentGoal : GID, showMod : B,
                         language : cafeobj, originalCafeModule : TL, Atts >
   => < O : X@Database | db : DB, input : nilTermList,
                         output : (if QIL == 'OK
                                   then QIL'
                                   else QIL
                                   fi), default : ME, pTree : P',
                         currentGoal : getDefaultGoalIndex(P'), showMod : B,
                         language : cafeobj, originalCafeModule : T1, Atts >
   if ME' := parseModExp(T) /\
      < DB' ; ME'' > := evalModExp(ME', DB) /\
      < T1 ; ODS ; M > := getTermModule(ME'', DB') /\
      isCafeMod?(T1) /\
      << DB'' ; P' ; QIL >> := procGoalsCafe(DB', ME'', T') /\
      QIL' := prettyPrintProofTreeCafe(P', DB', B, T1) '\n '\g
              'INFO: '\o 'an 'initial 'goal 'generated! .

***(%
\end{verbatim}
}

\noindent
where the function \verb"isCafeMod?" just checks the operator at the top of the term:

{\codesize
\begin{verbatim}
%)

  op isCafeMod? : Term -> Bool .
  eq isCafeMod?('cmod!_`{_`}[TL]) = true .
  eq isCafeMod?('cmod*_`{_`}[TL]) = true .
  eq isCafeMod?(T) = false [owise] .

***(%
\end{verbatim}
}

When the selected module does not correspond to a CafeOBJ specification, we use the
rule \texttt{goal-Mod-cafe-error-module-type} to display an error message:

{\codesize
\begin{verbatim}
%)

  crl [goal-Mod-cafe-error-module-type] :
      < O : X@Database | db : DB, input : ('goal_|-_[T, T']), output : nil,
                         language : cafeobj, Atts >
   => < O : X@Database | db : DB, input : nilTermList,
                         output : ('\r 'WARNING: '\o 'the 'selected 'module 'is 'not
                                   'a 'CafeOBJ 'specification.),
                         language : cafeobj, Atts >
   if ME' := parseModExp(T) /\
      < DB' ; ME'' > := evalModExp(ME', DB) /\
      < null ; ODS ; M > := getTermModule(ME'', DB') .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  crl [goal-Mod-cafe-error-module-type] :
      < O : X@Database | db : DB, input : ('goal_|-_[T, T']), output : nil,
                         language : cafeobj, Atts >
   => < O : X@Database | db : DB, input : nilTermList,
                         output : ('\n '\r 'WARNING: '\o 'the 'selected 'module 'is 'not
                                   'a 'CafeOBJ 'specification. '\n),
                         language : cafeobj, Atts >
   if ME' := parseModExp(T) /\
      < DB' ; ME'' > := evalModExp(ME', DB) /\
      < T1 ; ODS ; M > := getTermModule(ME'', DB') /\
      not isCafeMod?(T1) .

  crl [goal-Mod-cafe-error-no-module] :
      < O : X@Database | db : DB, input : ('goal_|-_[T, T']), output : nil,
                         language : cafeobj, Atts >
   => < O : X@Database | db : DB, input : nilTermList,
                         output : ('\n '\r 'WARNING: '\o 'the 'selected 'module 'is 'not
                                   'in 'the 'database. '\n),
                         language : cafeobj, Atts >
   if ME' := parseModExp(T) /\
      < DB' ; ME'' > := evalModExp(ME', DB) /\
      not unitInDb(ME'', DB') .

***(%
\end{comment}
}

The \verb"showGoal-cafe" rule displays the current goal by using the
\texttt{prettyPrintProofTreeCafe} function:

%  *************************************************************
%  ************************* SHOW GOAL *************************
%  *************************************************************

{\codesize
\begin{verbatim}
%)

  rl [showGoal-cafe] :
     < O : X@Database | db : DB, input : ('show`goal`..@Command@),
                        output : nil , pTree : P, currentGoal : GID,
                        showMod : B, language : cafeobj,
                        originalCafeModule : T, Atts >
  => < O : X@Database | db : DB, input : nilTermList, currentGoal : GID,
                        output : if GID =/= 'nil
                                 then
                                   prettyPrintProofTreeCafe(getPTree(P, GID), DB, B, T)
                                 else
                                   ('\r 'WARNING: '\o 'no 'goals 'to 'show!)
                                 fi, pTree : P, showMod : B,
                        language : cafeobj, originalCafeModule : T, Atts > .

***(%
\end{verbatim}
}

The \verb"showGoal-id-cafe" rule displays the goal selected by the user by applying the
function \texttt{prettyPrintProofTreeCafe}:

%  ****************************************************************
%  ************************* SHOW GOAL ID *************************
%  ****************************************************************

{\codesize
\begin{verbatim}
%)

  crl [showGoal-id-cafe] :
      < O : X@Database | db : DB, input : ('show`goal_.['token[T]]),
                         output : nil, pTree : P, currentGoal : GID,
                         showMod : B, language : cafeobj,
                         originalCafeModule : T', Atts >
   => < O : X@Database | db : DB, input : nilTermList, currentGoal : downQidList(T),
                         output : prettyPrintProofTreeCafe(P', DB, B, T'),
                         pTree : P, showMod : B, language : cafeobj,
                         originalCafeModule : T', Atts >
   if P' := getPTree(P, downQidList(T)) .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  crl [showGoal-id-cafe-error] :
      < O : X@Database | db : DB, input : ('show`goal_.['token[T]]),
                         output : nil, pTree : P, currentGoal : GID,
                         language : cafeobj, Atts >
   => < O : X@Database | db : DB, input : nilTermList, output : ('\r 'WARNING: '\o QIL),
                         pTree : P, currentGoal : GID, language : cafeobj, Atts >
   if ptreeErr(QIL) := getPTree(P, downQidList(T)) .

***(%
\end{comment}
}

%  **********************************************************************
%  ************************* SHOW UNPROVED GOAL *************************
%  **********************************************************************

{\codesize
\begin{comment}
%)

  crl [showUnprovedGoals-cafe] :
      < O : X@Database | db : DB, input : ('show`unproved`goals`..@Command@),
                         output : nil, pTree : P, currentGoal : GID, showMod : B,
                         language : cafeobj, originalCafeModule : T,
       Atts >
   => < O : X@Database | db : DB, input : nilTermList,
                         output : if PS =/= empty
                                  then (prettyPrintProofTreeAuxCafe(PS, DB, B, T)
                                        '\n '\g 'INFO: '\o (qid(string(num(PS), 10))
                                        'goal '`( 's '`) ' 'unproved! '\n '\g 'INFO:
                                        '\o 'Next 'goal 'to 'be 'proved 'is '\r
                                        getDefaultGoalIndex(PS) '\o))
                                  else ('\r 'WARNING: 'no 'goals!)
                                  fi, pTree : P, currentGoal : getDefaultGoalIndex(PS),
                         showMod : B, language : cafeobj, originalCafeModule : T, Atts >
   if PS := unprovedGoals(P) .

***(%
\end{comment}
}

The \texttt{applyRule-cafe-not-finish} rule applies the given rule to the default goal.
It first checks whether it is a valid rule. If true, then it is applied to the current
goal and the new set of goals is displayed:

%  **************************************************************
%  ************************* APPLY RULE *************************
%  **************************************************************

{\codesize
\begin{verbatim}
%)

  crl [applyRule-cafe-not-finished] :
      < O : X@Database | db : DB, input : ('apply_.['bubble[T]]), output : nil,
                         pTree : P, currentGoal : GID, tactic : N, showMod : B,
                         language : cafeobj, originalCafeModule : T', Atts >
   => < O : X@Database | db : DB, input   : nilTermList,
                         output  : ('~~~~~~~~~~~~~~~~~~~~~~~ '\s '\s '\s '\s '\s '\s
                                    'Generated 'GOALS '\s '\s '\s '\s '\s '\s
                                    '~~~~~~~~~~~~~~~~~~~~~~~ '\n '\n
                                    prettyPrintProofTreeAuxCafe((P'' PS), DB, B, T')
                                    '\n '\g 'INFO: '\o (qid(string(num(P'' PS), 10))
                                    'goal`(s`) 'generated! '\n '\g 'INFO: '\o 'Next
                                    'goal 'to 'be 'proved 'is '\r
                                    getDefaultGoalIndex(P'') '\o )),
                         pTree : addPTreeSet(P, GID, (P'' PS)),
                         currentGoal : getDefaultGoalIndex(P''), tactic : N,
                         showMod : B, language : cafeobj, originalCafeModule : T',
                         Atts >
   if isValidRule(downQidList(T)) /\
      P' := getPTree(P, GID) /\
      (P'' PS) := applyRules(downQidList(T), P') .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  crl [applyRule-cafe-finished] :
      < O : X@Database | input : ('apply_.['bubble[T]]), output : nil, pTree : P,
                         currentGoal : GID, language : cafeobj, Atts >
   => < O : X@Database | input : nilTermList,
                         output : ('\g 'INFO: '\o 'goal GID 'is 'proved '\n '\g
                                   'INFO: '\o (if num(PS) == 0
                                               then ('PROOF 'COMPLETED!)
                                               else ('\r qid(string(num(PS), 10)) '\o
                                                     'goal '`( 's '`) ' 'remained '\n
                                                     '\g 'INFO: '\o 'Next 'goal 'to
                                                     'be 'proved 'is '\r
                                                     getDefaultGoalIndex(PS) '\o)
                                                     fi )),
                         pTree : P'', currentGoal : getDefaultGoalIndex(PS),
                         language : cafeobj, Atts >
   if isValidRule(downQidList(T)) /\
      P' := getPTree(P, GID) /\
      empty := applyRules(downQidList(T), P') /\
      P'' := setGoalProved(P, GID)  /\
      PS := unprovedGoals(P'') .

  crl [applyRule-cafe-error-tree] :
      < O : X@Database | input : ('apply_.['bubble[T]]), output : nil, pTree : P,
                         currentGoal : GID, language : cafeobj, Atts >
   => < O : X@Database | input : nilTermList, output : ('\r 'ERROR: '\o QIL),
                         pTree : P, currentGoal : GID, language : cafeobj, Atts >
   if isValidRule(downQidList(T)) /\
      ptreeErr(QIL) := getPTree(P, GID) .

  crl [applyRule-cafe-error-not-valid] :
      < O : X@Database | input : ('apply_.['bubble[T]]), output : nil, pTree : P,
                         currentGoal : GID, language : cafeobj, Atts >
   => < O : X@Database | input : nilTermList,
                         output : ('\r 'ERROR: '\o getInvalidTac(downQidList(T)) 'is
                                   'not 'a 'valid 'proof 'rule '\n 'Valid 'proof
                                   'rules: '\n ruleList), pTree : P,
                         currentGoal : GID,  language : cafeobj, Atts >
   if not isValidRule(downQidList(T)) .

  crl [applyRule-cafe-error-apply] :
      < O : X@Database | input : ('apply_.['bubble[T]]), output : nil ,
                         pTree : P, currentGoal : GID, language : cafeobj, Atts >
   => < O : X@Database | input : nilTermList, output : ('\r 'ERROR: '\o QIL ),
                         pTree : P, currentGoal : GID, language : cafeobj, Atts >
   if isValidRule(downQidList(T)) /\
      P' := getPTree(P,GID) /\
      applyError(QIL) := applyRules(downQidList(T), P') .

***(%
\end{comment}
}

% The \texttt{init-lemma-cafe} rule initializes a rule or transition by
% using the substitution given in the command:

%  **************************************************************
%  ************************* INIT LEMMA *************************
%  **************************************************************

{\codesize
\begin{comment}
%)

  crl [init-lemma-label-cafe] :
      < O : X@Database | db : DB, input : ('init_by_.['token[T],T']),
                         output : nil, pTree : P, currentGoal : GID,
                         language : cafeobj, Atts >
   =>  < O : X@Database | db : DB', input : if QIL == 'OK
                                            then 'show`goal`..@Command@
                                            else nilTermList
                                            fi,
                          output : if QIL == 'OK
                                   then '\g 'INFO: '\o 'Lemma downQidList(T)
                                        'is 'initialized! '\n
                                   else QIL
                                   fi,
                          pTree : if QIL == 'OK
                                  then replacePTree(P, GID, P')
                                  else P
                                  fi, currentGoal : GID, language : cafeobj, Atts >
   if GID =/= 'nil /\
      << DB' ; P' ; QIL >> := procInitLemma(DB, getPTree(P,GID), downQidList(T),T') .

  crl [init-lemma-eq-cafe] :
      < O : X@Database | db : DB, input : ('init_by_.[Q[TL],T']), output : nil,
                         pTree : P, currentGoal : GID, language : cafeobj, Atts >
   => < O : X@Database | db : DB', input : (if QIL == 'OK
                                            then 'show`goal`..@Command@
                                            else nilTermList
                                            fi),
                         output : (if QIL == 'OK
                                   then ('\g 'INFO: '\o 'Lemma 'is 'initialized! '\n)
                                   else QIL
                                   fi),
                         pTree : (if QIL == 'OK
                                  then replacePTree(P,GID,P')
                                  else P
                                  fi ), currentGoal : GID, language : cafeobj, Atts >
   if (Q == 'eq_=_. or-else Q == 'ceq_=_if_. or-else Q == 'cq_=_if_.) /\
      GID =/= 'nil /\
      << DB' ; P' ; QIL >> := procInitLemma(DB,getPTree(P,GID),parseEq(Q[TL]),
                                                T') .

  crl [init-lemma-rl-cafe] :
      < O : X@Database | db : DB, input : ('init_by_.[Q[TL],T']),
                         output : nil, pTree : P, currentGoal : GID,
                         language : cafeobj, Atts >
   => < O : X@Database | db : DB', input : (if QIL == 'OK
                                            then 'show`goal`..@Command@ else
                                            nilTermList
                                            fi),
                         output : (if QIL == 'OK
                                   then ('\g 'INFO: '\o 'Lemma 'is 'initialized! '\n)
                                   else QIL
                                   fi),
                         pTree : (if QIL == 'OK
                                  then replacePTree(P,GID,P')
                                  else P
                                  fi), currentGoal : GID, language : cafeobj, Atts >
   if (Q == 'trans_=>_. or-else Q == 'trns_=>_. or-else
       Q == 'ctrans_=>_if_. or-else Q == 'ctrns_=>_if_.) /\
      GID =/= 'nil /\
      << DB' ; P' ; QIL >> := procInitLemma(DB, getPTree(P,GID), parseTrans(Q[TL]),
                                                T') .


  op parseTrans : Term ~> RuleSet .
  eq parseTrans('trans_=>_.[T, T']) = rl T => T' [none] . .
  eq parseTrans('trns_=>_.[T, T']) = rl T => T' [none] . .
  eq parseTrans('ctrans_=>_if_.[T, T', T'']) =
                          crl T => T' if T'' = 'true.Bool [none] . .
  eq parseTrans('ctrns_=>_if_.[T, T', T'']) =
                          crl T => T' if T'' = 'true.Bool [none] . .
  ceq parseTrans('__[T,T']) = R RS
   if R := parseTrans(T) /\ RS := parseTrans(T') .
  eq parseTrans('__[T,T']) = ruleError('Bad 'goal)  [owise] .


  crl [init-lemma-cp] :
      < O : X@Database | db : DB, input : ('init_by_.['token[T],T']),
                         output : nil , pTree : P, currentGoal : GID, critPair : none,
                         language : cafeobj, Atts >
   => < O : X@Database | db : DB', input : nilTermList,
                         output : ('\g 'INFO: '\o 'Non-confluence 'occurred 'after
                                   'initializing 'lemma downQidList(T) '! '\n QIL '\n
                                   '\n '\g 'INFO '\o 'use 'command '\r 'discard
                                   'critical 'pair '\o 'to 'make 'module 'confluent
                                   '\n 'or 'command '\r 'ignore '\o 'to 'ignore 'the
                                   'non-confluence '\n) ,
                         pTree : replacePTree(P, GID, P'), critPair : CPS,
                         currentGoal : GID, language : cafeobj, Atts >
   if GID =/= 'nil /\
      << DB' ; P' ; QIL ; CPS >> := procInitLemma(DB, getPTree(P, GID),
                                                  downQidList(T), T') .

  rl [init-lemmar-noGoal-cafe] :
     < O : X@Database | input : ('init_by_.['token[T],T']), output : nil,
                        currentGoal : 'nil, language : cafeobj, Atts >
  => < O : X@Database | input : nilTermList,
                        output : ('\r 'ERROR: '\o 'No 'goal 'is 'specified!) ,
                        currentGoal : 'nil, language : cafeobj, Atts > .

***(%
\end{comment}
}

% We define next the rules for dealing with critical pairs:

%  ******************************************************************
%  ************************* CRITICAL PAIRS *************************
%  ******************************************************************

{\codesize
\begin{comment}
%)

  crl [critical-pair-cafe] :
      < O : X@Database | db : DB, input : ('discard`critical`pair`..@Command@),
                         output : nil, critPair : (CP CPS), pTree : P,
                         currentGoal : GID, answerMode : B, language : cafeobj, Atts >
   => < O : X@Database | db : DB, input : nilTermList,
                         output : (eMetaPrettyPrint(M,'=>, CP) '\n '\g 'Question:
                                   '\o 'add 'as '\r 'equation '\o 'or '\r
                                   'transition '\o '? ),
                         critPair : (CP CPS), currentGoal : GID, answerMode : true,
                         pTree : P, language : cafeobj, Atts >
   if M := getModuleinGoal(getGoalinTree(P,GID)) .

  crl [critical-pair-cafe-eq] :
      < O : X@Database | db : DB, input : ('equation`..@Command@), output : nil,
                         critPair : (CP CPS), pTree : P, currentGoal : GID,
                         answerMode : true, showMod : B, language : cafeobj,
                         originalCafeModule : T, Atts >
   => < O : X@Database | db : DB, input : if CPS == none
                                          then nilTermList
                                          else 'discard`critical`pair`..@Command@
                                          fi,
                         critPair : CPS, output : prettyPrintGoalCafe(G', DB, B, T),
                         answerMode : (CPS =/= none), pTree : setGoalinTree(P,GID,G'),
                         currentGoal : GID, showMod : B, language : cafeobj,
                         originalCafeModule : T, Atts >
   if GID =/= 'nil /\
      G := getGoalinTree(P, GID) /\
      M := addEqs(eq(CP, true), getModuleinGoal(G)) /\
      G' := setModuleinGoal(G, M) .

  crl [critical-pair-cafe-back-eq] :
      < O : X@Database | db : DB, input : ('backward`equation`..@Command@),
                         output : nil, critPair : (CP CPS), pTree : P,
                         currentGoal : GID, answerMode : true, showMod : B,
                         language : cafeobj, originalCafeModule : T, Atts >
   => < O : X@Database | db : DB, input : if CPS == none
                                          then nilTermList
                                          else 'discard`critical`pair`..@Command@
                                          fi,
                         output : if CPS == none
                                  then ('\n '\g 'INFO: '\o 'All 'critical 'pairs
                                        'are 'discarded '\n '\n
                                        prettyPrintGoalCafe(G', DB, B, T))
                                  else nil
                                  fi,
                         critPair : CPS, answerMode : (CPS =/= none),
                         pTree : setGoalinTree(P,GID,G'), currentGoal : GID,
                         showMod : B, language : cafeobj, originalCafeModule : T, Atts >
   if GID =/= 'nil /\
      G := getGoalinTree(P, GID) /\
      M := addEqs(eq(CP, false), getModuleinGoal(G)) /\
      G' := setModuleinGoal(G, M) .


  crl [critical-pair-cafe-trans] :
      < O : X@Database | db : DB, input : ('transition`..@Command@), output : nil,
                         critPair : (CP CPS), pTree : P, currentGoal : GID,
                         answerMode : true, showMod : B, language : cafeobj,
                         originalCafeModule : T, Atts >
   => < O : X@Database | db : DB, input : if CPS == none
                                          then nilTermList
                                          else 'discard`critical`pair`..@Command@
                                          fi,
                         output : if CPS == none
                                  then ('\n '\g 'INFO: '\o 'All 'critical 'pairs
                                        'are 'discarded '\n '\n
                                        prettyPrintGoalCafe(G', DB, B, T))
                                  else nil fi, critPair : CPS,
                         answerMode : (CPS =/= none), pTree : setGoalinTree(P,GID,G'),
                         currentGoal : GID, showMod : B, language : cafeobj,
                         originalCafeModule : T, Atts >
   if GID =/= 'nil /\
      G := getGoalinTree(P, GID) /\
      M := addRls(rl(CP, true), getModuleinGoal(G)) /\
      G' := setModuleinGoal(G, M) .

  crl [critical-pair-cafe-back-trans] :
      < O : X@Database | db : DB, input : ('backward`transition`..@Command@),
                         output : nil, critPair : (CP CPS), pTree : P,
                         currentGoal : GID, answerMode : true, showMod : B,
                         language : cafeobj, originalCafeModule : T, Atts >
   => < O : X@Database | db : DB, input : if CPS == none
                                          then nilTermList
                                          else 'discard`critical`pair`..@Command@
                                          fi,
                         output : if CPS == none
                                  then ('\n '\g 'INFO: '\o 'All 'critical 'pairs
                                        'are 'discarded '\n '\n
                                        prettyPrintGoalCafe(G', DB, B, T)) else nil
                                  fi,
                         critPair : CPS, answerMode : (CPS =/= none),
                         pTree : setGoalinTree(P, GID, G'), currentGoal : GID,
                         showMod : B, language : cafeobj, originalCafeModule : T, Atts >
   if GID =/= 'nil /\
      G := getGoalinTree(P, GID) /\
      M := addRls(rl(CP, false), getModuleinGoal(G)) /\
      G' := setModuleinGoal(G, M) .

  rl [ignore-cafe] :
     < O : X@Database | db : DB, input : ('ignore`..@Command@), output : nil,
                        critPair : (CP CPS), answerMode : true, language : cafeobj,
                        Atts >
  => < O : X@Database | db : DB, input : if CPS == none
                                         then nilTermList
                                         else 'discard`critical`pair`..@Command@
                                         fi,
                        output : if CPS == none
                                 then ('\n '\g 'INFO: '\o 'All 'critical 'pairs
                                       'are 'discarded)
                                 else nil
                                 fi, critPair : CPS, answerMode : (CPS =/= none),
                        language : cafeobj, Atts > .

  crl [answerMode-cafe] :
      < O : X@Database | input : CMD, output : nil, answerMode : true,
                         language : cafeobj, Atts >
   => < O : X@Database | input : nilTermList, output : ('\r 'WARNING: '\o 'please
                                                        'answer '\r 'equation '\o
                                                        'or '\r 'transition '\o '\n),
                         answerMode : true, language : cafeobj, Atts >
   if CMD =/= 'equation`..@Command@ /\ CMD =/= 'transition`..@Command@ /\
      CMD =/= 'ignore`..@Command@ /\ CMD =/= 'backward`equation`..@Command@ /\
      CMD =/= 'backward`transition`..@Command@ .


  crl [nonAnswerMode-cafe] :
      < O : X@Database | input : CMD, output : nil, answerMode : false,
                         language : cafeobj, Atts >
   => < O : X@Database | input : nilTermList, output : ('\r 'ERROR: '\o 'No 'critical
                                                        'pair 'to 'discard '\n),
                         answerMode : false, language : cafeobj, Atts >
   if CMD == 'transition`..@Command@ or-else CMD == 'equation`..@Command@ or-else
      CMD == 'ignore`..@Command@ or-else CMD == 'backward`equation`..@Command@ or-else
      CMD == 'backward`transition`..@Command@ .

  crl [crit-pair-cafe-terms] :
      < O : X@Database | db : DB, input : ('cp_><_[T,T']), output : nil,
                         pTree : P, currentGoal : GID, answerMode : B,
                         critPair : CPS', language : cafeobj, Atts >
   => < O : X@Database | db : DB, input : nilTermList,
                         output : ('\g 'INFO: '\o if CPS == none
                                                  then ('No 'critical 'pairs)
                                                  else eMetaPrettyPrint(M, '=>, CPS)
                                                  fi),
                         pTree : P, currentGoal : GID, critPair : CPS,
                         answerMode : if CPS == none then B else true fi,
                         language : cafeobj, Atts >
   if M := getModuleinGoal(getGoalinTree(P, GID)) /\
      CPS := procCPCmd(DB, M, T, T')  .

  crl [crit-pair-cafe-label] :
      < O : X@Database | db : DB, input : ('cp_><_.['token[T],'token[T']]),
                         output : nil, pTree : P, currentGoal : GID, answerMode : B,
                         critPair : CPS', language : cafeobj, Atts >
   => < O : X@Database | db : DB, input : nilTermList,
                         output : ('\g 'INFO: '\o if CPS == none
                                                  then ('No 'critical 'pairs)
                                                  else eMetaPrettyPrint(M,'=>,CPS)
                                                  fi),
                         pTree : P, currentGoal : GID, critPair : CPS,
                         answerMode : if CPS == none
                                      then B
                                      else true
                                      fi,
                         language : cafeobj, Atts >
   if M := getModuleinGoal(getGoalinTree(P,GID)) /\
      CPS := procCPCmdLabel(M,downQidList(T),downQidList(T'))  .

  crl [crit-pair-cafe-label-error] :
      < O : X@Database | db : DB, input : ('cp_><_.['token[T],'token[T']]),
                         output : nil, pTree : P, currentGoal : GID,
                         language : cafeobj, Atts >
   => < O : X@Database | db : DB, input : nilTermList, output : ('\r 'ERROR: '\o QIL),
                         pTree : P, currentGoal : GID, language : cafeobj, Atts >
   if M := getModuleinGoal(getGoalinTree(P, GID)) /\
      cpError(QIL) := procCPCmdLabel(M, downQidList(T), downQidList(T'))  .



  crl [crit-pair-term-error] :
      < O : X@Database | db : DB, input : ('cp_><_[T,T']), output : nil, pTree : P,
                         currentGoal : GID, language : cafeobj, Atts >
   => < O : X@Database | db : DB, input : nilTermList, output : ('\r 'ERROR: '\o  QIL),
                         pTree : P, currentGoal : GID, language : cafeobj, Atts >
   if M := getModuleinGoal(getGoalinTree(P, GID)) /\
      cpError(QIL) := procCPCmd(DB, M, T, T') .

***(%
\end{comment}
}

Finally, we define a constant with the initial values of the attributes related to
CafeOBJ specifications:

%  ***********************************************************************
%  ************************* AUXILIARY FUNCTIONS *************************
%  ***********************************************************************

{\codesize
\begin{verbatim}
%)

  op initCafeAttS : -> AttributeSet .
  eq initCafeAttS = strict : false, originalCafeModule : empty .
endm

***(%

\end{verbatim}
}
%)




mod THEOREM-PROVER-UI is 
    protecting THM-BANNER .
    extending LOOP-MODE .
    protecting META-THM-SIGN .
    protecting THM-DATABASE-HANDLING .
    pr CAFE-UI .
    *** Adrian
    inc LOOP-PRE-PROCESSING .
    *** Adrian
    
    subsort Object < State .
    op o : -> Oid .
    

    var H 				: Header .
    var O 				: Oid .
    var X@Database 		        : DatabaseClass .
    var QI 				: Qid .
    vars QIL QIL' QIL''                 : QidList .
    var TL 				: TermList .
    var DB 				: Database .
    var Atts 			        : AttributeSet .    

    op init 			        : -> System .
        
    rl [init] : init => [nil,
	  < o		: CITPDatabase | 
	  *** Adrian 
	  db		: initialDatabase, 
	  input 	: nilTermList , 
          default       : 'CONVERSION ,
	  pTree         : null,
	  currentGoal   : 'nil, 
	  showMod       : false, 
	  tactic        : 0,
	  critPair      : none,
	  answerMode    : false,
	  tacticRec     : ('SI 'CA 'CS 'TC 'IP),
	  language : maude,
	  *** Adrian
	  initCafeAttS,
	  *** Adrian
	  output 	: nil >,
	  ('\s '\s '\s '\s '\s '\b string2qidList(thm-banner) '\o '\n help-list)] .
    
    rl [input] : 	[QI QIL, 
	  < O 			: X@Database | 
	  input 		: nilTermList,
	  output 		: nil, Atts >,  
	  QIL' ] => 
      if metaParse(thm-Grammar, QI QIL, '@Input@) :: ResultPair
	then
	  [nil, 
	    < O 		: X@Database | 
	    input 		: getTerm(metaParse(thm-Grammar, QI QIL, '@Input@)), 
	    output 		: nil, Atts >, 
	    QIL']
	else 
	  [nil, 
	    < O 		: X@Database | 
	    input 		: nilTermList, 
	    output 		: ('\r 'WARNING: '\o printSyntaxError(metaParse(thm-Grammar, QI QIL, '@Input@), QI QIL) '\n 
	      'ERROR: 'No 'parse 'for 'input.), Atts >, 
	    QIL' ]
	fi .
    
    rl 	[output] : 	
	[QIL, 
	  < O : X@Database | 
			     output 	: (QI QIL'), Atts >,
	  QIL''] =>
	[QIL, 
	  < O 		: X@Database | 
	  output 	: nil, Atts >, (QIL'' QI QIL')] .
endm
    

loop init .

set print conceal on .
print conceal db .
print conceal fmod_is_sorts_.____endfm .

print conceal mod_is_sorts_._____endm .
print conceal th_is_sorts_._____endth .
print conceal fth_is_sorts_.____endfth .


