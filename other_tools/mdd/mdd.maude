----                                         To be run on Maude 2.7 (alpha 103)
----                                                    author: Francisco Duran
----                           printSyntaxError functionality by Peter Olveczky
----                                       narrowing search by Santiago Escobar

set show loop stats off .
set show loop timing off .
set show advisories off .

fmod BANNER is
  pr STRING .
  op banner : -> String .
  eq banner = "Full Maude 2.7 June 18th 2014" .
endfm

***(
    This file is part of the Maude 2 interpreter.

    Copyright 1997-2003 SRI International, Menlo Park, CA 94025, USA.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 inclof the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNSS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public Leicense
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
)

---- to do:
---- - continue .
---- - show search graph .
---- - show path <number> .
---- - show path labels <number> .
---- - show components .

---- Main changes and bugs fixed:
----
---- - Feb 18th, 2015
----   - An operator <_[,_]*> was added to the modules for narrowing. It has been
----     renamed as @<@_[,_]*@>@ to avoid clashes with user-defined operators.
----   - acu coherence completion has been renamed to ax coherence completion.
----     This applies to the acu coherence completion [<module-name>] ., to the
----     metalevel operation axCohComplete and to the module AX-COHERENCE-COMPLETION.
----     The completion was already performed for the different combinations of
----     attributes, but the name was the original one.
---- - Nov 12th, 2014
----   - Classes without attributes may be defined as class Foo . or class Foo | .
----     Requested by A. Riesco.
----   - Parameter sorts used in sort constraints were not appropriately instantiated.
----     Reported by A. Riesco.
---- - July 14th, 2014
----   - Fixed bug in the parsing of terms with operators '=' or '=>'. Although the first-level
----     parsing was done correctly, to solve bubbles an operator = (resp. =>) was introduced
----     to handle equations (resp. rules). Reported by Adrian Riesco.
----   - Fixed bug on the pretty printing of views. Typical error on structures with id elements.
----     Probably due to changes in the definion of map sets. Reported by Adrian Riesco.
---- - September 12th, 2013
----   - Bug in ACU completion when handling modules with explicit use of kinds. Reported
----     by Luis Aguirre
---- - December 12th, 2013
----   - Bug in the renaming of operators with explicit arity where parameterized sorts
----     are used.
----   - Bug in the renaming of ac operators fixed. Given an acu operator __, a term
----     card(E E S, C) was not renamed.
---- - July 24th, 2012
----   - commands remove ids and remove non-handled ids available
---- - July 7th, 2012
----   - A bug in the removal of identity attributes has been fixed. A metadata("variant")
----     was expected in all equations to be used to generate the variants. To be consistent
----     to the new built-in getVariants function I'm using the attribute variant instead
----     of the metadata.
---- - March 20th, 2012
----   - Core Maude views are now accessible from Full Maude. Full Maude do not require
----     explicit sort maps any more.
----   - The set of more general eqs and rls (moreGeneralEqs and moreGeneralRls ops)
----     is now correctly calculated. These functions are used in several places, for
----     example, in the functions and commands to eliminate identity attributes and in
----     the completion procedures.
----     Reported by Santiago Escobar.
---- - October 24th, 2011
----   - format attribute was not correctly handled. Equation missing in the downAttr op.
---- - July 13th, 2011
----   - A bug on the load metamodule command making it fail when loading a metamodule
----     with a metadata attribute has been fixed.
----     Reported by Tobias Muhlbauer and Jonas Eckhardt.
---- - December 5th, 2009
----   - New command (remove id attributes [<module-expr.>] .) that shows the
----     module with the id attributes removed using variants.
----   - New command (remove assoc attributes [<module-expr.>] .) that shows the
----     module with the assoc (if not with comm) attributes removed using variants.
---- - November 22nd, 2009
----   - A new version of the narrowing/unification stuff by S. Escobar fixing a bug in the
----     getVariants function and incorporating some other changes.
----     To integrate it into Full Maude:
----     - The TERMSET module is moved, so that now Full Maude uses it instead of its
----       definition of term sets. In the original module by Santiago this module imported
----       the SUBSTITUTION-HANDLING module; this importation is now commented out.
---- - October 4th, 2009
----   - New (acu coherence completion .) / (acu coherence completion <Module> .) command.
----     It shows result of completing the flatten version of the module for acu coherence.
---- - Setember 11th, 2009
----   - sort Set<List<Type>> replaced by the TypeListSet sort from META-MODULE
----   - sort List<Set<Type>> renamed as TypeSetList
----   - MAYBE removed, DEFAULT-VALUE used instead. MAYBE{TERM} replaced by DEFAULT-VALUE{Term}
---- - July 28th, 2009
----   - Some cleaning up. Some of the changes may break other applications.
---- - April 18th, 2009
----   - The metadata attribute is now available for operation declarations. Reported by A. Riesco.
----   - Fixed bug in the handling of ditto. ctor and metadata attributes were copied.
---- - March 9th, 2009
----   - Bug in the search command. The number of solutions argument was used as depth bound. Reported by P. Olveczky.
----   - New (remove id attributes .) / (remove id attributes <Module> .) command
----     It shows an equivalent version of the flatten module without ids using variants.
---- - March 9th, 2009
----   - Bug in the handling of mbs/cmbs. Sorts in bubbles were not handled correctly. Reported by T. Serbanuta.
---- - February 12th, 2009
----   - The summation module expression now generates a module
----        fmod A + B + C is
----          inc A .
----          inc B .
----          inc C .
----        endfm
----     for a module expression A + B + C.
---- - February 6th, 2009
----   - Fixed a bug in the id-unify command. Fixed by Santiago Escobar
---- - February 3rd, 2009
----   - Missing equation for downAttr, for the case of nonexec
----   - Missing declaration in the CONFIGURATION+ module to handle class declarations with no attributes
---- - January 29th, 2009
----   - The downModule operation has been extended to be able to handle oo metamodules.
----     Note that omod metamodules are defined in the UNIT Full Maude module. Therefore,
----     to be able to do things like
----        (load omod ... endm .)
----     the current module must be the FM UNIT module or one extending it.
---- - January 28th, 2009
----   - A bug in downAttr. Found thanks to a problem with metamodule load. Reported by Peter Olveczky.
---- - January 8th, 2009
----   - A bug in the narrowing functionality. It was narrowing on frozen positions.
----     (fixed by Santiago Escobar)
---- - December 20th, 2008
----   - Fixed a bug in the handling of the such-that part of search commands.
----     Reported by Enrique Martin.
---- - December 17th, 2008
----   - A new search_~>_ family of commands (as for search_=>_) is now available.
----     The commands are implemented by Santiago Escobar.
---- - December 8th, 2008
----   - A new meta-module load command is available.
----     It enters a metamodule into Full Maude's database of modules.
----     Asked by Peter Olveczky and Jose Meseguer.
----     The syntax for the new command is (load <meta-module> .), where <meta-module is any term of sort
----     Module, either a term of the form fmod...endfm or any other expression reducing to a module.
----     Thus, you can write things like
----
----     (select META-LEVEL .)
----
----     (load fmod 'FOO is
----             including 'BOOL .
----             sorts 'Foo .
----             none
----             op 'f : nil -> 'Foo [none] .
----             op 'g : nil -> 'Foo [none] .
----             none
----             eq 'f.Foo = 'g.Foo [none] .
----           endfm .)
----
----     or
----
----     (load upModule('NAT, true) .)
----
---- - September 18th, 2008
----   The search command now supports its complete generality (maximum depth couln't be given). Bug reported by Zhang Min.
----   The unify command is now supported.
----   Bug in the renaming of partial operations fixed. Reported by Edu Rivera.
---- - April 2nd, 2008
----   Bug in the application of views (and renamings) with kinds in the specification
----   of op renamings. It appears in an example in which the sort was coming from a theory.
----   Reported by A. Boronat.
---- - March 24th, 2008
----   Bug in the application of renamings to op hooks. Reported by A. Boronat
---- - March 17th, 2008
----   Bug in the instantiation of parameterized sorts in sort memberships.
----   Reported by A. Boronat
---- - March 14th, 2008
----   Bug in the handling of parameterized module expressions. When the parameterers
----   are not right, the system hangs. Reported by A. Verdejo.
---- - March 9th, 2008
----   Statement attributes of membership axioms were not correctly handled.
----   Reported by A. Riesco & A. Verdejo
---- - Feb 18th, 2008
----   Bug in the renaming of operators
---- - Feb 14th, 2008
----   Statement attributes of membership axioms were not correctly handled.
----   Reported by A. Riesco & A. Verdejo
---- - Dec 17th, 2007
----   Rule in CONFIGURATION+ was causing non-termination
---- - Dec 13th, 2007
----   Change in the specification of the transform function to allow new types of modules
---- - Nov 23rd, 2007
----   Bug in the evaluation of expressions in commands (red in FOO + BAR : ...)
---- - Oct 5th, 2007
----   Bug in down of modules (reported by Pedro Ojeda)
---- - July 31st, 2007
----   bug in the application of maps to terms
---- - July 31st, 2007
----   bug in getThClasses
----   (reported by Marisol)
---- - (october 17th, 2006)
----   Changes in Alpha88a's prelude are now correctly handled
---- - (july 22nd, 2006)
----   Bug in the meta-pretty-print of types.
---- - (july 21st, 2006)
----   Object-oriented messages where not given the attribute msg
----   (from a comment by Peter).
---- - (reported by Radestock)
----   getSort was not handling parameterized sorts appropriately.
---- - the set protect/extend/include off commands didn't work if the
----   module not importing was not among the imported ones
----
---- Last changes:
----
---- - May 21st, 2007
----   GRAMMAR now extends a module BUBBLES with all bubble delcarations.
----   This BUBBLES module is also used to define the GRAMMAR-RED, GRAMMAR-REW, ...
----   modules.
----
---- - May 19th, 2007
----   procCommand changed. It now returns a Tuple{Database, QidList} instead of
----   just a QidList. Since some modules may need to be compiled for the
----   execution of a command, the resulting database is returned and used as
----   new database.
----
---- - May 19th, 2007
----   proRew takes now one argument less. The Bound (4th arg.) was unnecessary.
----
---- - BOOL is included, instead of protected, into any entered module.
----
---- - A new module expression POWER[n] is now available. A module expression
----   POWER[n]{Nat} produces a module
----
----    fmod POWER[n]{X :: TRIV} is
----      inc TUPLE[n]{X, X, ..., X} .
----    endfm
----
----   which is then instantiated by the Nat view.

---- - (July 18th, 2006)
----   The summation module expression now generates a module
----   that includes (instead of protect) its summands.
----
---- - All sorts declared in modules used for parsing have been renamed.
----   Any sort S in one of these modules is nos called @S@.
----   Since some of these modules where added to the user defined modules
----   for dealing with ups, conditions, etc., he was getting error when
----   using sorts like Token or OpDecl in his specs.
----
---- - Syntax for parameterization has been changed (again) !!! :
----     - module definition: FOO{X :: TRIV, Y :: TRIV}
----     - module instantiation: FOO{Bar,Baz}
----     - parameterized sorts: Foo{Bar,Baz}
----
---- - Any module loaded in Core Maude can be used in Full Maude.
----   This may be particularly useful in the case of using the model checker.
----
----   (mod CHECK-RESP is
----      protecting MODEL-CHECKER .
----      ...
----    endm)
----
----   (red p(0) |= (<> Qstate) .)
----
---- - Module renaming and summation consistent with Core Maude's. Built-ins
----   are now handled at the metalevel, instead of leaving the inclusions to
----   Core Maude. In this way, they can be renamed and redefined, as in
----   Core Maude. This makes Full Maude slower.
----
---- - The lazy evaluation of modules is working. When a module is redefined
----   its dependent modules are removed only if generated internally. Those
----   introduced by the user save their term representation, from which the
----   whole processing can take place. They will be recompiled by need.
----
---- - The form of qualifying sorts coming from the parameters in
----   parameterized modules has changed AGAIN: The sort Elt coming from
----   X :: TRIV is now written as X$Elt (Note that sort names cannot contain
----   dots anymore).
----
---- - Tuples are built with the syntax
----     TUPLE[size]{comma_separated_list_of_views}
----   For example, given a view Nat from TRIV to NAT we can define pairs of
----   nats with TUPLE[2]{Nat, Nat}.
----
---- - The model-checker is loaded before the full maude modules, so that
----   it can be used.
----
---- - Object-oriented modules include a module CONFIGURATION+, which
----   imports CONFIGURATION, defines a function
----     op class : Object -> Cid .
----   returning the actual class of the given object, and add syntax
----   for objects with no attributes <_:_| >. Classes without attributes
----   are defined with syntax class CLASS-NAME .
----
---- Things to come:
----
---- - Commands missing: continue ...
----
---- - On parameterized theories and views: linked parameters, composed and
----   lifted views, and default views.
----
---- - ops names in op declarations
----
---- known bugs:
----
---- - error messages could be given in down commands
----
---- - Check: perhaps we need to convert constants back into vbles in
----   procViewAux
----
---- - Parameterized sorts don't work in sort constraints (nor by themselves,
----   nor in the conditions of axioms. They are accepted in their equivalent
----   single token form but do not get instantiated
----     cmb (A, B) S : PFun(X, Y) if not(A in dom(S)) /\ S : PFun`(X`,Y`) .
----

set include BOOL off .
set include TRUTH-VALUE on .
set show advisories off .

mod CONFIGURATION is
  sorts Attribute AttributeSet .
  subsort Attribute < AttributeSet .
  op none : -> AttributeSet  [ctor] .
  op _,_ : AttributeSet AttributeSet -> AttributeSet [ctor assoc comm id: none] .

  sorts Oid Cid Object Msg Portal Configuration .
  subsort Object Msg Portal < Configuration .
  op <_:_|_> : Oid Cid AttributeSet -> Object [ctor object] .
  op none : -> Configuration [ctor] .
  op __ : Configuration Configuration -> Configuration [ctor config assoc comm id: none] .
  op <> : -> Portal [ctor] .
endm

mod CONFIGURATION+ is
  including CONFIGURATION .
  op <_:_|`> : Oid Cid -> Object .
  op class : Object -> Cid .
  ---- eq < O:Oid : C:Cid | > = < O:Oid : C:Cid | none > .
  eq class(< O:Oid : C:Cid | A:AttributeSet >) = C:Cid .
endm

set include BOOL on .
set include TRUTH-VALUE off .

*******************************************************************************
*******************************************************************************
***
*** Narrowing and Equational Unification
*** by Santiago Escobar
***
fmod META-LEVEL-MNPA is
  pr META-LEVEL * (op `{_`,_`} : Term Nat -> SmtResult to `{_`,_`}Smt )  .
endfm

fmod UNIFICATIONTRIPLE is
  protecting META-LEVEL-MNPA .
  protecting INT .

  --- UnificationPair --------------------------------------------
  ---sorts UnificationPair UnificationPair? .
  ---op {_,_} : Substitution Nat -> UnificationPair [ctor] .
  ---subsort UnificationPair < UnificationPair? .
  ---op noUnifier : -> UnificationPair? [ctor] .

  op getSubst : UnificationPair -> Substitution .
  eq getSubst({S1:Substitution, N:Nat}) = S1:Substitution .
  op getNextVar : UnificationPair -> Nat .
  eq getNextVar({S1:Substitution, N:Nat}) = N:Nat .

  --- UnificationTriple --------------------------------------------
  ---sorts UnificationTriple UnificationTriple? .
  ---op {_,_,_} : Substitution Substitution Nat -> UnificationTriple [ctor] .
  ---subsort UnificationTriple < UnificationTriple? .
  ---op noUnifier : -> UnificationTriple? [ctor] .

  op getLSubst : UnificationTriple -> Substitution .
  eq getLSubst({S1:Substitution, S2:Substitution, N:Nat}) = S1:Substitution .
  op getRSubst : UnificationTriple -> Substitution .
  eq getRSubst({S1:Substitution, S2:Substitution, N:Nat}) = S2:Substitution .
  op getNextVar : UnificationTriple -> Nat .
  eq getNextVar({S1:Substitution, S2:Substitution, N:Nat}) = N:Nat .

endfm

fmod TERM-HANDLING is
  protecting META-TERM .
  protecting META-LEVEL-MNPA .
  protecting EXT-BOOL . *** For and-then

  var T T' T'' : Term .
  var C C' : Constant .
  var QIL : QidList .
  var N N' : Nat .
  var NL NL' : NatList .
  var Q F F' : Qid .
  var AtS : AttrSet .
  var EqS : EquationSet .
  var Eq : Equation .
  var Cond : Condition .
  var TP : Type .
  var TPL TPL' : TypeList .
  var TL TL' TL'' : TermList .
  var B : Bool .
  var V V' : Variable .
  var Ct : Context .
  var CtL : NeCTermList .
  var NeTL : NeTermList .
  var M : Module .

  *** root  ******************************
  op root : Term -> Qid .
  eq root(V) = V .
  eq root(C) = C .
  eq root(F[TL]) = F .

  *** size  ******************************
  op size : TermList -> Nat .
  eq size(empty) = 0 .
  eq size((T,TL)) = s(size(TL)) .

  *** elem_of_ *****************************************************
  op elem_of_ : Nat TermList ~> Term .
  eq elem 1 of (T,TL) = T .
  eq elem s(s(N)) of (T,TL) = elem s(N) of TL .

  *** subTerm_of_ *****************************************************
  op subTerm_of_ : NatList Term ~> Term .
  eq subTerm NL of T = subTerm* NL of T  .

  op subTerm*_of_ : NatList Term ~> Term .
  eq subTerm* nil of T = T .
  eq subTerm* N NL of (F[TL]) = subTerm* NL of (elem N of TL) .

  *** ToDo: UPGRADE THIS NOTION TO MODULO AC *********************
  *** is_subTermOf_ *****************************************************
  op is_subTermOf_ : Term TermList -> Bool .
  eq is T subTermOf (T',NeTL) = is T subTermOf T'
                                or-else is T subTermOf NeTL .
  eq is T subTermOf T = true .
  eq is T subTermOf T' = is T subTermOf* T' [owise] .

  op is_subTermOf*_ : Term TermList -> Bool .
  eq is T subTermOf* (F[TL]) = is T subTermOf TL .
  eq is T subTermOf* T' = false [owise] .

  *** noVarOfSort_In_ *****************************************************
  op noVarOfSort_In_ : Type TermList -> Bool .
  eq noVarOfSort T:Type In V = getType(V) =/= T:Type .
  eq noVarOfSort T:Type In (F[TL]) = noVarOfSort T:Type In TL .
  eq noVarOfSort T:Type In (T',NeTL)
   = noVarOfSort T:Type In T' and noVarOfSort T:Type In NeTL .
  eq noVarOfSort T:Type In X:TermList = true [owise] .

  *** findSubTermOf_In_ ***********************************************
  op findSubTermOf_In_ : NeCTermList TermList ~> Term .
  eq findSubTermOf (TL, [], TL') In (TL, T, TL') = T .
  eq findSubTermOf (TL, F[CtL], TL'') In (TL, F[TL'], TL'')
   = findSubTermOf CtL In TL' .

  *** replaceElem_of_by_ ****************************************************
  op replaceElem_of_by_ : Nat TermList Term ~> TermList .
  eq replaceElem 1 of (T,TL) by T' = (T',TL) .
  eq replaceElem s(s(N)) of (T,TL) by T' = (T,replaceElem s(N) of TL by T') .

  *** replaceSubTerm_of_by_ *************************************************
  op replaceSubTerm_of_by_ : NatList TermList Term ~> TermList .
  eq replaceSubTerm nil of T by T' = T' .
  eq replaceSubTerm N NL of (F[TL]) by T'
   = F[replaceSubTermL N NL of TL by T'] .

  op replaceSubTermL_of_by_ : NatList TermList Term ~> TermList .
  eq replaceSubTermL 1 NL of (T,TL) by T'
   = (replaceSubTerm NL of T by T', TL) .
  eq replaceSubTermL s(s(N)) NL of (T,TL) by T'
   = (T,replaceSubTermL s(N) NL of TL by T') .

  op replaceTerm_by_in_ : Term Term TermList ~> TermList .
  eq replaceTerm T by T' in T = T' .
  eq replaceTerm T by T' in (F[TL]) = F[replaceTerm T by T' in TL] .
  eq replaceTerm T by T' in T'' = T'' [owise] .
  eq replaceTerm T by T' in (T'',NeTL)
   = (replaceTerm T by T' in T'',replaceTerm T by T' in NeTL) .

  *** context replacement **************************************************

  op _[_] : Context Context -> Context .
  op _[_] : NeCTermList Context -> NeCTermList .
  eq [] [ Ct ] = Ct .
  eq (F[CtL])[ Ct ] = F[ CtL [ Ct ] ] .
  eq (CtL,NeTL) [Ct] = (CtL [Ct] ), NeTL .
  eq (NeTL,CtL) [Ct] = NeTL, (CtL [Ct] ) .

  op _[_] : Context Term -> Term .
  op _[_] : NeCTermList Term -> TermList .
  eq [] [ T ] = T .
  eq (F[CtL])[ T ] = F[ CtL [ T ] ] .
  eq (CtL,NeTL) [T] = (CtL [T] ), NeTL .
  eq (NeTL,CtL) [T] = NeTL, (CtL [T] ) .

  *** is_substring_ *****************************************
  op is_substring_ : Qid Qid -> Bool [memo] .
  eq is F:Qid substring F':Qid
   = rfind(string(F':Qid), string(F:Qid), length(string(F':Qid))) =/= notFound .

  *** addprefix_To_ addsufix_To_ *****************************************
  op addprefix_To_ : Qid Variable -> Variable [memo] .
  eq addprefix Q To V
   = qid(string(Q) + string(getName(V)) + ":" + string(getType(V))) .

  op addprefix_To_ : Qid Constant -> Constant [ditto] .
  eq addprefix Q To F
   = if noUnderBar(F) and getName(F) :: Qid then
       if getType(F) :: Type then
         qid(string(Q) + string(getName(F)) + "." + string(getType(F)))
       else
         qid(string(Q) + string(getName(F)))
       fi
     else
       qid(string(Q) + string(F))
     fi .

  op addsufix_To_ : Qid Variable -> Variable [memo] .
  eq addsufix Q To V
   = qid(string(getName(V)) + string(Q) + ":" + string(getType(V))) .

  op addsufix_To_ : Qid Constant -> Constant [ditto] .
  eq addsufix Q To F
   = if noUnderBar(F) and getName(F) :: Qid then
       if getType(F) :: Type then
         qid(string(getName(F)) + string(Q) + "." + string(getType(F)))
       else
         qid(string(getName(F)) + string(Q))
       fi
     else
       qid(string(F) + string(Q))
     fi .

  op addType_ToVar_ : Type Qid -> Variable [memo] .
  eq addType TP:Qid ToVar V:Qid
   = qid(string(V:Qid) + ":" + string(TP:Qid)) .

  *** noUnderBar (auxiliary) ****************************
  op noUnderBar : Qid -> Bool .
  eq noUnderBar(F)
   = rfind(string(F), "_", length(string(F))) == notFound .

  *** addType  ******************************
  op addType : Qid Type -> Qid .
  eq addType(F,TP)
   = if noUnderBar(F) and getName(F) :: Qid then
       qid( string(getName(F)) + "." + string(TP) )
     else
       qid( string(F) + "." + string(TP) )
     fi .

  *** addTypeVar  ******************************
  op addTypeVar : Qid Type -> Qid .
  eq addTypeVar(F,TP)
   = qid( string(F) + ":" + string(TP) ) .

endfm

fmod SUBSTITUTION-HANDLING is
  protecting META-TERM .
  protecting META-LEVEL-MNPA .
  protecting TERM-HANDLING .

  var S S' Subst Subst' : Substitution .
  var V V' : Variable .
  var C C' : Constant .
  var Ct : Context .
  var T T' T1 T2 T1' T2' T1'' T2'' : Term .
  var F F' : Qid .
  var TL TL' TL1 TL2 TL1' TL2' : TermList .
  var Att : AttrSet .
  var RLS : RuleSet .
  var Rl : Rule .
  var TP : Type .
  var N : Nat .
  var NeTL : NeTermList .
  var CtL : NeCTermList .

  --- Apply Substitution to Term --------------------------------------------
  op _<<_ : Term Substitution -> Term .
  eq TL << none = TL .
  eq C << Subst = C .
  eq V << ((V <- T) ; Subst) = T .
  eq V << Subst = V [owise] .
  eq F[TL] << Subst = F[TL << Subst] .

  op _<<_ : TermList Substitution -> TermList .
  eq (T, NeTL) << Subst = (T << Subst, NeTL << Subst) .
  eq empty << Subst = empty .

  op _<<_ : Context Substitution -> Context .
  eq Ct << none = Ct .
  eq [] << Subst = [] .
  eq F[CtL,NeTL] << Subst = F[CtL << Subst,NeTL << Subst] .
  eq F[NeTL,CtL] << Subst = F[NeTL << Subst, CtL << Subst] .
  eq F[Ct] << Subst = F[Ct << Subst] .

  op _<<_ : Substitution Substitution -> Substitution .
  eq S << (none).Substitution = S .
  eq (none).Substitution << S = (none).Substitution .
  eq ((V' <- T) ; S') <<  S
   = (V' <- (T << S))
     ;
     (S' << S) .

  --- Combine Substitutions -------------------------------------------------
  op _.._ : Substitution Substitution -> Substitution .
  eq S .. S' = (S << S') ; S' .

  --- Restrict Assignments to Variables in a Term ----------------------
  op _|>_ : Substitution TermList -> Substitution .

  eq Subst |> TL = Subst |>* Vars(TL) .

  op _|>*_ : Substitution TermList -> Substitution .
---   eq noMatch |>* TL = noMatch .
  eq Subst |>* TL = Subst |>** TL [none] .

  op _|>**_[_] : Substitution TermList
                 Substitution -> Substitution .
  eq none |>** TL [Subst']
   = Subst' .
  eq ((V <- V) ; Subst) |>** TL [Subst']
   = Subst |>** TL [Subst'] .
  eq ((V <- T') ; Subst) |>** TL [Subst']
    = Subst |>** TL
      [Subst' ; if any V in TL then (V <- T') else none fi] .

  --- Remove Variables from list ----------------------
  op _intersect_ : TermList TermList -> TermList .
  eq (TL1,T,TL2) intersect (TL1',T,TL2')
   = (T,((TL1,TL2) intersect (TL1',TL2'))) .
  eq TL intersect TL' = empty [owise] .

  op _intersectVar_ : TermList TermList -> TermList .
  eq TL1 intersectVar TL2
   = TL1 intersectVar* Vars(TL2) .

  op _intersectVar*_ : TermList TermList -> TermList .
  eq (T,TL1) intersectVar* TL2
   = (if any Vars(T) in TL2 then T else empty fi,TL1 intersectVar* TL2) .
  eq empty intersectVar* TL2
   = empty .

  --- Remove Variables from list ----------------------
  op _setMinus_ : TermList TermList -> TermList .
  eq (TL1,T,TL2) setMinus (TL1',T,TL2')
   = (TL1,TL2) setMinus (TL1',TL2') .
  eq TL setMinus TL' = TL [owise] .

  --- Variables ---
  op Vars : GTermList -> TermList .
  eq Vars((T,TL:GTermList)) = VarsTerm(T),Vars(TL:GTermList) .
  eq Vars((Ct,TL:GTermList)) = VarsTerm(Ct),Vars(TL:GTermList) .
  eq Vars(empty) = empty .

  op VarsTerm : Term -> TermList . ---warning memo
  eq VarsTerm(V) = V .
  eq VarsTerm(F[TL:TermList]) = Vars(TL:TermList) .
  eq VarsTerm(C) = empty .

  op VarsTerm : Context -> TermList . ---warning memo
  eq VarsTerm(F[TL:GTermList]) = Vars(TL:GTermList) .

  --- membership ---
  op _in_ : Term TermList -> Bool .
  eq T in (TL,T,TL') = true .
  eq T in TL = false [owise] .

  --- membership ---
  op any_in_ : TermList TermList -> Bool . --- [memo] .
  eq any empty in TL = false .
  eq any (TL1,T,TL2) in (TL1',T,TL2') = true .
  eq any TL in TL' = false [owise] .

  --- membership ---
  op all_in_ : TermList TermList -> Bool . --- [memo] .
  eq all empty in TL = true .
  eq all (TL1,T,TL2) in (TL1',T,TL2') = all (TL1,TL2) in (TL1',T,TL2') .
  eq all TL in TL' = false [owise] .

  --- Occur check ---
  op allVars_inVars_ : GTermList GTermList -> Bool .
  eq allVars TL:GTermList inVars TL':GTermList
   = all Vars(TL:GTermList) in Vars(TL':GTermList) .

  op anyVars_inVars_ : GTermList GTermList -> Bool .
  eq anyVars TL:GTermList inVars TL':GTermList
   = any Vars(TL:GTermList) in Vars(TL':GTermList) .

  op rangeVars : Substitution -> TermList .
  eq rangeVars(V <- T ; Subst) = (Vars(T),rangeVars(Subst)) .
  eq rangeVars(none) = empty .

  op dom_inVars_ : Substitution TermList -> Bool .
  eq dom Subst inVars TL = dom Subst in Vars(TL) .

  op dom_in_ : Substitution TermList -> Bool .
  eq dom (V <- T ; Subst) in (TL1,V,TL2) = true .
  eq dom Subst in TL = false [owise] .

  op dom_notInVars_ : Substitution TermList -> Bool .
  eq dom Subst notInVars TL = dom Subst notIn Vars(TL) .

  op dom_notIn_ : Substitution TermList -> Bool .
  eq dom none notIn TL = true .
 ceq dom (V <- T ; Subst) notIn TL = true if not (V in TL) .
  eq dom Subst notIn TL = false [owise] .

  op range_inVars_ : Substitution TermList -> Bool .
  eq range Subst inVars TL = range Subst in Vars(TL) .

  op range_in_ : Substitution TermList -> Bool .
  eq range (V <- T ; Subst) in TL
   = any Vars(T) in TL or-else range Subst in TL .
  eq range none in TL
   = false .

  op valid-occur-check? : Substitution -> Bool .
  eq valid-occur-check?(Subst)
   = not (dom Subst inVars (rangeVars(Subst))) .
endfm

fmod TERMSET is
  protecting META-LEVEL-MNPA .
  protecting SUBSTITUTION-HANDLING .

  sort TermSet .
  subsort Term < TermSet .
  op emptyTermSet : -> TermSet [ctor] .
  op _|_ : TermSet TermSet -> TermSet
    [ctor assoc comm id: emptyTermSet format (d n d d)] .
  eq X:Term | X:Term = X:Term .

  op _in_ : Term TermSet -> Bool .
  eq T:Term in (T:Term | TS:TermSet) = true .
  eq T:Term in TS:TermSet = false [owise] .

  op TermSet : TermList -> TermSet .
  eq TermSet(empty)
   = emptyTermSet .
  eq TermSet((T:Term,TL:TermList))
   = T:Term | TermSet(TL:TermList) .

endfm

fmod RENAMING is
  protecting META-TERM .
  protecting META-LEVEL-MNPA .
  protecting TERM-HANDLING .
  protecting SUBSTITUTION-HANDLING .
  protecting TERMSET .
  protecting CONVERSION .
  protecting QID .
  protecting INT .
  protecting UNIFICATIONTRIPLE .

  var S S' Subst Subst' : Substitution .
  var V V' : Variable .
  var C C' : Constant .
  var CtL : NeCTermList .
  var Ct : Context .
  var T T' T1 T2 T1' T2' T1'' T2'' : Term .
  var F F' : Qid .
  var TL TL' TL'' TL''' : TermList .
  var Att : AttrSet .
  var RLS : RuleSet .
  var Rl : Rule .
  var TP : Type .
  var N N' : Nat .
  var NeTL : NeTermList .

  var Q Q' : Qid .
  var IL : ImportList .
  var SS : SortSet .
  var SSDS : SubsortDeclSet .
  var OPDS : OpDeclSet .
  var MAS : MembAxSet .
  var EQS : EquationSet .

  var TPL : TypeList .

  --- Extra filter for substitutions ------
  op _|>_ : Substitution Nat -> Substitution .
  eq Subst |> N
   = Subst |>* N [none] .

  op _|>*_[_] : Substitution Nat Substitution -> Substitution .
  eq none |>* N [Subst']
   = Subst' .
  eq ((V <- T') ; Subst) |>* N [Subst']
   = Subst |>* N
     [Subst' ; if highestVar(V) < N then (V <- T') else none fi ] .

  --- instantiatesAbove -----------------------------------
  op _instantiatesAbove_ : Substitution Nat -> Bool .
  eq none instantiatesAbove N = false .
  eq ((V <- T') ; Subst) instantiatesAbove N
   = highestVar(V) >= N
     or-else
     Subst instantiatesAbove N .

  ----------------------------------------------
  --- New Renaming Utilities -------------------
  op highestVar : GTermList -> Nat .
  eq highestVar(TL:GTermList)
   = highestVar(TL:GTermList,0) .

  op highestVarTerm : Term -> Nat . ---warning memo
  op highestVarTerm : Context -> Nat . ---warning memo
  eq highestVarTerm([]) = 0 .
  eq highestVarTerm(C) = 0 .
  eq highestVarTerm(V)
   = if rfind(string(V), "#", length(string(V))) =/= notFound
        and
        rfind(string(V), ":", length(string(V))) =/= notFound
        and
        rat(substr(string(V),
                   rfind(string(V), "#", length(string(V))) + 1,
                   rfind(string(V), ":", length(string(V))) + (- 1))
            ,10)
        :: Nat
     then rat(substr(string(V),
                   rfind(string(V), "#", length(string(V))) + 1,
                   rfind(string(V), ":", length(string(V))) + (- 1))
              ,10)
     else
         if rfind(string(V), "%", length(string(V))) =/= notFound
            and
            rfind(string(V), ":", length(string(V))) =/= notFound
            and
            rat(substr(string(V),
                       rfind(string(V), "%", length(string(V))) + 1,
                       rfind(string(V), ":", length(string(V))) + (- 1))
                ,10)
            :: Nat
         then rat(substr(string(V),
                         rfind(string(V), "%", length(string(V))) + 1,
                         rfind(string(V), ":", length(string(V))) + (- 1))
                  ,10)
         else 0
         fi
     fi .

  eq highestVarTerm(F[TL:GTermList])
   = highestVar(TL:GTermList,0) .

  op highestVar : GTermList Nat -> Nat .
  eq highestVar(empty,N)
   = N .
  eq highestVar((Ct,TL:GTermList),N)
   = highestVar(TL:GTermList,
       if highestVarTerm(Ct) > N then highestVarTerm(Ct) else N fi
     ) .
  eq highestVar((T,TL:GTermList),N)
   = highestVar(TL:GTermList,
       if highestVarTerm(T) > N then highestVarTerm(T) else N fi
     ) .

  --- For substitutions
  op highestVar : Substitution -> Nat . --- [memo] .
  eq highestVar(Subst)
   = highestVar(Subst,0) .

  op highestVar : Substitution Nat -> Nat .
  eq highestVar((none).Substitution,N) = N .
  eq highestVar(V <- T ; Subst,N)
   = highestVar(Subst,highestVar((T,V),N)) .

  --- Renaming ------------------------------------------------------
  op newVar : Nat TypeList -> TermList .
  eq newVar(N,nil) = empty .
  eq newVar(N,TP TPL) = (newVar*(N,TP),newVar(s(N),TPL)) .

  op newVar* : Nat Type -> Variable .
  eq newVar*(N,TP)
   = qid("#" + string(N,10) + ":" + string(TP)) .

  op simplifyVars : TermList -> TermList .
  eq simplifyVars(TL) = TL << 0 < .

  op _<<`(_`)< : TermList GTermList -> TermList .
  eq X:TermList <<(TL:GTermList)<
   = X:TermList << highestVar(TL:GTermList) + 1 < .

  op _<<_ : TermList UnificationPair -> TermList .
  eq TL << {Subst,N} = TL << Subst .

  op _<<_ : TermList UnificationTriple -> TermList .
  eq TL << {Subst,Subst',N} = TL << (Subst ; Subst') .

  op _<<_ : Substitution UnificationTriple -> Substitution .
  eq S:Substitution << {Subst,Subst',N} = S:Substitution << (Subst ; Subst') .

  op _<<_< : TermList Nat -> TermList .
  eq TL << N < = TL << (TL << { none, N } <) .

  op _<<_< : TermList UnificationPair -> UnificationPair . ***Huge [memo] .
  eq C << {S,N} < = {S,N} .
  eq F[TL] << {S,N} < = TL << {S,N} < .
  eq V << {S,N} <
   = if not (dom S inVars V)
     then {S ; V <- newVar(N,getType(V)), N + 1}
     else {S,N}
     fi .

  eq (T,TL:NeTermList) << {S,N} <
   = TL:NeTermList << (T << {S,N} < ) < .
  eq empty << {S,N} <
   = {S,N} .

endfm

fmod SUBSTITUTIONSET is
  protecting SUBSTITUTION-HANDLING .
  protecting META-LEVEL-MNPA .
  protecting TERMSET .
  protecting RENAMING .

  sort SubstitutionSet NeSubstitutionSet .
  subsort Substitution < NeSubstitutionSet < SubstitutionSet .
  op empty : -> SubstitutionSet [ctor] .
  op _|_ : SubstitutionSet SubstitutionSet -> SubstitutionSet
    [ctor assoc comm id: empty format (d n d d)] .
  op _|_ : NeSubstitutionSet SubstitutionSet -> NeSubstitutionSet
    [ctor ditto] .
  eq X:Substitution | X:Substitution = X:Substitution .

  vars SS SS' : SubstitutionSet .
  vars S S' Subst : Substitution .
  vars T T' : Term .
  vars TL TL' : TermList .
  vars N N' : Nat .
  var V : Variable .

  op _<<_ : Substitution SubstitutionSet -> SubstitutionSet .
  eq S << empty = empty .
  ceq S << (S' | SS') = (S << S') | (S << SS') if SS' =/= empty .

  op _..._ : SubstitutionSet [SubstitutionSet]
          -> SubstitutionSet [strat (1) gather (e E)] .

  eq empty ... SS':[SubstitutionSet] = empty .
  eq (S | SS) ... SS':[SubstitutionSet]
   = (S ...' SS':[SubstitutionSet])
     |
     (SS ... SS':[SubstitutionSet]) .

  op _...'_ : Substitution SubstitutionSet -> SubstitutionSet .

  eq S ...' empty
   = empty .

  eq S ...' (S' | SS')
   = (S .. S')
     |
     (S ...' SS') .

  op _|>_ : SubstitutionSet TermList -> SubstitutionSet .
  eq (empty).SubstitutionSet |> TL = empty .
  eq (S | SS:NeSubstitutionSet) |> TL
   = (S |> TL) | (SS:NeSubstitutionSet |> TL) .

  op _|>_ : SubstitutionSet Nat -> SubstitutionSet .
  eq SS:NeSubstitutionSet |> N
   = SS:NeSubstitutionSet |> (0,N) .

  op _|>`(_,_`) : SubstitutionSet Nat Nat -> SubstitutionSet .
  eq (empty).SubstitutionSet |> (N,N') = empty .
  eq (S | SS:NeSubstitutionSet) |> (N,N')
   = (S |> (N,N')) | (SS:NeSubstitutionSet |> (N,N')) .

  op _|>`(_,_`) : Substitution Nat Nat -> Substitution .
  eq none |> (N,N') = none .
  eq ((V <- T') ; Subst) |> (N,N')
   = if N <= highestVar(V) and highestVar(V) <= N'
     then (V <- T')
     else none
     fi
     ; (Subst |> (N,N')) .

  op filter_by!InVars_ : SubstitutionSet TermList -> SubstitutionSet .
  eq filter (empty).SubstitutionSet by!InVars TL
   = (empty).SubstitutionSet .
  eq filter (S | SS) by!InVars TL
   = if dom S inVars TL
     then empty
     else S
     fi
     | filter SS by!InVars TL .

  op _==* none : SubstitutionSet -> Bool .
  eq (none | SS) ==* none = SS ==* none .
  eq (empty).SubstitutionSet ==* none = true .
  eq SS ==* none = false [owise] .

  op |_| : SubstitutionSet -> Nat .
  eq | (empty).SubstitutionSet | = 0 .
  eq | (S | SS) | = s(| SS |) .

endfm

fmod UNIFICATIONPAIRSET is
  protecting SUBSTITUTIONSET .
  protecting RENAMING .
  protecting UNIFICATIONTRIPLE .

  vars V V' : Variable .
  vars U U' : UnificationPair .
  vars US US' : UnificationPairSet .
  vars S S' S1 S1' S2 S2' : Substitution .
  var SS : SubstitutionSet .
  vars N N' N1 N2 : Nat .
  vars T T' : Term .
  var TL : TermList .
  var M : Module .

  --- Combine UnificationPair ---------------------------------------------
  op _.._ : UnificationPair UnificationPair -> UnificationPair .
  eq {S,N} .. {S',N'} = {S .. S',max(N,N')} .

  --- Detect used variables ----------------------------------------------
  op dom_inVars_ : UnificationPair TermList -> Bool . --- [memo] .
  eq dom {S,N} inVars TL = dom S inVars TL .

  --- UnificationPairSet --------------------------------------------------
  sort UnificationPairSet .
  subsort UnificationPair < UnificationPairSet .
  op empty : -> UnificationPairSet [ctor] .
  op _|_ : UnificationPairSet UnificationPairSet -> UnificationPairSet
    [ctor assoc comm id: empty format (d n d d)] .
  eq X:UnificationPair | X:UnificationPair = X:UnificationPair .

  op _..._ : UnificationPairSet [UnificationPairSet]
          -> UnificationPairSet [strat (1) gather (e E)] .

  eq (empty).UnificationPairSet ... US':[UnificationPairSet]
   = (empty).UnificationPairSet .
  eq (U | US) ... US':[UnificationPairSet]
   = (U ...' US':[UnificationPairSet])
     |
     (US ... US':[UnificationPairSet]) .

  op _...'_ : UnificationPair UnificationPairSet -> UnificationPairSet .

  eq U ...' (empty).UnificationPairSet
   = (empty).UnificationPairSet .

  eq U ...' (U' | US')
   = (U .. U')
     |
     (U ...' US') .

  --- Restriction -----------------------
  op _|>_ : UnificationPairSet TermList -> UnificationPairSet .
  eq (empty).UnificationPairSet |> TL = empty .
  eq ({S,N} | US) |> TL = {(S |> TL),N} | (US |> TL) .

  op filter_by!InVars_ : UnificationPairSet TermList
                      -> UnificationPairSet .
  eq filter (empty).UnificationPairSet by!InVars TL
   = (empty).UnificationPairSet .
  eq filter (U | US) by!InVars TL
   = if dom U inVars TL
     then empty
     else U
     fi
     | filter US by!InVars TL .

  op toUnificationPair[_]`(_`) : Nat SubstitutionSet -> UnificationPairSet .
  eq toUnificationPair[N](empty)
   = empty .
  eq toUnificationPair[N](S | SS)
   = {S,highestVar(S,N)}
     | toUnificationPair[N](SS) .

  op toSubstitution : UnificationPairSet -> SubstitutionSet .
  eq toSubstitution((empty).UnificationPairSet)
   = empty .
  eq toSubstitution({S,N} | US)
   = S | toSubstitution(US) .

  op _in_ : UnificationPair UnificationPairSet -> Bool .
  eq X:UnificationPair in (X:UnificationPair | XS:UnificationPairSet) = true .
  eq X:UnificationPair in XS:UnificationPairSet = false [owise] .

endfm

fmod UNIFICATIONTRIPLESET is
  protecting SUBSTITUTIONSET .
  protecting RENAMING .
  protecting UNIFICATIONPAIRSET .

  vars V V' : Variable .
  var C : Constant .
  var F : Qid .
  vars U U' : UnificationTriple .
  vars US US' : UnificationTripleSet .
  vars S S' S1 S1' S2 S2' : Substitution .
  var SS : SubstitutionSet .
  var SSe : NeSubstitutionSet .
  vars N N' N1 N2 NextVar : Nat .
  vars T T' : Term .
  var TL : TermList .
  var NeTL : NeTermList .
  var M : Module .
  var UPS : UnificationPairSet .

  --- Combine UnificationPair ---------------------------------------------
  op _.._ : UnificationTriple UnificationTriple -> UnificationTriple .
  eq {S1,S1',N1} .. {S2,S2',N2} = {S1 .. S2,S1' .. S2',max(N1,N2)} .

  --- UnificationPairSet --------------------------------------------------
  sort UnificationTripleSet .
  subsort UnificationTriple < UnificationTripleSet .
  op empty : -> UnificationTripleSet [ctor] .
  op _|_ : UnificationTripleSet UnificationTripleSet
        -> UnificationTripleSet
    [ctor assoc comm id: empty format (d n d d)] .
  eq X:UnificationTriple | X:UnificationTriple = X:UnificationTriple .

  op _..._ : UnificationTripleSet [UnificationTripleSet]
          -> UnificationTripleSet [strat (1) gather (e E)] .

  eq (empty).UnificationTripleSet ... US':[UnificationTripleSet]
   = (empty).UnificationTripleSet .
  eq (U | US) ... US':[UnificationTripleSet]
   = (U ...' US':[UnificationTripleSet])
     |
     (US ... US':[UnificationTripleSet]) .

  op _...'_ : UnificationTriple UnificationTripleSet
           -> UnificationTripleSet .

  eq U ...' (empty).UnificationTripleSet
   = (empty).UnificationTripleSet .

  eq U ...' (U' | US')
   = (U .. U')
     |
     (U ...' US') .

  --- convert  -----------------------------------------------------
  op split : UnificationPair Nat -> UnificationTriple .
  eq split({none,N},N') = {none,none,N} .
  eq split({(V <- T') ; S,N},N')
   = if highestVar(V) < N'
     then {(V <- T'),none,N}
     else {none,(V <- T'),N}
     fi
     .. split({S,N},N') .

  op split : UnificationPairSet Term Term -> UnificationTripleSet .
  eq split(empty,T,T') = empty .
  eq split({S,N} | UPS,T,T') = {S |> T, S |> T',N} | split(UPS,T,T') .

  op toUnificationTriple[_]`(_`) :
             Nat SubstitutionSet -> UnificationTripleSet .
  eq toUnificationTriple[N](SS)
   = toUnificationTriple*[N](SS,empty) .

  op toUnificationTriple*[_]`(_,_`) :
             Nat SubstitutionSet
             UnificationTripleSet -> UnificationTripleSet .
  eq toUnificationTriple*[N](empty,US)
   = US .
  eq toUnificationTriple*[N](S | SS,US)
   = toUnificationTriple*[N](SS, US | {none,S,highestVar(S,N)}) .

  op toUnificationTriple[_,_]`(_`) :
             Nat Nat SubstitutionSet -> UnificationTripleSet .
  eq toUnificationTriple[NextVar,N](SS)
   = toUnificationTriple*[NextVar,N](SS,empty) .

  op toUnificationTriple*[_,_]`(_,_`) :
             Nat Nat SubstitutionSet
             UnificationTripleSet -> UnificationTripleSet .
  eq toUnificationTriple*[NextVar,N](empty,US)
   = US .
  eq toUnificationTriple*[NextVar,N](S | SS,US)
   = toUnificationTriple*[NextVar,N](SS,
             US | split({S,highestVar(S,N)},NextVar)) .

  op toUnificationTriple[_,_,_]`(_`) :
             Term Term Nat SubstitutionSet -> UnificationTripleSet .
  eq toUnificationTriple[T,T',N](SS)
   = toUnificationTriple*[T,T',N](SS,empty) .

  op toUnificationTriple*[_,_,_]`(_,_`) :
             Term Term Nat SubstitutionSet
             UnificationTripleSet -> UnificationTripleSet .
  eq toUnificationTriple*[T,T',N](empty,US)
   = US .
  eq toUnificationTriple*[T,T',N](S | SS,US)
   = toUnificationTriple*[T,T',N](SS, US | {S |> T,S |> T',highestVar(S,N)}) .

  op toSubstitution : UnificationTripleSet -> SubstitutionSet .
  eq toSubstitution(US)
   = toSubstitution*(US,empty) .

  op toSubstitution* : UnificationTripleSet
                       SubstitutionSet -> SubstitutionSet .
  eq toSubstitution*((empty).UnificationTripleSet,SS)
   = SS .
  eq toSubstitution*({S,S',N} | US,SS)
   = toSubstitution*(US,SS | (S ; S')) .

  op _in_ : UnificationTriple UnificationTripleSet -> Bool .
  eq X:UnificationTriple
     in (X:UnificationTriple | XS:UnificationTripleSet) = true .
  eq X:UnificationTriple in XS:UnificationTripleSet = false [owise] .

  --- restriction ---------------------------------------------------
  op _|>_ : UnificationTripleSet TermList -> UnificationTripleSet .
  eq US |> TL
   = US *|> TL [empty] .

  op _*|>_[_] : UnificationTripleSet TermList
               UnificationTripleSet -> UnificationTripleSet .
  eq (empty).UnificationTripleSet *|> TL [US']
   = US' .
  eq ({S,S',N} | US) *|> TL [US']
   = US *|> TL [US' | {(S |> TL),(S' |> TL),N} ] .

  op _filterBy_ : UnificationTripleSet Nat -> UnificationTripleSet .
  eq US filterBy NextVar
   = US filterBy* NextVar [empty] .

  op _filterBy*_[_] : UnificationTripleSet Nat
                     UnificationTripleSet -> UnificationTripleSet .
  eq empty filterBy* NextVar [US']
   = US' .
  eq ({S,S',N} | US) filterBy* NextVar [US']
   = US filterBy* NextVar
     [US' | if S instantiatesAbove NextVar then empty else {S,S',N} fi ] .
endfm

fmod MODULE-HANDLING is
  protecting INT .
  protecting META-LEVEL-MNPA .
  protecting EXT-BOOL . *** From Full Maude
  protecting SUBSTITUTION-HANDLING .
  protecting UNIFICATIONTRIPLESET .

  var T T' T'' T1 T2 Lhs Rhs : Term .
  var C C' : Constant .
  var QIL : QidList .
  var N N' : Nat .
  var NL NL' : NatList .
  var Q F F' : Qid .
  vars AtS AtS' : AttrSet .
  var EqS : EquationSet .
  var Eq : Equation .
  var RlS : RuleSet .
  var Rl : Rule .
  var Cond : Condition .
  var TP TP' : Type .
  var TPL TPL' : TypeList .
  ---var TPL TPL' : ETypeList .
  ---var ET ET' : EType .
  var VDS OPDS : OpDeclSet .
  var OPD : OpDecl .
  var M : Module .
  var TL TL' TL'' : TermList .
  var B : Bool .
  var V V' : Variable .
  var I  : Int .
  vars S S' : Substitution .
  var US : UnificationTripleSet .

  *** canonice  ******************************
  op canonice : Module Term -> Term .
---  eq canonice(M,T) = getTerm(metaReduce(eraseRls(eraseEqs(M)),T)) .
  eq canonice(M,T) = getTerm(metaNormalize(M,T)) .

  op canonice : Module Substitution -> Substitution .
  eq canonice(M,(none).Substitution) = none .
  eq canonice(M,V <- T ; S) = V <- canonice(M,T) ; canonice(M,S)  .

  op canonice : Module UnificationTripleSet -> UnificationTripleSet .
  eq canonice(M,(empty).UnificationTripleSet) = (empty).UnificationTripleSet .
  eq canonice(M,{S,S',N} | US) = {canonice(M,S),canonice(M,S'),N} | canonice(M,US) .


  *** normalize  ******************************
  op normalize : Module Term -> Term .
  eq normalize(M,T) = getTerm(metaReduce(eraseRls(M),T)) .

  op normalize : Module Substitution -> Substitution .
  eq normalize(M,(none).Substitution) = none .
  eq normalize(M,V <- T ; S) = V <- normalize(M,T) ; normalize(M,S)  .

  *** normalizeRls  ******************************
  op normalizeRls : Module Term -> Term .
  eq normalizeRls(M,T) = getTerm(metaReduce(rls2eqs(M),T)) .

  op normalizeRls : Module Substitution -> Substitution .
  eq normalizeRls(M,(none).Substitution) = none .
  eq normalizeRls(M,V <- T ; S) = V <- normalizeRls(M,T) ; normalizeRls(M,S)  .

  *** typeLeq **************************************************
  op typeLeq : Module TypeList TypeList ~> Bool [memo] .

  eq typeLeq(M,TP:Sort TPL,TP':Sort TPL')
   = sortLeq(M,TP:Sort,TP':Sort) and typeLeq(M,TPL,TPL') .
  eq typeLeq(M,TP:Sort TPL,TP':Kind TPL')
   = getKind(M,TP:Sort) == TP':Kind
     and typeLeq(M,TPL,TPL') .
  eq typeLeq(M,TP:Kind TPL,TP':Sort TPL')
   = false .
  eq typeLeq(M,TP:Kind TPL,TP':Kind TPL')
   = TP:Kind == TP':Kind and typeLeq(M,TPL,TPL') .
  eq typeLeq(M,nil,nil)
   = true .

  *** getTypes **************************************************
  op getTypes : Module TermList -> TypeList . ---Memo is huge
  eq getTypes(M, (T, TL)) = leastSort(M, T) getTypes(M, TL) .
  eq getTypes(M, empty) = nil .

  *** getFrozen ************************************************
  op getFrozen : Module Qid TypeList -> NatList [memo] .
  eq getFrozen(M,F,TPL) = getFrozen(getOpsOfQid(M,F,TPL)) .

  op getFrozen : OpDeclSet -> NatList .
  eq getFrozen((op F : TPL -> TP [frozen(NL) AtS] .) OPDS) = NL .
  eq getFrozen(OPDS) = 0 [owise] .

  *** inNatList ************************************************
  op _inNatList_ : Nat NatList -> Bool .
  eq N inNatList (NL N NL') = true .
  eq N inNatList NL = false [owise] .

  *** membership ************************************************
  op _in_ : Type TypeList ~> Bool .
  eq TP in (TPL TP TPL') = true .
  eq TP in TPL = false [owise] .

  *** isConstructor  ******************************
  op isConstructor : Module Term -> Bool .
  op isConstructor : Module Qid TypeList -> Bool [memo] .
  op isConstructor : OpDeclSet -> Bool .

  eq isConstructor(M,V) = false .
  eq isConstructor(M,C) = isConstructor(M,C,nil) .
  eq isConstructor(M,F[TL]) = isConstructor(M,F,getTypes(M,TL)) .

  eq isConstructor(M,F,TPL)
   = getEqsOfQid(M,F,TPL) == none or-else isConstructor(getOpsOfQid(M,F,TPL)) .

  eq isConstructor((op F : TPL -> TP [ctor AtS] .) OPDS) = true .
  eq isConstructor(OPDS) = false [owise] .

  *** getOpsOfType ***********************************************
  op getOpsOfType : Module Type -> OpDeclSet [memo] .
  op getOpsOfType : Module OpDeclSet Type -> OpDeclSet .

  eq getOpsOfType(M,TP) = getOpsOfType(M,getOps(M),TP) .

  eq getOpsOfType(M,((op F : TPL -> TP [AtS] .) OPDS),TP')
    = if TP == TP'
      then (op F : TPL -> TP [AtS] .)
           getOpsOfType(M,OPDS,TP')
      else getOpsOfType(M,OPDS,TP')
      fi .

  eq getOpsOfType(M,OPDS,TP)
   = none
     [owise] .

  *** getOpsOfQid ***********************************************
  op getOpsOfQid : Module Qid -> OpDeclSet [memo] .
  op getOpsOfQid : Module Qid TypeList -> OpDeclSet [memo] .
  op getOpsOfQid : Module OpDeclSet Qid -> OpDeclSet .
  op getOpsOfQid : Module OpDeclSet Qid TypeList -> OpDeclSet .

  eq getOpsOfQid(M,F)
   = getOpsOfQid(M,getOps(M),F) .

  eq getOpsOfQid(M,F,TPL)
   = if getOpsOfQid(M,getOps(M),F,TPL) =/= none
     then getOpsOfQid(M,getOps(M),F,TPL)
     else getOpsOfQid(M,getOps(M),F,restrict TPL To 2)
     fi .

  eq getOpsOfQid(M,((op F : TPL -> TP [AtS] .) OPDS),F)
    = (op F : TPL -> TP [AtS] .)
      getOpsOfQid(M,OPDS,F) .

  eq getOpsOfQid(M,OPDS,F')
   = none
     [owise] .

  eq getOpsOfQid(M,((op F : TPL -> TP [AtS] .) OPDS),F,TPL')
    = if eSameKind(M,TPL,TPL')
      then (op F : TPL -> TP [AtS] .)
           getOpsOfQid(M,OPDS,F,TPL')
      else getOpsOfQid(M,OPDS,F,TPL')
      fi .

  eq getOpsOfQid(M,OPDS,F',TPL')
   = none
     [owise] .

  op restrict_To_ : TypeList Nat -> TypeList .
  eq restrict nil To NL = nil .
  eq restrict TPL To 0 = nil .
  eq restrict (TP,TPL) To s(N) = (TP, restrict TPL To N) .

  *** getOpsOfEqs ******************************************************
  op getOpsOfEqs : EquationSet -> QidList [memo] .
  eq getOpsOfEqs((eq C = T' [AtS] .) EqS )
   = C getOpsOfEqs(EqS) .
  eq getOpsOfEqs((eq F[TL] = T' [AtS] .) EqS )
   = F getOpsOfEqs(EqS) .
  eq getOpsOfEqs((none).EquationSet)
   = nil .

  *** getEqsOfQid ******************************************************
  op getEqsOfQid : Module Qid TypeList -> EquationSet [memo] .
  op getEqsOfQid : Module Qid TypeList EquationSet -> EquationSet .

  eq getEqsOfQid(M, F,TPL) = getEqsOfQid(M, F, TPL, getEqs(M)) .

  ceq getEqsOfQid(M, F, TPL, (eq C = T' [AtS] .) EqS )
   = (eq C = T' [AtS] .) getEqsOfQid(M, F, TPL, EqS)
   if F == C .
  ceq getEqsOfQid(M, F, TPL, (eq F[TL] = T' [AtS] .) EqS )
   = (eq F[TL] = T' [AtS] .) getEqsOfQid(M, F, TPL, EqS)
   if eSameKind(M,getTypes(M,TL),TPL) .
  ceq getEqsOfQid(M, F, TPL, (ceq C = T' if Cond [AtS] .) EqS )
   = (ceq C = T' if Cond [AtS] .) getEqsOfQid(M, F, TPL, EqS)
   if F == C .
  ceq getEqsOfQid(M, F, TPL, (ceq F[TL] = T' if Cond [AtS] .) EqS )
   = (ceq F[TL] = T' if Cond [AtS] .) getEqsOfQid(M, F, TPL, EqS)
   if eSameKind(M,getTypes(M,TL),TPL) .
  eq getEqsOfQid(M, F, TPL, Eq EqS )
   = getEqsOfQid(M, F, TPL, EqS) [owise] .
  eq getEqsOfQid(M, F, TPL, (none).EquationSet )
   = (none).EquationSet .

  *** getTypesOfQid  ****************************************
  op getTypesOfQid : Module Qid TypeList -> TypeSet [memo] .
  op getTypesOfQid : OpDeclSet -> TypeSet .

  eq getTypesOfQid(M,F,TPL) = getTypesOfQid(getOpsOfQid(M,F,TPL)) .
  eq getTypesOfQid((op F : TPL -> TP [AtS] .) OPDS)
   = TP ; getTypesOfQid(OPDS) .
  eq getTypesOfQid((none).OpDeclSet) = (none).TypeSet .

  *** filterConstructorSymbols ************************************
  op filterConstructorSymbols : OpDeclSet -> OpDeclSet .
  eq filterConstructorSymbols(((op F : TPL -> TP [AtS] .) OPDS))
    = if isConstructor((op F : TPL -> TP [AtS] .) none)
      then (op F : TPL -> TP [AtS] .)
           filterConstructorSymbols(OPDS)
      else filterConstructorSymbols(OPDS)
      fi .
  eq filterConstructorSymbols(none)
    = none .

  *** filterDefinedSymbols *****************************************
  op filterDefinedSymbols : OpDeclSet -> OpDeclSet .
  eq filterDefinedSymbols(((op F : TPL -> TP [ctor AtS] .) OPDS))
    = filterDefinedSymbols(OPDS) .
  eq filterDefinedSymbols(((op F : TPL -> TP [AtS] .) OPDS))
    = (op F : TPL -> TP [AtS] .) filterDefinedSymbols(OPDS) [owise] .
  eq filterDefinedSymbols(none)
    = none .

  *** isCommutative ******************************
  op isCommutative : Module Term -> Bool .
  op isCommutative : Module Qid TypeList -> Bool [memo] .
  op isCommutative : OpDeclSet -> Bool .

  eq isCommutative(M,V) = false .
  eq isCommutative(M,C) = false .
  eq isCommutative(M,F[TL]) = isCommutative(M,F,getTypes(M,TL)) .

  eq isCommutative(M,F,TPL) = isCommutative(getOpsOfQid(M,F,TPL)) .

  eq isCommutative((op F : TPL -> TP [comm AtS] .) OPDS) = true .
  eq isCommutative(OPDS) = false [owise] .

  *** isAssociative ******************************
  op isAssociative : Module Term -> Bool .
  op isAssociative : Module Qid TypeList -> Bool [memo] .
  op isAssociative : OpDeclSet -> Bool .

  eq isAssociative(M,V) = false .
  eq isAssociative(M,C) = false .
  eq isAssociative(M,F[TL]) = isAssociative(M,F,getTypes(M,TL)) .

  eq isAssociative(M,F,TPL) = isAssociative(getOpsOfQid(M,F,TPL)) .

  eq isAssociative((op F : TPL -> TP [assoc AtS] .) OPDS) = true .
  eq isAssociative(OPDS) = false [owise] .

  *** getIdSymbol ******************************
  op getIdSymbol : Module Term ~> Term .
  eq getIdSymbol(M,F[TL]) = getIdSymbol(M,F,getTypes(M,TL)) .

  op getIdSymbol : Module Qid TypeList ~> Term [memo] .
  eq getIdSymbol(M,F,TPL) = getIdSymbol(getOpsOfQid(M,F,TPL)) .

  op getIdSymbol : OpDeclSet ~> Term .
  eq getIdSymbol((op F : TPL -> TP [id(T) AtS] .) OPDS) = T .

  op getLeftIdSymbol : Module Term ~> Term .
  eq getLeftIdSymbol(M,F[TL]) = getLeftIdSymbol(M,F,getTypes(M,TL)) .

  op getLeftIdSymbol : Module Qid TypeList ~> Term .
  eq getLeftIdSymbol(M,F,TPL) = getLeftIdSymbol(getOpsOfQid(M,F,TPL)) .

  op getLeftIdSymbol : OpDeclSet ~> Term .
  eq getLeftIdSymbol((op F : TPL -> TP [left-id(T) AtS] .) OPDS) = T .

  op getRightIdSymbol : Module Term ~> Term .
  eq getRightIdSymbol(M,F[TL]) = getRightIdSymbol(M,F,getTypes(M,TL)) .

  op getRightIdSymbol : Module Qid TypeList ~> Term .
  eq getRightIdSymbol(M,F,TPL) = getRightIdSymbol(getOpsOfQid(M,F,TPL)) .

  op getRightIdSymbol : OpDeclSet ~> Term .
  eq getRightIdSymbol((op F : TPL -> TP [right-id(T) AtS] .) OPDS) = T .

  *** anyIdSymbol ******************************
  op anyIdSymbol : Module Term -> Bool .
  eq anyIdSymbol(M,C:Constant)
   = false .
  eq anyIdSymbol(M,V:Variable)
   = false .
  eq anyIdSymbol(M,F:Qid[TL:TermList])
   = getIdSymbol(M,F:Qid[TL:TermList]) :: Term
     or-else
     anyIdSymbol*(M,TL:TermList) .

  op anyIdSymbol* : Module TermList -> Bool .
  eq anyIdSymbol*(M,empty)
   = false .
  eq anyIdSymbol*(M,(T:Term,TL:TermList))
   = anyIdSymbol(M,T:Term)
     or-else
     anyIdSymbol*(M,TL:TermList) .

  ****
  op anyIdSymbol : Module Substitution -> Bool .
  eq anyIdSymbol(M,(none).Substitution) = false .
  eq anyIdSymbol(M,V:Variable <- T:Term ; S:Substitution)
   = anyIdSymbol(M,T:Term)
     or-else
     anyIdSymbol(M,S:Substitution) .

  *** eSameKind ******************************
  op eSameKind : Module TypeList TypeList -> Bool [memo] .
  eq eSameKind(M,TP TPL, TP' TPL')
   = sameKind(M,TP,TP') and eSameKind(M,TPL,TPL') .
  eq eSameKind(M,nil,nil) = true .
  eq eSameKind(M,TPL,nil) = true .
  eq eSameKind(M,nil,TPL') = true .
  ---eq eSameKind(M,TPL,TPL') = false [owise] .

  *** eqs2rls *******************************
  sort EqSet&RlsSet .
  op {_,_} : EquationSet RuleSet -> EqSet&RlsSet .
  op getEqs : EqSet&RlsSet -> EquationSet .
  eq getEqs({EqS,RlS}) = EqS .
  op getRls : EqSet&RlsSet -> RuleSet .
  eq getRls({EqS,RlS}) = RlS .

  op eqs2rls# : EquationSet -> EqSet&RlsSet [memo] .
  eq eqs2rls#(none) = {none,none} .
  eq eqs2rls#((eq Lhs = Rhs [AtS] .) EqS)
   = {getEqs(eqs2rls#(EqS)),
      (rl Lhs => Rhs [AtS] .) getRls(eqs2rls#(EqS))
     } .
  eq eqs2rls#((ceq Lhs = Rhs if Cond [AtS] .) EqS)
   = {getEqs(eqs2rls#(EqS)),
      (crl Lhs => Rhs if Cond [AtS] .) getRls(eqs2rls#(EqS))
     } .

  op eqs2rls : SModule -> SModule .
  eq eqs2rls(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqs(eqs2rls#(E:EquationSet))
       getRls(eqs2rls#(E:EquationSet))
     endm .

  op eqs2rls : FModule -> FModule .
  eq eqs2rls(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqs(eqs2rls#(E:EquationSet))
       getRls(eqs2rls#(E:EquationSet))
     endm .

  op eqsNoBuiltInUnify2rls : SModule -> SModule .
  eq eqsNoBuiltInUnify2rls(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       (getEqs(eqs2rls#(getEqsNoBuiltInUnify(E:EquationSet))) getEqsBuiltInUnify(E:EquationSet))
       getRls(eqs2rls#(getEqsNoBuiltInUnify(E:EquationSet)))
     endm .

  op eqsNoBuiltInUnify2rls : FModule -> SModule .
  eq eqsNoBuiltInUnify2rls(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       (getEqs(eqs2rls#(getEqsNoBuiltInUnify(E:EquationSet))) getEqsBuiltInUnify(E:EquationSet))
       getRls(eqs2rls#(getEqsNoBuiltInUnify(E:EquationSet)))
     endm .

  op eqsNoVariant2rls : SModule -> SModule .
  eq eqsNoVariant2rls(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       (getEqs(eqs2rls#(getEqsNoVariant(E:EquationSet))) getEqsVariant(E:EquationSet))
       getRls(eqs2rls#(getEqsNoVariant(E:EquationSet)))
     endm .

  op eqsNoVariant2rls : FModule -> SModule .
  eq eqsNoVariant2rls(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       (getEqs(eqs2rls#(getEqsNoVariant(E:EquationSet))) getEqsVariant(E:EquationSet))
       getRls(eqs2rls#(getEqsNoVariant(E:EquationSet)))
     endm .

  op eqsVariant2rls : SModule -> SModule .
  eq eqsVariant2rls(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       (getEqs(eqs2rls#(getEqsVariant(E:EquationSet))) getEqsNoVariant(E:EquationSet))
       getRls(eqs2rls#(getEqsVariant(E:EquationSet)))
     endm .

  op eqsVariant2rls : FModule -> SModule .
  eq eqsVariant2rls(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       (getEqs(eqs2rls#(getEqsVariant(E:EquationSet))) getEqsNoVariant(E:EquationSet))
       getRls(eqs2rls#(getEqsVariant(E:EquationSet)))
     endm .

  op removeVariantLabel : SModule -> SModule .
  eq removeVariantLabel(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-EQSV2EQSNV To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       removeVariantLabel(E:EquationSet)
       R:RuleSet
      endm .

  op removeVariantLabel : FModule -> SModule .
  eq removeVariantLabel(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = fmod (addsufix '-EQSV2EQSNV To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       removeVariantLabel(E:EquationSet)
     endfm .

  op removeVariantLabel : EquationSet -> EquationSet .
  eq removeVariantLabel((eq Lhs = Rhs [AtS variant] .) EqS)
   = (eq Lhs = Rhs [AtS] .)
     removeVariantLabel(EqS) .
  eq removeVariantLabel(EqS)
   = EqS [owise] .

  *** getEqsNoBuiltInUnify *******************************
  op getEqsNoBuiltInUnify : Module -> EquationSet .
  eq getEqsNoBuiltInUnify(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = getEqsNoBuiltInUnify(E:EquationSet) .
  eq getEqsNoBuiltInUnify(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = getEqsNoBuiltInUnify(E:EquationSet) .

  op getEqsNoBuiltInUnify : EquationSet -> EquationSet [memo] .
  eq getEqsNoBuiltInUnify(none) = none .
  eq getEqsNoBuiltInUnify((eq Lhs = Rhs [AtS metadata("builtin-unify")] .) EqS)
   = getEqsNoBuiltInUnify(EqS) .
  eq getEqsNoBuiltInUnify((eq Lhs = Rhs [AtS] .) EqS)
   = (eq Lhs = Rhs [AtS] .) getEqsNoBuiltInUnify(EqS)
  [owise] .
  eq getEqsNoBuiltInUnify((ceq Lhs = Rhs if Cond [AtS] .) EqS)
   = (ceq Lhs = Rhs if Cond [AtS] .) getEqsNoBuiltInUnify(EqS) .

  *** getEqsNoVariant *******************************
  op getEqsNoVariant : Module -> EquationSet .
  eq getEqsNoVariant(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = getEqsNoVariant(E:EquationSet) .
  eq getEqsNoVariant(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = getEqsNoVariant(E:EquationSet) .

  op getEqsNoVariant : EquationSet -> EquationSet [memo] .
  eq getEqsNoVariant(none) = none .
  eq getEqsNoVariant((eq Lhs = Rhs [AtS variant] .) EqS)
   = getEqsNoVariant(EqS) .
  eq getEqsNoVariant((eq Lhs = Rhs [AtS] .) EqS)
   = (eq Lhs = Rhs [AtS] .) getEqsNoVariant(EqS)
  [owise] .
  eq getEqsNoVariant((ceq Lhs = Rhs if Cond [AtS] .) EqS)
   = (ceq Lhs = Rhs if Cond [AtS] .) getEqsNoVariant(EqS) .

  *** getEqsVariant *******************************
  op getEqsVariant : Module -> EquationSet .
  eq getEqsVariant(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = getEqsVariant(E:EquationSet) .
  eq getEqsVariant(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = getEqsVariant(E:EquationSet) .

  op getEqsVariant : EquationSet -> EquationSet [memo] .
  eq getEqsVariant(none) = none .
  eq getEqsVariant((eq Lhs = Rhs [AtS variant] .) EqS)
   = (eq Lhs = Rhs [AtS variant] .)
     getEqsVariant(EqS) .
  eq getEqsVariant((eq Lhs = Rhs [AtS] .) EqS)
   = getEqsVariant(EqS)
  [owise] .
  eq getEqsVariant((ceq Lhs = Rhs if Cond [AtS] .) EqS)
   = (ceq Lhs = Rhs if Cond [AtS] .) getEqsVariant(EqS) .

  *** onlyEqsNoBuiltInUnify *******************************
  op onlyEqsNoBuiltInUnify : Module -> Module .
  eq onlyEqsNoBuiltInUnify(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = fmod (addsufix '-OnlyEqsNoBuiltInUnify To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsNoBuiltInUnify(E:EquationSet)
     endfm .
  eq onlyEqsNoBuiltInUnify(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-OnlyEqsNoBuiltInUnify To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsNoBuiltInUnify(E:EquationSet)
       R:RuleSet
     endm .

  *** onlyEqsNoVariant *******************************
  op onlyEqsNoVariant : Module -> Module .
  eq onlyEqsNoVariant(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = fmod (addsufix '-OnlyEqsNoVariant To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsNoVariant(E:EquationSet)
     endfm .
  eq onlyEqsNoVariant(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-OnlyEqsNoVariant To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsNoVariant(E:EquationSet)
       R:RuleSet
     endm .

  *** getEqsBuiltInUnify *******************************
  op getEqsBuiltInUnify : Module -> EquationSet .
  eq getEqsBuiltInUnify(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = getEqsBuiltInUnify(E:EquationSet) .
  eq getEqsBuiltInUnify(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = getEqsBuiltInUnify(E:EquationSet) .

  op getEqsBuiltInUnify : EquationSet -> EquationSet [memo] .
  eq getEqsBuiltInUnify(none) = none .
  eq getEqsBuiltInUnify((eq Lhs = Rhs [AtS metadata("builtin-unify")] .) EqS)
   = (eq Lhs = Rhs [AtS metadata("builtin-unify")] .) getEqsBuiltInUnify(EqS) .
  eq getEqsBuiltInUnify((eq Lhs = Rhs [AtS] .) EqS)
   = getEqsBuiltInUnify(EqS)
  [owise] .
  eq getEqsBuiltInUnify((ceq Lhs = Rhs if Cond [AtS] .) EqS)
   = getEqsBuiltInUnify(EqS) .

  *** getEqsVariant *******************************
  op getEqsVariant : Module -> EquationSet .
  eq getEqsVariant(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = getEqsVariant(E:EquationSet) .
  eq getEqsVariant(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = getEqsVariant(E:EquationSet) .

  op getEqsVariant : EquationSet -> EquationSet [memo] .
  eq getEqsVariant(none) = none .
  eq getEqsVariant((eq Lhs = Rhs [AtS variant] .) EqS)
   = (eq Lhs = Rhs [AtS variant] .) getEqsVariant(EqS) .
  eq getEqsVariant((eq Lhs = Rhs [AtS] .) EqS)
   = getEqsVariant(EqS)
  [owise] .
  eq getEqsVariant((ceq Lhs = Rhs if Cond [AtS] .) EqS)
   = getEqsVariant(EqS) .

  *** onlyEqsBuiltInUnify *******************************
  op onlyEqsBuiltInUnify : Module -> Module .
  eq onlyEqsBuiltInUnify(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsBuiltInUnify(E:EquationSet)
     endfm .
  eq onlyEqsBuiltInUnify(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsBuiltInUnify(E:EquationSet)
       R:RuleSet
     endm .

  *** onlyEqsVariant *******************************
  op onlyEqsVariant : Module -> Module .
  eq onlyEqsVariant(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsVariant(E:EquationSet)
     endfm .
  eq onlyEqsVariant(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsVariant(E:EquationSet)
       R:RuleSet
     endm .

  *** rls2eqs *******************************
  op rls2eqs# : RuleSet -> EquationSet [memo] .
  eq rls2eqs#(none) = none .
  eq rls2eqs#((rl Lhs => Rhs [AtS] .) RlS)
   = (eq Lhs = Rhs [AtS] .) rls2eqs#(RlS) .
  eq rls2eqs#((crl Lhs => Rhs if Cond [AtS] .) RlS)
   = (ceq Lhs = Rhs if Cond [AtS] .) rls2eqs#(RlS) .

  op rls2eqs : SModule -> SModule .
  eq rls2eqs(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-RLS2EQS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet rls2eqs#(R:RuleSet)
       none
     endm .

  *** flipRls *******************************
  op flipRls : RuleSet -> RuleSet [memo] .
  eq flipRls(none) = none .
  eq flipRls((rl Lhs => Rhs [AtS] .) RlS:RuleSet)
   = if all Vars(Lhs) in Vars(Rhs)
     then (rl Rhs => Lhs [removeNonExec(AtS)] .)
     else (rl Rhs => Lhs [nonexec removeNonExec(AtS)] .)
     fi
     flipRls(RlS:RuleSet) .
  eq flipRls((crl Lhs => Rhs if Cond [AtS] .) RlS:RuleSet)
   = if all Vars(Lhs) in Vars(Rhs)
     then (crl Rhs => Lhs if Cond [removeNonExec(AtS)] .)
     else (crl Rhs => Lhs if Cond [nonexec removeNonExec(AtS)] .)
     fi
     flipRls(RlS:RuleSet) .

  op removeNonExec : AttrSet -> AttrSet .
  eq removeNonExec(nonexec AtS) = AtS .
  eq removeNonExec(AtS) = AtS [owise] .

  op flipRls : SModule -> SModule .
  eq flipRls(mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
             O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm)
   = mod (addsufix '-FLIPPEDRLS To Q:Qid)
     is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
     O:OpDeclSet M:MembAxSet E:EquationSet flipRls(R:RuleSet) endm .

  *** addOp *******************************
  op addOps : OpDeclSet SModule -> SModule .
  eq addOps(OO:OpDeclSet,mod Q:Qid is IL:ImportList sorts S:SortSet .
      S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm)
   = mod (addsufix '-ADDEDOPS To Q:Qid)
     is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
     override(O:OpDeclSet,OO:OpDeclSet)
     M:MembAxSet E:EquationSet R:RuleSet endm .
  op addOps : OpDeclSet FModule -> FModule .
  eq addOps(OO:OpDeclSet,fmod Q:Qid is IL:ImportList sorts S:SortSet .
      S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet endfm)
   = fmod (addsufix '-ADDEDOPS To Q:Qid)
     is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
     override(O:OpDeclSet,OO:OpDeclSet)
     M:MembAxSet E:EquationSet endfm .

  op override : OpDeclSet OpDeclSet -> OpDeclSet .
  eq override(
      (op F : TPL -> TP [AtS] .)  O:OpDeclSet,
      (op F : TPL -> TP [AtS'] .) O':OpDeclSet)
   = override(O:OpDeclSet,(op F : TPL -> TP [AtS'] .) O':OpDeclSet) .
  eq override(O:OpDeclSet,O':OpDeclSet)
   = O:OpDeclSet O':OpDeclSet [owise] .

  *** addRules *******************************
  op addRules : RuleSet SModule -> SModule [memo] .
  eq addRules(RR:RuleSet,mod Q:Qid is IL:ImportList sorts S:SortSet .
          S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm)
   = mod (addsufix '-ADDEDRLS To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet (R:RuleSet RR:RuleSet) endm .

  *** addEqs *******************************
  op addEqs : EquationSet SModule -> SModule .
  op addEqs : EquationSet FModule -> FModule .
  eq addEqs(ES:EquationSet,mod Q:Qid is IL:ImportList sorts S:SortSet .
          S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm)
   = mod (addsufix '-ADDEDEQS To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet (E:EquationSet ES:EquationSet) R:RuleSet endm .
  eq addEqs(ES:EquationSet,fmod Q:Qid is IL:ImportList sorts S:SortSet .
          S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet endfm)
   = fmod (addsufix '-ADDEDEQS To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet (E:EquationSet ES:EquationSet) endfm .

  *** addSorts *******************************
  op addSorts : SortSet SModule -> SModule .
  op addSorts : SortSet FModule -> FModule .
  eq addSorts(X:SortSet,
       mod Q:Qid is IL:ImportList sorts S:SortSet .
       S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm)
   = mod Q:Qid is IL:ImportList sorts (X:SortSet ; S:SortSet) .
       S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm .
  eq addSorts(X:SortSet,
       fmod Q:Qid is IL:ImportList sorts S:SortSet .
       S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet endfm)
   = fmod Q:Qid is IL:ImportList sorts (X:SortSet ; S:SortSet) .
       S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet endfm .

  *** putFrozen *******************************
  op putFrozen : NatList Qid TypeList SModule -> SModule [memo] .
  eq putFrozen(NL,F,TPL,
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [frozen(NL') AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix F To (addsufix '-FROZEN# To Q:Qid))
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [frozen(NL) AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm) .
  eq putFrozen(NL,F,TPL,
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix F To (addsufix '-FROZEN# To Q:Qid))
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [frozen(NL) AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm) [owise] .

  *** putStrat *******************************
  op putStrat : NatList Qid TypeList SModule -> SModule [memo] .
  eq putStrat(NL,F,TPL,
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [strat(NL') AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix F To (addsufix '-STRAT#EQ# To Q:Qid))
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [strat(NL) AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm) .
  eq putStrat(NL,F,TPL,
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix F To (addsufix '-STRAT#EQ# To Q:Qid))
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [strat(NL) AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm) [owise] .

  op putStrat : NatList Qid TypeList FModule -> FModule [memo] .
  eq putStrat(NL,F,TPL,
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [strat(NL') AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet endfm))
   = (fmod (addsufix F To (addsufix '-STRAT#EQ# To Q:Qid))
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [strat(NL) AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet endfm) .
  eq putStrat(NL,F,TPL,
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet endfm))
   = (fmod (addsufix F To (addsufix '-STRAT#EQ# To Q:Qid))
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [strat(NL) AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet endfm) [owise] .

  *** clearFrozen *******************************
  op clearFrozen : NatList Qid TypeList SModule -> SModule [memo] .
  eq clearFrozen(NL,F,TPL,
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [frozen(NL') AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm) .
  eq clearFrozen(NL,F,TPL,M)
   = M [owise] .

  *** clearEqsFrozen *******************************
  op clearEqsFrozen : SModule -> SModule [memo] .
  eq clearEqsFrozen(M)
   = clearEqsFrozen*(M) .

  op clearEqsFrozen* : SModule -> SModule .
  eq clearEqsFrozen*(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [frozen(NL') AtS] .) O:OpDeclSet)
      M:MembAxSet
      ((eq F[TL] = Rhs [AtS'] .) E:EquationSet)
      R:RuleSet endm))
   = clearEqsFrozen*(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [AtS] .) O:OpDeclSet)
      M:MembAxSet
      ((eq F[TL] = Rhs [AtS'] .) E:EquationSet)
      R:RuleSet endm)) .
  eq clearEqsFrozen*(M)
   = M [owise] .

  *** clearAllFrozen *******************************
  op clearAllFrozen : SModule -> SModule [memo] .
  eq clearAllFrozen(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet
      M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix '-CLEARFROZEN To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      clearAllFrozen(O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm) .

  op clearAllFrozen : FModule -> FModule [memo] .
  eq clearAllFrozen(
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet
      M:MembAxSet E:EquationSet endfm))
   = (fmod (addsufix '-CLEARFROZEN To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      clearAllFrozen(O:OpDeclSet)
      M:MembAxSet E:EquationSet endfm) .

  op clearAllFrozen : OpDeclSet -> OpDeclSet .
  eq clearAllFrozen(none)
   = none .
  eq clearAllFrozen(
      (op F : TPL -> TP [frozen(NL) AtS] .) O:OpDeclSet)
   = (op F : TPL -> TP [AtS] .)
     clearAllFrozen(O:OpDeclSet) .
  eq clearAllFrozen(
      (op F : TPL -> TP [AtS] .) O:OpDeclSet)
   = (op F : TPL -> TP [AtS] .)
     clearAllFrozen(O:OpDeclSet) [owise] .

  *** anyNonExec *******************************
  op anyNonExec : SModule -> Bool [memo] .
  eq anyNonExec(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm))
   = anyNonExec(E:EquationSet) or-else anyNonExec(R:RuleSet) .

  op anyNonExec : RuleSet -> Bool .
  eq anyNonExec(
      (rl Lhs => Rhs [nonexec AtS] .) R:RuleSet)
   = true .
  eq anyNonExec(
      (crl Lhs => Rhs if Cond [nonexec AtS] .) R:RuleSet)
   = true .
  eq anyNonExec(R:RuleSet)
   = false [owise] .

  op anyNonExec : EquationSet -> Bool .
  eq anyNonExec(
      (eq Lhs = Rhs [nonexec AtS] .) R:EquationSet)
   = true .
  eq anyNonExec(
      (ceq Lhs = Rhs if Cond [nonexec AtS] .) R:EquationSet)
   = true .
  eq anyNonExec(R:EquationSet)
   = false [owise] .

  *** clearNonExec *******************************
  op clearNonExecRls&Eqs : SModule -> SModule [memo] .
  eq clearNonExecRls&Eqs(M:SModule)
   = clearNonExecRls(clearNonExecEqs(M:SModule)) .

  op clearNonExecRls : SModule -> SModule [memo] .
  eq clearNonExecRls(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix '-CLEARNONEXEC To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet
        E:EquationSet clearNonExec(R:RuleSet) endm) .

  op clearNonExecEqs : SModule -> SModule [memo] .
  eq clearNonExecEqs(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix '-CLEARNONEXEC To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet
        clearNonExec(E:EquationSet) R:RuleSet endm) .

  op clearNonExecEqs : FModule -> FModule [memo] .
  eq clearNonExecEqs(
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet endfm))
   = (fmod (addsufix '-CLEARNONEXEC To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet
        clearNonExec(E:EquationSet) endfm) .

  op clearNonExec : RuleSet -> RuleSet .
  eq clearNonExec((none).RuleSet)
   = (none).RuleSet .
  eq clearNonExec(
      (rl Lhs => Rhs [nonexec AtS] .) R:RuleSet)
   = (rl Lhs => Rhs [AtS] .)
     clearNonExec(R:RuleSet) .
  eq clearNonExec(
      (rl Lhs => Rhs [AtS] .) R:RuleSet)
   = (rl Lhs => Rhs [AtS] .)
     clearNonExec(R:RuleSet) [owise] .

  op clearNonExec : EquationSet -> EquationSet .
  eq clearNonExec((none).EquationSet)
   = (none).EquationSet .
  eq clearNonExec(
      (eq Lhs = Rhs [nonexec AtS] .) R:EquationSet)
   = (eq Lhs = Rhs [AtS] .)
     clearNonExec(R:EquationSet) .
  eq clearNonExec(
      (eq Lhs = Rhs [AtS] .) R:EquationSet)
   = (eq Lhs = Rhs [AtS] .)
     clearNonExec(R:EquationSet) [owise] .

  *** eraseRls *******************************
  op eraseRls : Module -> Module [memo] .
  eq eraseRls(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet none endm) .
  eq eraseRls(
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet endfm))
   = (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet endfm) .

  *** eraseEqs *******************************
  op eraseEqs : Module -> Module [memo] .
  eq eraseEqs(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet none R:RuleSet endm) .
  eq eraseEqs(
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet endfm))
   = (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet none endfm) .

  *** flatten  ******************************
  op flatten : Module TermList -> TermList .
  eq flatten(M,V) = V .
  eq flatten(M,C) = C .
  eq flatten(M,F[TL:NeTermList])
   = if isAssociative(M,F,getTypes(M,TL:NeTermList))
     then F[aliens(TL:NeTermList,F)]
     else F[flatten(M,TL:NeTermList)]
     fi .
  eq flatten(M,(T:Term,TL:NeTermList))
   = (flatten(M,T:Term),flatten(M,TL:NeTermList)) .

  op aliens : TermList Qid -> TermList .
  eq aliens(empty,F) = empty .
  eq aliens((F[TL':NeTermList],TL:TermList),F)
   = aliens((TL':NeTermList,TL:TermList),F) .
  eq aliens((T:Term,TL:TermList),F)
   = (T:Term,aliens(TL:TermList,F)) [owise] .

  *** unflatten  ******************************
  op unflatten : Module TermList -> TermList .
  eq unflatten(M,T) = unflatten*(M,T) .

  op unflatten* : Module TermList -> TermList .
  eq unflatten*(M,V) = V .
  eq unflatten*(M,C) = C .
  eq unflatten*(M,F[TL:NeTermList])
   = if isAssociative(M,F,getTypes(M,TL:NeTermList))
     then unflatten**(M,F,TL:NeTermList)
     else F[unflatten*(M,TL:NeTermList)]
     fi .
  eq unflatten*(M,(T:Term,TL:NeTermList))
   = (unflatten*(M,T:Term),unflatten*(M,TL:NeTermList)) .

  op unflatten** : Module Qid TermList -> TermList .
  eq unflatten**(M,F,(T1:Term,TL:NeTermList))
   = F[unflatten*(M,T1:Term),unflatten**(M,F,TL:NeTermList)] .
  eq unflatten**(M,F,T:Term)
   = unflatten*(M,T:Term) .

  *** wrapRules_bySymbol_ *******************************
  op wrapRules_bySymbol_ : SModule Qid -> SModule [memo] .
  eq wrapRules
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet
      M:MembAxSet E:EquationSet R:RuleSet endm)
     bySymbol F:Qid
   = (mod (addsufix F:Qid To (addsufix '-WRAPPED# To Q:Qid))
       is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet
      M:MembAxSet E:EquationSet
      wrapRules R:RuleSet bySymbol F:Qid endm) .

  op wrapRules_bySymbol_ : RuleSet Qid -> RuleSet .
  eq wrapRules none bySymbol F:Qid = none .
  eq wrapRules ((rl Lhs => Rhs [AtS] .) RlS:RuleSet) bySymbol F:Qid
   = (rl F:Qid[Lhs] => F:Qid[Rhs] [AtS] .)
     wrapRules RlS:RuleSet bySymbol F:Qid .
  eq wrapRules ((crl Lhs => Rhs if Cond [AtS] .) RlS:RuleSet) bySymbol F:Qid
   = (crl F:Qid[Lhs] => F:Qid[Rhs] if Cond [AtS] .)
     wrapRules RlS:RuleSet bySymbol F:Qid .

  op toSModule : FModule -> SModule .
  eq toSModule(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   =  mod (addsufix '-CONVERTED#SMODULE To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       none
      endm .

  op newName : Qid SModule -> SModule .
  op newName : Qid FModule -> FModule .
  eq newName(F:Qid,
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = fmod F:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm .
  eq newName(F:Qid,
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod F:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm .

  ***
  op removeBoolEqs : Module -> Module [memo] .
  eq removeBoolEqs(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet
      removeBoolEqs(E:EquationSet)
      R:RuleSet endm) .
  eq removeBoolEqs(
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet endfm))
   = (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet
      removeBoolEqs(E:EquationSet) endfm) .

  op removeBoolEqs : EquationSet -> EquationSet .
  eq removeBoolEqs((eq '_and_[TL] = Rhs [AtS] .) EqS)
   = removeBoolEqs(EqS) .
  eq removeBoolEqs((eq 'not_[TL] = Rhs [AtS] .) EqS)
   = removeBoolEqs(EqS) .
  eq removeBoolEqs((eq '_or_[TL] = Rhs [AtS] .) EqS)
   = removeBoolEqs(EqS) .
  eq removeBoolEqs((eq '_xor_[TL] = Rhs [AtS] .) EqS)
   = removeBoolEqs(EqS) .
  eq removeBoolEqs((eq '_implies_[TL] = Rhs [AtS] .) EqS)
   = removeBoolEqs(EqS) .
  eq removeBoolEqs(EqS)
   = EqS [owise] .

  *******************************************
  op keepOnlyACAttr : Module -> Module [memo] .
  eq keepOnlyACAttr(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix '-REMOVED-ID-SYMBOLS To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      keepOnlyACAttr*(O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm) .
  eq keepOnlyACAttr(
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet endfm))
   = (fmod (addsufix '-REMOVED-ID-SYMBOLS To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      keepOnlyACAttr*(O:OpDeclSet)
      M:MembAxSet E:EquationSet endfm) .

  op keepOnlyACAttr* : OpDeclSet -> OpDeclSet .
  eq keepOnlyACAttr*((op F : TPL -> TP [id(T) AtS] .) OPDS)
   = keepOnlyACAttr*((op F : TPL -> TP [AtS] .) OPDS) .
  eq keepOnlyACAttr*((op F : TPL -> TP [left-id(T) AtS] .) OPDS)
   = keepOnlyACAttr*((op F : TPL -> TP [AtS] .) OPDS) .
  eq keepOnlyACAttr*((op F : TPL -> TP [right-id(T) AtS] .) OPDS)
   = keepOnlyACAttr*((op F : TPL -> TP [AtS] .) OPDS) .
  eq keepOnlyACAttr*(OPDS)
   = removeAssocAttr(OPDS) [owise] .

  op _in#_ : Attr AttrSet -> Bool .
  eq X:Attr in# X:Attr X:AttrSet = true .
  eq X:Attr in# X:AttrSet = false [owise] .

  op removeAssocAttr : OpDeclSet -> OpDeclSet .
  eq removeAssocAttr((op F : TPL -> TP [assoc AtS] .) OPDS)
   = if comm in# AtS
     then (op F : TPL -> TP [assoc AtS] .) removeAssocAttr(OPDS)
     else removeAssocAttr((op F : TPL -> TP [AtS] .) OPDS)
     fi .
  eq removeAssocAttr(OPDS)
   = OPDS [owise] .

  *******************************************
  op keepOnlyACUAttr : Module -> Module [memo] .
  eq keepOnlyACUAttr(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix '-REMOVED-ID-SYMBOLS To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      keepOnlyACUAttr*(O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm) .
  eq keepOnlyACUAttr(
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet endfm))
   = (fmod (addsufix '-REMOVED-ID-SYMBOLS To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      keepOnlyACUAttr*(O:OpDeclSet)
      M:MembAxSet E:EquationSet endfm) .

  op keepOnlyACUAttr* : OpDeclSet -> OpDeclSet .
  eq keepOnlyACUAttr*(OPDS)
   = removeAssocAttr(OPDS) .

endfm

fmod VARIANT is
  pr SUBSTITUTION-HANDLING .
  pr MODULE-HANDLING .
  pr META-LEVEL-MNPA .

  var M : Module .
  vars T T' TS TS' CtTS CtTS' Lhs Rhs : Term .
  vars N N' NextVar NextVar' NextVar'' : Nat .
  var B : Bound .
  var TL TL' : TermList .
  var NeTL : NeTermList .
  var EqS : EquationSet .
  var AtS : AttrSet .
  var Q : Qid .
  vars S S' : Substitution .
  var V : Variable .
  vars TP TP' : Type .
  var C : Constant .
  vars F F' : Qid .

  --- Variants ----------------------------------------------------------
---  sort VariantTriple .
---  op {_,_,_} : Term Substitution Nat -> VariantTriple [ctor] .

  sort VariantTripleSet .
---  subsort VariantTriple < VariantTripleSet .
  subsort Variant < VariantTripleSet .
  op empty : -> VariantTripleSet [ctor] .
  op _|_ : VariantTripleSet VariantTripleSet -> VariantTripleSet
    [ctor assoc comm id: empty prec 65 format (d d n d)] .
---  eq X:VariantTriple | X:VariantTriple = X:VariantTriple .
  eq X:Variant | X:Variant = X:Variant .

  op getTerms : VariantTripleSet -> TermSet .
  eq getTerms({T:Term,S:Substitution,NextVar:Nat}
              | R:VariantTripleSet)
   = T:Term | getTerms(R:VariantTripleSet) .
  eq getTerms((empty).VariantTripleSet)
   = emptyTermSet .

  op getSubstitutions : VariantTripleSet -> SubstitutionSet .
  eq getSubstitutions({T:Term,S:Substitution,NextVar:Nat}
              | R:VariantTripleSet)
   = S:Substitution | getSubstitutions(R:VariantTripleSet) .
  eq getSubstitutions((empty).VariantTripleSet)
   = empty .

  --- Variants ----------------------------------------------------------
  sort VariantFour .
  op {_,_,_,_} : Term Substitution Substitution Nat -> VariantFour [ctor] .

  sort VariantFourSet .
  subsort VariantFour < VariantFourSet .
  op empty : -> VariantFourSet [ctor] .
  op _|_ : VariantFourSet VariantFourSet -> VariantFourSet
    [ctor assoc comm id: empty prec 65 format (d d n d)] .
  eq X:VariantFour | X:VariantFour = X:VariantFour .

endfm

fmod META-MINIMIZE-BINDINGS is
  pr SUBSTITUTION-HANDLING .
  pr MODULE-HANDLING .
  pr SUBSTITUTIONSET .
  pr UNIFICATIONTRIPLESET .
  pr CONVERSION .
  pr META-LEVEL-MNPA .
  pr VARIANT .

  vars M : Module .
  vars T T' T1 T2 T3 : Term .
  vars TL TL' TL1 TL2 TL3 : TermList .
  vars F F' : Qid .
  vars S S' S* S'* : Substitution .
  vars V V' V1 V2 : Variable .
  vars N N' NOld : Nat .
  var US? : [UnificationTripleSet] .
  vars US US' : UnificationTripleSet .
  vars VTS VTS' : VariantFourSet .

  --- minimizeBindings ---
  op minimizeBindingsTerm : Module TermList UnificationTripleSet
                         -> UnificationTripleSet .
  eq minimizeBindingsTerm(M,TL,US)
   = minimizeBindingsTerm(M,TL,highestVar(TL),US) .

  op minimizeBindingsTerm : Module TermList Nat UnificationTripleSet
                         -> UnificationTripleSet .
  eq minimizeBindingsTerm(M,TL,NOld,US)
   = minimizeBindingsTerm*(M,TL,NOld,US,empty) .

  op minimizeBindingsTerm* : Module TermList Nat UnificationTripleSet
                             UnificationTripleSet -> UnificationTripleSet .
  eq minimizeBindingsTerm*(M,TL,NOld,empty,US')
   = US' .
  eq minimizeBindingsTerm*(M,TL,NOld,{S,S',N} | US,US')
   = minimizeBindingsTerm*(M,TL,NOld,US,
        US' | minimizeBindingsTerm**(M,TL,NOld,{S,S',N},S,S')
     ) .

  ****************
  op minimizeBindingsTerm** : Module TermList ---variables to minimize bindings
                             Nat --- or maximum index of variables
                             UnificationTriple Substitution Substitution
                          -> UnificationTriple .
  eq minimizeBindingsTerm**(M,TL',NOld,{S*,S'*,N},none,none)
   = {remDup(S*),remDup(S'*),N} .

 ceq minimizeBindingsTerm**(M,TL',NOld,{S*,V <- V' ; S'*,N},none,V <- V' ; S')
   = minimizeBindingsTerm**(M,TL',NOld,
         {  S* << (V' <- V),    S'* .. (V' <- V),  N},
         none,
         S' .. (V' <- V)
     )
  if V' =/= V and-then not (V in TL') and-then not (V' in TL')
     and-then highestVar(V) < NOld
     and-then highestVar(V') >= NOld
     and-then typeLeq(M,getTypes(M,V),getTypes(M,V')) .

  eq minimizeBindingsTerm**(M,TL',NOld,{S*,V <- T' ; S'*,N},none,V <- T' ; S')
   = minimizeBindingsTerm**(M,TL',NOld,{S*,V <- T' ; S'*,N},none,S')
  [owise] .

 ceq minimizeBindingsTerm**(M,TL',NOld,{V <- V' ; S*,S'*,N},V <- V' ; S,S')
   = minimizeBindingsTerm**(M,TL',NOld,
         { S* << (V' <- V),   S'* .. (V' <- V),   N},
         S << (V' <- V),
         S' .. (V' <- V)
     )
  if V' =/= V and-then V in TL' and-then not (V' in TL')
     and-then typeLeq(M,getTypes(M,V),getTypes(M,V')) .

  eq minimizeBindingsTerm**(M,TL',NOld,{V <- T' ; S*,S'*,N},V <- T' ; S,S')
   = minimizeBindingsTerm**(M,TL',NOld,{V <- T' ; S*,S'*,N},S,S')
  [owise] .

  --- minimizeBindings ---
  op minimizeBindingsTerm : Module TermList VariantFourSet
                         -> VariantFourSet .
  eq minimizeBindingsTerm(M,TL,VTS)
   = minimizeBindingsTerm(M,TL,highestVar(TL),VTS) .

  op minimizeBindingsTerm : Module TermList Nat VariantFourSet
                         -> VariantFourSet .
  eq minimizeBindingsTerm(M,TL,NOld,VTS)
   = minimizeBindingsTerm*(M,TL,NOld,VTS,empty) .

  op minimizeBindingsTerm* : Module TermList Nat VariantFourSet
                             VariantFourSet -> VariantFourSet .
  eq minimizeBindingsTerm*(M,TL,NOld,empty,VTS')
   = VTS' .
  eq minimizeBindingsTerm*(M,TL,NOld,{T,S,S',N} | VTS,VTS')
   = minimizeBindingsTerm*(M,TL,NOld,VTS,
        VTS' | minimizeBindingsTerm**(M,TL,NOld,{T,S,S',N},S,S')
     ) .

  ****************
  op minimizeBindingsTerm** : Module TermList ---variables to minimize bindings
                             Nat --- or maximum index of variables
                             VariantFour Substitution Substitution
                          -> VariantFour .
  eq minimizeBindingsTerm**(M,TL',NOld,{T,S*,S'*,N},none,none)
   = {T,remDup(S*),remDup(S'*),N} .

 ceq minimizeBindingsTerm**(M,TL',NOld,{T,S*,V <- V' ; S'*,N},none,V <- V' ; S')
   = minimizeBindingsTerm**(M,TL',NOld,
         { T << (V' <- V), S* << (V' <- V),    S'* .. (V' <- V),  N},
         none,
         S' .. (V' <- V)
     )
  if V' =/= V and-then not (V in TL') and-then not (V' in TL')
     and-then highestVar(V) < NOld
     and-then highestVar(V') >= NOld
     and-then typeLeq(M,getTypes(M,V),getTypes(M,V')) .

  eq minimizeBindingsTerm**(M,TL',NOld,{T,S*,V <- T' ; S'*,N},none,V <- T' ; S')
   = minimizeBindingsTerm**(M,TL',NOld,{T,S*,V <- T' ; S'*,N},none,S')
  [owise] .

 ceq minimizeBindingsTerm**(M,TL',NOld,{T,V <- V' ; S*,S'*,N},V <- V' ; S,S')
   = minimizeBindingsTerm**(M,TL',NOld,
         { T << (V' <- V), S* << (V' <- V),   S'* .. (V' <- V),   N},
         S << (V' <- V),
         S' .. (V' <- V)
     )
  if V' =/= V and-then V in TL' and-then not (V' in TL')
     and-then typeLeq(M,getTypes(M,V),getTypes(M,V')) .

  eq minimizeBindingsTerm**(M,TL',NOld,{T,V <- T' ; S*,S'*,N},V <- T' ; S,S')
   = minimizeBindingsTerm**(M,TL',NOld,{T,V <- T' ; S*,S'*,N},S,S')
  [owise] .

  ****
  op remDup : Substitution -> Substitution .
  eq remDup(V <- V ; S) = remDup(S) .
  eq remDup(S) = S [owise] .

endfm
fmod TYPEOFNARROWING is
  pr QID .
  pr META-TERM .

  --- TypeOfNarrowing ----------------------------------
  sorts TypeOfNarrowingElem TypeOfNarrowing .
  subsort TypeOfNarrowingElem < TypeOfNarrowing .
  op none : -> TypeOfNarrowing [ctor] .
  op __ : TypeOfNarrowing TypeOfNarrowing -> TypeOfNarrowing
          [ctor assoc comm id: none] .
  ---eq X:TypeOfNarrowingElem X:TypeOfNarrowingElem = X:TypeOfNarrowingElem .

  *** select one and only one of the following
  op full : -> TypeOfNarrowingElem [ctor] .
  op basic : -> TypeOfNarrowingElem [ctor] .
  op variant : -> TypeOfNarrowingElem [ctor] .
  op variant : Nat -> TypeOfNarrowingElem [ctor] .
  op E-rewriting : -> TypeOfNarrowingElem [ctor] .

  *** Extra flags
  op rigidife : Qid -> TypeOfNarrowingElem [ctor] .

  *** Irreducible terms for equational unification to check
  op irrTerms : TermList -> TypeOfNarrowingElem [ctor] .

  op getIrrTerms : TypeOfNarrowing -> TermList .
  eq getIrrTerms(X:TypeOfNarrowing irrTerms(TL:TermList)) = TL:TermList .
  eq getIrrTerms(X:TypeOfNarrowing) = empty [owise] .

  *** select one and only one of the following
  op E-ACU-unify : -> TypeOfNarrowingElem [ctor] .
  op E-ACU-unify-Irr : -> TypeOfNarrowingElem [ctor] .
  op ACU-unify : -> TypeOfNarrowingElem [ctor] .
  op BuiltIn-unify : -> TypeOfNarrowingElem [ctor] .
  op E-BuiltIn-unify : -> TypeOfNarrowingElem [ctor] .
  op E-BuiltIn-unify-Irr : -> TypeOfNarrowingElem [ctor] .

  *** select one and only one of the following
  op noStrategy : -> TypeOfNarrowingElem [ctor] .
  op topmost : -> TypeOfNarrowingElem [ctor] .
  op innermost : -> TypeOfNarrowingElem [ctor] .
  op outermost : -> TypeOfNarrowingElem [ctor] .

  *** select any combination of the following
  op E-normalize-terms : -> TypeOfNarrowingElem [ctor] .
  op normalize-terms : -> TypeOfNarrowingElem [ctor] .
  op computed-normalized-subs : -> TypeOfNarrowingElem [ctor] .
  op applied-normalized-subs : -> TypeOfNarrowingElem [ctor] .
  op minimal-unifiers : -> TypeOfNarrowingElem [ctor] .
  op testUnifier : -> TypeOfNarrowingElem [ctor] .
  op alsoAtVarPosition : -> TypeOfNarrowingElem [ctor] .

  op _in_ : TypeOfNarrowingElem TypeOfNarrowing -> Bool .
  eq X:TypeOfNarrowingElem in X:TypeOfNarrowingElem XS:TypeOfNarrowing
   = true .
  eq variant in variant(N:Nat) XS:TypeOfNarrowing
   = true .
  eq X:TypeOfNarrowingElem in XS:TypeOfNarrowing
   = false [owise] .

  op _!in_ : TypeOfNarrowingElem TypeOfNarrowing -> Bool .
  eq X:TypeOfNarrowingElem !in XS:TypeOfNarrowing
   = not (X:TypeOfNarrowingElem in XS:TypeOfNarrowing) .
  -------------------------------------------------------

  sort TypeOfRelation .
  ops '* '! '+ : -> TypeOfRelation .

  op [_] : TypeOfRelation -> Qid .
  eq [ '+ ] = qid("+") .
  eq [ '* ] = qid("*") .
  eq [ '! ] = qid("!") .

  op typeOfRelation : Qid ~> TypeOfRelation .
  eq typeOfRelation( '+ ) = '+ .
  eq typeOfRelation( '* ) = '* .
  eq typeOfRelation( '! ) = '! .
endfm

fmod IRR-FLAGS is
  sort IrrFlags .
  op __ : IrrFlags IrrFlags -> IrrFlags [assoc comm id: none] .
  op none : -> IrrFlags [ctor] .
  op irreducible : -> IrrFlags [ctor] .
  op reducible : -> IrrFlags [ctor] .
  op minimal-unifiers : -> IrrFlags [ctor] .
endfm

fmod EFLAGS is
  pr TYPEOFNARROWING .
  pr IRR-FLAGS .

  sort EFlags .
  subsort IrrFlags < EFlags .
  op __ : EFlags EFlags -> EFlags [assoc comm id: none] .
  op none : -> EFlags [ctor] .
  op ACUUnify : -> EFlags [ctor] .
  op BuiltInUnify : -> EFlags [ctor] .
  op testUnifier : -> EFlags [ctor] .

  op _in_ : EFlags EFlags -> Bool .
  eq X:EFlags in X:EFlags Y:EFlags = true .
  eq X:EFlags in Y:EFlags = false [owise] .

  op _!in_ : EFlags EFlags -> Bool .
  eq X:EFlags !in Y:EFlags = not (X:EFlags in Y:EFlags) .

  op [_] : EFlags -> TypeOfNarrowing .
  eq [ ACUUnify X:EFlags ] = ACU-unify [ X:EFlags ] .
  eq [ BuiltInUnify X:EFlags ] = BuiltIn-unify [ X:EFlags ] .
  eq [ minimal-unifiers X:EFlags ] = minimal-unifiers [ X:EFlags ] .
  eq [ testUnifier X:EFlags ] = testUnifier [ X:EFlags ] .
  eq [ X:EFlags ] = none [owise] .
endfm

fmod RESULT-CONTEXT-SET is
  protecting META-TERM .
  protecting META-LEVEL-MNPA .
  protecting TERM-HANDLING .
  protecting SUBSTITUTION-HANDLING .
  protecting RENAMING .
  protecting SUBSTITUTIONSET .
  protecting UNIFICATIONTRIPLESET .

  vars T T' TS CtTS : Term .
  var TP : Type .
  vars S S' Subst Subst' : Substitution .
  var NL : NatList .
  var M : Module .
  vars Ct CtS : Context .
  vars RTS RTS' : ResultContextSet .
  vars NextVar N : Nat .
  var TL : TermList .

  op subTerm_of_ : NatList ResultTriple ~> ResultTriple .
  eq subTerm NL of {T,TP,S} = {subTerm NL of T,TP,S} .

  op replaceSubTerm_of_by_ : NatList ResultTriple Term ~> ResultTriple .
  eq replaceSubTerm NL of {T,TP,S} by T' = {replaceSubTerm NL of T by T',TP,S} .

  --- ResultTriple ---------------------------
  --- op {_,_,_} : Term Type Substitution -> ResultTriple [ctor] .

  sort ResultTripleSet .
  subsort ResultTriple < ResultTripleSet .
  op empty : -> ResultTripleSet [ctor] .
  op _|_ : ResultTripleSet ResultTripleSet -> ResultTripleSet
    [ctor assoc comm id: empty prec 65 format (d d n d)] .
  eq X:ResultTriple | X:ResultTriple = X:ResultTriple .

  var RT : ResultTripleSet .

  op _|>_ : ResultTripleSet TermList -> ResultTripleSet .
  eq (empty).ResultTripleSet |> TL = (empty).ResultTripleSet .
  eq ({T,TP,S} | RT) |> TL = {T,TP,S |> TL} | (RT |> TL) .
  eq (failure | RT ) |> TL = failure | (RT |> TL) .

  op getTerms : ResultTripleSet -> TermSet .
  eq getTerms({T:Term,TP:Type,S:Substitution} | R:ResultTripleSet)
   = T:Term | getTerms(R:ResultTripleSet) .
  eq getTerms((empty).ResultTripleSet)
   = emptyTermSet .

  op getSubstitutions : ResultTripleSet -> SubstitutionSet .
  eq getSubstitutions({T,TP,S} | R:ResultTripleSet)
   = S | getSubstitutions(R:ResultTripleSet) .
  eq getSubstitutions((empty).ResultTripleSet)
   = (empty).SubstitutionSet .

  --- ResultContextSet ---------------------------

  --- Flags
  sort Flags Flag .
  subsort Flag < Flags .

  op empty : -> Flags [ctor] .
  op __ : Flags Flags -> Flags [ctor assoc comm id: empty] .
  eq X:Flag X:Flag = X:Flag .

  --- Flag to know whether term is a end point or not
  op end : Bool -> Flag [ctor frozen] .

  op end : Bool Flags -> Flags .
  eq end(B:Bool, end(B':Bool) B:Flags) = end(B:Bool) B:Flags .
  eq end(B:Bool, B:Flags) = end(B:Bool) B:Flags [owise] .

  op end : Flags -> Bool .
  eq end(end(B:Bool) B:Flags) = B:Bool .
  eq end(B:Flags) = false [owise] .
  ---

  sorts TraceNarrowStep TraceNarrow TraceNarrowSet .
  subsort TraceNarrowStep < TraceNarrow < TraceNarrowSet .
  op {_,_,_,_} : Term Substitution Type Rule -> TraceNarrowStep [ctor format (d d d d d n d n d d)] .
  op nil : -> TraceNarrow [ctor] .
  op __ : TraceNarrow TraceNarrow -> TraceNarrow [ctor assoc id: nil format (d n d)] .
  op empty : -> TraceNarrowSet [ctor] .
  op _|_ : TraceNarrowSet TraceNarrowSet -> TraceNarrowSet [ctor assoc comm id: empty format (d n n d)] .

  ---
  sorts ResultContext ResultContextSet ResultContextNeSet .
  op {_,_,_,_,_,_,_,_,_,_,_} :
      Term Type
      Substitution Substitution --- computed subs and applied subst
      Context Context --- Original and WithSubst
      Term Term --- TermWithSubst and ContextWithTermAndSubt
      Nat --- highest index of variable
      TraceNarrow
      Flags
      -> ResultContext [ctor] .

  subsort ResultContext < ResultContextNeSet < ResultContextSet .
  op empty : -> ResultContextSet [ctor] .
  op _|_ : ResultContextSet ResultContextSet -> ResultContextSet
    [ctor assoc comm id: empty prec 65 format (d n d d)] .
  op _|_ : ResultContextNeSet ResultContextSet -> ResultContextNeSet
    [ctor ditto] .
  eq X:ResultContext | X:ResultContext = X:ResultContext .

  op getCTTerm : ResultContext -> Term .
  eq getCTTerm(
      {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags})
   = CtTS:Term .
  op getNextVar : ResultContext -> Nat .
  eq getNextVar(
      {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags})
   = NextVar .
  op getLSubst : ResultContext -> Substitution .
  eq getLSubst(
      {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags})
   = S .
  op getRSubst : ResultContext -> Substitution .
  eq getRSubst(
      {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags})
   = S' .

  op _<<_ : ResultContext UnificationTripleSet -> ResultContextSet .
  eq {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
     << (empty).UnificationTripleSet
   = (empty).ResultContextSet .
  eq {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
     << ({Subst,Subst',N} | SS:UnificationTripleSet)
   = {T,
      TP,
      (S .. Subst) << Subst', (S' .. Subst') << Subst,
      Ct:Context,
      CtS:Context << (Subst ; Subst'),
      TS:Term << (Subst ; Subst'),
      CtTS:Term << (Subst ; Subst'),
      max(NextVar,N + 1),
      (Tr:TraceNarrow << T TP <) << {Subst,Subst',N},
      B:Flags}
     | {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
         << SS:UnificationTripleSet .

  op _<<__< : TraceNarrow Term Type -> TraceNarrow .
  eq (nil).TraceNarrow << T:Term TP:Type <
   = (nil).TraceNarrow .
  eq (Tr:TraceNarrow {T$:Term,none,TP$:Type,R:Rule}) --- Subst none here is special
     << T:Term TP:Type <
   = (Tr:TraceNarrow {T:Term,none,TP:Type,R:Rule}) .
  eq (Tr:TraceNarrow {T$:Term,S:Substitution,TP$:Type,R:Rule})
     << T:Term TP:Type <
   = (Tr:TraceNarrow {T$:Term,S:Substitution,TP$:Type,R:Rule}) [owise] .

  op _<<_ : TraceNarrow UnificationTriple -> TraceNarrow .
  eq (nil).TraceNarrow << {Subst,Subst',N}
   = (nil).TraceNarrow .
  eq (Tr:TraceNarrow {T$:Term,none,TP$:Type,R:Rule}) --- Subst none here is special
     << {Subst,Subst',N}
   = (Tr:TraceNarrow {T$:Term << (Subst ; Subst'),Subst ; Subst',TP$:Type,R:Rule}) .
  eq (Tr:TraceNarrow {T$:Term,S:Substitution,TP$:Type,R:Rule})
     << {Subst,Subst',N}
   = (Tr:TraceNarrow {T$:Term,S:Substitution,TP$:Type,R:Rule}) [owise] .

  op toTriple : Module ResultContextSet -> ResultTripleSet .
  eq toTriple(M, empty ) = empty .
  eq toTriple(M, {T,TP,S,S',Ct,CtS,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags} | RTS )
   = {CtTS:Term, leastSort(M,CtTS:Term), S .. S'}
     | toTriple(M,RTS) .

  op _|>_ : ResultContextSet TermList -> ResultContextSet .
  eq (empty).ResultContextSet |> TL = (empty).ResultContextSet .
  eq ({T,TP,S,S',Ct,CtS,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
      | RTS:ResultContextSet) |> TL
   = {T,TP,S |> TL,S' |> TL,Ct,CtS,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
     | (RTS:ResultContextSet |> TL) .

  op getTerms : ResultContextSet -> TermSet .
  eq getTerms({T,TP,S,S',Ct,CtS,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags} | RTS)
   = CtTS:Term | getTerms(RTS) .
  eq getTerms((empty).ResultContextSet)
   = emptyTermSet .

  op toUnificationTriples : ResultContextSet -> UnificationTripleSet .
  eq toUnificationTriples(
      {T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags} | R:ResultContextSet)
   = {S,S',NextVar}
     | toUnificationTriples(R:ResultContextSet) .
  eq toUnificationTriples((empty).ResultContextSet)
   = (empty).UnificationTripleSet .

  *** auxiliary Sort SubstitutionCond for metaNarrowSearch *****
  sort SubstitutionCond .
  subsort Substitution < SubstitutionCond .

  op |_| : ResultTripleSet -> Nat .
  eq | (empty).ResultTripleSet | = 0 .
  eq | (RT:ResultTriple | RTS:ResultTripleSet) |
   = | RTS:ResultTripleSet | + 1 .

  op |_| : ResultContextSet -> Nat .
  eq | (empty).ResultContextSet | = 0 .
  eq | (RT:ResultContext | RTS:ResultContextSet) |
   = | RTS:ResultContextSet | + 1 .

endfm

fmod META-MATCH is
  protecting TERM-HANDLING .
  protecting MODULE-HANDLING .
  protecting SUBSTITUTION-HANDLING .
  protecting META-LEVEL-MNPA .
  protecting RENAMING .
  protecting SUBSTITUTIONSET .

  vars T T' : Term .
  vars TL TL' : TermList .
  var M : Module .
  vars S S' : Substitution .
  var S? : Substitution? .
  vars SS SS' : SubstitutionSet .
  vars V V' : Variable .
  vars TPL TPL' : TypeList .
  vars N N' : Nat .

  --- Not defined in this module ----------------------------------------
  op isNF$ : Module Term ~> Bool .
  --- Not defined in this module ----------------------------------------

  --- metaCoreMatch(M,T,T') implies that T is an instance of T'
  op metaCoreMatch : Module Term Term -> SubstitutionSet .
  eq metaCoreMatch(M,T,T')
   = metaCoreMatch$(M,canonice(M,T),canonice(M,T')) .

  op metaCoreMatch$ : Module Term Term -> SubstitutionSet .
  eq metaCoreMatch$(M,T,T')
   = if glbSorts(M,leastSort(M,T),leastSort(M,T')) == none
     then empty
     else metaCoreMatchCollect(eraseEqs(eraseRls(M)),T,T')
     fi .

  op metaCoreMatch? : Module Term Term -> Bool .
  eq metaCoreMatch?(M,T,T')
   = metaCoreMatch?$(M,canonice(M,T),canonice(M,T')) .

  op metaCoreMatch?$ : Module Term Term -> Bool .
  eq metaCoreMatch?$(M,T,T')
   = glbSorts(M,leastSort(M,T),leastSort(M,T')) =/= none
     and-then
     metaMatch(eraseEqs(eraseRls(M)),T',T,nil,0) =/= noMatch .

  --- metaCoreMatchCollect(M,T,T') calls Maude metaMatch
  op metaCoreMatchCollect : Module Term Term -> SubstitutionSet .
  eq metaCoreMatchCollect(M,T,T')
   = metaCoreMatchCollect*(M,T,T',empty,0) .

  op metaCoreMatchCollect* : Module Term Term SubstitutionSet Nat
                             -> SubstitutionSet .
  eq metaCoreMatchCollect*(M,T,T',SS,N:Nat)
   = if metaMatch(M,T',T,nil,N:Nat) =/= noMatch
     then metaCoreMatchCollect*(M,T,T',
                            SS | metaMatch(M,T',T,nil,N:Nat),
                            s(N:Nat))
     else SS
     fi .

  op metaBuiltInEqual : Module TermList Term Term -> Bool .
  eq metaBuiltInEqual(M,TL,T,T')
   = canonice(M,T) == canonice(M,T') .

endfm
fmod VARIANT-HANDLING is
  pr SUBSTITUTION-HANDLING .
  pr META-MINIMIZE-BINDINGS .
  pr RESULT-CONTEXT-SET .
  pr MODULE-HANDLING .
  pr META-LEVEL-MNPA .
  pr VARIANT .

  var M : Module .
  vars T T' TS TS' CtTS CtTS' Lhs Rhs : Term .
  vars N N' NextVar NextVar' NextVar'' : Nat .
  var B : Bound .
  var TL TL' : TermList .
  var NeTL : NeTermList .
  var EqS : EquationSet .
  var AtS : AttrSet .
  var Q : Qid .
  vars S S' : Substitution .
  var V : Variable .
  var R RT : ResultContext .
  vars RTS RTS' : ResultContextSet .
  vars TP TP' : Type .
  vars Ct Ct' CtS CtS' : Context .
  var C : Constant .
  vars F F' : Qid .

  var VTS : VariantFourSet .

  op toVariants : Nat ResultContextSet -> VariantFourSet .
  eq toVariants(OldNextVar:Nat,empty)
   = empty .
  eq toVariants(OldNextVar:Nat,{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags} | RTS)
   = {CtTS,S |> OldNextVar:Nat,S' |> OldNextVar:Nat,NextVar}
      | toVariants(OldNextVar:Nat,RTS) .

  op _|>_ : VariantFourSet TermList -> VariantFourSet .
  eq (empty).VariantFourSet |> TL = empty .
  eq ({T,S,S',N} | VTS) |> TL = {T,(S |> TL),(S' |> TL),N} | (VTS |> TL) .

  op getTerms : VariantFourSet -> TermSet .
  eq getTerms({T:Term,S:Substitution,S':Substitution,NextVar:Nat}
              | R:VariantFourSet)
   = T:Term | getTerms(R:VariantFourSet) .
  eq getTerms((empty).VariantFourSet)
   = emptyTermSet .

  op toVariantTripleSet : VariantFourSet -> VariantTripleSet .
  eq toVariantTripleSet(empty)
   = empty .
  eq toVariantTripleSet({T,S,S',NextVar} | VTS)
---    = {T,S ; S',NextVar} | toVariantTripleSet(VTS) .
   = {T,S,NextVar} | toVariantTripleSet(VTS) .

endfm

fmod RIGIDIFE is
  protecting UNIFICATIONTRIPLESET .
  protecting MODULE-HANDLING .
  protecting RESULT-CONTEXT-SET .
  protecting VARIANT .

  vars V V' : Variable .
  var C : Constant .
  vars F Q : Qid .
  vars U U' : UnificationTriple .
  vars US US' : UnificationTripleSet .
  vars S S' S1 S1' S2 S2' S* : Substitution .
  vars Ct CtS Ct' CtS' : Context .
  vars TS TS' CtTS CtTS' : Term .
  var SS : SubstitutionSet .
  var SSe : NeSubstitutionSet .
  vars N N' N1 N2 NextVar : Nat .
  vars T T' : Term .
  vars TL TL' : TermList .
  var NeTL : NeTermList .
  var M : Module .
  var RTS : ResultTripleSet .
  var TP : Type .

  sort PairRigidife .
  op {_,_} : Module TermList -> PairRigidife .
  op getM : PairRigidife -> Module .
  eq getM({M,TL}) = M .
  op getTL : PairRigidife -> TermList .
  eq getTL({M,TL}) = TL .

  *** Transform variables in TermList into constants
  op rigidifeList : Module Qid TermList TermList -> PairRigidife .
  eq rigidifeList(M,Q,TL,empty)
   = {M,TL} .
  eq rigidifeList(M,Q,(T,NeTL),TL)
   = { getM(rigidifeList(getM(rigidifeList(M,Q,T,TL)),Q,NeTL,TL)),
       (getTL(rigidifeList(M,Q,T,TL)),
        getTL(rigidifeList(getM(rigidifeList(M,Q,T,TL)),Q,NeTL,TL))) } .
  eq rigidifeList(M,Q,C,TL)
   = {M,C} .
  eq rigidifeList(M,Q,F[NeTL],TL)
   = {getM(rigidifeList(M,Q,NeTL,TL)),
      F[getTL(rigidifeList(M,Q,NeTL,TL))]} .
  eq rigidifeList(M,Q,V,TL)
   = if V in TL then rigidifeVar***(M,Q,V) else {M,V} fi .

  *** Transform all variables into constants
  op rigidifeAllVar : Module Qid TermList -> PairRigidife .
  eq rigidifeAllVar(M,Q,TL)
   = rigidifeNat(M,Q,TL,0) .

  *** Transform variables above Nat into constants
  op rigidifeNat : Module Qid TermList Nat -> PairRigidife .
  eq rigidifeNat(M,Q,(T,NeTL),N)
   = { getM(rigidifeNat(getM(rigidifeNat(M,Q,T,N)),Q,NeTL,N)),
       (getTL(rigidifeNat(M,Q,T,N)),
        getTL(rigidifeNat(getM(rigidifeNat(M,Q,T,N)),Q,NeTL,N))) } .
  eq rigidifeNat(M,Q,C,N)
   = {M,C} .
  eq rigidifeNat(M,Q,F[NeTL],N)
   = {getM(rigidifeNat(M,Q,NeTL,N)),
      F[getTL(rigidifeNat(M,Q,NeTL,N))]} .
  eq rigidifeNat(M,Q,V,N)
   = if highestVar(V) >= N then rigidifeVar***(M,Q,V) else {M,V} fi .

  *** Transform variables with rigid# into constants
  op rigidifeRigid : Module Qid TermList -> PairRigidife .
  eq rigidifeRigid(M,Q,(T,NeTL))
   = { getM(rigidifeRigid(getM(rigidifeRigid(M,Q,T)),Q,NeTL)),
       (getTL(rigidifeRigid(M,Q,T)),
        getTL(rigidifeRigid(getM(rigidifeRigid(M,Q,T)),Q,NeTL))) } .
  eq rigidifeRigid(M,Q,C)
   = {M,C} .
  eq rigidifeRigid(M,Q,F[NeTL])
   = {getM(rigidifeRigid(M,Q,NeTL)),
      F[getTL(rigidifeRigid(M,Q,NeTL))]} .
  eq rigidifeRigid(M,Q,V)
   = if rfind(string(V), "rigid#", length(string(V))) =/= notFound
     then rigidifeVar***(M,Q,V)
     else {M,V}
     fi .

  *** Basic case for transforming variables into constants
  op rigidifeVar*** : Module Qid Variable -> PairRigidife .
  ceq rigidifeVar***(M,Q,V)
    = {addOps((op qid(F:String) : nil -> getType(V) [none].), M),
       qid(F:String + "." + string(getType(V)))}
   if F:String := "rigid@" + string(Q)
                     + "@" + string(getName(V)) + "@" + string(getType(V)) .

  *** Undo the transformation of variables into constants
  op unrigidife : Qid TermList -> TermList .
  eq unrigidife(Q,(T,NeTL))
   = (unrigidife(Q,T),unrigidife(Q,NeTL)) .
  eq unrigidife(Q,V) = V .
  eq unrigidife(Q,F[TL]) = F[unrigidife(Q,TL)] .
  eq unrigidife(Q,C)
   = if rfind(string(C), "rigid@" + string(Q) + "@", length(string(C)))
          =/= notFound
     then qid(
           string(
             qid(
              substr(string(C),
               rfind(string(C), "rigid@" + string(Q) + "@", length(string(C)))
                + 7 + length(string(Q)),
               rfind(
                substr(string(C),
                  rfind(string(C), "rigid@" + string(Q) + "@", length(string(C)))
                   + 7 + length(string(Q)),
                  length(string(C))),
                "@",length(string(C))
               )
              )
             )
           )
           + ":" +
           string(getType(qid(
                   substr(string(C),
                   rfind(string(C), "rigid@" + string(Q) + "@",
                           length(string(C))) + 7 + length(string(Q)),
                   length(string(C)))
           )))
          )
     else C
     fi .

  op unrigidife : Qid Substitution -> Substitution .
  eq unrigidife(Q,(none).Substitution) = none .
  eq unrigidife(Q,V <- T ; S)
   = unrigidife(Q,V) <- unrigidife(Q,T) ; unrigidife(Q,S) .

  op unrigidife : Qid SubstitutionSet -> SubstitutionSet .
  eq unrigidife(Q,(empty).SubstitutionSet) = empty .
  eq unrigidife(Q,S | SSe)
   = unrigidife(Q,S) | unrigidife(Q,SSe) .

  op unrigidife : Qid UnificationTripleSet -> UnificationTripleSet .
  eq unrigidife(Q,(empty).UnificationTripleSet) = empty .
  eq unrigidife(Q,{S1,S2,N'} | US)
   = {unrigidife(Q,S1),unrigidife(Q,S2),N'}
     | unrigidife(Q,US) .

  op unrigidife : Qid ResultTripleSet -> ResultTripleSet .
  eq unrigidife(Q,(empty).ResultTripleSet) = empty .
  eq unrigidife(Q,{T,TP,S} | RTS)
   = {unrigidife(Q,T),TP,unrigidife(Q,S)}
     | unrigidife(Q,RTS) .

  op unrigidife : Qid VariantFourSet -> VariantFourSet  .
  eq unrigidife(Q,(empty).VariantFourSet) = empty .
  eq unrigidife(Q,{T,S,S',N} | R:VariantFourSet)
   = {unrigidife(Q,T),unrigidife(Q,S),unrigidife(Q,S'),N}
     | unrigidife(Q,R:VariantFourSet) .

  *** Label variables with rigid
  op rigidLabel : Module TermList TermList -> TermList .
  eq rigidLabel(M,TL,empty)
   = TL .
  eq rigidLabel(M,(T,NeTL),TL)
   = rigidLabel(M,T,TL), rigidLabel(M,NeTL,TL) .
  eq rigidLabel(M,C,TL)
   = C .
  eq rigidLabel(M,F[NeTL],TL)
   = F[rigidLabel(M,NeTL,TL)] .
  eq rigidLabel(M,V,TL)
   = if V in TL then rigidLabel***(M,V) else V fi .

  op rigidLabel*** : Module Variable -> Variable .
  eq rigidLabel***(M,V)
   = qid("rigid#" + string(getName(V)) + ":" + string(getType(V))) .

  *** Undo the transformation of variables into constants
  op unrigidLabel : TermList -> TermList .
  eq unrigidLabel((T,NeTL))
   = (unrigidLabel(T),unrigidLabel(NeTL)) .
  eq unrigidLabel(C) = C .
  eq unrigidLabel(F[TL]) = F[unrigidLabel(TL)] .
  eq unrigidLabel(V)
   = if rfind(string(V), "rigid#", length(string(V)))
          =/= notFound
     then qid(
          string(getName(qid(
                   substr(string(V),
                   rfind(string(V), "rigid#",
                           length(string(V))) + 6,
                   length(string(V)))
          )))
          + ":" +
          string(getType(qid(
                   substr(string(V),
                   rfind(string(V), "rigid#",
                           length(string(V))) + 6,
                   length(string(V)))
          )))
          )
     else V
     fi .

  op unrigidLabel : Substitution -> Substitution .
  eq unrigidLabel((none).Substitution) = none .
  eq unrigidLabel(V <- T ; S)
   = unrigidLabel(V) <- unrigidLabel(T) ; unrigidLabel(S) .

  op unrigidLabel : SubstitutionSet -> SubstitutionSet .
  eq unrigidLabel((empty).SubstitutionSet) = empty .
  eq unrigidLabel(S | SSe)
   = unrigidLabel(S) | unrigidLabel(SSe) .

  op unrigidLabel : UnificationTripleSet -> UnificationTripleSet .
  eq unrigidLabel((empty).UnificationTripleSet) = empty .
  eq unrigidLabel({S1,S2,N'} | US)
   = {unrigidLabel(S1),unrigidLabel(S2),N'}
     | unrigidLabel(US) .

  op unrigidLabel : ResultTripleSet -> ResultTripleSet .
  eq unrigidLabel((empty).ResultTripleSet) = empty .
  eq unrigidLabel({T,TP,S} | RTS)
   = {unrigidLabel(T),TP,unrigidLabel(S)}
     | unrigidLabel(RTS) .

  op unrigidLabel : ResultContextSet -> ResultContextSet .
  eq unrigidLabel((empty).ResultContextSet) = empty .
  eq unrigidLabel({T,TP,S,S*,Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags} | RTS:ResultContextSet)
   = {unrigidLabel(T),TP,unrigidLabel(S),unrigidLabel(S*),Ct,CtS,unrigidLabel(TS),unrigidLabel(CtTS),NextVar,unrigidLabel(Tr:TraceNarrow),B:Flags}
     | unrigidLabel(RTS:ResultContextSet) .

  op unrigidLabel : TraceNarrow -> TraceNarrow .
  eq unrigidLabel((nil).TraceNarrow) = nil .
  eq unrigidLabel(Tr:TraceNarrow {CtTS:Term,Subst:Substitution,TP:Type,R:Rule})
   = unrigidLabel(Tr:TraceNarrow)
     {unrigidLabel(CtTS:Term),unrigidLabel(Subst:Substitution),TP:Type,R:Rule} .

  op unrigidLabel : VariantFourSet -> VariantFourSet  .
  eq unrigidLabel((empty).VariantFourSet) = empty .
  eq unrigidLabel({T,S,S',N} | R:VariantFourSet)
   = {unrigidLabel(T),unrigidLabel(S),unrigidLabel(S'),N}
     | unrigidLabel(R:VariantFourSet) .

  op qid : Nat -> Qid .
  eq qid(N:Nat) = qid(string(N:Nat,10)) .

endfm

fmod META-E-UNIFICATION is
  pr TYPEOFNARROWING .
  pr EFLAGS .
  pr RESULT-CONTEXT-SET .
  pr SUBSTITUTION-HANDLING .
  pr META-MINIMIZE-BINDINGS .
  pr RESULT-CONTEXT-SET .
  pr MODULE-HANDLING .
  pr META-LEVEL-MNPA .
  pr VARIANT .
  pr RIGIDIFE .

  *** Repeated definitions to avoid cross calls between modules ************
  op normalizedSubstitution? : Module SubstitutionSet -> Bool .
  op metaACUUnify : Module Term Term Nat -> UnificationTripleSet .
  op metaACUUnify? : Module Term Term Nat -> Bool .
  op metaACUUnify* : Module UnificandPair Nat Nat ~> UnificationTriple? .
  op metaCoreUnify : Module Term Term Nat -> UnificationTripleSet .
  op metaCoreUnify? : Module Term Term Nat -> Bool .
  op metaBuiltInUnify : Module TermList Term Term Nat -> UnificationTripleSet .
  op metaBuiltInUnify? : Module TermList Term Term Nat -> Bool .
  op _<=[_]_ : SubstitutionSet Module SubstitutionSet -> Bool .
  op _<=[_]_ : Term Module Term -> Bool .
  *** Repeated definitions to avoid cross calls between modules ************

  var M : Module .
  vars T T' TS TS' CtTS CtTS' Lhs Rhs : Term .
  vars N N' NextVar NextVar' NextVar'' NextVar1 NextVar2 NextVar3 : Nat .
  var B : Bound .
  var TL TL' : TermList .
  var NeTL : NeTermList .
  var EqS : EquationSet .
  var AtS : AttrSet .
  var ON : TypeOfNarrowing .
  var Q : Qid .
  vars US US' US$ : UnificationTripleSet .
  vars U U' : UnificationTriple .
  vars S S' S* S'* S1 S1' S2 S2' S3 S3' : Substitution .
  var V : Variable .
  var R RT : ResultContext .
  vars RTS RTS' : ResultContextSet .
  vars TP TP' : Type .
  vars Ct Ct' CtS CtS' : Context .
  var C : Constant .
  vars F F' : Qid .
  var EF : EFlags .
  vars VT VT' : VariantFour .
  vars VTS VTS' VTS$ : VariantFourSet .
  var IRR : IrrFlags .

  --- metaECoreUnify --------------------------------------------------
  op metaECoreUnify : Module Term Term TermList -> SubstitutionSet .
                     --- Term Lhs
  eq metaECoreUnify(M, T, T',TL)
   = metaEACUUnify(M, T, T',TL) .

  op metaECoreUnify? : Module Term Term TermList -> Bool .
  eq metaECoreUnify?(M, T, T', TL)
   = metaEACUUnify?(M, T, T', TL) .

  --- metaVariantUnify --------------------------------------------------
  op metaVariantUnify : Module Term Term -> SubstitutionSet .
  eq metaVariantUnify(M, T, T') = metaEACUUnify(M, T, T', empty) .

  op metaVariantUnify : Module Term Term TermList -> SubstitutionSet .
  eq metaVariantUnify(M, T, T', TL) = metaEACUUnify(M, T, T', TL) .

  op metaVariantUnify? : Module Term Term TermList -> Bool .
  eq metaVariantUnify?(M, T, T', TL) = metaEACUUnify?(M, T, T', TL) .

  op metaVariantUnify : Module Term Term Nat IrrFlags -> UnificationTripleSet .
  eq metaVariantUnify(M, T, T',NextVar,IRR) = metaEACUUnify(M, T, T',empty,NextVar,IRR) .

  op metaVariantUnify : Module Term Term TermList Nat IrrFlags -> UnificationTripleSet .
  eq metaVariantUnify(M, T, T',TL,NextVar,IRR) = metaEACUUnify(M, T, T',TL,NextVar,IRR) .

  op metaVariantUnify? : Module Term Term TermList Nat IrrFlags -> Bool .
  eq metaVariantUnify?(M, T, T',TL,NextVar,IRR) = metaEACUUnify?(M, T, T',TL,NextVar,IRR) .

  --- metaEACUUnify --------------------------------------------------
  op metaEACUUnify : Module Term Term TermList -> SubstitutionSet .
  eq metaEACUUnify(M, T, T', TL)
   = toSubstitution(metaEACUUnify(M,T,T',TL,highestVar((T,T')) + 1,reducible)) .

  op metaEACUUnify? : Module Term Term TermList -> Bool .
  eq metaEACUUnify?(M, T, T', TL)
   = metaEACUUnify?(M,T,T',TL,highestVar((T,T')) + 1,reducible) .

  op metaEACUUnifyIrr : Module Term Term TermList -> SubstitutionSet .
                    --- T irreducible T' reducible
  eq metaEACUUnifyIrr(M, T, T',TL)
   = toSubstitution(metaEACUUnify(M,T,T',TL,highestVar((T,T')) + 1,irreducible)) .

  op metaEACUUnifyIrr? : Module Term Term TermList -> Bool .
  eq metaEACUUnifyIrr?(M, T, T', TL)
   = metaEACUUnify?(M,T,T',TL,highestVar((T,T')) + 1,irreducible) .

  op metaEACUUnify : Module Term Term TermList Nat IrrFlags -> UnificationTripleSet .
  eq metaEACUUnify(M, T, T',TL,NextVar,IRR)
   = minimizeBindingsTerm(M,Vars(T),NextVar,
          metaEUnify&(M, T, T',TL,NextVar,ACUUnify IRR)
     ) |> (T,T',TL) .

  op metaEACUUnify? : Module Term Term TermList Nat IrrFlags -> Bool .
  eq metaEACUUnify?(M, T, T',TL,NextVar,IRR)
   = metaEUnify&?(M, T, T',TL,NextVar,ACUUnify IRR) .

  --- metaEBuiltInUnify --------------------------------------------------
  op metaEBuiltInUnify : Module Term Term -> SubstitutionSet .
  eq metaEBuiltInUnify(M, T, T') = metaEBuiltInUnify(M, T, T',empty) .

  op metaEBuiltInUnify : Module Term Term TermList -> SubstitutionSet .
  eq metaEBuiltInUnify(M, T, T', TL)
   = toSubstitution(metaEBuiltInUnify(M,T,T',TL,highestVar((T,T')) + 1,reducible)) .

  op metaEBuiltInUnify? : Module Term Term -> Bool .
  eq metaEBuiltInUnify?(M, T, T') = metaEBuiltInUnify?(M, T, T',empty) .

  op metaEBuiltInUnify? : Module Term Term TermList -> Bool .
  eq metaEBuiltInUnify?(M, T, T',TL)
   = metaEBuiltInUnify?(M,T,T',TL,highestVar((T,T')) + 1,reducible) .

  op metaEBuiltInUnifyIrr : Module Term Term -> SubstitutionSet .
  eq metaEBuiltInUnifyIrr(M, T, T') = metaEBuiltInUnifyIrr(M, T, T', empty) .

  op metaEBuiltInUnifyIrr : Module Term Term TermList -> SubstitutionSet .
                          --- T irreducible T' reducible
  eq metaEBuiltInUnifyIrr(M, T, T', TL)
   = toSubstitution(
       metaEBuiltInUnify(M,T,T',TL,highestVar((T,T')) + 1,irreducible)
     ) .

  op metaEBuiltInUnifyIrr? : Module Term Term  -> Bool .
  eq metaEBuiltInUnifyIrr?(M, T, T') = metaEBuiltInUnifyIrr?(M, T, T', empty) .

  op metaEBuiltInUnifyIrr? : Module Term Term TermList -> Bool .
                          --- T irreducible T' reducible
  eq metaEBuiltInUnifyIrr?(M, T, T', TL)
   = metaEBuiltInUnify?(M,T,T',TL,highestVar((T,T')) + 1,irreducible) .

  op metaEBuiltInUnify : Module Term Term TermList Nat IrrFlags
                         -> UnificationTripleSet .
  eq metaEBuiltInUnify(M, T, T',TL,NextVar,IRR)
   = minimizeBindingsTerm(M,Vars(T),NextVar,
        metaEUnify&(M, T, T',TL,NextVar,BuiltInUnify IRR)
     ) |> (T,T') .

  op metaEBuiltInUnify? : Module Term Term TermList Nat IrrFlags -> Bool .
  eq metaEBuiltInUnify?(M, T, T',TL,NextVar,IRR)
   = metaEUnify&?(M, T, T',TL,NextVar,BuiltInUnify IRR) .

  --- metaEUnify --------------------------------------------------
  op metaEUnify& : Module Term Term TermList Nat EFlags -> UnificationTripleSet .
                      --- Term Lhs
  eq metaEUnify&(M,T,T',TL,NextVar,EF)
   = if sameKind(M,leastSort(M,T),leastSort(M,T'))
     then metaEUnify&*(removeBoolEqs(M),T,T',TL,NextVar,EF)
     else empty
     fi .

  op metaEUnify&? : Module Term Term TermList Nat EFlags -> Bool .
                      --- Term Lhs
  eq metaEUnify&?(M,T,T',TL,NextVar,EF)
   = sameKind(M,leastSort(M,T),leastSort(M,T'))
     and-then
     metaEUnify&*?(removeBoolEqs(M),T,T',TL,NextVar,EF) .

  op metaEUnify&* : Module Term Term TermList Nat EFlags -> UnificationTripleSet .
                      --- Term Lhs
  eq metaEUnify&*(M,T,T',TL,NextVar,EF)
   = if metaBuiltInUnify?(M,TL,
          fst(generalize(onlyEqsVariant(M),NextVar,T)),
          fst(generalize(onlyEqsVariant(M),
                         snd(generalize(onlyEqsVariant(M),NextVar,T)),T')),
          snd(generalize(onlyEqsVariant(M),
                         snd(generalize(onlyEqsVariant(M),NextVar,T)),T'))
        )
     then if T == fst(generalize(onlyEqsVariant(M),NextVar,T))
             and
             T' == fst(
                    generalize(onlyEqsVariant(M),
                               snd(generalize(onlyEqsVariant(M),NextVar,T)),T'))
          then --- no narrowing is necessary to unify
               metaBuiltInUnify(M,TL,T,T',NextVar)
          else metaEUnify$(M,T,T',TL,NextVar,EF)
          fi
     else empty
     fi .

  op metaEUnify&*? : Module Term Term TermList Nat EFlags -> Bool .
                      --- Term Lhs
  eq metaEUnify&*?(M,T,T',TL,NextVar,EF)
   = if metaBuiltInUnify?(M,TL,
          fst(generalize(onlyEqsVariant(M),NextVar,T)),
          fst(generalize(onlyEqsVariant(M),
                         snd(generalize(onlyEqsVariant(M),NextVar,T)),T')),
          snd(generalize(onlyEqsVariant(M),
                         snd(generalize(onlyEqsVariant(M),NextVar,T)),T'))
        )
     then if T == fst(generalize(onlyEqsVariant(M),NextVar,T))
             and
             T' == fst(
                    generalize(onlyEqsVariant(M),
                               snd(generalize(onlyEqsVariant(M),NextVar,T)),T'))
          then --- no narrowing is necessary to unify
               metaBuiltInUnify?(M,TL,T,T',NextVar)
          else metaEUnify$?(M,T,T',TL,NextVar,EF)
          fi
     else false
     fi .

  op metaEUnify$ : Module Term Term TermList Nat EFlags -> UnificationTripleSet .
                      --- Term Lhs
  eq metaEUnify$(M,T,T',TL,NextVar,irreducible EF)
   = metaEUnifyCollect(M,T,T',(T,TL),NextVar,0,empty) .
  eq metaEUnify$(M,T,T',TL,NextVar,EF)
   = metaEUnifyCollect(M,T,T',TL,NextVar,0,empty) [owise] .

  op metaEUnify$? : Module Term Term TermList Nat EFlags -> Bool .
                      --- Term Lhs
  eq metaEUnify$?(M,T,T',TL,NextVar,irreducible EF)
   = metaEUnifyCollect?(M,T,T',(T,TL),NextVar,0) .
  eq metaEUnify$?(M,T,T',TL,NextVar,EF)
   = metaEUnifyCollect?(M,T,T',TL,NextVar,0) [owise] .

  op metaEUnifyCollect : Module Term Term TermList Nat Nat
                          UnificationTripleSet
                       -> UnificationTripleSet  .
  eq metaEUnifyCollect(M,T,T',TL,N,N',US)
   = if metaEUnify*(M,T =? T',TL,N,N') :: UnificationTriple?
        and
        metaEUnify*(M,T =? T',TL,N,N') =/= noUnifier
     then metaEUnifyCollect(M,T,T',TL,N,s(N'),
             US | metaEUnify*(M,T =? T',TL,N,N') )
     else US
     fi .

  op metaEUnifyCollect? : Module Term Term TermList Nat Nat
                       -> Bool .
  eq metaEUnifyCollect?(M,T,T',TL,N,N')
   = metaEUnify*(M,T =? T',TL,N,N') :: UnificationTriple?
     and
     metaEUnify*(M,T =? T',TL,N,N') =/= noUnifier .

  *** Code for collection all unifiers
  op metaEUnify* : Module UnificandPair TermList Nat Nat ~> UnificationTriple? .
  eq metaEUnify*(M, T =? T',TL,N,N')
   = metaEUnifyTriple(
       M,
       unflatten(M,T) =? unflatten(M,T'),
       TL,N,N') .

  op metaEUnifyTriple : Module UnificationProblem TermList Nat Nat ~> UnificationTriple? .
  eq metaEUnifyTriple(M,T =? T',TL,N,N')
   = if metaVariantUnify(M,T =? T',TL,N,N') == noUnifier
     then noUnifier
     else {getSubst(metaVariantUnify(M,T =? T',TL,N,N')) |> T,
           getSubst(metaVariantUnify(M,T =? T',TL,N,N')) |> T',
           getNextVar(metaVariantUnify(M,T =? T',TL,N,N'))}
     fi .

  **************************************
  ***** Variant Generation

  op getVariants : Module Term -> VariantFourSet .
  eq getVariants(M,T) = getVariants(M,T,highestVar(T) + 1,reducible BuiltInUnify) .

  op getVariants : Module Term Nat EFlags -> VariantFourSet .
  eq getVariants(M,T,NextVar,EF)
   = unrigidife(qid(NextVar),
      getVariants*(
          getM(rigidifeRigid(M,qid(NextVar),T)),
          getTL(rigidifeRigid(M,qid(NextVar),T)),
          NextVar + 1,EF
      )
     ) .

  op getVariants* : Module Term Nat EFlags -> VariantFourSet .
  eq getVariants*(M,T,NextVar,EF)
   = if howMany(onlyEqsVariant(M),T) == 0
     then {T,none,none,NextVar}
     else if getVariants**(M,T,NextVar,EF) :: VariantFourSet
             and
             getVariants**(M,T,NextVar,EF) =/= empty
          then getVariants**(M,T,NextVar,EF)
          else {T,none,none,NextVar}
          fi
     fi .

  op getVariants** : Module Term Nat EFlags -> VariantFourSet .
  eq getVariants**(M,T,NextVar,EF)
   = minimizeBindingsTerm(M,Vars(T),NextVar,
            getVariants***(M,T,NextVar,empty,0)
     ) .

  op getVariants*** : Module Term Nat VariantFourSet Nat -> VariantFourSet .
  eq getVariants***(M,T,NextVar,VTS,N)
   = if metaGetVariant(M,T,empty,NextVar,N) == noVariant
     then VTS
     else getVariants***$(M,T,NextVar,VTS,N,
             metaGetVariant(M,T,empty,NextVar,N))
     fi .

  op getVariants***$ : Module Term Nat VariantFourSet Nat Variant -> VariantFourSet .
  eq getVariants***$(M,T,NextVar,VTS,N,{T2:Term,S:Substitution,NV2:Nat})
   = getVariants***$$(M,T,NextVar,VTS,N,{T2:Term,S:Substitution,NV2:Nat},
           split({S:Substitution,NV2:Nat},NextVar)  ) .

  op getVariants***$$ : Module Term Nat VariantFourSet Nat Variant UnificationTriple -> VariantFourSet .
  eq getVariants***$$(M,T,NextVar,VTS,N,
         {T2:Term,S:Substitution,NV2:Nat},
         {S1:Substitution,S2:Substitution,NV2:Nat})
   = getVariants***(M,T,NextVar,
             VTS | {T2:Term,S1:Substitution,S2:Substitution,NV2:Nat},
             N + 1) .

  sort PairGeneralize .
  op {_,_} : TermList Nat -> PairGeneralize .
  op fst : PairGeneralize -> TermList .
  eq fst({X:TermList,Y:Nat}) = X:TermList .
  op snd : PairGeneralize -> Nat .
  eq snd({X:TermList,Y:Nat}) = Y:Nat .

  op generalize : Module Nat NeTermList -> PairGeneralize .
  eq generalize(M,NextVar,NeTL)
   = generalize*(M,NextVar,getEqs(M),NeTL) .

  op generalize* : Module Nat EquationSet TermList -> PairGeneralize .
  eq generalize*(M,NextVar,EqS,empty)
   = {empty,NextVar} .
  eq generalize*(M,NextVar,EqS,(T,TL))
   = {(fst(generalize**(M,NextVar,EqS,T)),
       fst(generalize*(M,snd(generalize**(M,NextVar,EqS,T)),EqS,TL))),
      snd(generalize*(M,snd(generalize**(M,NextVar,EqS,T)),EqS,TL))
     } .

  op generalize** : Module Nat EquationSet Term -> PairGeneralize .
  eq generalize**(M,NextVar,EqS,C)
   = {C,NextVar} .
  eq generalize**(M,NextVar,EqS,V)
   = {V,NextVar} .
  ceq generalize**(M,NextVar,(eq F'[TL'] = Rhs [AtS] .) EqS,F[TL])
    = {newVar(NextVar,getKind(M,leastSort(M,F[TL]))),NextVar + 1}
   if F == F'
      and-then
      glbSorts(M,leastSort(M,TL),leastSort(M,TL')) =/= none .
  eq generalize**(M,NextVar,EqS,F[TL])
   = {F[fst(generalize*(M,NextVar,EqS,TL))],
      snd(generalize*(M,NextVar,EqS,TL))}
  [owise] .

  *** Identify bound for terms
  op howMany : Module NeTermList -> Nat .
  eq howMany(M,NeTL)
   = howMany*(M,getEqs(M),NeTL << 0 < ) .

  op howMany* : Module EquationSet TermList -> Nat .
  eq howMany*(M,EqS,empty)
   = 0 .
  eq howMany*(M,EqS,(T,TL))
   = howMany**(M,EqS,T) + howMany*(M,EqS,TL) .

  op howMany** : Module EquationSet Term -> Nat .
  eq howMany**(M,EqS,C)
   = 0 .
  eq howMany**(M,EqS,V)
   = 0 .
  ceq howMany**(M,(eq F'[TL'] = Rhs [AtS] .) EqS,F[TL])
    = 1 + howMany*(M,(eq F'[TL'] = Rhs [AtS] .) EqS,TL)
   if F == F'
      and-then
      glbSorts(M,leastSort(M,TL),leastSort(M,TL')) =/= none
      and-then not isAssociative(M,F,getTypes(M,TL)) .
  ceq howMany**(M,(eq F'[TL'] = Rhs [AtS] .) EqS,F[TL])
    = sd(length(TL),1) + howMany*(M,(eq F'[TL'] = Rhs [AtS] .) EqS,TL)
   if F == F'
      and-then
      glbSorts(M,leastSort(M,TL),leastSort(M,TL')) =/= none
      and-then isCommutative(M,F,getTypes(M,TL))
      and-then isAssociative(M,F,getTypes(M,TL)) .
  eq howMany**(M,EqS,F[TL])
   = howMany*(M,EqS,TL) [owise] .


  *** Identify whether basic or variant narrowing should be used
  op howManyAC : Module NeTermList -> Nat .
  eq howManyAC(M,NeTL)
   = if howManyAC$(M,getEqs(M)) == 0
     then 0
     else howManyAC*(M,getEqs(M),NeTL << 0 < )
     fi .

  op howManyAC* : Module EquationSet TermList -> Nat .
  eq howManyAC*(M,EqS,empty)
   = 0 .
  eq howManyAC*(M,EqS,(T,TL))
   = howManyAC**(M,EqS,T) + howManyAC*(M,EqS,TL) .

  op howManyAC** : Module EquationSet Term -> Nat .
  eq howManyAC**(M,EqS,C)
   = 0 .
  eq howManyAC**(M,EqS,V)
   = 0 .
  ceq howManyAC**(M,(eq F'[TL'] = Rhs [AtS] .) EqS,F[TL])
    = sd(length(TL),1) + howManyAC*(M,(eq F'[TL'] = Rhs [AtS] .) EqS,TL)
   if F == F'
      and-then
      glbSorts(M,leastSort(M,TL),leastSort(M,TL')) =/= none
      and-then isCommutative(M,F,getTypes(M,TL))
      and-then isAssociative(M,F,getTypes(M,TL)) .
  eq howManyAC**(M,EqS,F[TL])
   = howManyAC*(M,EqS,TL) [owise] .

  op length : TermList -> Nat .
  eq length((empty).TermList) = 0 .
  eq length((T:Term,TL:TermList)) = 1 + length(TL:TermList) .

  op howManyAC$ : Module EquationSet -> Nat [memo] .
  eq howManyAC$(M,EqS)
   = howManyAC$$(M,EqS) .

  op howManyAC$$ : Module EquationSet -> Nat .
  eq howManyAC$$(M,none)
   = 0 .
  eq howManyAC$$(M,(eq F[TL] = Rhs [AtS] .) EqS)
    = if isCommutative(M,F,getTypes(M,TL))
         and isAssociative(M,F,getTypes(M,TL))
      then 1 else 0 fi
      + howManyAC$$(M,EqS) .

endfm

fmod META-ACU-UNIFICATION is
  pr TERM-HANDLING .
  pr SUBSTITUTION-HANDLING .
  pr MODULE-HANDLING .
  pr SUBSTITUTIONSET .
  pr UNIFICATIONPAIRSET .
  pr CONVERSION .
  pr META-LEVEL-MNPA .
  pr META-MINIMIZE-BINDINGS .
  pr META-E-UNIFICATION .

  var M : Module .
  vars T T' : Term .
  vars N N' : Nat .
  vars US : UnificationTripleSet .

  --- metaACUUnify --------------------------------------------------
  op metaACUUnify : Module Term Term -> SubstitutionSet .
  eq metaACUUnify(M, T, T')
   = toSubstitution(metaACUUnify(M, T, T', highestVar((T,T')) + 1)) .

  op metaACUUnify? : Module Term Term -> Bool .
  eq metaACUUnify?(M, T, T')
   = metaACUUnify?(M, T, T', highestVar((T,T')) + 1) .

  *** General Call for UnificationPairSet
  op metaACUUnify : Module Term Term Nat -> UnificationTripleSet .
  eq metaACUUnify(M, T, T', N)
   = metaACUUnify$(M, canonice(M,T), canonice(M,T'), N) .

  op metaACUUnify$ : Module Term Term Nat -> UnificationTripleSet .
                      --- Term Lhs
  eq metaACUUnify$(M, T, T', N)
   = if (root(T) =/= root(T')
         and not (root(T) :: Variable) and not (root(T') :: Variable))
        or-else
        glbSorts(M,leastSort(M,T),leastSort(M,T')) == none
     then empty
     else minimizeBindingsTerm(M,Vars(T),N,
              metaACUUnifyCollect(M, T, T',N,0,empty))
     fi .

  op metaACUUnify? : Module Term Term Nat -> Bool .
  eq metaACUUnify?(M, T, T', N)
   = metaACUUnify?$(M, canonice(M,T), canonice(M,T'), N) .

  op metaACUUnify?$ : Module Term Term Nat -> Bool .
  eq metaACUUnify?$(M, T, T', N)
   = glbSorts(M,leastSort(M,T),leastSort(M,T')) =/= none
     and-then
     (metaACUUnify*(M,T =? T',N,0) :: UnificationTriple?
      and
      metaACUUnify*(M,T =? T',N,0) =/= noUnifier) .

  op metaACUUnifyCollect : Module Term Term Nat Nat
                          UnificationTripleSet
                       -> UnificationTripleSet .
  eq metaACUUnifyCollect(M,T,T',N,N',US)
   = if metaACUUnify*(M,T =? T',N,N') :: UnificationTriple?
        and
        metaACUUnify*(M,T =? T',N,N') =/= noUnifier
     then metaACUUnifyCollect(M,T,T',N,s(N'),
             US | metaACUUnify*(M,T =? T',N,N') )
     else US
     fi .

  *** Code for collection all unifiers
  op metaACUUnify* : Module UnificandPair Nat Nat ~> UnificationTriple? .
  eq metaACUUnify*(M, T =? T',N,N')
   = metaUnifyTriple(
       keepOnlyACUAttr(eraseEqs(eraseRls(M))),
       unflatten(M,T) =? unflatten(M,T'),
       N,N') .

  op metaUnifyTriple : Module UnificationProblem Nat Nat ~> UnificationTriple? .
  eq metaUnifyTriple(M,T =? T',N,N')
   = if metaUnify(M,T =? T',N,N') == noUnifier
     then noUnifier
     else {getSubst(metaUnify(M,T =? T',N,N')) |> T,
           getSubst(metaUnify(M,T =? T',N,N')) |> T',
           getNextVar(metaUnify(M,T =? T',N,N'))}
     fi .
endfm

fmod META-UNIFICATION is
  pr META-ACU-UNIFICATION .

  var M : Module .
  var T T' : Term .
  var N : Nat .

  --- metaUnify --------------------------------------------------
  op metaCoreUnify : Module Term Term -> SubstitutionSet .
  eq metaCoreUnify(M, T, T')
   = toSubstitution(metaCoreUnify(M, T, T', highestVar((T,T')) + 1)) .

  op metaCoreUnify : Module Term Term Nat -> UnificationTripleSet .
                    --- Term Lhs
  eq metaCoreUnify(M, T, T', N)
   = metaACUUnify(M, T, T', N)  .

  op metaCoreUnify? : Module Term Term Nat -> Bool .
                    --- Term Lhs
  eq metaCoreUnify?(M, T, T', N)
   = metaACUUnify?(M, T, T', N)  .

endfm

fmod META-MSG-UNIFICATION is
  pr META-ACU-UNIFICATION .
  pr META-MATCH .

  var M : Module .
  vars T T' T1# T2# T1$ T2$ T1 T2 : Term .
  vars N N' N'' N1# N2# : Nat .
  vars S S' S1# S2# LSubst RSubst : Substitution .
  var UP : UnificationProblem .
  vars UTS UTS' : UnificationTripleSet .
  var C : Constant .
  vars V V' V1 V2 V3 : Variable .
  vars F F1 F2 : Qid .
  vars TL TL1 TL1' TL1'' TL2 TL2' TL2'' : TermList .
  var NeTL : NeTermList .

  var U : UnificationPair .
  vars US US' : UnificationPairSet .
  var SS SS' : SubstitutionSet .
  vars TP TP' : Type .
  var TPS : TypeSet .
  var TPL : TypeList .
  var AtS : AttrSet .
  var OPDS : OpDeclSet .

  ******* metaBuiltInMatch ***********************************************
  op metaBuiltInMatch : Module Term Term -> SubstitutionSet .
                           *** T1 instance of T2
  eq metaBuiltInMatch(M, T1, T2)
   = metaCoreMatch(M, T1, T2) .

  op metaBuiltInMatch? : Module Term Term -> Bool .
                           *** T1 instance of T2
  eq metaBuiltInMatch?(M, T1, T2)
   = metaCoreMatch?(M, T1, T2) .

  ******* metaBuiltInUnify ***********************************************
  op metaBuiltInUnify : Module Term Term -> SubstitutionSet .
  eq metaBuiltInUnify(M, T, T')
   = metaBuiltInUnify(M, empty, T, T') .

  op metaBuiltInUnify : Module TermList Term Term -> SubstitutionSet .
  eq metaBuiltInUnify(M, TL T, T')
   = toSubstitution(metaBuiltInUnify(M, TL, T, T', highestVar((T,T')) + 1)) .

  *** General Call for UnificationPairSet
  op metaBuiltInUnify : Module TermList Term Term Nat -> UnificationTripleSet .
                       --- Term Lhs
  eq metaBuiltInUnify(M, TL, T1, T2, N)
   = metaBuiltInUnify(M, T1, T2, N) .

  op metaBuiltInUnify : Module Term Term Nat -> UnificationTripleSet .
  eq metaBuiltInUnify(M, T1, T2, N)
   = metaCoreUnify(M, T1, T2, N) .

  op metaBuiltInUnify? : Module Term Term -> Bool .
  eq metaBuiltInUnify?(M, T, T')
   = metaBuiltInUnify?(M, empty, T, T') .

  op metaBuiltInUnify? : Module TermList Term Term -> Bool .
  eq metaBuiltInUnify?(M, TL, T, T')
   = metaBuiltInUnify?(M, TL, T, T',highestVar((T,T')) + 1) .

  op metaBuiltInUnify? : Module TermList Term Term Nat -> Bool .
  eq metaBuiltInUnify?(M, TL, T1, T2, N)
   = metaBuiltInUnify?(M, T1, T2, N)  .

  op metaBuiltInUnify? : Module Term Term Nat -> Bool .
  eq metaBuiltInUnify?(M, T1, T2, N)
   = metaCoreUnify?(M, T1, T2, N) .


endfm
fmod ORDERS-TERM-SUBSTITUTION is
  protecting TERM-HANDLING .
  protecting SUBSTITUTION-HANDLING .
  protecting META-MATCH .
  protecting META-LEVEL-MNPA .
  protecting META-UNIFICATION .
  protecting META-E-UNIFICATION .
  protecting RENAMING .
  protecting SUBSTITUTIONSET .
  protecting META-MSG-UNIFICATION .

  vars T T' : Term .
  vars TL TL' TL1 TL2 TL3 : TermList .
  var M : Module .
  vars S S' : Substitution .
  vars SS SS' SS'' : SubstitutionSet .
  vars V V' V1 V2 V3 : Variable .
  vars TPL TPL' : TypeList .
  vars N N' : Nat .
  vars F : Qid .
  var C : Constant .

  --- metaEMatch(M,T,T') implies that T is an instance of T' modulo E + axioms
  op metaEMatch : Module Term Term -> SubstitutionSet .
  eq metaEMatch(M,T,T')
   = if metaCoreMatch(M,T,T') =/= empty
     then metaCoreMatch(M,T,T')
     else if metaEBuiltInUnifyIrr?(M,T,T')
          then metaShared-filter(M,T,T',metaEBuiltInUnifyIrr(M,T,T'))
          else empty
          fi
     fi .

  op metaEMatch? : Module Term Term -> Bool .
  eq metaEMatch?(M,T,T')
   = metaCoreMatch?(M,T,T')
     or-else
     metaEBuiltInUnifyIrr?(M,T,T') .

  --- order between terms ---------------------------
  --- T <=[M] T' implies that T' is an instance of T
  op _<=[_]_ : Term Module Term -> Bool .
  eq T <=[M] T' = (metaCoreMatch(M,T',T) |> T) =/= empty .

  --- order between substitutions ---------------------------
  --- Subst <=[M] Subst' implies that Subst' is an instance of Subst
  op _<=[_]_ : SubstitutionSet Module SubstitutionSet -> Bool [ditto] .
  eq SS <=[M] SS'
   = SS <=[empty,M] SS' .

  op _<=[_`,_]_ : SubstitutionSet TermList Module SubstitutionSet -> Bool .
  eq empty <=[TL,M] SS'
   = false .
  eq SS <=[TL,M] SS'
   = SS <=[TL,M]$ SS' [owise] .

  op _<=[_`,_]$_ : SubstitutionSet TermList Module SubstitutionSet -> Bool .
  eq SS <=[TL,M]$ empty
   = true .
  eq SS <=[TL,M]$ (S' | SS')
   = (SS <=[TL,M]* S') and-then SS <=[TL,M]$ SS' .

  op _<=[_`,_]*_ : SubstitutionSet TermList Module Substitution -> Bool .
  eq empty <=[TL,M]* S'
   = false .
  eq (S | SS) <=[TL,M]* S'
   = S <=[TL,M]** S' or-else SS <=[TL,M]* S' .

  op _<=[_`,_]**_ : Substitution TermList Module Substitution -> Bool .
  eq none <=[TL,M]** S'
   = true .
  eq S <=[TL,M]** S'
   = 'Q[1st(gen(TL,S,S'))]
     *<=[
       addSorts('XXX,
       addOps((op 'Q : 3rd(gen(TL,S,S')) -> 'XXX [none] .),
         M))
     ]*
     'Q[2nd(gen(TL,S,S'))]
  [owise] .

  --- T <=[M] T' implies that T' is an instance of T
  --- T and T' can have shared variables
  op _*<=[_]*_ : Term Module Term -> Bool .
  eq T *<=[M]* T'
   = (if anyVars T inVars T'
      then metaCoreMatchShared(M,T',T)
      else metaCoreMatch(M,T',T)
      fi |> T)
     =/= empty .

  sort Triple .
  op {{_`,_`,_}} : TermList TermList TypeList -> Triple .
  op 1st : Triple -> TermList .
  eq 1st({{TL,TL',TPL}}) = TL .
  op 2nd : Triple -> TermList .
  eq 2nd({{TL,TL',TPL}}) = TL' .
  op 3rd : Triple -> TypeList .
  eq 3rd({{TL,TL',TPL}}) = TPL .

  ops gen : TermList Substitution Substitution -> Triple . ---[memo] .
  eq gen(empty,none,none)
   = {{empty,empty,nil}} .
  eq gen((V,TL),none,none)
   = {{(V,1st(gen(TL,none,none))),
       (V,2nd(gen(TL,none,none))),
       (getType(V) 3rd(gen(TL,none,none)))}} .
  eq gen(TL,none,V <- T ; S')
   = {{(V,1st(gen(TL \\ V,none,S'))),
       (T,2nd(gen(TL \\ V,none,S'))),
       (getType(V) 3rd(gen(TL \\ V,none,S')))}} .
  eq gen(TL,V <- T ; S,V <- T' ; S')
   = {{(T,1st(gen(TL \\ V,S,S'))),
       (T',2nd(gen(TL \\ V,S,S'))),
       (getType(V) 3rd(gen(TL \\ V,S,S')))}} .
  eq gen(TL,V <- T ; S,S')
   = {{(T,1st(gen(TL \\ V,S,S'))),
       (V,2nd(gen(TL \\ V,S,S'))),
       (getType(V) 3rd(gen(TL \\ V,S,S')))}}
   [owise] .

  op _\\_ : TermList Variable -> TermList .
  eq (TL,V,TL') \\ V = (TL,TL') .
  eq TL \\ V = TL [owise] .

  --- renaming -----------------------------------------------
  op _=[_]=_ : TermSet Module TermSet -> Bool .
  eq T1:TermSet =[M]= T2:TermSet
   = metaBuiltInRenaming(M,T1:TermSet,T2:TermSet) .

  *****
  op metaBuiltInRenaming : Module TermSet TermSet -> Bool .
  eq metaBuiltInRenaming(M,emptyTermSet,emptyTermSet)
   = true .
 ceq metaBuiltInRenaming(M,T:Term | T:TermSet,T':Term | T':TermSet)
    = metaBuiltInRenaming(M,T:TermSet,T':TermSet)
   if metaBuiltInRenaming$(M,T:Term,T':Term) .
  eq metaBuiltInRenaming(M,T:TermSet,T':TermSet)
   = false [owise] .

  op metaBuiltInRenaming$ : Module Term Term -> Bool .
  eq metaBuiltInRenaming$(M,T:Term,T':Term)
   = canonice(M,nullVars(T)) == canonice(M,nullVars(T'))
     and-then
     (metaBuiltInRenaming$$1(M,canonice(M,T),canonice(M,T'))
      or-else
      metaBuiltInRenaming$$2(M,canonice(M,T),canonice(M,T'))
      ) .

  op metaBuiltInRenaming$$1 : Module Term Term -> Bool .
  eq metaBuiltInRenaming$$1(M,T:Term,T':Term)
   = metaBuiltInRenaming$$1*(
         canonice(M,totalOrder(M,flatten(M,T:Term)) <<( 0 )<),
         canonice(M,totalOrder(M,flatten(M,T':Term)) <<( 0 )<) ) .

  op metaBuiltInRenaming$$1* : Term Term -> Bool .
  eq metaBuiltInRenaming$$1*(T:Term,T':Term) = T:Term == T':Term .

  op totalOrder : Module Term -> Term .
  eq totalOrder(M,C) = C .
  eq totalOrder(M,V) = V .
  eq totalOrder(M,F[TL])
   = if not isCommutative(M,F[TL])
     then F[totalOrderTL(M,TL)]
     else F[reorderTL(M,F,totalOrderTL(M,TL))]
     fi .

  op totalOrderTL : Module TermList -> TermList .
  eq totalOrderTL(M,empty) = empty .
  eq totalOrderTL(M,(T,TL)) = (totalOrder(M,T),totalOrderTL(M,TL)) .

  op reorderTL : Module Qid TermList -> TermList .
  eq reorderTL(M,F,empty) = empty .
  eq reorderTL(M,F,(T,TL))
   = if insertTL(M,F,T,TL) =/= (T,TL)
     then reorderTL(M,F,insertTL(M,F,T,TL))
     else (T,reorderTL(M,F,TL))
     fi .

  op insertTL : Module Qid Term TermList -> TermList .
  eq insertTL(M,F,T',empty) = T' .
  eq insertTL(M,F,T',(T,TL))
   = if canonice(M,F[nullVars(T'),nullVars(T)]) == F[canonice(M,nullVars(T')),canonice(M,nullVars(T))]
     then (T',T,TL)
     else (T,insertTL(M,F,T',TL))
     fi .

  op nullVars : Term -> Term .
  eq nullVars(C) = C .
  eq nullVars(V) = qid("#0:" + string(getType(V))) .
  eq nullVars(F[TL]) = F[nullVarsTL(TL)] .

  op nullVarsTL : TermList -> TermList .
  eq nullVarsTL(empty) = empty .
  eq nullVarsTL((T,TL)) = (nullVars(T),nullVarsTL(TL)) .

  *****
  op metaBuiltInRenaming$$2 : Module Term Term -> Bool .
  eq metaBuiltInRenaming$$2(M,T:Term,T':Term)
   = T == T'
     or-else
     onlyRenamingAny(M,metaBuiltInMatchShared(M,T',T) |> T) .

  *****
  op onlyRenamingAll : Module SubstitutionSet -> Bool .
  eq onlyRenamingAll(M,empty)
   = true .
  eq onlyRenamingAll(M,S | SS)
   = onlyRenaming*(M,S)
     and-then
     onlyRenamingAll(M,SS) .

  op onlyRenamingAny : Module SubstitutionSet -> Bool .
  eq onlyRenamingAny(M,empty)
   = false .
  eq onlyRenamingAny(M,S | SS)
   = onlyRenaming*(M,S)
     or-else
     onlyRenamingAny(M,SS) .

  op onlyRenaming* : Module Substitution -> Bool .
  eq onlyRenaming*(M,(V <- T) ; (V' <- T) ; S)
   = false .
  eq onlyRenaming*(M,S)
   = onlyRenaming**(M,S) [owise] .

  op onlyRenaming** : Module Substitution -> Bool .
 ceq onlyRenaming**(M,(V <- F[TL]) ; S)
   = onlyRenaming*(M,
        canonice(M, S << (V1 <- getIdSymbol(M,F[TL])))
     )
  if getIdSymbol(M,F[TL]) :: Term
  /\ TL1,V1,TL2,V2,TL3 := TL
  /\ typeLeq(M,getType(getIdSymbol(M,F[TL])),getType(V1))
     and-then
     not (V1 in Vars((TL1,TL2,V2,TL3)))
  /\ typeLeq(M,getType(getIdSymbol(M,F[TL])),getType(V2))
     and-then
     not (V2 in Vars((TL1,V1,TL2,TL3))) .
  eq onlyRenaming**(M,S)
   = onlyRenaming***(S) [owise] .

  op onlyRenaming*** : Substitution -> Bool .
  eq onlyRenaming***(none)
   = true .
  eq onlyRenaming***((V <- T) ; S)
   = T :: Variable
     and-then
     getType(V) == getType(T)
     and-then
     onlyRenaming***(S) .

  --- Standard metaMatch does not deal with shared variables between T and T'
  --- metaCoreMatch(M,T,T') implies that T is an instance of T'

  op metaCoreMatchShared : Module Term Term -> SubstitutionSet .
  eq metaCoreMatchShared(M,T,T')
   = metaShared-filter(M,T,T',metaCoreMatch(M,T,T')) .

  op metaBuiltInMatchShared : Module Term Term -> SubstitutionSet .
  eq metaBuiltInMatchShared(M,T,T')
   = metaShared-filter(M,T,T',metaBuiltInMatch(M,T,T')) .

  *******
  op metaShared-filter : Module Term Term SubstitutionSet
                           -> SubstitutionSet .
  eq metaShared-filter(M,T,T',SS)
   = metaShared-filter*(M,T,T',empty,SS) .

  op metaShared-filter* : Module Term Term SubstitutionSet SubstitutionSet
                           -> SubstitutionSet .
  eq metaShared-filter*(M,T,T',SS',empty)
   = SS' .
  eq metaShared-filter*(M,T,T',SS',S | SS)
   = metaShared-filter*(M,T,T',
        if S |> T == none
        then SS' | S
        else SS'
        fi,
     SS ) .


  *** Normalize Substitutions
  op normalizedSubstitution? : Module SubstitutionSet -> Bool .
  eq normalizedSubstitution?(M, empty)
   = true .
  eq normalizedSubstitution?(M, S | SS)
   = normalizedSubstitution?*(M, S) and-then normalizedSubstitution?(M, SS) .

  op normalizedSubstitution?* : Module Substitution -> Bool . ---[memo] .
  eq normalizedSubstitution?*(M, none)
   = true .
  eq normalizedSubstitution?*(M, V <- T ; S:Substitution)
   = isNF$(clearAllFrozen(M),T)
     and-then
     normalizedSubstitution?*(M, S:Substitution) .

  *** Normalize Substitutions
  op |_|`(_`) : SubstitutionSet Module -> SubstitutionSet .
  eq | S:SubstitutionSet |(M)
   = eqNormalizeSubstitution(M,S:SubstitutionSet) .

  op eqNormalizeSubstitution : Module SubstitutionSet -> SubstitutionSet .
  eq eqNormalizeSubstitution(M, empty)
   = empty .
  eq eqNormalizeSubstitution(M, S | SS)
   = eqNormalizeSubstitution*(M, S) | eqNormalizeSubstitution(M, SS) .

  op eqNormalizeSubstitution* : Module Substitution -> Substitution .
  eq eqNormalizeSubstitution*(M, none)
   = none .
  eq eqNormalizeSubstitution*(M, V <- T ; S:Substitution)
   = V <- getTerm(metaReduce(eraseRls(M),T))
     ; eqNormalizeSubstitution*(M, S:Substitution) .

endfm
fmod META-NORMALIZE is
  protecting META-TERM .
  protecting META-LEVEL-MNPA .
  protecting META-UNIFICATION .
  protecting RESULT-CONTEXT-SET .
  protecting ORDERS-TERM-SUBSTITUTION .
  protecting TYPEOFNARROWING .

  vars T T' TOrig Lhs Rhs TS TS' CtTS CtTS' : Term .
  var V : Variable .
  var C : Constant .
  var F : Qid .
  vars TL TL' : TermList .
  var M : Module .
  vars RTS RTS' RTS$ RTS$' : ResultContextSet .
  vars RT RT' : ResultContext .
  vars TP TP' : Type .
  vars S S' S* S'* Subst : Substitution .
  var RLS : RuleSet .
  var Att : AttrSet .
  vars B BN : Bound .
  vars N NextVar NextVar' : Nat .
  var NL : NatList .
  vars Ct CtS Ct' CtS' : Context .
  var ON : TypeOfNarrowing .
  var QQ : TypeOfRelation .

  op |_| : ResultTripleSet -> Nat .
  eq | (empty).ResultTripleSet | = 0 .
  eq | {T,TP,S} | RTS:ResultTripleSet | = s(| RTS:ResultTripleSet |) .

  *** Shortcut to Normalization by rewriting Search
  op metaNormalizeCollect$ : Module Term ~> ResultTripleSet .
  eq metaNormalizeCollect$(M,T)
   = metaNormalizeCollect$(M,{T,leastSort(M,T),none}) .

  op metaNormalizeCollect$ : Module Term Type ~> ResultTripleSet .
  eq metaNormalizeCollect$(M,T,TP)
   = metaNormalizeCollect$(M,{T,TP,none}) .

  op metaNormalizeCollect$ : Module ResultTriple ~> ResultTripleSet .
  eq metaNormalizeCollect$(M,{T,TP,S})
   = metaSearchCollect(M,
       T, (addType TP ToVar 'XXXXXXX),
       '!,unbounded) .

  *** Shortcut to One rewriting step
  op metaOneRewriting$ : Module Term ~> ResultTripleSet .
  eq metaOneRewriting$(M,T)
   = metaOneRewriting$(M,{T,leastSort(M,T),none}) .

  op metaOneRewriting$ : Module Term Type -> ResultTripleSet .
  eq metaOneRewriting$(M,T,TP)
   = metaOneRewriting$(M,{T,TP,none}) .

  op metaOneRewriting$ : Module ResultTriple -> ResultTripleSet .

  eq metaOneRewriting$(M,{T,TP,S})
   = metaSearchCollect(M,
       T, (addType TP ToVar 'XXXXXXX),
       '+,1) .

  *** Use Standard Maude metaSearch
  op metaSearchCollect : Module Term Term TypeOfRelation Bound
                      ~> ResultTripleSet .
  eq metaSearchCollect(M,T,T',QQ,B)
   = metaSearchCollect(M,T,T',QQ,B,0) .

  op metaSearchCollect : Module Term Term TypeOfRelation Bound Nat
                      ~> ResultTripleSet .
  eq metaSearchCollect(M,T,T',QQ,B,N:Nat)
   = if metaSearch(M,T,T',nil,[QQ],B,N:Nat) :: ResultTripleSet
        and
        metaSearch(M,T,T',nil,[QQ],B,N:Nat) =/= failure
     then metaSearch(M,T,T',nil,[QQ],B,N:Nat)
          |
          metaSearchCollect(M,T,T',QQ,B,s(N:Nat))
     else empty
     fi .

  *** Shortcut to normal form detection
  op isNF$ : Module Substitution ~> Bool .
  eq isNF$(M, (none).Substitution)
   = true .
  eq isNF$(M, V:Variable <- T:Term ; S:Substitution)
   = isNF$(M,T) and-then isNF$(M, S:Substitution) .

  op isNF$ : Module Term ~> Bool .
  eq isNF$(M,T) = isNF$$(M,T,leastSort(M,T)) .

  op isNF$$ : Module Term Type ~> Bool .
  eq isNF$$(M,T,TP)
   = metaSearch(M,T,(addType TP ToVar 'XXXXXXX),nil,'+,1,0) == failure .

  ***********************************************************************
  --- Not defined in this module-------------
  op metaNarrowSearchAll : Module Term Term SubstitutionCond TypeOfRelation
                            Bound Bound --- number steps / number solutions
                            Bound --- chosen solution
                            TypeOfNarrowing
                            ResultContextSet
			 -> ResultContextSet .
  --- Not defined in this module-------------

  op metaNormalizeCollect : Module Term ~> ResultTripleSet .
  eq metaNormalizeCollect(M,T)
   = if anyNonExec(M)
     then metaNormalizeCollect#(M,T)
     else metaNormalizeCollect$(M,T)
     fi .

  op metaNormalizeCollect : Module Term Type -> ResultTripleSet .
  eq metaNormalizeCollect(M,T,TP)
   = if anyNonExec(M)
     then metaNormalizeCollect#(M,T,TP)
     else metaNormalizeCollect$(M,T,TP)
     fi .

  op metaNormalizeCollect : Module ResultTriple -> ResultTripleSet .
  eq metaNormalizeCollect(M,{T,TP,S})
   = if anyNonExec(M)
     then metaNormalizeCollect#(M,{T,TP,S})
     else metaNormalizeCollect$(M,{T,TP,S})
     fi .

  op metaOneRewriting : Module Term ~> ResultTripleSet .
  eq metaOneRewriting(M,T)
   = if anyNonExec(M)
     then metaOneRewriting#(M,T)
     else metaOneRewriting$(M,T)
     fi .

  op metaOneRewriting : Module Term Type -> ResultTripleSet .
  eq metaOneRewriting(M,T,TP)
   = if anyNonExec(M)
     then metaOneRewriting#(M,T,TP)
     else metaOneRewriting$(M,T,TP)
     fi .

  op metaOneRewriting : Module ResultTriple -> ResultTripleSet .
  eq metaOneRewriting(M,{T,TP,S})
   = if anyNonExec(M)
     then metaOneRewriting#(M,{T,TP,S})
     else metaOneRewriting$(M,{T,TP,S})
     fi .

  --- Based on narrowing -----------------------------
  op metaNormalizeCollect# : Module Term ~> ResultTripleSet .
  eq metaNormalizeCollect#(M,T)
   = metaNormalizeCollect#(M,{T,leastSort(M,T),none}) .

  op metaNormalizeCollect# : Module Term Type -> ResultTripleSet .
  eq metaNormalizeCollect#(M,T,TP)
   = metaNormalizeCollect#(M,{T,TP,none}) .

  ---metaSearch of Maude doesn't work for rules with extra vars
  op metaNormalizeCollect# : Module ResultTriple -> ResultTripleSet .
  eq metaNormalizeCollect#(M,{T,TP,S})
   = toTriple(M,
     metaNarrowSearchAll(
       M,
       T, (addType TP ToVar 'XXXXXXX),
       none,'!,unbounded,unbounded,unbounded,E-rewriting noStrategy,
       {T,TP,S,none,[],[],T << S,T << S,
        max(highestVar(S),highestVar((T,T << S))) + 1,
        nil,
        empty}
     )) .

  op metaOneRewriting# : Module Term ~> ResultTripleSet .
  eq metaOneRewriting#(M,T)
   = metaOneRewriting#(M,{T,leastSort(M,T),none}) .

  op metaOneRewriting# : Module Term Type -> ResultTripleSet .
  eq metaOneRewriting#(M,T,TP)
   = metaOneRewriting#(M,{T,TP,none}) .

  op metaOneRewriting# : Module ResultTriple -> ResultTripleSet .
  eq metaOneRewriting#(M,{T,TP,S})
   = toTriple(M,
     metaNarrowSearchAll(
       M,
       T, (addType TP ToVar 'XXXXXXX),
       none,'+,1,unbounded,unbounded,E-rewriting noStrategy,
       {T,TP,S,none,[],[],T << S,T << S,
        max(highestVar(S),highestVar((T,T << S))) + 1,
        nil,
        empty}
     )) .

  *** Remove itself
  op noSelf : ResultContextSet ResultContextSet -> ResultContextSet .
  eq noSelf(empty,RTS')
   = RTS' .
  eq noSelf({T,TP,S,S*,Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags} | RTS,RTS')
   = noSelf(RTS,
      if TS == T and-then CtTS == T and-then Ct == [] and-then CtS == []
      then noSelf*({T,TP,S,S*,Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags}, RTS')
      else RTS'
      fi
     ) .

  op noSelf* : ResultContext ResultContextSet -> ResultContextSet .
  eq noSelf*(RT,empty)
   = empty .
  eq noSelf*({T,TP,S,S*,[],[],T,T,NextVar,Tr:TraceNarrow,B:Flags},
             {T',TP',S',S'*,Ct',CtS',TS',CtTS',NextVar',Tr':TraceNarrow,B':Flags} | RTS)
   = if TS' == T' and-then CtTS' == T' and-then Ct' == [] and-then CtS' == []
        and-then
        T == T' and-then TP == TP'
        and-then
        (S |> T) == (S' |> T)
     then ---remove
          empty
     else ---keep
          {T',TP',S',S'*,Ct',CtS',TS',CtTS',NextVar',Tr:TraceNarrow,B':Flags}
     fi
     | noSelf*({T,TP,S,S*,[],[],T,T,NextVar,Tr':TraceNarrow,B:Flags},RTS) .

endfm

fmod META-E-NARROWING is
  protecting META-TERM .
  protecting META-LEVEL-MNPA .
  protecting META-UNIFICATION .
  protecting META-MSG-UNIFICATION .
  protecting META-E-UNIFICATION .
  protecting RESULT-CONTEXT-SET .
  protecting ORDERS-TERM-SUBSTITUTION .
  protecting TYPEOFNARROWING .
  protecting META-NORMALIZE .
  protecting UNIFICATIONTRIPLESET .
  protecting RIGIDIFE .

  var T T' T'' TOrig Lhs Lhs' Rhs Rhs'  : Term .
  var CT' TS TS' TS'' CtTS CtTS' CtTS'' : Term .
  var V : Variable .
  var C : Constant .
  var F : Qid .
  var M : Module .
  var RTS RTS' RTS$ RTS-Rls RTS-Sub RTSSol : ResultContextSet .
  var RTNeS : ResultContextNeSet .
  var RT RT' : ResultContext .
  vars S S' S'' Subst Subst' S* S'* : Substitution .
  var SS : SubstitutionSet .
  var RLS : RuleSet .
  var RL : Rule .
  vars Att Att' : AttrSet .
  var B BN : Bound .
  vars N N' N1 N2 : Nat .
  var NL : NatList .
  vars Ct CtS Ct' CtS' Ct'' CtS'' : Context .
  var NeTL NeTL' : NeTermList .
  vars TL TL' TL'' TL''' : TermList .
  vars TP TP' TP'' : Type .
  var ON : TypeOfNarrowing .
  vars NextVar NextVar' NextVar'' NVarPrev : Nat .
  var U : UnificationTriple .
  vars US US' : UnificationTripleSet .
  var IRR : IrrFlags .

  --- metaNarrow ---------------------------
  ---( We implement:
       * basic narrowing, where terms introduced
         by unifiers (substitutions) are never
         selected for narrowing, and
       * standard narrowing, where this
         restriction does not apply  )


  *** Shortcuts to Narrowing
  op metaNarrow : Module Term -> ResultTripleSet .
  eq metaNarrow(M,T) = metaNarrow(M,T,1) .

  op metaNarrow : Module Term Bound -> ResultTripleSet .
  eq metaNarrow(M,T,B)
   = toTriple(M,metaENarrowShowAll(M,T,B,full noStrategy BuiltIn-unify)) |> T .

  *** Shortcuts to Basic Narrowing
  op metaBasicNarrow : Module Term -> ResultTripleSet .
  eq metaBasicNarrow(M,T) = metaBasicNarrow(M,T,1) .

  op metaBasicNarrow : Module Term Bound -> ResultTripleSet .
  eq metaBasicNarrow(M,T,B)
   = toTriple(M,metaENarrowShowAll(M,T,B,basic noStrategy BuiltIn-unify)) |> T .

  *** Shortcuts to Narrowing
  op metaENarrow : Module Term -> ResultTripleSet .
  eq metaENarrow(M,T) = metaENarrow(M,T,1) .

  op metaENarrow : Module Term Bound -> ResultTripleSet .
  eq metaENarrow(M,T,B)
   = toTriple(M,metaENarrowShowAll(M,T,B,full noStrategy E-BuiltIn-unify))
     |> T .

  *** Shortcuts to Narrowing
  op metaEBuiltInTopMostNarrow : Module Term Nat -> ResultTripleSet .
  eq metaEBuiltInTopMostNarrow(M,T,N)
   = metaETopMostNarrow(M,T,1,reducible, E-BuiltIn-unify,N) .
  op metaEBuiltInTopMostNarrowIrr : Module Term Nat -> ResultTripleSet .
  eq metaEBuiltInTopMostNarrowIrr(M,T,N)
   = metaETopMostNarrow(M,T,1,irreducible, E-BuiltIn-unify,N) .

  op metaEACUTopMostNarrow : Module Term Nat -> ResultTripleSet .
  eq metaEACUTopMostNarrow(M,T,N)
   = metaETopMostNarrow(M,T,1,reducible, E-ACU-unify,N) .
  op metaEACUTopMostNarrowIrr : Module Term Nat -> ResultTripleSet .
  eq metaEACUTopMostNarrowIrr(M,T,N)
   = metaETopMostNarrow(M,T,1,irreducible, E-ACU-unify,N) .

  op metaETopMostNarrow : Module Term Bound IrrFlags TypeOfNarrowing Nat
                       -> ResultTripleSet .
  eq metaETopMostNarrow(M,T,B,IRR,ON,N)
   = toTriple(M,metaENarrowShowAll(M,T,B,full topmost ON [IRR],N)) |> T .

  op metaEBuiltInTopMostNarrowRC : Module Term TermList Nat -> ResultContextSet .
  eq metaEBuiltInTopMostNarrowRC(M,T,TL,N)
   = metaETopMostNarrowRC(M,T,1,reducible, E-BuiltIn-unify irrTerms(TL),N) .
  op metaEBuiltInTopMostNarrowRCIrr : Module Term TermList Nat -> ResultContextSet .
  eq metaEBuiltInTopMostNarrowRCIrr(M,T,TL,N)
   = metaETopMostNarrowRC(M,T,1,irreducible, E-BuiltIn-unify irrTerms(TL),N) .

  op metaEACUTopMostNarrowRC : Module Term Nat -> ResultContextSet .
  eq metaEACUTopMostNarrowRC(M,T,N)
   = metaETopMostNarrowRC(M,T,1,reducible, E-ACU-unify,N) .
  op metaEACUTopMostNarrowRCIrr : Module Term Nat -> ResultContextSet .
  eq metaEACUTopMostNarrowRCIrr(M,T,N)
   = metaETopMostNarrowRC(M,T,1,irreducible, E-ACU-unify,N) .

  op metaETopMostNarrowRC : Module Term Bound IrrFlags TypeOfNarrowing Nat
                       -> ResultContextSet .
  eq metaETopMostNarrowRC(M,T,B,IRR,ON,N)
   = metaENarrowShowAll(M,T,B,full topmost ON [IRR],N) |> T .

  --- Auxiliary
  op [_,_] : TypeOfNarrowing IrrFlags ~> TypeOfNarrowing .
  eq [ E-ACU-unify, reducible ] = E-ACU-unify .
  eq [ E-ACU-unify, irreducible ] = E-ACU-unify-Irr .
  eq [ E-BuiltIn-unify, reducible ] = E-BuiltIn-unify .
  eq [ E-BuiltIn-unify, irreducible ] = E-BuiltIn-unify-Irr .

  *** Shortcuts to Basic Narrowing
  op metaEBasicNarrow : Module Term -> ResultTripleSet .
  eq metaEBasicNarrow(M,T)
   = metaEBasicNarrow(M,T,1) .

  *** Shortcuts for normalization
  op metaEBasicNarrow : Module Term Bound -> ResultTripleSet .
  eq metaEBasicNarrow(M,T,B)
   = toTriple(M,metaENarrowShowAll(M,T,B,E-BuiltIn-unify noStrategy basic)) |> T .

  op metaBasicNarrowNormalize : Module Term -> ResultTripleSet .
  eq metaBasicNarrowNormalize(M,T)
   = toTriple(M,metaBasicNarrowNormalizeAll(M,T,highestVar(T) + 1)) |> T .

  op metaBasicNarrowNormalizeAll : Module Term Nat -> ResultContextSet .
  eq metaBasicNarrowNormalizeAll(M,T,NextVar)
   = metaENarrowShowAll(M,T,unbounded,
         basic BuiltIn-unify
         computed-normalized-subs applied-normalized-subs
         normalize-terms noStrategy,NextVar) .

  op metaNarrowNormalize : Module Term -> ResultTripleSet .
  eq metaNarrowNormalize(M,T)
   = toTriple(M,metaNarrowNormalizeAll(M,T,highestVar(T) + 1)) |> T .

  op metaNarrowNormalizeAll : Module Term Nat -> ResultContextSet .
  eq metaNarrowNormalizeAll(M,T,NextVar)
   = metaENarrowShowAll(M,T,unbounded,
         full BuiltIn-unify
         computed-normalized-subs applied-normalized-subs
         normalize-terms noStrategy,NextVar) .

  *** General Call
  op metaENarrowShowAll : Module Term Bound TypeOfNarrowing
                       -> ResultContextSet .
  eq metaENarrowShowAll(M,T,B,ON)
   = metaENarrowShowAll(M,T,B,ON,highestVar(T) + 1) .

  op metaENarrowShowAll : Module Term Bound TypeOfNarrowing Nat
                       -> ResultContextSet .
  eq metaENarrowShowAll(M,T,B,ON,N)
   = metaENarrowGen(removeBoolEqs(M),B,ON,
       {T,leastSort(M,T),none,none,[],[],T,T,N,nil,empty}) .

  *** Call for ResultContextSet
  op metaENarrowGen : Module Bound TypeOfNarrowing
                      ResultContextSet
                   -> ResultContextSet .

  eq metaENarrowGen(M,B,ON,RTS)
   = if B == 0
     then RTS
     else metaENarrowGen*(M,B,ON,empty,empty,RTS)
     fi .

  op metaENarrowGen* : Module
                       Bound TypeOfNarrowing
                       ResultContextSet ResultContextSet ResultContextSet
                    -> ResultContextSet .
  eq metaENarrowGen*(M,B,ON,RTSSol,RTS',empty)
   = if RTS' == empty
        or-else
        (B =/= unbounded and-then B <= 1)
     then RTSSol | RTS' --- Stop
     else metaENarrowGen*(M,dec(B),ON,RTSSol,empty,RTS')
     fi .
  eq metaENarrowGen*(M,B,ON,RTSSol,RTS',RT | RTS)
   = if isEND(normalize-terms?(M,ON,RT))
     then metaENarrowGen*(M,B,ON,
          RTSSol | normalize-terms?(M,ON,RT),
          RTS',RTS)
     else metaENarrowGen*(M,B,ON,RTSSol,
          RTS' |
             filter-variant-RT(M,ON,normalize-terms?(M,ON,RT),
                metaENarrowGen**(M,B,ON,normalize-terms?(M,ON,RT))),
          RTS)
     fi .

  op testNonVarRedex : TypeOfNarrowing Term Term -> Bool .
  eq testNonVarRedex(alsoAtVarPosition ON,T,TS) = true .
  eq testNonVarRedex(ON,T,TS) = testNonVarRedex*(ON,T,TS) [owise] .

  op testNonVarRedex* : TypeOfNarrowing Term Term -> Bool .
  eq testNonVarRedex*(basic ON,T,TS) = not(T :: Variable) .
  eq testNonVarRedex*(ON,T,TS)       = not(TS :: Variable) [owise] .

  op metaENarrowGen** : Module
                        Bound TypeOfNarrowing
                        ResultContext
                     -> ResultContextSet .
  eq metaENarrowGen**(M,B,ON,{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
   = if not testNonVarRedex(ON,T,TS) --- T is a variable
     then if CtS == []
          then *** Term CtTS is a normal form so we return it
               {T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags}
	  else *** Term T is a rigid normal form inside a context Ct
	       *** but since no rewrite has been done and
               *** this can be part of a previous metaNarrowSub call,
               *** this path is discarded
               empty
          fi
     else if metaENarrowStra(M,B,ON,{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
	     =/= empty
          then metaENarrowStra(M,B,ON,{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
          else if CtS == []
               then *** Term CtTS is a normal form so we return it
                    {T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,end(true,B:Flags)}
	       else *** Term T is a rigid normal form inside a context Ct
	            *** but since no rewrite has been done and
                    *** this can be part of a previous metaNarrowSub call,
                    *** this path is discarded
                    empty
               fi
          fi
     fi .

  *** Try all rules at top level of term T in context Ct with metaENarrowRls
  *** Try also inner subterms of T with metaENarrowSub
  *** Note that metaENarrowRls and metaENarrowSub
  *** call to metaNarrow recursively
  op metaENarrowStra : Module Bound TypeOfNarrowing ResultContext
                    -> ResultContextSet .
  ---innermost
  eq metaENarrowStra(M,B,innermost ON,RT)
   = if metaENarrowSub(M,B,innermost ON,RT) =/= empty
     then metaENarrowSub(M,B,innermost ON,RT)
     else metaENarrowRls(M,B,innermost ON,getRls(M),RT)
     fi .

  ---outermost
  eq metaENarrowStra(M,B,outermost ON,RT)
   = if metaENarrowRls(M,B,outermost ON,getRls(M),RT) =/= empty
     then metaENarrowRls(M,B,outermost ON,getRls(M),RT)
     else metaENarrowSub(M,B,outermost ON,RT)
     fi .

  ---topmost
  eq metaENarrowStra(M,B,topmost ON,RT)
   = metaENarrowRls(M,B,topmost ON,getRls(M),RT) .

  ---noStrategy
  eq metaENarrowStra(M,B,noStrategy ON,RT)
   = metaENarrowRls(M,B,noStrategy ON,getRls(M),RT)
     |
     metaENarrowSub(M,B,noStrategy ON,RT) .

  op dec : Bound -> Bound .
  eq dec(unbounded) = unbounded .
  eq dec(s(N)) = N .

  *** Generic call to metaUnification with different parameters
  op auxMetaUnify : Module TypeOfNarrowing
                    Term Term Nat ~> UnificationTripleSet .
		--- Term Lhs
  eq auxMetaUnify(M,variant(N') ON,T,T',N)
   = unrigidife(qid(N'),
       auxMetaUnify*(getM(rigidifeNat(M,qid(N'),T,N')),
                     variant(N') ON,
                     getTL(rigidifeNat(M,qid(N'),T,N')),
                     T',
                     N)
     ) .

  eq auxMetaUnify(M,ON,T,T',N)
   = auxMetaUnify*(M,ON,T,T',N) [owise] .

  op auxMetaUnify* : Module TypeOfNarrowing
                    Term Term Nat ~> UnificationTripleSet .
		--- Term Lhs
 ceq auxMetaUnify*(M,rigidife(F:Qid) ON,T,T',N)
   = unrigidife(Q:Qid,
       auxMetaUnify**(M#:Module,rigidife(F:Qid) ON,T#:Term,T',N)
     )
  if F:Qid[TL:TermList] := T
  /\ Q:Qid := 'auxMetaUnify
  /\ X:PairRigidife := rigidifeRigid(M,Q:Qid,T)
  /\ M#:Module := getM(X:PairRigidife)
  /\ T#:Term := getTL(X:PairRigidife) .

  eq auxMetaUnify*(M,ON,T,T',N)
   = auxMetaUnify**(M,ON,T,T',N) [owise] .

  op auxMetaUnify** : Module TypeOfNarrowing
                     Term Term Nat ~> UnificationTripleSet .
		 --- Term Lhs
                 --- [memo] . --- Very useful but huge space use
  eq auxMetaUnify**(M,E-rewriting ON,T,T',N)
   = toUnificationTriple[N](metaCoreMatch(removeBoolEqs(M),T,T')) .
  eq auxMetaUnify**(M,E-ACU-unify ON,T,T',N)
   = metaEACUUnify(removeBoolEqs(M),T,T',getIrrTerms(ON),N,reducible) .
  eq auxMetaUnify**(M,E-ACU-unify-Irr ON,T,T',N)
   = metaEACUUnify(removeBoolEqs(M),T,T',getIrrTerms(ON),N,irreducible) .
  eq auxMetaUnify**(M,E-BuiltIn-unify ON,T,T',N)
   = metaEBuiltInUnify(removeBoolEqs(M),T,T',getIrrTerms(ON),N,reducible) .
  eq auxMetaUnify**(M,E-BuiltIn-unify-Irr ON,T,T',N)
   = metaEBuiltInUnify(removeBoolEqs(M),T,T',getIrrTerms(ON),N,irreducible) .
  eq auxMetaUnify**(M,ACU-unify ON,T,T',N)
   = metaACUUnify(removeBoolEqs(M),T,T',N) .
  eq auxMetaUnify**(M,BuiltIn-unify ON,T,T',N)
   = metaBuiltInUnify(removeBoolEqs(M),getIrrTerms(ON),T,T',N) .

  *** Remove rigid normal forms
  op removeEND : ResultContextSet -> ResultContextSet .
  eq removeEND(RTS)
   = removeEND*(RTS,empty) .

  op removeEND* : ResultContextSet ResultContextSet -> ResultContextSet .
  eq removeEND*(empty,RTS')
   = RTS' .
  eq removeEND*(RT | RTS,RTS')
   = removeEND*(RTS,if isEND(RT) then RTS' else RTS' | RT fi) .

  op remove_From_ : ResultContextSet ResultContextSet -> ResultContextSet .
  eq remove(RT | RTS) From (RT | RTS')
   = remove(RTS) From (RT | RTS') .
  eq remove(RTS) From (RTS')
   = RTS [owise] .

  op isEND : ResultContext -> Bool .
  eq isEND({T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
   = end(B:Flags) .

  *** Call for Rules ---> Returns empty if no rule is applied
  op metaENarrowRls : Module Bound TypeOfNarrowing
                      RuleSet ResultContext
                   -> ResultContextSet .
  eq metaENarrowRls(M,B,ON,RL RLS,RT)
   = metaENarrowRls#(M,B,ON,RL RLS,RT,empty) .
  eq metaENarrowRls(M,B,ON,none,RT)
   = empty .

  op metaENarrowRls# : Module Bound TypeOfNarrowing
                      RuleSet ResultContext ResultContextSet
                   -> ResultContextSet .
  eq metaENarrowRls#(M,B,ON,none,RT,RTS)
   = RTS .
  eq metaENarrowRls#(M,B,ON,RL RLS,RT,RTS)
   = metaENarrowRls#(M,B,ON,RLS,RT,
      RTS |
        filter-variant-RT(M,ON,RT,
           metaENarrowRls*(M,B,ON,RL,RT)
        )
     ) .

  --- General case
  op metaENarrowRls* : Module Bound TypeOfNarrowing
                       Rule ResultContext
                    -> ResultContextSet .
  eq metaENarrowRls*(M,B,ON,
        (rl Lhs => Rhs [Att].),
	{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
   = metaENarrowRls**$(M,B,ON,
        (rl Lhs => Rhs [Att].),
	{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,
           Tr:TraceNarrow {CtTS,none,leastSort(M,CtTS),(rl Lhs => Rhs [Att].)},
                          --- Subst none here is key to write the real stuff
                          --- later in function _<<_
           B:Flags},
        'rl_=>_`[_`].[Lhs,Rhs,'none.AttrSet] <<{none,NextVar}<) .
  eq metaENarrowRls*(M,B,ON, X:Rule, X:ResultContext)
   = empty [owise] .

  op metaENarrowRls**$ : Module Bound TypeOfNarrowing
                         Rule ResultContext
                         UnificationPair
                      -> ResultContextSet .
  eq metaENarrowRls**$(M,B,ON,
        (rl Lhs => Rhs [Att].),
	{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags},
        {Subst,NextVar'})
   = metaENarrowRls**$$(M,B,ON,
	{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags},
        {Subst,NextVar'},
        'rl_=>_`[_`].[Lhs,Rhs,'none.AttrSet] << Subst) .

  op metaENarrowRls**$$ : Module Bound TypeOfNarrowing
                          ResultContext
                          UnificationPair Term
                       -> ResultContextSet .
  eq metaENarrowRls**$$(M,B,ON,
	{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,
          Tr:TraceNarrow {CtTS,none,TP$:Type,(rl Lhs => Rhs [Att].)},
          B:Flags},
        {Subst,NextVar'},
        'rl_=>_`[_`].[Lhs',Rhs','none.AttrSet])
   = metaENarrowRls**$$$(M,B,ON,
	{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,
           Tr:TraceNarrow {CtTS,none,TP$:Type,(rl Lhs' => Rhs' [Att].)},
           B:Flags},
        {Subst,NextVar'},
        'rl_=>_`[_`].[Lhs',Rhs','none.AttrSet],
        auxMetaUnify(M,ON,TS,Lhs',NextVar')) .

  op metaENarrowRls**$$$ : Module Bound TypeOfNarrowing
                           ResultContext
                           UnificationPair Term UnificationTripleSet
                        -> ResultContextSet .
  eq metaENarrowRls**$$$(M,B,ON,
	{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags},
        {Subst,NextVar'},
        'rl_=>_`[_`].[Lhs',Rhs','none.AttrSet],US)
    = if US =/= empty
      then rebuildTypeAndDiscardErroneous(M,ON,
               {Ct[Rhs'],
	        TP,
		S,S',
		[],
		[],
		CtS[Rhs'],
		CtS[Rhs'],
		NextVar',
                Tr:TraceNarrow,
                B:Flags}
               <<(M,ON) US
            )
      else empty
      fi .

  *** rebuild the context of the applied rule **********************
  op rebuildTypeAndDiscardErroneous : Module TypeOfNarrowing
                                      ResultContextSet -> ResultContextSet .
  eq rebuildTypeAndDiscardErroneous(M,ON,empty)
   = empty .
  eq rebuildTypeAndDiscardErroneous(M,ON,RT | RTS)
   = rebuildTypeAndDiscardErroneous*(M,ON,RT)
     | rebuildTypeAndDiscardErroneous(M,ON,RTS) .

  op rebuildTypeAndDiscardErroneous* : Module TypeOfNarrowing
                                       ResultContext -> ResultContextSet .
  eq rebuildTypeAndDiscardErroneous*(M,ON,
       {T,TP,S,S',[],[],TS,TS,NextVar,Tr:TraceNarrow,B:Flags})
   = if	leastSort(M,TS) :: Type
     then normalize-terms?(M,ON,
             {canonice(M,T),leastSort(M,TS),S,S',
              [],[],canonice(M,TS),canonice(M,TS),
              NextVar,Tr:TraceNarrow,B:Flags})
     else empty
     fi .

  *** auxiliary for variant narrowing **********************
  op _<<`(_`,_`)_ : ResultContext
                    Module TypeOfNarrowing
                    UnificationTripleSet -> ResultContextSet .

  eq RT <<(M,ON) (empty).UnificationTripleSet
   = (empty).ResultContextSet .

  eq {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
     <<(M,ON) ({Subst,Subst',N} | SS:UnificationTripleSet)
   = {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
     <<((M,ON)) {Subst,Subst',N}
     |
     {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
     <<(M,ON) SS:UnificationTripleSet .

  op _<<`(`(_`,_`)`)_ : ResultContext
                        Module TypeOfNarrowing
                        UnificationTriple -> ResultContextSet .

  eq {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
     <<((M,ON)) {Subst,Subst',N}
   = if (variant in ON
         and-then
         (Subst == none
          or-else
          (not anyIdSymbol(M,Subst ; Subst')
           and-then
           normalizedSubstitution?(M,Subst ; Subst'))
          or-else
          anyIdSymbol(M,Subst ; Subst')
         )
        )
        or-else
        (computed-normalized-subs in ON
         and-then normalizedSubstitution?(M,Subst))
        or-else
        (applied-normalized-subs in ON
         and-then normalizedSubstitution?(M,Subst'))
        or-else
        (not variant in ON
         and-then
         not applied-normalized-subs in ON
         and-then
         not computed-normalized-subs in ON)
     then {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
           << if not anyIdSymbol(M,Subst ; Subst')
              then {Subst,Subst',N}
              else {normalizeRls(M,Subst),normalizeRls(M,Subst'),N}
              fi
     else (empty).ResultContextSet
     fi .

  *** test flag normalize-terms and normalize **********************
  *** !!!! This mustn't be combined with basic -> strange behavior
  op normalize-terms? : Module TypeOfNarrowing ResultContext
                     -> ResultContext .
  eq normalize-terms?(M,E-normalize-terms ON,
     {T,TP,S,S',[],[],TS,TS,NextVar,Tr:TraceNarrow,B:Flags})
   = {getTerm(metaReduce(M,T)),
      getType(metaReduce(M,T)),
      S,S',[],[],
      getTerm(metaReduce(M,TS)),
      getTerm(metaReduce(M,TS)),
      NextVar,Tr:TraceNarrow,B:Flags} .
  eq normalize-terms?(M,normalize-terms ON,
     {T,TP,S,S',[],[],TS,TS,NextVar,Tr:TraceNarrow,B:Flags})
   = {getTerm(metaNormalizeCollect(M,T)),
      getType(metaNormalizeCollect(M,T)),
      S,S',[],[],
      getTerm(metaNormalizeCollect(M,TS)),
      getTerm(metaNormalizeCollect(M,TS)),
      NextVar,Tr:TraceNarrow,B:Flags} .
  eq normalize-terms?(M,ON,RT)
   = RT [owise] .

  *** Call at inner subterms
  op metaENarrowSub : Module Bound TypeOfNarrowing ResultContext
                      -> ResultContextSet .
  eq metaENarrowSub(M,B,ON,{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
   = metaENarrowSub#(M,B,ON,flatten(M,auxSplitTerm(ON,T,TS)),
            {T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags}) .

  op auxSplitTerm : TypeOfNarrowing Term Term -> Term .
  eq auxSplitTerm(basic ON,T,TS) = T .
  eq auxSplitTerm(ON,T,TS) = TS [owise] .

  op metaENarrowSub# : Module Bound TypeOfNarrowing Term ResultContext
                      -> ResultContextSet .
  eq metaENarrowSub#(M,B,ON,C,RT) = empty .
  eq metaENarrowSub#(M,B,ON,V,RT) = empty .
  eq metaENarrowSub#(M,B,ON,F[NeTL],RT)
   = metaENarrowSub#Gen(M,B,ON,
       splitTerm(M,F,
                 1,getFrozen(M,F,getTypes(M,NeTL)),
                 isAssociative(M,F,getTypes(M,NeTL))
                 or isCommutative(M,F,getTypes(M,NeTL)),
                 empty,NeTL,RT)) .

  op splitTerm : Module Qid
                 Nat NeNatList Bool
                 TermList TermList
                 ResultContext -> ResultContextSet .

  eq splitTerm(M,F,
               N,NL,AC?:Bool,
               TL',empty,
               RT)
   = empty .

  eq splitTerm(M,F,
               N,NL,AC?:Bool,
               TL',(T,TL),
               {T'',TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
   = if ((not AC?:Bool) and-then N inNatList NL)
        or-else
        (AC?:Bool and-then NL =/= 0)
     then empty
     else {T,leastSort(M,T),S,S',
           Ct[F[TL',[],TL]],
           CtS[F[TL' << (S ; S'),[],TL << (S ; S')]],T << (S ; S'),
           CtTS,NextVar,Tr:TraceNarrow,B:Flags}
     fi
     | splitTerm(M,F,
                 s(N),NL,AC?:Bool,
                 (TL',T),TL,
                 {T'',TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags}) .

  op metaENarrowSub#Gen : Module Bound TypeOfNarrowing ResultContextSet
                       -> ResultContextSet .
  eq metaENarrowSub#Gen(M,B,ON,empty)
   = empty .
  eq metaENarrowSub#Gen(M,B,ON,RT | RTS)
   = metaENarrowGen**(M,B,ON,RT) | metaENarrowSub#Gen(M,B,ON,RTS) .

  op filter-variant-RT : Module TypeOfNarrowing ResultContext
                      ResultContextSet -> ResultContextSet .
  eq filter-variant-RT(M,ON,
          {T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags},RTS)
   = if variant in ON and testUnifier !in ON
     then filter-variant-RT*(M,Vars(TS),empty,RTS)
     else RTS
     fi .

  op filter-variant-RT* :
       Module TermList ResultContextSet ResultContextSet -> ResultContextSet .
  eq filter-variant-RT*(M,TL,RTS$,empty)
   = RTS$ .
  eq filter-variant-RT*(M,TL,RTS$,RT | RTS)
   = filter-variant-RT**(M,TL,RTS$,RTS,RT,RTS) .

  op filter-variant-RT** :
        Module TermList ResultContextSet ResultContextSet
                        ResultContext ResultContextSet -> ResultContextSet .
  eq filter-variant-RT**(M,TL,RTS$,RTS',RT,empty)
   = --- RT is not implied by any in RTS'
     filter-variant-RT*(M,TL,RTS$ | RT,RTS') .
  eq filter-variant-RT**(M,TL,RTS$,RT | RTS',RT',RT | RTS)
   = if test-variant-RT(M,TL,RT,RT')
     then --- RT' is implied by RT in RTS'
          filter-variant-RT*(M,TL,RTS$,RT | RTS')
     else if test-variant-RT(M,TL,RT',RT)
          then --- remove RT from the set RTS'
               filter-variant-RT**(M,TL,RTS$,RTS',RT',RTS)
          else --- continue searching in RTS
               filter-variant-RT**(M,TL,RTS$,RT | RTS',RT',RTS)
          fi
     fi .

  op test-variant-RT : Module TermList ResultContext ResultContext
                    -> Bool .
  eq test-variant-RT(M,TL,
         {T,TP,S,S*,Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags},
         {T',TP',S',S'*,Ct',CtS',TS',CtTS',NextVar',Tr':TraceNarrow,B':Flags})
   = test-variant-RT*(M,TL,S |> TL,S' |> TL) .

  op test-variant-RT* : Module TermList Substitution Substitution -> Bool .
  eq test-variant-RT*(M,TL,S,S')
   = | S | <= | S' |
     and-then
     S <=[TL,M] S' . --- keep T & remove T'

  op |_| : Substitution -> Nat .
  eq | (none).Substitution | = 0 .
  eq | V <- T ; S | = s(| S |) .

endfm

fmod META-NARROWING-SEARCH is
  protecting META-E-NARROWING .
  protecting META-TERM .
  protecting META-LEVEL-MNPA .
  protecting META-UNIFICATION .
  protecting RESULT-CONTEXT-SET .
  protecting ORDERS-TERM-SUBSTITUTION .

  var T T' TOrig Lhs Rhs TS TS' CtTS CtTS' : Term .
  var V : Variable .
  var C : Constant .
  var F : Qid .
  vars TL TL' : TermList .
  var M : Module .
  var RTS RTS' RTSSol : ResultContextSet .
  var RT RT' : ResultContext .
  vars TP TP' : Type .
  vars S S' Subst S* S'* : Substitution .
  var RLS : RuleSet .
  var Att : AttrSet .
  var B BN Sol : Bound .
  var N : Nat .
  var NL : NatList .
  vars Ct Ct' CtS CtS' : Context .
  var ON : TypeOfNarrowing .
  vars QQ QQ' : TypeOfRelation .
  vars NextVar NextVar' : Nat .

  var SCond : SubstitutionCond .

  --- metaNarrowSearch --------------------------------------------------------

  *** Shortcuts to Narrowing Search
  op metaNarrowSearch : Module Term Term SubstitutionCond
                        TypeOfRelation Bound Bound Bound
                        -> ResultTripleSet .
  eq metaNarrowSearch(M,T,T',SCond,QQ,BN,B,Sol)
   = if (BN == unbounded and-then Sol =/= unbounded)
        or-else
        (BN =/= unbounded and-then Sol =/= unbounded and-then BN < Sol)
     then metaNarrowSearch*(M,T,T',SCond,QQ,Sol,B,Sol)
     else metaNarrowSearch*(M,T,T',SCond,QQ,BN,B,Sol)
     fi .

  op metaNarrowSearch* : Module Term Term SubstitutionCond
                         TypeOfRelation Bound Bound Bound
                         -> ResultTripleSet .
  eq metaNarrowSearch*(M,T,T',SCond,QQ,BN,B,Sol)
   = metaNarrowSearchGen(M,T,T',SCond,QQ,BN,B,Sol,
         full E-BuiltIn-unify noStrategy E-normalize-terms) .

  *** Shortcuts to Paramodulation Search
  op metaParamodulationSearch : Module Term Term SubstitutionCond
                                TypeOfRelation Bound Bound Bound
                             -> ResultTripleSet .
  eq metaParamodulationSearch(M,T,T',SCond,QQ,BN,B,Sol)
   = if (BN == unbounded and-then Sol =/= unbounded)
        or-else
        (BN =/= unbounded and-then Sol =/= unbounded and-then BN < Sol)
     then metaParamodulationSearch*(M,T,T',SCond,QQ,Sol,B,Sol)
     else metaParamodulationSearch*(M,T,T',SCond,QQ,BN,B,Sol)
     fi .

  op metaParamodulationSearch* : Module Term Term SubstitutionCond
                         TypeOfRelation Bound Bound Bound
                         -> ResultTripleSet .
  eq metaParamodulationSearch*(M,T,T',SCond,QQ,BN,B,Sol)
   = metaNarrowSearchGen(M,T,T',SCond,QQ,BN,B,Sol,
         full E-BuiltIn-unify noStrategy E-normalize-terms alsoAtVarPosition) .

  *** General Call
  op metaNarrowSearchGen : Module Term Term SubstitutionCond
                           TypeOfRelation
                           Bound --- number of steps
                           Bound --- number of solutions
                           Bound --- chosen solution
                           TypeOfNarrowing
			-> ResultTripleSet .
  eq metaNarrowSearchGen(M,T,T',SCond,QQ,B,BN,Sol,ON)
   = toTriple(M,metaNarrowSearchGenAll(M,T,T',SCond,QQ,B,BN,Sol,ON)) .

  *** Shortcuts to Narrowing Search Path
  op metaNarrowSearchPath : Module Term Term SubstitutionCond
                            TypeOfRelation Bound Bound Bound
                         -> TraceNarrowSet .
  eq metaNarrowSearchPath(M,T,T',SCond,QQ,B,BN,Sol)
   = if (BN == unbounded and-then Sol =/= unbounded)
        or-else
        (BN =/= unbounded and-then Sol =/= unbounded and-then BN < Sol)
     then metaNarrowSearchPath*(M,T,T',SCond,QQ,Sol,B,Sol)
     else metaNarrowSearchPath*(M,T,T',SCond,QQ,BN,B,Sol)
     fi .

  op metaNarrowSearchPath* : Module Term Term SubstitutionCond
                             TypeOfRelation Bound Bound Bound
                          -> TraceNarrowSet .
  eq metaNarrowSearchPath*(M,T,T',SCond,QQ,BN,B,Sol)
   = extractTraces(
       metaNarrowSearchGenAll(M,T,T',SCond,QQ,B,BN,Sol,
         full E-BuiltIn-unify noStrategy E-normalize-terms)) .

  op extractTraces : ResultContextSet -> TraceNarrowSet .
  eq extractTraces(empty) = empty .
  eq extractTraces({T,TP,S,S*,Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags} | RTS)
   = if Tr:TraceNarrow == nil then empty else Tr:TraceNarrow fi
     | extractTraces(RTS) .

  *** Starting Call
  op metaNarrowSearchGenAll : Module Term Term SubstitutionCond
                              TypeOfRelation Bound Bound Bound TypeOfNarrowing
                           -> ResultContextSet .
  eq metaNarrowSearchGenAll(M,T,T',SCond,QQ,B,BN,Sol,ON)
   = metaNarrowSearchGenAll(M,T,T',SCond,QQ,B,BN,Sol,ON,highestVar((T,T')) + 1) .

  op metaNarrowSearchGenAll : Module Term Term SubstitutionCond
                            TypeOfRelation Bound Bound Bound TypeOfNarrowing Nat
                         -> ResultContextSet .
  eq metaNarrowSearchGenAll(M,T,T',SCond,QQ,B,BN,Sol,ON,N)
   = metaNarrowSearchAll(addSorts('Universal,M),
            T,T',SCond,QQ,B,BN,Sol,ON,
            {T,leastSort(M,T),none,none,[],[],T,T,N,nil,empty}) .

  *** One Narrowing step in the search process (including possible filters)
  op metaNarrowStep : Module SubstitutionCond
                      ResultContextSet TypeOfNarrowing
		   -> ResultContextSet .
  eq metaNarrowStep(M,SCond,RTS,ON)
   = filterSCond(M,SCond,metaENarrowGen(M,1,ON,RTS)) .

  *** Filter and normal forms
  op filterSCond : Module SubstitutionCond ResultContextSet
                   -> ResultContextSet .
  eq filterSCond(M,none,RTS)
   = RTS .
  eq filterSCond(M,SCond,RTS)
   = filterSCond*(M,SCond,RTS) [owise] .

  op filterSCond* : Module SubstitutionCond ResultContextSet
                   -> ResultContextSet .
  eq filterSCond*(M,SCond,empty)
   = empty .
  eq filterSCond*(M,SCond,RT | RTS)
   = filterSCond**(M,SCond,RT) | filterSCond*(M,SCond,RTS) .

  op filterSCond** : Module SubstitutionCond ResultContext
                   -> ResultContextSet .
  eq filterSCond**(M,SCond,{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
   = if SCond <=[M] S
     then {T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags}
     else empty
     fi .

  *** Generate next successors in a breadth way
  --- We reuse the metaNarrowSearchAll function
  op metaNarrowSearchAll : Module Term Term SubstitutionCond TypeOfRelation
                            Bound --- number steps
                            Bound --- number solutions
                            Bound --- chosen solution
                            TypeOfNarrowing
                            ResultContextSet
			 -> ResultContextSet .
  eq metaNarrowSearchAll(M,TOrig,T',SCond,QQ,B,BN,Sol,ON,RTS)
   = if QQ == '+
     then noSelf(RTS,
          metaNarrowSearchCheck(M,TOrig,T',SCond,'*,B,BN,Sol,ON,empty,RTS,empty)
          )
     else metaNarrowSearchCheck(M,TOrig,T',SCond,QQ,B,BN,Sol,ON,empty,RTS,RTS)
     fi .

  *** Take only normal forms
  op isNF : Module ResultContext -> Bool .
  eq isNF(M,{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
   = end(B:Flags) or-else metaOneRewriting(M,CtTS) == empty .

  *** Take only normal forms
  op isVariant : Module Nat ResultContextSet ResultContext -> Bool .
  eq isVariant(M,N,
        {T',TP',S',S'*,Ct',CtS',TS',CtTS',NextVar',Tr':TraceNarrow,B':Flags} | RTS,
        {T,TP,S,S*,Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
    = not (
       (S' |> N ; (newVar(N + 1,TP') <- CtTS'))
           <=[M]
       (S |> N ; (newVar(N + 1,TP) <- CtTS))
      )
      and-then
      isVariant(M,N,RTS,{T,TP,S,S*,Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags}) .
  eq isVariant(M,N,RTS,RT)
   = true [owise] .


  *** Generate successors
  op oneMoreStep : Module SubstitutionCond TypeOfNarrowing
                   ResultContextSet -> ResultContextSet [memo] .
  eq oneMoreStep(M,SCond,ON,RTS)
   = remove metaNarrowStep(M,SCond,removeEND(RTS),ON) From RTS .

  *** Check each next successor for conditions
  op metaNarrowSearchCheck : Module Term Term SubstitutionCond
                             TypeOfRelation Bound Bound Bound TypeOfNarrowing
                             ResultContextSet ResultContextSet ResultContextSet
			     -> ResultContextSet .

  eq metaNarrowSearchCheck(M,TOrig,T',SCond,QQ,B,BN,Sol,ON,RTSSol,RTS',empty)
   = if B == 0 or-else BN == 0 or-else Sol == 0 or-else RTS' == empty
     then *** Stop the search
          RTSSol
     else *** Compute Next successors of RTS' with oneMoreStep
          metaNarrowSearchCheck(M,
            TOrig,T',SCond,
            QQ,
            dec(B),BN,Sol,
            ON,
            RTSSol,
            oneMoreStep(M,SCond,ON,RTS'),
            oneMoreStep(M,SCond,ON,RTS')
          )
     fi .

  eq metaNarrowSearchCheck(M,TOrig,T',SCond,QQ,B,BN,Sol,ON,RTSSol,RTS',
         RT | RTS)
   = if isSolution?(M,TOrig,T',QQ,BN,Sol,ON,RTSSol,RT)
        and-then
        auxMetaUnify(M,ON,getCTTerm(RT),T',getNextVar(RT)) =/= empty *** Is actual term an instance of T'?
     then *** This is a solution
          metaNarrowSearchCheck(M,TOrig,T',SCond,QQ,
                  B,dec(BN),dec(Sol),
                  ON,
                  if Sol == unbounded or-else Sol == 1
                  then RT << auxMetaUnify(M,ON,getCTTerm(RT),T',getNextVar(RT))
                  else empty
                  fi
                  | RTSSol,
                  RTS',RTS)
     else *** Continue with the remaining
	  metaNarrowSearchCheck(M,TOrig,T',SCond,QQ,
             B,BN,Sol,ON,RTSSol,RTS',RTS)
     fi .

  op isSolution? : Module Term Term
                   TypeOfRelation Bound Bound TypeOfNarrowing
                   ResultContextSet ResultContext
	        -> Bool .
  eq isSolution?(M,TOrig,T',QQ,BN,Sol,ON,RTSSol,RT)
   = *** Is this the chosen solution?
     (BN == unbounded or-else BN > 0)
     and-then
     *** Is this step correct wrt relations <'!,'*,'+> ?
     ( QQ == '* or-else (QQ == '! and-then isEND(RT)) )
     and-then
     *** Is this a valid variant solution?
     (not (variant in ON) or-else
      (isNF(M,RT) and-then isVariant(M,highestVar(TOrig) + 1,RTSSol,RT))) .

  op upDown : Module ResultTripleSet -> ResultTripleSet .
  eq upDown(M,RTS:ResultTripleSet)
   = upDown#(M,empty,RTS:ResultTripleSet) .
  op upDown# : Module ResultTripleSet ResultTripleSet -> ResultTripleSet .
  eq upDown#(M,RTS':ResultTripleSet, empty)
   = RTS':ResultTripleSet .
  eq upDown#(M,RTS':ResultTripleSet, {T,TP,S} | RTS:ResultTripleSet)
   = upDown#(M,{getTerm(metaReduce(M,T)),TP,upDown(M,S)}
               | RTS':ResultTripleSet,RTS:ResultTripleSet) .

  op upDown : Module Substitution -> Substitution .
  eq upDown(M,S:Substitution)
   = upDown#(M,none,S:Substitution) .
  op upDown# : Module Substitution Substitution -> Substitution .
  eq upDown#(M,S':Substitution,none)
   = S':Substitution .
  eq upDown#(M,S':Substitution,V <- T ; S:Substitution)
   = upDown#(M,S':Substitution ; V <- getTerm(metaReduce(M,T)),S:Substitution) .

endfm
*************************************
****** End of Santiago Escobar's code
*******************************************************************************
*******************************************************************************

fmod 2TUPLE{X :: TRIV, Y :: TRIV} is
  sorts Tuple{X, Y} .
  op ((_,_)) : X$Elt Y$Elt -> Tuple{X, Y} .
  op p1_ : Tuple{X, Y} -> X$Elt .
  op p2_ : Tuple{X, Y} -> Y$Elt .
  eq p1(V1:[X$Elt],V2:[Y$Elt]) = V1:[X$Elt] .
  eq p2(V1:[X$Elt],V2:[Y$Elt]) = V2:[Y$Elt] .
endfm

fmod 3TUPLE{X :: TRIV, Y :: TRIV, Z :: TRIV} is
  sort Tuple{X, Y, Z} .
  op ((_,_,_)) : X$Elt Y$Elt Z$Elt -> Tuple{X, Y, Z} .
  op p1_ : Tuple{X, Y, Z} -> X$Elt .
  op p2_ : Tuple{X, Y, Z} -> Y$Elt .
  op p3_ : Tuple{X, Y, Z} -> Z$Elt .
  eq p1((A:[X$Elt], B:[Y$Elt], C:[Z$Elt])) = A:[X$Elt] .
  eq p2((A:[X$Elt], B:[Y$Elt], C:[Z$Elt])) = B:[Y$Elt] .
  eq p3((A:[X$Elt], B:[Y$Elt], C:[Z$Elt])) = C:[Z$Elt] .
endfm

fmod 4TUPLE{W :: TRIV, X :: TRIV, Y :: TRIV, Z :: TRIV} is
  sort Tuple{W, X, Y, Z} .
  op ((_,_,_,_)) : W$Elt X$Elt Y$Elt Z$Elt -> Tuple{W, X, Y, Z} .
  op p1_ : Tuple{W, X, Y, Z} -> W$Elt .
  op p2_ : Tuple{W, X, Y, Z} -> X$Elt .
  op p3_ : Tuple{W, X, Y, Z} -> Y$Elt .
  op p4_ : Tuple{W, X, Y, Z} -> Z$Elt .
  eq p1((A:[W$Elt], B:[X$Elt], C:[Y$Elt], D:[Z$Elt])) = A:[W$Elt] .
  eq p2((A:[W$Elt], B:[X$Elt], C:[Y$Elt], D:[Z$Elt])) = B:[X$Elt] .
  eq p3((A:[W$Elt], B:[X$Elt], C:[Y$Elt], D:[Z$Elt])) = C:[Y$Elt] .
  eq p4((A:[W$Elt], B:[X$Elt], C:[Y$Elt], D:[Z$Elt])) = D:[Z$Elt] .
endfm

fmod 5TUPLE{V :: TRIV, W :: TRIV, X :: TRIV, Y :: TRIV, Z :: TRIV} is
  sort Tuple{V, W, X, Y, Z} .
  op ((_,_,_,_,_)) : V$Elt W$Elt X$Elt Y$Elt Z$Elt -> Tuple{V, W, X, Y, Z} .
  op p1_ : Tuple{V, W, X, Y, Z} -> V$Elt .
  op p2_ : Tuple{V, W, X, Y, Z} -> W$Elt .
  op p3_ : Tuple{V, W, X, Y, Z} -> X$Elt .
  op p4_ : Tuple{V, W, X, Y, Z} -> Y$Elt .
  op p5_ : Tuple{V, W, X, Y, Z} -> Z$Elt .
  eq p1((A:[V$Elt], B:[W$Elt], C:[X$Elt], D:[Y$Elt], E:[Z$Elt])) = A:[V$Elt] .
  eq p2((A:[V$Elt], B:[W$Elt], C:[X$Elt], D:[Y$Elt], E:[Z$Elt])) = B:[W$Elt] .
  eq p3((A:[V$Elt], B:[W$Elt], C:[X$Elt], D:[Y$Elt], E:[Z$Elt])) = C:[X$Elt] .
  eq p4((A:[V$Elt], B:[W$Elt], C:[X$Elt], D:[Y$Elt], E:[Z$Elt])) = D:[Y$Elt] .
  eq p5((A:[V$Elt], B:[W$Elt], C:[X$Elt], D:[Y$Elt], E:[Z$Elt])) = E:[Z$Elt] .
endfm

fmod 6TUPLE{U :: TRIV, V :: TRIV, W :: TRIV, X :: TRIV, Y :: TRIV, Z :: TRIV} is
  sort Tuple{U, V, W, X, Y, Z} .
  op ((_,_,_,_,_,_)) : U$Elt V$Elt W$Elt X$Elt Y$Elt Z$Elt -> Tuple{U, V, W, X, Y, Z} .
  op p1_ : Tuple{U, V, W, X, Y, Z} -> U$Elt .
  op p2_ : Tuple{U, V, W, X, Y, Z} -> V$Elt .
  op p3_ : Tuple{U, V, W, X, Y, Z} -> W$Elt .
  op p4_ : Tuple{U, V, W, X, Y, Z} -> X$Elt .
  op p5_ : Tuple{U, V, W, X, Y, Z} -> Y$Elt .
  op p6_ : Tuple{U, V, W, X, Y, Z} -> Z$Elt .
  eq p1((A:[U$Elt], B:[V$Elt], C:[W$Elt], D:[X$Elt], E:[Y$Elt], F:[Z$Elt])) = A:[U$Elt] .
  eq p2((A:[U$Elt], B:[V$Elt], C:[W$Elt], D:[X$Elt], E:[Y$Elt], F:[Z$Elt])) = B:[V$Elt] .
  eq p3((A:[U$Elt], B:[V$Elt], C:[W$Elt], D:[X$Elt], E:[Y$Elt], F:[Z$Elt])) = C:[W$Elt] .
  eq p4((A:[U$Elt], B:[V$Elt], C:[W$Elt], D:[X$Elt], E:[Y$Elt], F:[Z$Elt])) = D:[X$Elt] .
  eq p5((A:[U$Elt], B:[V$Elt], C:[W$Elt], D:[X$Elt], E:[Y$Elt], F:[Z$Elt])) = E:[Y$Elt] .
  eq p6((A:[U$Elt], B:[V$Elt], C:[W$Elt], D:[X$Elt], E:[Y$Elt], F:[Z$Elt])) = F:[Z$Elt] .
endfm

view QidList from TRIV to QID-LIST is
  sort Elt to QidList .
endv

view TermList from TRIV to META-MODULE is
  sort Elt to TermList .
endv

view RuleSet from TRIV to META-MODULE is
  sort Elt to RuleSet .
endv

view EquationSet from TRIV to META-MODULE is
  sort Elt to EquationSet .
endv

view OpDeclSet from TRIV to META-MODULE is
  sort Elt to OpDeclSet .
endv

view ImportList from TRIV to META-MODULE is
  sort Elt to ImportList .
endv

view Condition from TRIV to META-MODULE is
  sort Elt to Condition .
endv

view QidSet from TRIV to META-MODULE is
  sort Elt to QidSet .
endv

view Module from TRIV to META-MODULE is
  sort Elt to Module .
endv

view ParameterDeclList from TRIV to META-MODULE is
  sort Elt to ParameterDeclList .
endv

view Bound from TRIV to META-LEVEL is
  sort Elt to Bound .
endv

view Oid from TRIV to CONFIGURATION is
  sort Elt to Oid .
endv

-------------------------------------------------------------------------------
*******************************************************************************
***
*** 2 The Signature of Full Maude
***
*******************************************************************************
-------------------------------------------------------------------------------

fmod EXTENDED-SORTS is
  ---- Any modification in this module must be reflected in the metamodule
  ---- used in eq addInfoConds in module UNIT-BUBBLE-PARSING
  sorts @SortToken@ @ViewToken@ @Sort@ @Kind@ @Type@ @SortList@
        @TypeList@ @ViewExp@ @ModExp@ .

  subsorts @SortToken@ < @Sort@ < @SortList@ < @TypeList@ .
  subsorts @Sort@ @Kind@ < @Type@ < @TypeList@ .
  subsort @ViewToken@ < @ViewExp@ .

  op _`{_`} : @Sort@ @ViewExp@ -> @Sort@ [prec 40] .
  op __ : @SortList@ @SortList@ -> @SortList@ [assoc] .
  op __ : @TypeList@ @TypeList@ -> @TypeList@ [assoc] .
  op `[_`] : @Sort@ -> @Kind@ .

  op _`,_ : @ViewExp@ @ViewExp@ -> @ViewExp@ [assoc] .
  op _`{_`} : @ViewExp@ @ViewExp@ -> @ViewExp@ [prec 40] .
endfm

-------------------------------------------------------------------------------
******************************************************************************
-------------------------------------------------------------------------------

fmod OPERATOR-ATTRIBUTES is
  sorts @Attr@ @AttrList@ @Hook@ @HookList@ @Bubble@ @Token@ @NeTokenList@ .
  subsort @Attr@ < @AttrList@ .
  subsort @Hook@ < @HookList@ .

  op __ : @AttrList@ @AttrList@ -> @AttrList@ [assoc] .
  ops assoc associative : -> @Attr@ .
  ops comm commutative : -> @Attr@ .
  ops idem idempotent : -> @Attr@ .
  ops id:_ identity:_ : @Bubble@ -> @Attr@ .
  ops left`id:_ left`identity:_ : @Bubble@ -> @Attr@ .
  ops right`id:_ right`identity:_ : @Bubble@ -> @Attr@ .
  ops frozen`(_`) poly`(_`) strat`(_`) strategy`(_`) :
        @NeTokenList@ -> @AttrList@ .
  ops memo memoization : -> @Attr@ .
  ops prec_ precedence_ : @Token@ -> @Attr@ .
  ops gather`(_`) gathering`(_`) : @NeTokenList@ -> @Attr@ .
  ops format`(_`) : @NeTokenList@ -> @Attr@ .
  ops ctor constructor : -> @Attr@ .
  ops frozen ditto iter : -> @Attr@ .
  ops object msg message config : -> @Attr@ .
  op metadata_ : @Token@ -> @Attr@ .

  op special`(_`) : @HookList@ -> @Attr@ .
  op __ : @HookList@ @HookList@ -> @HookList@ [assoc] .
  op id-hook_ : @Token@ -> @Hook@ .
  op id-hook_`(_`) : @Token@ @NeTokenList@ -> @Hook@ .
  op op-hook_`(_:_->_`) : @Token@ @Token@ @NeTokenList@ @Token@ -> @Hook@ .
  op op-hook_`(_:`->_`) : @Token@ @Token@ @Token@ -> @Hook@ .
  op op-hook_`(_:_~>_`) : @Token@ @Token@ @NeTokenList@ @Token@ -> @Hook@ .
  op op-hook_`(_:`~>_`) : @Token@ @Token@ @Token@ -> @Hook@ .
  op term-hook_`(_`) : @Token@ @Bubble@ -> @Hook@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-EXPRS is
  including OPERATOR-ATTRIBUTES .
  including EXTENDED-SORTS .

  sorts @Map@ @MapList@ .
  subsort @Map@ < @MapList@ .
  subsorts @Token@ < @ModExp@ .

  *** module expression
  op _*`(_`) : @ModExp@ @MapList@ -> @ModExp@ .
  op _`{_`} : @ModExp@ @ViewExp@ -> @ModExp@ .
  op TUPLE`[_`] : @Token@ -> @ModExp@ .
  op POWER`[_`] : @Token@ -> @ModExp@ .
  op _+_ : @ModExp@ @ModExp@ -> @ModExp@ [assoc prec 42] .

  *** renaming maps
  op op_to_ : @Token@ @Token@ -> @Map@ .
  op op_:_->_to_ : @Token@ @TypeList@ @Type@ @Token@ -> @Map@ .
  op op_: ->_to_ : @Token@ @Type@ @Token@ -> @Map@ .
  op op_:_~>_to_ : @Token@ @TypeList@ @Type@ @Token@ -> @Map@ .
  op op_: ~>_to_ : @Token@ @Type@ @Token@ -> @Map@ .
  op op_to_`[_`] : @Token@ @Token@ @AttrList@ -> @Map@ .
  op op_:_->_to_`[_`] : @Token@ @TypeList@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op op_:`->_to_`[_`] : @Token@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op op_:_~>_to_`[_`] : @Token@ @TypeList@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op op_:`~>_to_`[_`] : @Token@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op sort_to_ : @Sort@ @Sort@ -> @Map@ .
  op label_to_ : @Token@ @Token@ -> @Map@ .
  op class_to_ : @Sort@ @Sort@ -> @Map@ .
  op attr_._to_ : @Sort@ @Token@ @Token@ -> @Map@ .
  op msg_to_ : @Token@ @Token@ -> @Map@ .
  op msg_:_->_to_ : @Token@ @TypeList@ @Type@ @Token@ -> @Map@ .
  op msg_:`->_to_ : @Token@ @Type@ @Token@ -> @Map@ .

  op _`,_ : @MapList@ @MapList@ -> @MapList@ [assoc prec 42] .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod SIGNATURES is
  inc MOD-EXPRS .

  sorts @SortDecl@ @SubsortRel@ @SubsortDecl@ @OpDecl@ .

  op `(_`) : @Token@ -> @Token@ .

  *** sort declaration
  op sorts_. : @SortList@ -> @SortDecl@ .
  op sort_. : @SortList@ -> @SortDecl@ .

  *** subsort declaration
  op subsort_. : @SubsortRel@ -> @SubsortDecl@ .
  op subsorts_. : @SubsortRel@ -> @SubsortDecl@ .
  op _<_ : @SortList@ @SortList@ -> @SubsortRel@ .
  op _<_ : @SortList@ @SubsortRel@ -> @SubsortRel@ .

  *** operator declaration
  op op_:`->_. : @Token@ @Type@ -> @OpDecl@ .
  op op_:`->_`[_`]. : @Token@ @Type@ @AttrList@ -> @OpDecl@ .
  op op_:_->_. : @Token@ @TypeList@ @Type@ -> @OpDecl@ .
  op op_:_->_`[_`]. : @Token@ @TypeList@ @Type@ @AttrList@ -> @OpDecl@ .
  op ops_:`->_. : @NeTokenList@ @Type@ -> @OpDecl@ .
  op ops_:`->_`[_`]. : @NeTokenList@ @Type@ @AttrList@ -> @OpDecl@ .
  op ops_:_->_. : @NeTokenList@ @TypeList@ @Type@ -> @OpDecl@ .
  op ops_:_->_`[_`]. : @NeTokenList@ @TypeList@ @Type@ @AttrList@ -> @OpDecl@ .

  op op_:`~>_. : @Token@ @Sort@ -> @OpDecl@ .
  op op_:`~>_`[_`]. : @Token@ @Sort@ @AttrList@ -> @OpDecl@ .
  op op_:_~>_. : @Token@ @TypeList@ @Sort@ -> @OpDecl@ .
  op op_:_~>_`[_`]. : @Token@ @TypeList@ @Sort@ @AttrList@ -> @OpDecl@ .
  op ops_:`~>_. : @NeTokenList@ @Sort@ -> @OpDecl@ .
  op ops_:`~>_`[_`]. : @NeTokenList@ @Sort@ @AttrList@ -> @OpDecl@ .
  op ops_:_~>_. : @NeTokenList@ @TypeList@ @Sort@ -> @OpDecl@ .
  op ops_:_~>_`[_`]. : @NeTokenList@ @TypeList@ @Sort@ @AttrList@ -> @OpDecl@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod F&S-MODS&THS is
  including SIGNATURES .
  including QID-LIST .

  sorts @FDeclList@ @SDeclList@ @Module@ @ImportDecl@ @Parameter@
        @List<Parameter>@ @EqDecl@ @RlDecl@ @MbDecl@ @VarDecl@ @VarDeclList@ .

  subsort @VarDecl@ < @VarDeclList@ .
  subsorts @VarDecl@ @ImportDecl@ @SortDecl@ @SubsortDecl@ @OpDecl@ @MbDecl@
           @EqDecl@ @VarDeclList@ < @FDeclList@ .
  subsorts @RlDecl@ @FDeclList@ < @SDeclList@ .

  *** variable declaration
  op vars_:_. : @NeTokenList@ @Type@ -> @VarDecl@ .
  op var_:_. : @NeTokenList@ @Type@ -> @VarDecl@ .

  *** membership axiom declaration
  op mb_:_. : @Bubble@ @Bubble@ -> @MbDecl@ .
  ----op mb[_]:_:_. : @Token@ @Bubble@ @Bubble@ -> @MbDecl@ .
  op cmb_:_if_. : @Bubble@ @Sort@ @Bubble@ -> @MbDecl@ .
  op cmb[_]:_:_if_. : @Token@ @Bubble@ @Sort@ @Bubble@ -> @MbDecl@ .

  *** equation declaration
  op eq_=_. : @Bubble@ @Bubble@ -> @EqDecl@ .
  op ceq_=_if_. : @Bubble@ @Bubble@ @Bubble@ -> @EqDecl@ .
  op cq_=_if_. : @Bubble@ @Bubble@ @Bubble@ -> @EqDecl@ .

  *** rule declaration
  *** op rl`[_`]:_=>_. : @Token@ @Bubble@ @Bubble@ -> @RlDecl@ .
  op rl_=>_. : @Bubble@ @Bubble@ -> @RlDecl@ .
  *** op crl`[_`]:_=>_if_. : @Token@ @Bubble@ @Bubble@ @Bubble@ -> @RlDecl@ .
  op crl_=>_if_. : @Bubble@ @Bubble@ @Bubble@ -> @RlDecl@ .

  *** importation declaration
  ops including_. inc_. : @ModExp@ -> @ImportDecl@ .
  ops extending_. ex_. : @ModExp@ -> @ImportDecl@ .
  ops protecting_. pr_. : @ModExp@ -> @ImportDecl@ .

  sorts @Interface@ .
  subsort @Parameter@ < @List<Parameter>@ .
  subsorts @Token@ < @Interface@ .

  *** parameterized module interface
  op _::_ : @Token@ @ModExp@ -> @Parameter@ [prec 40 gather (e &)] .
  op _::_ : @Token@ @Interface@ -> @Parameter@ [prec 40 gather (e &)] .

  op _`,_ : @List<Parameter>@ @List<Parameter>@ -> @List<Parameter>@ [assoc] .

  op _`{_`} : @ModExp@ @List<Parameter>@ -> @Interface@ .

  *** declaration list
  op __ : @VarDeclList@ @VarDeclList@ -> @VarDeclList@ [assoc] .
  op __ : @SDeclList@ @SDeclList@ -> @SDeclList@ [assoc] .
  op __ : @FDeclList@ @FDeclList@ -> @FDeclList@ [assoc] .

  *** functional and system module and theory
  op fmod_is_endfm : @Interface@ @FDeclList@ -> @Module@ .
  op obj_is_jbo : @Interface@ @FDeclList@ -> @Module@ .
  op obj_is_endo : @Interface@ @FDeclList@ -> @Module@ .
  op mod_is_endm : @Interface@ @SDeclList@ -> @Module@ .
  op fth_is_endfth : @Interface@ @FDeclList@ -> @Module@ .
  op th_is_endth : @Interface@ @SDeclList@ -> @Module@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod O-MODS&THS is
  including F&S-MODS&THS .

  sorts @ClassDecl@ @AttrDecl@ @AttrDeclList@ @SubclassDecl@ @MsgDecl@
        @ODeclList@ .
  subsorts @SDeclList@ @MsgDecl@ @SubclassDecl@ @ClassDecl@ < @ODeclList@ .
  subsort @AttrDecl@ < @AttrDeclList@ .

  op __ : @ODeclList@ @ODeclList@ -> @ODeclList@ [assoc] .

  *** object-oriented module and theory
  op omod_is_endom : @Interface@ @ODeclList@ -> @Module@ .
  op oth_is_endoth : @Interface@ @ODeclList@ -> @Module@ .

  *** class declaration
  op class_|_. : @Sort@ @AttrDeclList@ -> @ClassDecl@ .
  op class_|`. : @Sort@ -> @ClassDecl@ .
  op class_. : @Sort@ -> @ClassDecl@ .
  op _`,_ : @AttrDeclList@ @AttrDeclList@ -> @AttrDeclList@ [assoc] .
  op _:_ : @Token@ @Sort@ -> @AttrDecl@ [prec 40] .

  *** subclass declaration
  op subclass_. : @SubsortRel@ -> @SubclassDecl@ .
  op subclasses_. : @SubsortRel@ -> @SubclassDecl@ .

  *** message declaration
  op msg_:_->_. : @Token@ @SortList@ @Sort@ -> @MsgDecl@ .
  op msgs_:_->_. : @NeTokenList@ @SortList@ @Sort@ -> @MsgDecl@ .
  op msg_:`->_. : @Token@ @Sort@ -> @MsgDecl@ .
  op msgs_:`->_. : @NeTokenList@ @Sort@ -> @MsgDecl@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod VIEWS is
  including O-MODS&THS .

  sorts @ViewDecl@ @ViewDeclList@ @View@ .
  subsorts @VarDecl@ < @ViewDecl@ < @ViewDeclList@ .
  subsort @VarDeclList@ < @ViewDeclList@ .

  *** view maps
  op op_to`term_. : @Bubble@ @Bubble@ -> @ViewDecl@ .
  op op_to_. : @Token@ @Token@ -> @ViewDecl@ .
  op op_:_->_to_. : @Token@ @TypeList@ @Type@ @Token@ -> @ViewDecl@ .
  op op_:`->_to_. : @Token@ @Type@ @Token@ -> @ViewDecl@ .
  op op_:_~>_to_. : @Token@ @TypeList@ @Type@ @Token@ -> @ViewDecl@ .
  op op_:`~>_to_. : @Token@ @Type@ @Token@ -> @ViewDecl@ .
  op sort_to_. : @Sort@ @Sort@ -> @ViewDecl@ .
  op class_to_. : @Sort@ @Sort@ -> @ViewDecl@ .
  op attr_._to_. : @Sort@ @Token@ @Token@ -> @ViewDecl@ .
  op msg_to_. : @Token@ @Token@ -> @ViewDecl@ .
  op msg_:_->_to_. : @Token@ @TypeList@ @Type@ @Token@ -> @ViewDecl@ .
  op msg_:`->_to_. : @Token@ @Type@ @Token@ -> @ViewDecl@ .

  *** view
  op view_from_to_is_endv : @Interface@ @ModExp@ @ModExp@ @ViewDeclList@ -> @View@ .
  op view_from_to_is endv : @Interface@ @ModExp@ @ModExp@ -> @View@ .
  op __ : @ViewDeclList@ @ViewDeclList@ -> @ViewDeclList@ [assoc] .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod COMMANDS is
  including MOD-EXPRS .

  sorts @Command@ .

  *** down function
  op down_:_ : @ModExp@ @Command@ -> @Command@ .

  *** parse commands
  op parse_. : @Bubble@ -> @Command@ .

  *** reduce commands
  op red_. : @Bubble@ -> @Command@ .
  op reduce_. : @Bubble@ -> @Command@ .

  *** rewrite commands
  op rew_. : @Bubble@ -> @Command@ .
  op rewrite_. : @Bubble@ -> @Command@ .

  *** frewrite commands
  op frew_. : @Bubble@ -> @Command@ .
  op frewrite_. : @Bubble@ -> @Command@ .

  *** search commands
  op search_=>1_. : @Bubble@ @Bubble@ -> @Command@ .
  op search_=>*_. : @Bubble@ @Bubble@ -> @Command@ .
  op search_=>+_. : @Bubble@ @Bubble@ -> @Command@ .
  op search_=>!_. : @Bubble@ @Bubble@ -> @Command@ .

  *** search commands
  op search_~>1_. : @Bubble@ @Bubble@ -> @Command@ .
  op search_~>*_. : @Bubble@ @Bubble@ -> @Command@ .
  op search_~>+_. : @Bubble@ @Bubble@ -> @Command@ .
  op search_~>!_. : @Bubble@ @Bubble@ -> @Command@ .

  *** matching commands
  op match_<=?_. : @Bubble@ @Bubble@ -> @Command@ .
  op xmatch_<=?_. : @Bubble@ @Bubble@ -> @Command@ .

  *** unifying command
  op unify_. : @Bubble@ -> @Command@ .

  *** unifying command
  op id-unify_. : @Bubble@ -> @Command@ .

  *** unifying command
  op variant`unify_. : @Bubble@ -> @Command@ .

  *** unifying command
  op asymmetric`variant`unify_. : @Bubble@ -> @Command@ .

  *** unifying command
  op get`variants_. : @Bubble@ -> @Command@ .

  *** select command
  op select_. : @ModExp@ -> @Command@ .

  *** show commands
  op show`module`. : -> @Command@ .
  op show`module_. : @ModExp@ -> @Command@ .
  op show`all`. : -> @Command@ .
  op show`all_. : @ModExp@ -> @Command@ .
  op show`vars`. : -> @Command@ .
  op show`vars_. : @ModExp@ -> @Command@ .
  op show`sorts`. : -> @Command@ .
  op show`sorts_. : @ModExp@ -> @Command@ .
  op show`ops`. : -> @Command@ .
  op show`ops_. : @ModExp@ -> @Command@ .
  op show`mbs`. : -> @Command@ .
  op show`mbs_. : @ModExp@ -> @Command@ .
  op show`eqs`. : -> @Command@ .
  op show`eqs_. : @ModExp@ -> @Command@ .
  op show`rls`. : -> @Command@ .
  op show`rls_. : @ModExp@ -> @Command@ .
  op show`view_. : @ViewExp@ -> @Command@ .
  op show`modules`. : -> @Command@ .
  op show`views`. : -> @Command@ .

  *** set commands
  op set`protect_on`. : @ModExp@ -> @Command@ .
  op set`protect_off`. : @ModExp@ -> @Command@ .
  op set`include_on`. : @ModExp@ -> @Command@ .
  op set`include_off`. : @ModExp@ -> @Command@ .
  op set`extend_on`. : @ModExp@ -> @Command@ .
  op set`extend_off`. : @ModExp@ -> @Command@ .

  *** miscellaneous
  op load_. : @Bubble@ -> @Command@ .
  ops remove`identity`attributes`. rm`ids`. : -> @Command@ .
  ops remove`identity`attributes_. rm`ids_. : @ModExp@ -> @Command@ .
  op remove`assoc`attributes`. : -> @Command@ .
  op remove`assoc`attributes_. : @ModExp@ -> @Command@ .
  op ax`coherence`completion`. : -> @Command@ .
  op ax`coherence`completion_. : @ModExp@ -> @Command@ .
  op help`. : -> @Command@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FULL-MAUDE-SIGN is
  including VIEWS .
  including COMMANDS .

  sort @Input@ .
  subsorts @Command@ @Module@ @View@ < @Input@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------


*******
******* ERROR HANDLING, by Peter Olveczky
*******

*** The following module defines a function which prints up to n characters
*** of a bubble, followed by the usual arrow <---*HERE* which points to the
*** erroneous token:

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod PRINT-SYNTAX-ERROR is
---  protecting META-LEVEL + PRE-VARIANT .
  protecting META-LEVEL .
  protecting INT .

  var  QIL : QidList .
  var  Q : Qid .
  var  N : Nat .
  vars RP RP' : ResultPair .
  var  RP? : [ResultPair?] .

  op printN : Nat QidList -> QidList .  *** first N qid's in a qidList
  eq printN(N, nil) = nil .
  eq printN(0, QIL) = nil .
  eq printN(s N, Q QIL) = Q printN(N, QIL) .

  op removeFront : Nat QidList -> QidList .  *** removes first N qid's
  eq removeFront(N, nil) = nil .
  eq removeFront(0, QIL) = QIL .
  eq removeFront(s N, Q QIL) = removeFront(N, QIL) .

  op printSyntaxError : [ResultPair?] QidList -> QidList .
  eq printSyntaxError(noParse(N), QIL)
    = '\r 'Parse 'error 'in '\o '\s printN(N + 1, QIL) '\r '<---*HERE* '\o .
  eq printSyntaxError(ambiguity(RP, RP'), QIL)
    = '\r 'Ambiguous 'parsing 'for '\o '\s QIL '\o .
  eq printSyntaxError(RP?, QIL) = QIL [owise] .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------
***
*** The Abstract Data Type \texttt{Module}
***
-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** In this section we present the abstract data type \texttt{Module}, which
*** can be seen as an extension of the predefined sort \texttt{Module} in
*** several ways. There are constructors for functional, system, and object-
*** oriented modules and theories, which can be parameterized and can import
*** module expressions. There can also be parameterized sorts in Full Maude
*** modules, and therefore, the constructors for the different declarations
*** that can appear in a module have to be appropriately extended.

*** The section is structured as follows. After introducing some modules
*** defining some functions on the predefined sorts \texttt{Bool} and
*** \texttt{QidList} in Section~\ref{BOOL-QID-LIST}, we present in
*** Sections~\ref{EXT-SORT} and~\ref{EXT-DECL} the data types for extended
*** sorts and extended declarations. In Section~\ref{mod-exp-mod-id} we
*** introduce module expressions and module names, and in
*** Section~\ref{unitADT} the abstract data type \texttt{Module} itself.

***
*** Extension \texttt{QID-LIST}
***

*** The conversion of lists of quoted identifiers into single quoted
*** identifiers by concatenating them is heavily used in the coming modules.
*** This is the task of the \texttt{} function, which is
*** introduced in the following module \texttt{EXT-QID-LIST} extending the
*** predefined module \texttt{QID-LIST}.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod EXT-QID-LIST is
  pr QID-LIST .

  op qidList2Qid : QidList -> Qid .

  vars QI QI' QI'' : Qid .
  var  QIL : QidList .
  vars St St' : String .
  var  N : Nat .
  var  F : FindResult .

  eq qidList2Qid(('\s QIL)) = qid(" " + string(qidList2Qid(QIL))) .
  eq qidList2Qid((QI QIL))
    = qid(string(QI) + " " + string(qidList2Qid(QIL)))
    [owise] .
  eq qidList2Qid(nil) = qid("") .

  op trimQidList : QidList -> QidList .
  eq trimQidList(' QIL) = trimQidList(QIL) .
  eq trimQidList(QI QIL) = QI trimQidList(QIL) [owise] .
  eq trimQidList(nil) = nil .

  op qidList2string : QidList -> String .
  eq qidList2string('`( QIL) = "(" + " " + qidList2string(QIL) .
  eq qidList2string('`) QIL) = ")" + " " + qidList2string(QIL) .
  eq qidList2string('`{ QIL) = "{" + " " + qidList2string(QIL) .
  eq qidList2string('`} QIL) = "}" + " " + qidList2string(QIL) .
  eq qidList2string('`[ QIL) = "[" + " " + qidList2string(QIL) .
  eq qidList2string('`] QIL) = "]" + " " + qidList2string(QIL) .
  eq qidList2string('`, QIL) = "," + " " + qidList2string(QIL) .
  eq qidList2string(QI QIL) = string(QI) + " " + qidList2string(QIL) [owise] .
  eq qidList2string(nil) = "" .

  op string2qidList : String -> QidList .
  op string2qidListAux : String -> QidList .

  eq string2qidList(St) = trimQidList(string2qidListAux(St)) .

  eq string2qidListAux("") = nil .
  ceq string2qidListAux(St)
    = if F == notFound
      then qid(substr(St, findNonSpace(St), length(St)))
      else qid(substr(St, findNonSpace(St), F))
           if substr(St, findNonSpace(St) + F, 1) =/= " "
           then qid(substr(St, findNonSpace(St) + F, 1))
           else nil
           fi
           string2qidListAux(substr(St, findNonSpace(St) + F + 1, length(St)))
      fi
    if F := myfind(substr(St, findNonSpace(St), length(St)), " (){}[],", 0)
    [owise] .

  op findNonSpace : String -> Nat .
  op findNonSpace : String Nat -> Nat .
  ---- returns the length of the string if not found
  eq findNonSpace(St) = findNonSpace(St, 0) .

  eq findNonSpace(St, N)
    = if N < length(St)
      then if substr(St, N, 1) == " "
           then findNonSpace(St, N + 1)
           else N
           fi
      else length(St)
      fi .

  op myfind : String String Nat -> FindResult .
  eq myfind(St, St', N)
    = if N < length(St)
      then if find(St', substr(St, N, 1), 0) =/= notFound
           then N
           else myfind(St, St', N + 1)
           fi
      else notFound
      fi .

  op replace : QidList Qid Qid -> QidList .
  eq replace(QI QIL, QI', QI'')
    = if QI == QI'
      then QI'' replace(QIL, QI', QI'')
      else QI replace(QIL, QI', QI'')
      fi .
  eq replace(nil, QI, QI') = nil .
endfm

fmod HELP is
  pr EXT-QID-LIST .
  op fm-help : -> QidList .
  eq fm-help
    = string2qidList("Additional commands available:") '\n
      '\t string2qidList("(load <meta-module> .)") '\n
      '\t '\t string2qidList("Takes as argument a term of sort Module,") '\s string2qidList("i.e.,") '\s string2qidList("a metaterm.") '\n
      '\t '`( 'remove 'identity 'attributes '\s '`[ '<module-expr.> '`] '\s  '. '`) '\s  '| '\s '`( 'rm 'ids '\s '`[ '<module-expr.> '`] '\s  '. '`) '\n
      '\t '\t string2qidList("Shows the module with the id attributes removed using a variant-based transformation.") '\n
      '\t string2qidList("(remove assoc attributes") '\s string2qidList("[<module-expr.>]") '\s string2qidList(".)") '\n
      '\t '\t string2qidList("Shows the module with the assoc (if not with comm) attributes removed using a variant-based transformation.") '\n
      '\t string2qidList("(ax coherence completion") '\s string2qidList("[<module-expr.>]") '\s string2qidList(".)") '\n
      '\t '\t string2qidList("Shows the module resulting from completing for coherence for the different combinations of axioms.") '\n .
endfm


-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** 3.2 View Expressions and Extended Sorts

*** To allow the use of parameterized sorts, or sorts qualified by the view
*** expression with which the parameterized module in which the given sorts
*** appear is instantiated, we add the sort Sort of ``extended sorts'' as a
*** supersort of the predefined sort Sort.  View expressions and extended
*** sorts are introduced in the following modules.

*** 3.2.1 View Expressions

*** A view expression is given by a single quoted identifier, by a sequence of
*** view expressions (at the user level, separated by commas), or by the
*** composition of view expressions. In the current version, the composition
*** of view expressions is only used internally; we plan to make it available
*** to the user with syntax \verb~_;_~ in the future. View expressions are
*** used in the instantiation of parameterized modules and in parameterized
*** sorts.  We plan to support parameterized views in the future as well. We
*** use operators \verb~_|_~ and \verb~_;;_~ to represent, respectively,
*** sequences and composition of view expressions.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod VIEW-EXPR is
  pr META-MODULE .

  sort ViewExp .
  subsorts Sort < ViewExp < ModuleExpression NeParameterList .

  op mtViewExp : -> ViewExp .
  op _{_} : Sort ParameterList -> ViewExp [ctor prec 37].
  op _;;_ : ViewExp ViewExp -> ViewExp
       [assoc id: mtViewExp] .                       *** view composition  _;_

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** Since the Core Maude engine does not know about view expressions, or, as
*** we shall see, about extended sorts, extended module expressions, extended
*** modules, and other declarations that we introduce, to be able to use them
*** with built-in functions such as \texttt{sameComponent},
*** \texttt{leastSort}, \texttt{metaReduce}, etc., we shall have to convert
*** them into terms which only use the built-in constructors.  Thus, for
*** example, view expressions in sort \texttt{ViewExp} will be converted
*** into quoted identifiers of sort \texttt{Qid} by means of function
*** \texttt{parameter2Qid}, or, similarly, elements of sorts \texttt{Sort},
*** \texttt{SortList}, and \texttt{SortSet} are transformed into elements
*** of sorts \texttt{Qid}, \texttt{QidList}, and  \texttt{QidSet},
*** respectively, with functions \texttt{eSortToQid} defined  on the
*** appropriate sorts.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod VIEW-EXPR-TO-QID is
  pr VIEW-EXPR .
  pr EXT-QID-LIST .

  op viewExp2Qid : ViewExp -> Qid .
  op parameterList2Qid : ParameterList -> Qid .
  op viewExp2QidList : ViewExp -> QidList .
  op parameterList2QidList : ParameterList -> QidList .

  op eMetaPrettyPrint : ViewExp -> QidList .
  ceq eMetaPrettyPrint(VE) = viewExp2QidList(VE) if not VE :: TypeList .

  var  V : Sort .
  var  QI : Qid .
  var  QIL : QidList .
  var  P : ViewExp .
  var  PL : NeParameterList .
  vars VE VE' : ViewExp .

  eq parameterList2QidList(P) = viewExp2QidList(P) .
  ceq parameterList2QidList((P, PL))
    = (if QI == '`) then QIL QI '\s else QIL QI fi)
      '`, parameterList2QidList(PL)
    if QIL QI := viewExp2QidList(P).

  eq viewExp2QidList(V{PL})
    = (viewExp2QidList(V) '`{ parameterList2QidList(PL) '`}) .
  ceq viewExp2QidList(VE ;; VE')
    = (viewExp2QidList(VE) '; viewExp2QidList(VE'))
    if VE =/= mtViewExp /\ VE' =/= mtViewExp .
  eq viewExp2QidList(V) = V .

  eq parameterList2Qid(P) = viewExp2Qid(P) .
  eq parameterList2Qid((P, PL))
    = qid(string(viewExp2Qid(P)) + ", " + string(parameterList2Qid(PL))) .

  eq viewExp2Qid(VE) = qidList2Qid(viewExp2QidList(VE)) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Parameterized Sorts
***

*** In addition to the \texttt{Sort} sort, in the following module
*** \texttt{EXT-SORT} we also define sorts \texttt{SortList} and
*** \texttt{SortSet}.

*** The operator \texttt{eSort} is declared to be a constructor for extended
*** sorts.

*** As for lists and sTS of quoted identifiers, we declare \verb~__~ and
*** \verb~_;_~ as constructors for sorts \texttt{SortList} and
*** \texttt{SortList}, and \texttt{SortSet}, respectively.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod EXT-SORT is
---  pr META-LEVEL + PRE-VARIANT .
  pr META-LEVEL .
  pr EXT-BOOL .
  pr VIEW-EXPR-TO-QID .
  pr EXT-QID-LIST .
  pr TERMSET .

*** We define operations extending the built-in functions \texttt{sameKind}
*** and \texttt{leastSort}, respectively, to lists of sorts and
*** to lists of extended terms. The function \texttt{sameKind} takes
*** a module and two lists of extended sorts as arguments, and returns
*** \texttt{true} if the $i$-th elements of both lists are in the same
*** connected component of sorts. This function will be used, for example, to
*** check whether two operators are in the same family of subsort overloaded
*** operators. \texttt{leastSort} returns a list of sorts where the $i$-th
*** element of the list is the least sort, computed by the homonymous built-in
*** function, of the $i$-th term in the list of terms given as argument.
*** Moreover, we define a function \verb~_in_~ to check whether an
*** extended sort is in a given set of extended sorts.  Note that before
*** calling the built-in function \texttt{sameComponent}, extended sorts of
*** sort \texttt{Sort} have to be `desugared' into sorts of sort
*** \texttt{Sort} as defined in the predefined \texttt{META-LEVEL} module.
*** This conversion is done by the \texttt{eTypeToType} function. Basically,
*** user-defined sorts are converted into quoted identifiers by concatenating
*** the list of identifiers composing the name of the sort. For example, sorts
*** \texttt{'Nat} and \texttt{'List['Nat]} are converted, respectively, into
*** \texttt{'Nat} and \texttt{'List`[Nat`]}. Error
*** sorts~\cite{ClavelDuranEkerLincolnMarti-OlietMeseguerQuesada99} are left
*** as such.

  vars Tp Tp' Tp'' Tp''' : Type .
  vars TpL TpL' : TypeList .
  var  M : Module .

  op sameKind : Module TypeList TypeList -> Bool [ditto] .
  eq sameKind(M, (Tp Tp' TpL), (Tp'' Tp''' TpL'))
    = sameKind(M, Tp, Tp'')
      and-then sameKind(M, Tp' TpL, Tp''' TpL') .
  eq sameKind(M, nil, nil) = true .
  eq sameKind(M, TpL, TpL') = false [owise] .

  eq sameKind(M, cc(S:Sort ; SS:SortSet), Tp)
    = sameKind(M, S:Sort, Tp) .
  eq sameKind(M, Tp, cc(S:Sort ; SS:SortSet))
    = sameKind(M, Tp, S:Sort) .
  eq sameKind(M, cc(S:Sort ; SS:SortSet), cc(S':Sort ; SS':SortSet))
    = sameKind(M, S:Sort, S':Sort) .

  op sameKindAll : Module Type TypeList -> Bool .
  eq sameKindAll(M, Tp, Tp' TpL) = sameKind(M, Tp, Tp') and-then sameKindAll(M, Tp, TpL) .
  eq sameKindAll(M, Tp, nil) = true .

  op eLeastSort : Module TermList ~> TypeList .
  eq eLeastSort(M, (T:Term, TL:TermList))
    = (leastSort(M, T:Term) eLeastSort(M, TL:TermList)) .
  eq eLeastSort(M, empty) = nil .
  eq eLeastSort(M, qidError(QIL)) = qidError(QIL) .

  op eLeastSort : Module TermSet ~> TypeSet .
  eq eLeastSort(M, (T:Term | TS:TermSet))
    = (leastSort(M, T:Term) ; eLeastSort(M, TS:TermSet)) .
  eq eLeastSort(M, emptyTermSet) = none .
  eq eLeastSort(M, qidError(QIL)) = qidError(QIL) .

  op qidError : QidList -> [Sort] .
  op stringError : QidList -> [String] .
  eq string(qidError(QIL)) = stringError(QIL) .
  eq qid(stringError(QIL)) = qidError(QIL) .
  eq stringError(QIL) + St:String = stringError(QIL) .

  op getMsg : [Sort] -> QidList .
  eq getMsg(qidError(QIL:QidList)) = QIL:QidList .

  op kind : TypeList -> Type .

  eq kind(S:Sort TL:TypeList)
    = qid("[" + string(S:Sort) + "]") kind(TL:TypeList) .
  eq kind(K:Kind TL:TypeList) = K:Kind kind(TL:TypeList) .
  eq kind(nil) = nil .

  op kind : SortSet -> Type .
  eq kind(S:Sort ; SS:SortSet) = qid("[" + string(S:Sort) + "]") .

  op cc : SortSet -> Type .

  op getSort : Kind -> Sort .
  eq getSort(K:Kind)
    = if findOut(string(K:Kind), "`,", "{", "}", 0) == notFound
      then qid(substr(string(K:Kind),
                      2,
                      sd(length(string(K:Kind)), 4)))
      else qid(substr(string(K:Kind),
                      2,
                      sd(findOut(string(K:Kind), "`,", "{", "}", 0), 2)))
      fi .

  op getSorts : Kind -> SortSet .
  eq getSorts(K:Kind)
    = if findOut(string(K:Kind), "`,", "{", "}", 0) == notFound
      then qid(substr(string(K:Kind),
                      2,
                      sd(length(string(K:Kind)), 4)))
      else qid(substr(string(K:Kind),
                      2,
                      sd(findOut(string(K:Kind), "`,", "{", "}", 0), 2)))
           ;
           getSorts(qid("[" + substr(string(K:Kind),
                                     sd(findOut(string(K:Kind), "`,", "{", "}", 0), 1),
                                     length(string(K:Kind)))))
      fi .

----  op qid2Sort : Sort -> Sort .
----  eq qid2Sort(S:Sort) = getName{S:Sort} { getPars(S:Sort) } .

  ---- name of a sort (the name of S{P1, ..., Pn} is S)
  op getName : Sort -> Qid .
  eq getName(S:Sort)
    = if findOpening(string(S:Sort), "{", "}", sd(length(string(S:Sort)), 2))
           == notFound
      then S:Sort
      else qid(substr(string(S:Sort),
                      0,
                      findOpening(string(S:Sort),
                        "{", "}",
                        sd(length(string(S:Sort)), 2))))
      fi .

  ---- parameters of a sort (the parameters of S{P1, ..., Pn} are P1 ... Pn)
  op getPars : Sort -> ParameterList [memo] .
  op getParsAux : String Nat Nat -> ParameterList .

  eq getPars(S:Sort)
    = if findOpening(string(S:Sort), "{", "}", sd(length(string(S:Sort)), 2))
           == notFound
      then empty
      else getParsAux(string(S:Sort),
             findOpening(string(S:Sort),
               "{", "}", sd(length(string(S:Sort)), 2)) + 1,
             length(string(S:Sort)))
      fi .

  var  St Pattern OpenPar ClosingPar : String .
  vars L R N OpenPars ClosingPars : Nat .

  eq getParsAux(St, L, R)
    = if findOut(St, ",", "{", "}", L) == notFound
      then qid(substr(St, L, sd(findClosing(St, "{", "}", L), L)))
      else (qid(substr(St, L, sd(findOut(St, ",", "{", "}", L), L))),
            getParsAux(St, findOut(St, ",", "{", "}", L) + 1, R))
      fi .

  ---- finds a pattern out of balanced parentheses
  ---- findOut("S{P1, P2{P21, P22}, P3}", ",", "{", "}", 6) returns 18, not 12
  op findOut : String String String String Nat -> FindResult .
  op findOut : String String String String Nat Nat -> FindResult .

  eq findOut(St, Pattern, OpenPar, ClosingPar, N)
    = findOut(St, Pattern, OpenPar, ClosingPar, 0, N) .

  eq findOut(St, Pattern, OpenPar, ClosingPar, OpenPars, N)
    = if N >= length(St)
      then notFound
      else if OpenPars == 0 and-then substr(St, N, length(Pattern)) == Pattern
           then N
           else if substr(St, N, length(OpenPar)) == OpenPar
                then findOut(St, Pattern, OpenPar, ClosingPar,
                       OpenPars + 1, N + 1)
                else if substr(St, N, length(ClosingPar)) == ClosingPar
                     then findOut(St, Pattern, OpenPar, ClosingPar,
                            sd(OpenPars, 1), N + 1)
                     else findOut(St, Pattern, OpenPar, ClosingPar,
                            OpenPars, N + 1)
                     fi
                fi
           fi
      fi .

  ---- finds the first closing unbalanced parenthesis
  ---- findOut("P1, P2{P21, P22}, P3}", "{", "}", 6) returns 21, not 16
  op findClosing : String String String Nat -> FindResult .
  op findClosing : String String String Nat Nat -> FindResult .

  eq findClosing(St, OpenPar, ClosingPar, N)
    = findClosing(St, OpenPar, ClosingPar, 0, N) .

  eq findClosing(St, OpenPar, ClosingPar, OpenPars, N)
    = if N >= length(St)
      then notFound
      else if OpenPars == 0
              and-then substr(St, N, length(ClosingPar)) == ClosingPar
           then N
           else if substr(St, N, length(OpenPar)) == OpenPar
                then findClosing(St, OpenPar, ClosingPar,
                       OpenPars + 1, N + 1)
                else if substr(St, N, length(ClosingPar)) == ClosingPar
                     then findClosing(St, OpenPar, ClosingPar,
                            sd(OpenPars, 1), N + 1)
                     else findClosing(St, OpenPar, ClosingPar,
                            OpenPars, N + 1)
                     fi
                fi
           fi
      fi .

  ---- finds the last opening unbalanced parenthesis
  ---- findOpening("S{P1, P2{P21, P22}, P3}", "{", "}", 21) returns 1, not 8
  op findOpening : String String String Nat -> FindResult .
  op findOpening : String String String Nat Nat -> FindResult .

  eq findOpening(St, OpenPar, ClosingPar, N)
    = findOpening(St, OpenPar, ClosingPar, 0, N) .

  eq findOpening(St, OpenPar, ClosingPar, ClosingPars, N)
    = if N == 0
      then notFound
      else if ClosingPars == 0
              and-then substr(St, N, length(ClosingPar)) == OpenPar
           then N
           else if substr(St, N, length(OpenPar)) == ClosingPar
                then findOpening(St, OpenPar, ClosingPar,
                       ClosingPars + 1, sd(N, 1))
                else if substr(St, N, length(ClosingPar)) == OpenPar
                     then findOpening(St, OpenPar, ClosingPar,
                            sd(ClosingPars, 1), sd(N, 1))
                     else findOpening(St, OpenPar, ClosingPar,
                            ClosingPars, sd(N, 1))
                     fi
                fi
           fi
      fi .

  op makeSort : Sort ParameterList -> Sort .
  op makeSort : Sort ParameterList ParameterList ParameterList -> Sort .
  op makeSort2 : Sort ParameterList -> Sort .
  op makePars : ParameterList -> String .

  vars S P : Sort .
  vars PL PL' PL'' PL3 : ParameterList .
  var  VE : ViewExp .
  var  QIL : QidList .
  var  K : Kind .

  eq makeSort(S, PL)
    = if PL == empty
      then S
      else makeSort(S, PL, empty, empty)
      fi .

  ----eq makeSort(S, P, PL, PL') = makeSort(S, empty, (PL, P), PL') .
  eq makeSort(S, (P, PL), PL', PL'') = makeSort(S, PL, (PL', P), PL'') .
  eq makeSort(S, (P{PL}, PL'), PL'', PL3)
    = makeSort(S, PL', (PL'', makeSort(P, PL)), PL3) .
  ----eq makeSort(S, (P ;; VE), PL, PL')
  ----  = makeSort(S, empty, (PL, P), (PL', VE))
  ----  [owise] .
  eq makeSort(S, ((P ;; VE), PL), PL', PL'')
    = makeSort(S, PL, (PL', P), (PL'', VE))
    [owise] .
  eq makeSort(S, empty, PL, PL')
    = if PL' == empty
      then makeSort2(S, PL)
      else makeSort(makeSort2(S, PL), PL')
      fi .

  eq makeSort2(S, empty) = S:Sort .
  eq makeSort2(S, P) = qid(string(S) + "{" + string(P) + "}") .
  eq makeSort2(S, (P, PL))
    = qid(string(S) + "{" + string(P) + makePars(PL))
    [owise] .

  eq makePars((P, PL)) = "," + string(P) + makePars(PL) .
  eq makePars(P) = "," + string(P) + "}" .
  eq makePars(empty) = "}" .

  op list2set : TypeList -> TypeSet .
  eq list2set(Tp TpL) = Tp ; list2set(TpL) .
  eq list2set(nil) = none .

  op type2qid : Type -> Qid .
  eq type2qid(S)
    = if getPars(S) == empty
      then S
      else qid(string(getName(S)) + "{" + string(qidList2Qid(parameterList2QidList(getPars(S)))) + "}")
      fi .
  eq type2qid(K) = qid("[" + string(type2qid(getSort(K))) + "]") .

  op size : TypeList -> Nat .
  eq size(Tp TpL) = 1 + size(TpL) .
  eq size((nil).TypeList) = 0 .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod DEFAULT-VALUE{X :: TRIV} is
  sort Default{X} .
  subsort X$Elt < Default{X} .
  op null : -> Default{X} .
endfm

view Term from TRIV to META-TERM is
  sort Elt to Term .
endv

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Extended Declarations
***

*** In this section we discuss modules \texttt{EXT-DECL} and \texttt{O-O-DECL}
*** which introduce, respectively, the declarations extending the sorts and
*** constructors for declarations of the predefined data type \texttt{Module}
*** in the \texttt{META-LEVEL} module to allow the use of extended sorts in
*** them, and the declarations appearing in object-oriented units, namely
*** class declarations, subclass relation declarations, and message
*** declarations.

***
*** Declarations of Functional and System Modules
***

*** In the following module \texttt{EXT-DECL}, we introduce the declarations
*** extending those in \texttt{META-LEVEL} to allow the use of extended sorts
*** in declarations of sorts, subsort relations, operators, variables, and
*** membership axioms.

*** \begin{comment}
*** \footnote{In the future, the declarations for operators,
*** membership axioms, equations, and rules will be extended to allow
*** the use of extended sorts in sort tests, that is, terms of the
*** form \mbox{\verb~T : S~} and \mbox{\verb~T :: S~}.}
*** \end{comment}

*** The extension is accomplished by adding new supersorts for each of the
*** sorts in \texttt{META-LEVEL} involved, and by adding new constructors for
*** these new sorts.

*** We start introducing the declarations for the supersorts and their
*** corresponding constructors. The \texttt{EXT-DECL} module also contains the
*** declarations for sTS of such declarations.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod INT-LIST is
  pr META-MODULE .
  pr INT .
  sort IntList .
  subsort Int NatList < IntList .
  op __ : IntList IntList -> IntList [ctor ditto] .

  op numberError : QidList -> [Nat] .

  vars N M : Nat .

  op from_to_list : Nat Nat ~> NatList .
  ceq from N to M list
    = if N == M
      then N
      else N from N + 1 to M list
      fi
    if N <= M .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod EXT-DECL is
  pr EXT-SORT .
  pr INT-LIST .

  var  QI : Qid .
  vars QIL QIL' : QidList .
  var  At : Attr .
  var  AtS : AttrSet .
  var  OPD OPD' : OpDecl .
  var  OPDS : OpDeclSet .
  vars LHS RHS T T' : Term .
  var  S : Sort .
  var  Cond : Condition .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  MbS : MembAxSet .
  var  M : Module .

  op variant : -> Attr [ctor] .

*** subsort declarations error
  op subsortDeclError : QidList -> [SubsortDeclSet] [ctor format (r o)] .
  eq subsortDeclError(QIL) subsortDeclError(QIL')
    = subsortDeclError(QIL QIL') .

*** extended attribute declarations
  op strat : IntList -> Attr [ditto] .   *** to handle on-demand strategies
  op ditto : -> Attr [ctor] .

  op _in_ : Attr AttrSet -> Bool .
  eq At in At AtS = true .
  eq At in AtS = false [owise] .

*** extended operation declarations
  op opDeclError : QidList -> [OpDeclSet] [ctor format (r o)] .
  eq opDeclError(QIL) opDeclError(QIL') = opDeclError(QIL QIL') .

*** extended membership axioms
  op membAxError : QidList -> [MembAxSet] [ctor format (r o)] .
  eq membAxError(QIL) membAxError(QIL') = membAxError(QIL QIL') .

*** extended equations
  op equationError : QidList -> [EquationSet] [ctor format (r o)] .
  eq equationError(QIL) equationError(QIL') = equationError(QIL QIL') .

*** extended rules
  op ruleError : QidList -> [RuleSet] [ctor format (r o)] .
  eq ruleError(QIL) ruleError(QIL') = ruleError(QIL QIL') .

*** The function \verb~_in_~ checks whether a given operator
*** declaration is in a set of operator declarations.

  op _in_ : OpDecl OpDeclSet -> Bool .

  eq OPD in (OPD OPDS) = true .
  eq OPD in OPDS = false [owise] .

  ops lhs rhs : Rule -> Term .
  op cond : Rule -> Condition .
  op atts : Rule -> AttrSet .
  op label : Rule -> [Qid] .
  eq lhs(rl LHS => RHS [AtS] .) = LHS .
  eq lhs(crl LHS => RHS if Cond [AtS] .) = LHS .
  eq rhs(rl LHS => RHS [AtS] .) = RHS .
  eq rhs(crl LHS => RHS if Cond [AtS] .) = RHS .
  eq cond(rl LHS => RHS [AtS] .) = nil .
  eq cond(crl LHS => RHS if Cond [AtS] .) = Cond .
  eq atts(rl LHS => RHS [AtS] .) = AtS .
  eq atts(crl LHS => RHS if Cond [AtS] .) = AtS .
  eq label(rl LHS => RHS [label(QI) AtS] .) = QI .
  eq label(crl LHS => RHS if Cond [label(QI) AtS] .) = QI .

  ops lhs rhs : Equation -> Term .
  op cond : Equation -> Condition .
  op atts : Equation -> AttrSet .
  op label : Equation -> [Qid] .
  eq lhs(eq LHS = RHS [AtS] .) = LHS .
  eq lhs(ceq LHS = RHS if Cond [AtS] .) = LHS .
  eq rhs(eq LHS = RHS [AtS] .) = RHS .
  eq rhs(ceq LHS = RHS if Cond [AtS] .) = RHS .
  eq cond(eq LHS = RHS [AtS] .) = nil .
  eq cond(ceq LHS = RHS if Cond [AtS] .) = Cond .
  eq atts(eq LHS = RHS [AtS] .) = AtS .
  eq atts(ceq LHS = RHS if Cond [AtS] .) = AtS .
  eq label(eq LHS = RHS [label(QI) AtS] .) = QI .
  eq label(ceq LHS = RHS if Cond [label(QI) AtS] .) = QI .

  op cond : MembAx -> Condition .
  op atts : MembAx -> AttrSet .
  eq cond(mb T : S [AtS] .) = nil .
  eq cond(cmb T : S if Cond [AtS] .) = Cond .
  eq atts(mb T : S [AtS] .) = AtS .
  eq atts(cmb T : S if Cond [AtS] .) = AtS .

  op rulify : EquationSet -> RuleSet .
  ---- takes a set of equations and turn them into rules
  eq rulify(eq LHS = RHS [AtS] . EqS) = (rl LHS => RHS [AtS] .) rulify(EqS) .
  eq rulify(ceq LHS = RHS if Cond [AtS] . EqS) = (crl LHS => RHS if Cond [AtS] .) rulify(EqS) .
  eq rulify((none).EquationSet) = none .
endfm

**** The module EXT-TERM extends META-LEVEL with definitions of several
**** operations that manipulate terms: definitions for positions and operations
**** to get the subterm of a given term at a given position, to replace the
**** subterm of a term at a given position by another term, to get all the
**** nonvariable positions in a term, to apply a substitution to a term, and to
**** get a copy of a term in which all the variables in it have been renamed.

fmod EXT-TERM is
---  pr META-LEVEL + PRE-VARIANT .
  pr META-LEVEL .
  pr EXT-BOOL .
  pr EXT-DECL .

  vars T T' : Term .
  vars F X : Qid .
  var  TL : TermList .
  var  N : Nat .
  vars NL NL' : NatList .
  vars V V' W : Variable .
  var  Subst : Substitution .
  vars C Ct : Constant .
  var  NTL : NeTermList .
  var  M : Module .
  var  Tp : Type .
  vars TpL TpL' : TypeList .
  vars AtS AtS' : AttrSet .
  var  ODS : OpDeclSet .
  var  Cd : Condition .
  var  S : Sort .

  **** vars returns the set of variables in a term
  op vars : Term -> QidSet .
  op vars : TermList -> QidSet .

  eq vars(V) = V .
  eq vars(C) = none .
  eq vars(F[TL]) = vars(TL) .
  eq vars(empty) = none .
  eq vars((T, TL)) = vars(T) ; vars(TL) .

  **** varlist returns the list of variables in a term
  op varlist : Term -> QidList .
  op varlist : TermList -> QidList .

  eq varlist(V) = V .
  eq varlist(C) = nil .
  eq varlist(F[TL]) = varlist(TL) .
  eq varlist(empty) = nil .
  eq varlist((T, TL)) = varlist(T) varlist(TL) .

  **** occurs? checks whether a variable name occurs in a term or not.
  op occurs? : Variable Term -> Bool .
  op occurs? : Variable TermList -> Bool .
  eq occurs?(V, V') = V == V' .
  eq occurs?(V, C) = false .
  eq occurs?(V, F[TL]) = occurs?(V, TL) .
  eq occurs?(V, (T, TL)) = occurs?(V, T) or-else  occurs?(V, TL) .

  **** occurrences checks whether a variable name occurs in a term or not.
  op occurrences : Variable Term -> Nat .
  op occurrences : Variable TermList -> Nat .
  eq occurrences(V, V') = if V == V' then 1 else 0 fi .
  eq occurrences(V, C) = 0 .
  eq occurrences(V, F[TL]) = occurrences(V, TL) .
  eq occurrences(V, (T, TL)) = occurrences(V, T) + occurrences(V, TL) .

  op frozen : Module Term Nat -> Bool .
  op frozen : Module OpDeclSet Qid TypeList Nat -> Bool .
  eq frozen(M, F[TL], N)
    = frozen(M, getOps(M), F, eLeastSort(M, TL), N) .

  ceq frozen(M, op F : TpL -> Tp [AtS] . ODS, F, TpL', N)
    = true
    if sameKind(M, TpL, TpL')
       /\ not ctor(M, op F : TpL -> Tp [AtS] . ODS, F, TpL') .
  ceq frozen(M, op F : TpL -> Tp [AtS] . ODS, F, TpL', N)
    = true
    if sameKind(M, TpL, TpL')
       /\ ctor(M, op F : TpL -> Tp [AtS] . ODS, F, TpL')
       /\ frozen(NL N NL') AtS' := AtS .
  eq frozen(M, ODS, F, TpL, N) = false [owise] .

  ---- ctor check whether the operator at the top is a constructor
  ---- in any of its overloadings
  op ctor : Module OpDeclSet Term -> Bool .
  op ctor : Module OpDeclSet Qid TypeList -> Bool .

  eq ctor(M, ODS, Ct) = ctor(M, ODS, Ct, nil) .
  eq ctor(M, ODS, F[TL]) = ctor(M, ODS, F, eLeastSort(M, TL)) .
  eq ctor(M, ODS, T) = false [owise] .

  ceq ctor(M, op F : TpL -> Tp [AtS] . ODS, F, TpL')
    = ctor in AtS or-else ctor(M, ODS, F, TpL')
    if sameKind(M, TpL, TpL') .
  eq ctor(M, ODS, F, TpL) = false [owise] .

**** The function \texttt{substitute} takes a term $t$ and a substitution
**** $\sigma$ and returns the term $t\sigma$.

  op substitute : Module Term Substitution -> Term .
  op substitute : Module TermList Substitution -> TermList .

  eq substitute(M, T, none) = T .
  eq substitute(M, V, ((W <- T) ; Subst))
    = if getName(V) == getName(W) and-then sameKind(M, getType(V), getType(W))
      then T
      else substitute(M, V, Subst)
      fi .
  eq substitute(M, C, ((W <- T); Subst)) = C .
  eq substitute(M, F[TL], Subst) = F[substitute(M, TL, Subst)] .
  eq substitute(M, (T, TL), Subst)
    = (substitute(M, T, Subst), substitute(M, TL, Subst)) .

  op substitute : Module EqCondition Substitution -> EqCondition .
  eq substitute(M, T = T' /\ Cd, Subst)
    = substitute(M, T, Subst) = substitute(M, T', Subst) /\ substitute(M, Cd, Subst) .
  eq substitute(M, T := T' /\ Cd, Subst)
    = substitute(M, T, Subst) := substitute(M, T', Subst) /\ substitute(M, Cd, Subst) .
  eq substitute(M, T : S /\ Cd, Subst)
    = substitute(M, T, Subst) : S /\ substitute(M, Cd, Subst) .
  eq substitute(M, (nil).EqCondition, Subst) = nil .
endfm

***(
red substitute('f['X:Foo, 'g['Y:Foo, 'Z:Foo]], ('Y:Foo <- 'h['W:Foo])) .
red rename('f['X:Foo, 'g['Y:Foo, 'Z:Foo]]) .
red allNonVarPos(
      substitute('f['X:Foo, 'g['Y:Foo, 'Z:Foo]], ('Y:Foo <- 'h['W:Foo]))) .
)

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Declarations for Object-Oriented Modules
***

*** In the \texttt{O-O-DECL} module we introduce the sorts and constructors
*** for declarations of classes, subclass relations, and messages in
*** object-oriented units.

*** Note that we follow the same naming conventions for classes as for
*** extended sorts (see Section~\ref{parameterized-modules}), and therefore
*** we use the sort \texttt{Sort} for class identifiers, and
*** \texttt{TypeList} and \texttt{SortSet} for lists and sTS of class
*** identifiers, respectively.  We use the operator \verb~attr_:_~ as a
*** constructor for declarations of attributes. Since the operator name
*** \texttt{\_\,:\_\,} is used for sort  tests in the \texttt{META-LEVEL}
*** module, we use \texttt{attr\_\,:\_\,} as  constructor for declarations of
*** attributes to satisfy the preregularity  condition.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod O-O-DECL is
  pr EXT-SORT .

  vars QIL QIL' : QidList .

  sorts AttrDecl AttrDeclSet .
  subsort AttrDecl < AttrDeclSet .
  op attr_:_ : Qid Sort -> AttrDecl .
  op none : -> AttrDeclSet .
  op _`,_ : AttrDeclSet AttrDeclSet -> AttrDeclSet [assoc comm id: none] .

  eq AD:AttrDecl, AD:AttrDecl = AD:AttrDecl .

  sorts ClassDecl ClassDeclSet .
  subsort ClassDecl < ClassDeclSet .
  op class_|_. : Sort AttrDeclSet -> ClassDecl .
  op none : -> ClassDeclSet .
  op __ : ClassDeclSet ClassDeclSet -> ClassDeclSet [assoc comm id: none] .

  op classDeclError : QidList -> [ClassDeclSet] [ctor format (r o)] .
  eq classDeclError(QIL) classDeclError(QIL') = classDeclError(QIL QIL') .

  eq CD:ClassDecl CD:ClassDecl = CD:ClassDecl .

  sorts SubclassDecl SubclassDeclSet .
  subsort SubclassDecl < SubclassDeclSet .
  op subclass_<_. : Sort Sort -> SubclassDecl .
  op none : -> SubclassDeclSet .
  op __ : SubclassDeclSet SubclassDeclSet -> SubclassDeclSet
     [assoc comm id: none] .

  eq SCD:SubclassDecl SCD:SubclassDecl = SCD:SubclassDecl .

  op subclassDeclError : QidList -> [SubclassDeclSet] [ctor format (r o)] .
  eq subclassDeclError(QIL) subclassDeclError(QIL')
    = subclassDeclError(QIL QIL') .

  sorts MsgDecl MsgDeclSet .
  subsort MsgDecl < MsgDeclSet .
  op msg_:_->_. : Qid TypeList Sort -> MsgDecl .
  op none : -> MsgDeclSet .
  op __ : MsgDeclSet MsgDeclSet -> MsgDeclSet [assoc comm id: none] .

  eq MD:MsgDecl MD:MsgDecl = MD:MsgDecl .

  op msgDeclError : QidList -> [MsgDeclSet] [ctor format (r o)] .
  eq msgDeclError(QIL) msgDeclError(QIL') = msgDeclError(QIL QIL') .

*** The function \texttt{classSet} returns the set of class identifiers in
*** the set of class declarations given as argument.

  op classSet : ClassDeclSet -> SortSet .

  eq classSet((class S:Sort | ADS:AttrDeclSet .) CDS:ClassDeclSet)
    = (S:Sort ; classSet(CDS:ClassDeclSet)) .
  eq classSet(none) = none .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Renaming Maps
***

*** We introduce the different types of renaming maps in the module
*** \texttt{FMAP} below. A sort is introduced for each of these types of maps,
*** with the appropriate constructors for each sort (see
*** Section~\ref{module-expressions}). All these sorts are declared to be
*** subsorts of the sort \texttt{Map}. A sort for sTS of
*** maps (\texttt{RenamingSet}) is then declared as supersort of \texttt{Map}
*** with constructors \texttt{none} and \verb~_,_~.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FMAP is
  inc META-MODULE .
  pr EXT-SORT .

  *** renamings
  op class_to_ : Sort Sort -> Renaming .
  op attr_._to_ : Qid Sort Qid -> Renaming .
  op msg_to_ : Qid Qid -> Renaming .
  op msg_:_->_to_ : Qid TypeList Sort Qid -> Renaming .
  op op_to term_ : Term Term -> Renaming .

  op none : -> RenamingSet .
  eq (MAP, MAP) = MAP .
  eq (MAPS, none) = MAPS .

----  eq attr A . qidError(QIL) to A' = none .

*** Given a set of maps, the function \texttt{sortMaps} returns the
*** subset of sort maps in it.

  var  MAP : Renaming .
  var  MAPS : RenamingSet .
  vars S S' A A' : Sort .
  var  QIL : QidList .

  op sortMaps : RenamingSet -> RenamingSet .

  eq sortMaps(sort S to S') = sort S to S' .
  eq sortMaps(((sort S to S'), MAPS))
    = ((sort S to S'), sortMaps(MAPS)) .
  eq sortMaps(MAP) = none [owise] .
  eq sortMaps((MAP, MAPS)) = sortMaps(MAPS) [owise] .
  eq sortMaps(none) = none .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Module Expressions and Module Names
***

*** The abstract syntax for writing specifications in Maude can be seen as
*** given by module expressions, where the notion of module expression is
*** understood as an expression that defines a new module out of previously
*** defined modules by combining and/or modifying them according to a specific
*** set of operations.  All module expressions will be evaluated generating
*** modules with such module expressions as names. In the case of parameterized
*** modules, each of the parameters in an interface will be used as the name
*** of a new module created as a renamed copy of the parameter theory.

***
*** Module Expressions
***

*** The \texttt{TUPLE} and \texttt{POWER} are declared to be new types of
*** \texttt{ModuleExpression}s.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-EXPR is
  inc META-MODULE .
  pr FMAP .

  op TUPLE`[_`] : NzNat -> ModuleExpression .
  op POWER`[_`] : NzNat -> ModuleExpression .

  eq ME:ModuleExpression * ( none ) = ME:ModuleExpression .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Module Names
***

*** As we shall see in the coming sections, the evaluation of module
*** expressions may produce the creation of new modules, whose \emph{names}
*** are given by the module expressions themselves. If there is already a
*** module in the database with the module expression being evaluated as name,
*** the evaluation of such module expression does not produce any change in
*** the database. However, the evaluation of a module expression may involve
*** the evaluation of some other module expressions contained in the modules
*** involved, which in turn may generate new modules.

*** Given a parameterized module $\texttt{N\{L}_1\texttt{\ ::\ T}_1
*** \texttt{\ ,\ }\ldots\texttt{\ ,\ L}_n\texttt{\ ::\ T}_n\texttt{\}}$, with
*** $\texttt{L}_1\ldots\texttt{L}_n$ labels and
*** $\texttt{T}_1\ldots\texttt{T}_n$ theory identifiers, we say that
*** \texttt{N} is the name of the module and that
*** $\texttt{\{L}_1\texttt{\ ::\ T}_1\texttt{\ ,\ }
*** \ldots\texttt{\ ,\ L}_n\texttt{\ ::\ T}_n\texttt{\}}$
*** is its \emph{interface}.
*** As we shall see in Sections~\ref{instantiation} and~\ref{unit-processing},
*** for each parameter $\texttt{L}_i\texttt{\ ::\ T}_i$ in the interface of a
*** module, a new module is generated with such a parameter expression as its
*** name, and a declaration importing it in the parameterized module is added.
***  We regard the relationship between the body of a parameterized module and
*** the parameters in its interface, not as an inclusion, but as mediated by
*** a module constructor that generates renamed copies of the parameters,
*** which are then included. Therefore, the sort \texttt{ViewExp} is
*** declared as a subsort of \texttt{Header}, that is, terms of sort
*** \texttt{ViewExp} are considered to be module names. The constructor
*** operator for the sort \texttt{ViewExp} is \verb~par_::_~.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-NAME is
  inc MOD-EXPR .
  pr EXT-BOOL .
  op parameterError : QidList -> [ParameterDecl] .

  sort ModuleName .
  subsorts ModuleExpression < ModuleName < Header .
  op _{_}  : ModuleExpression ParameterDeclList -> Header .
  op pd : ParameterDecl -> ModuleName .
  op nullHeader : -> Header .

  op getName : Header -> ModuleExpression .
  op getParDecls : Header -> ParameterDeclList .

  vars QI QI' : Qid .
  var  ME : ModuleExpression .
  vars PDL PDL' : ParameterDeclList .
  var  PL : NeParameterList .
  var  MN : ModuleName .

  eq getName(ME{PDL}) = ME .
  eq getName(MN) = MN .
  eq getParDecls(ME{PDL}) = PDL .
  eq getParDecls(MN) = nil .

  op including_. : ModuleName -> Import [ctor] .
  op extending_. : ModuleName -> Import [ctor] .
  op protecting_. : ModuleName -> Import [ctor] .

  op fth_is_sorts_.____endfth : Header ImportList SortSet SubsortDeclSet
    OpDeclSet MembAxSet EquationSet -> FTheory [ctor gather (& & & & & & &)
     format (d d d n++i ni d d ni ni ni ni n--i d)] .
  op th_is_sorts_._____endth : Header ImportList SortSet SubsortDeclSet
    OpDeclSet MembAxSet EquationSet RuleSet -> STheory
    [ctor gather (& & & & & & & &)
     format (d d d n++i ni d d ni ni ni ni ni n--i d)] .

*** The function \texttt{labelInParameterDeclList} checks whether the quoted
*** identifier given as first argument is used as a label in the list of
*** parameters given as second argument.

  op labelInParameterDeclList : Sort ParameterDeclList -> Bool .
  eq labelInParameterDeclList(QI, (PDL, (QI :: ME), PDL')) = true .
  eq labelInParameterDeclList(QI, PDL) = false [owise] .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** Since the Core Maude engine assumes that module names are identifiers and
*** does not know about term-structured module names (such as parameterized
*** module interfaces or module expressions), for evaluation purposes we need
*** to transform them into quoted identifiers. The functions
*** \texttt{header2Qid} and \texttt{header2QidList} in the module
*** \texttt{MOD-NAME-TO-QID} below accomplish this transformation. In any
*** language extensions, new equations for the function
*** \texttt{header2QidList} should be added for each new module expression
*** constructor introduced. In Sections~\ref{renaming} and~\ref{instantiation}
*** we shall see how the corresponding equalities are added for renaming and
*** instantiation expressions, and in Section~\ref{extension} for other new
*** module expressions in extensions of Full Maude.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-NAME-TO-QID is
  pr MOD-NAME .
  pr EXT-QID-LIST .

  op header2Qid : Header -> Qid .
  op header2QidList : Header -> QidList .
  op parameterDecl2Qid : ParameterDecl -> Qid .
  op parameterDecl2QidList : ParameterDecl -> QidList .
  op parameterDeclList2Qid : ParameterDeclList -> Qid .
  op parameterDeclList2QidList : ParameterDeclList -> QidList .

  vars QI X : Qid .
  var  QIL : QidList .
  vars ME ME' : ModuleExpression .
  var  PDL : ParameterDeclList .
  var  PD : ParameterDecl .

  eq header2Qid(QI) = QI .
  eq header2Qid(nullHeader) = ' .
  eq header2Qid(pd(X :: ME)) = qidList2Qid(header2QidList(pd(X :: ME))) .
  eq header2QidList(pd(X :: ME)) = X ':: header2QidList(ME) .

  eq header2QidList(QI) = QI .
  eq header2QidList(nullHeader) = ' .

  eq header2Qid((ME { PDL })) = qidList2Qid(header2QidList((ME { PDL }))) .
  ceq header2QidList((ME { PDL }))
    = (if QI == '\s then QIL else QIL QI fi
       '`{ parameterDecl2QidList(PDL) '`} '\s)
    if QIL QI := header2QidList(ME) .

  eq parameterDecl2Qid(X :: ME) = qidList2Qid(X ':: header2Qid(ME)) .

  eq parameterDeclList2Qid(PDL)
    = qidList2Qid(parameterDeclList2QidList(PDL)) .

  eq parameterDeclList2QidList(X :: ME) = X ':: header2QidList(ME) .
  eq parameterDeclList2QidList((X :: ME, PDL))
    = parameterDeclList2QidList(X :: ME) '`, parameterDeclList2QidList(PDL)
    [owise] .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Modules
***

*** We handle six different types of units: functional, system, and
*** object-oriented modules, and functional, system, and object-oriented
*** theories.  Modules and theories of any kind are considered to be elements
*** in specific subsorts of the sort \texttt{Module}. A constructor
*** \texttt{error} is also included to represent incorrect units.
*** \texttt{error} has a list of quoted identifiers as argument, which is
*** used to report the error. Besides considering functional and system
*** theories and object-oriented theories and modules, the declarations
*** presented in the following module extend the declarations for sort
*** \texttt{Module} in the \texttt{META-LEVEL} module in three different ways:

*** \begin{itemize}
*** \item the name of a module can be any term of sort \texttt{Header},
*** \item parameterized modules are handled, for which a list of
***       parameters is added to the constructors of modules,
*** \item the importation declaration is extended to module names, and
*** \item parameterized sorts are supported.
*** \end{itemize}

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod UNIT is
  pr EXT-DECL .
  pr O-O-DECL .
  pr MOD-NAME-TO-QID .
---  inc META-LEVEL + PRE-VARIANT .
  inc META-LEVEL .

  op moduleName : Import -> ModuleName .
  eq moduleName(protecting MN .) = MN .
  eq moduleName(protecting ME{PL} .) = ME .
  eq moduleName(extending MN .) = MN .
  eq moduleName(extending ME{PL} .) = ME .
  eq moduleName(including MN .) = MN .
  eq moduleName(including ME{PL} .) = ME .

  op importError : QidList -> [ImportList] [ctor format (r o)] .
  eq importError(QIL) importError(QIL') = importError(QIL QIL') .

  sorts OModule OTheory .
  subsorts SModule < OModule < Module .
  subsorts STheory < OTheory < Module .

  op noModule : -> Module .   *** Module
  op unitError : QidList -> [Module] [ctor format (r o)] .
  op getMsg : [Module] -> QidList .
  eq getMsg(unitError(QIL)) = QIL .

  op omod_is_sorts_.________endom : Header ImportList
        SortSet SubsortDeclSet ClassDeclSet SubclassDeclSet OpDeclSet
        MsgDeclSet MembAxSet EquationSet RuleSet -> OModule
        [ctor
         gather (& & & & & & & & & & &)
         format (r! o r! n++io ni d d ni ni ni ni ni ni ni ni n--ir! o)] .
  op oth_is_sorts_.________endoth : Header ImportList
        SortSet SubsortDeclSet ClassDeclSet SubclassDeclSet OpDeclSet
        MsgDeclSet MembAxSet EquationSet RuleSet -> OTheory
        [ctor
         gather (& & & & & & & & & & &)
         format (r! o r! n++io ni d d ni ni ni ni ni ni ni ni n--ir! o)] .

*** In addition to the constructor operators, the following functions are
*** introduced in the \texttt{UNIT} module:
*** \begin{itemize}
*** \item A function \verb~_in_~ to check whether a given importation
***       declaration is in a set of importation declarations or not.

  op _in_ : Import ImportList -> Bool .

*** \item Selector functions for the different components of a Module.

  op getName : Module -> Header .
  op getPars : Module -> ParameterDeclList .
  op getClasses : Module -> ClassDeclSet .
  op getSubclasses : Module -> SubclassDeclSet .
  op getMsgs : Module -> MsgDeclSet .

*** \item Functions to change the value of each of the components of a Module.

  op setName : Module ModuleExpression -> Module .
  op setName : Module ParameterDecl -> Module .
  op setPars : Module ParameterDeclList -> Module .
  op setImports : Module ImportList -> Module .
  op setSorts : Module SortSet -> Module .
  op setSubsorts : Module SubsortDeclSet -> Module .
  op setOps : Module OpDeclSet -> Module .
  op setMbs : Module MembAxSet -> Module .
  op setEqs : Module EquationSet -> Module .
  op setRls : Module RuleSet ~> Module .
  op setClasses : Module ClassDeclSet -> Module .
  op setSubclasses : Module SubclassDeclSet -> Module .
  op setMsgs : Module MsgDeclSet -> Module .

*** \item Functions to add new declarations to the set of declarations
*** already in a unit.

  op addImports : ImportList Module -> Module .
  op addSorts : SortSet Module -> Module .
  op addSubsorts : [SubsortDeclSet] Module -> Module .
  op addOps : [OpDeclSet] Module -> Module .
  op addMbs : MembAxSet Module -> Module .
  op addEqs : EquationSet Module -> Module .
  op addRls : RuleSet Module -> Module .
  op addClasses : ClassDeclSet Module -> Module .
  op addSubclasses : SubclassDeclSet Module -> Module .
  op addMsgs : MsgDeclSet Module -> Module .

*** \item There are functions and constants to create empty modules of the
***       different types. For example, the function \texttt{emptyFTheory}
***       returns an empty functional theory. There is also a
***       function \texttt{empty} which takes a module as argument and returns
***       an empty module of the same type.

  op emptyFModule : Header -> FModule .
  op emptyFModule : -> FModule .
  op emptySModule : -> SModule .
  op emptyOModule : -> OModule .
  op emptyFTheory : -> FModule .
  op emptySTheory : -> SModule .
  op emptyOTheory : -> OModule .
  op empty : Module -> Module .

*** \item A function \texttt{addDecls} which returns the module resulting from
***       adding all the declarations in the module passed as second argument
***       to the module passed as first argument.

  op addDecls : Module Module -> Module .

*** \end{itemize}

*** Note that some of the `set' and `add' functions are partial functions.

  vars M M' M'' : Module .
  vars QI V : Qid .
  var  S : Sort .
  vars SSDS SSDS' SSDS'' : SubsortDeclSet .
  vars OPD OPD' : OpDecl .
  vars OPDS OPDS' : OpDeclSet .
  var  OPDS? : [OpDeclSet] .
  var  At : Attr .
  var  AtS : AttrSet .
  vars MAS MAS' MbS : MembAxSet .
  vars Eq Eq' : Equation .
  vars EqS EqS' : EquationSet .
  vars Rl Rl' : Rule .
  vars RlS RlS' : RuleSet .
  vars SS SS' : SortSet .
  vars IL IL' : ImportList .
  vars QIL QIL' : QidList .
  vars PL PL' : ParameterList .
  vars CDS CDS' : ClassDeclSet .
  vars SCD SCD' : SubclassDecl .
  vars SCDS SCDS' : SubclassDeclSet .
  vars U U' : Module .
  vars MDS MDS' : MsgDeclSet .
  vars I I' : Import .
  vars T T' T1 T1' T2 T2' : Term .
  vars ME ME' : ModuleExpression .
  vars PD PD' : ParameterDecl .
  vars PDL PDL' : ParameterDeclList .
  var  H : Header .
  vars MN MN' : ModuleName .
  var  Cd Cond Cond1 Cond2 : Condition .

  eq I in (IL I IL') = true .
  eq I in IL = false [owise] .

  op theory : Module -> Bool .
  eq theory(unitError(QIL)) = false .
  eq theory(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = false .
  eq theory(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = true .
  eq theory(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = false .
  eq theory(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth) = true .
  eq theory(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = false .
  eq theory(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = true .

*** Selection functions for units

  eq getName(unitError(QIL)) = ' .
  eq getName(noModule) = ' .
  eq getName(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = ME .
  eq getName(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = ME .
  eq getName(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = MN .
  ----eq getName(th PD is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = PD .
  eq getName(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm) = ME .
  eq getName(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm) = ME .
  eq getName(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth) = MN .
  eq getName(
       omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = ME .
  eq getName(
       omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = ME .
  eq getName(
       oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = MN .

  eq getImports(unitError(QIL)) = nil .
  eq getImports(noModule) = nil .
  eq getImports(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = IL .
  eq getImports(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = IL .
  eq getImports(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = IL .
  eq getImports(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = IL .
  eq getImports(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = IL .
  eq getImports(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = IL .

  eq getPars(unitError(QIL)) = nil .
  eq getPars(noModule) = nil .
  eq getPars(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = nil .
  eq getPars(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = PDL .
  eq getPars(mod nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = nil .
  eq getPars(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = nil .
  eq getPars(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = nil .
  eq getPars(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm) = nil .
  eq getPars(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm) = PDL .
  eq getPars(fmod nullHeader is IL sorts SS . SSDS OPDS MAS EqS endfm) = nil .
  eq getPars(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth) = nil .
  eq getPars(
       omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = nil .
  eq getPars(
        omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS
        endom)
    = PDL .
  eq getPars(
        omod nullHeader is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS
        endom)
    = nil .
  eq getPars(
       oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = nil .

  eq getSorts(unitError(QIL)) = none .
  eq getSorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = SS .
  eq getSorts(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = SS .
  eq getSorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = SS .
  eq getSorts(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = SS .
  eq getSorts(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = SS .
  eq getSorts(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = SS .

  op getAllSorts : Module -> SortSet .
  eq getAllSorts(M) = getSorts(M) .

  eq getSubsorts(unitError(QIL)) = none .
  eq getSubsorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = SSDS .
  eq getSubsorts(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = SSDS .
  eq getSubsorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = SSDS .
  eq getSubsorts(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = SSDS .
  eq getSubsorts(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = SSDS .
  eq getSubsorts(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = SSDS .

  eq getOps(unitError(QIL)) = none .
  eq getOps(noModule) = none .
  eq getOps(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = OPDS .
  eq getOps(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = OPDS .
  eq getOps(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = OPDS .
  eq getOps(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = OPDS .
  eq getOps(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = OPDS .
  eq getOps(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = OPDS .

  eq getMbs(unitError(QIL)) = none .
  eq getMbs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = MAS .
  eq getMbs(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = MAS .
  eq getMbs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = MAS .
  eq getMbs(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = MAS .
  eq getMbs(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = MAS .
  eq getMbs(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = MAS .

  eq getEqs(unitError(QIL)) = none .
  eq getEqs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = EqS .
  eq getEqs(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = EqS .
  eq getEqs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = EqS .
  eq getEqs(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = EqS .
  eq getEqs(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = EqS .
  eq getEqs(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = EqS .

  eq getRls(unitError(QIL)) = none .
  eq getRls(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = RlS .
  eq getRls(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = RlS .
  eq getRls(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getRls(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getRls(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = RlS .
  eq getRls(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = RlS .

  eq getClasses(unitError(QIL)) = none .
  eq getClasses(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getClasses(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getClasses(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getClasses(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getClasses(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = CDS .
  eq getClasses(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = CDS .

  eq getSubclasses(unitError(QIL)) = none .
  eq getSubclasses(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getSubclasses(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getSubclasses(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getSubclasses(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getSubclasses(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = SCDS .
  eq getSubclasses(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = SCDS .

  eq getMsgs(unitError(QIL)) = none .
  eq getMsgs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getMsgs(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getMsgs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getMsgs(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getMsgs(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = MDS .
  eq getMsgs(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = MDS .

*** Set functions

  eq setImports(unitError(QIL), IL) = unitError(QIL) .
  eq setImports(noModule, IL) = noModule .
  eq setImports(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, IL')
    = mod H is IL' sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setImports(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, IL')
    = th H is IL' sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setImports(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, IL')
    = fmod H is IL' sorts SS . SSDS OPDS MAS EqS endfm .
  eq setImports(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, IL')
    = fth H is IL' sorts SS . SSDS OPDS MAS EqS endfth .
  eq setImports(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, IL')
    = omod H is IL' sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setImports(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, IL')
    = oth H is IL' sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .

  eq setOps(unitError(QIL), OPDS) = unitError(QIL) .
  eq setOps(noModule, OPDS) = noModule .
  eq setOps(U, opDeclError(QIL) OPDS) = unitError(QIL) .
  eq setOps(unitError(QIL), opDeclError(QIL') OPDS) = unitError(QIL QIL') .
  eq setOps(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, OPDS')
    = mod H is IL sorts SS . SSDS OPDS' MAS EqS RlS endm .
  eq setOps(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, OPDS')
    = th MN is IL sorts SS . SSDS OPDS' MAS EqS RlS endth .
  eq setOps(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, OPDS')
    = fmod H is IL sorts SS . SSDS OPDS' MAS EqS endfm .
  eq setOps(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, OPDS')
    = fth MN is IL sorts SS . SSDS OPDS' MAS EqS endfth .
  eq setOps(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
       OPDS')
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS' MDS MAS EqS RlS endom .
  eq setOps(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
       OPDS')
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS' MDS MAS EqS RlS endoth .

  eq setSubsorts(unitError(QIL), SSDS) = unitError(QIL) .
  eq setSubsorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, SSDS')
    = mod H is IL sorts SS . SSDS' OPDS MAS EqS RlS endm .
  eq setSubsorts(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, SSDS')
    = th MN is IL sorts SS . SSDS' OPDS MAS EqS RlS endth .
  eq setSubsorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, SSDS')
    = fmod H is IL sorts SS . SSDS' OPDS MAS EqS endfm .
  eq setSubsorts(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, SSDS')
    = fth MN is IL sorts SS . SSDS' OPDS MAS EqS endfth .
  eq setSubsorts(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
       SSDS')
    = omod H is IL sorts SS . SSDS' CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setSubsorts(
       oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
       SSDS')
    = oth MN is IL sorts SS . SSDS' CDS SCDS OPDS MDS MAS EqS RlS endoth .

  eq setMbs(unitError(QIL), membAxError(QIL') MAS) = unitError(QIL QIL') .
  eq setMbs(unitError(QIL), MAS) = unitError(QIL) .
  eq setMbs(U, membAxError(QIL) MAS) = unitError(QIL) .
  eq setMbs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, MAS')
    = mod H is IL sorts SS . SSDS OPDS MAS' EqS RlS endm .
  eq setMbs(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MAS')
    = th MN is IL sorts SS . SSDS OPDS MAS' EqS RlS endth .
  eq setMbs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, MAS')
    = fmod H is IL sorts SS . SSDS OPDS MAS' EqS endfm .
  eq setMbs(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, MAS')
    = fth MN is IL sorts SS . SSDS OPDS MAS' EqS endfth .
  eq setMbs(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, MAS')
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS' EqS RlS endom .
  eq setMbs(
       oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, MAS')
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS' EqS RlS endoth .

  eq setEqs(unitError(QIL), EqS) = unitError(QIL) .
  eq setEqs(U, equationError(QIL) EqS?:[EquationSet]) = unitError(QIL) .
  eq setEqs(unitError(QIL), equationError(QIL') EqS?:[EquationSet])
    = unitError(QIL QIL') .
  eq setEqs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, EqS')
    = mod H is IL sorts SS . SSDS OPDS MAS EqS' RlS endm .
  eq setEqs(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, EqS')
    = th MN is IL sorts SS . SSDS OPDS MAS EqS' RlS endth .
  eq setEqs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, EqS')
    = fmod H is IL sorts SS . SSDS OPDS MAS EqS' endfm .
  eq setEqs(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, EqS')
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS' endfth .
  eq setEqs(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, EqS')
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS' RlS endom .
  eq setEqs(
       oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, EqS')
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS' RlS endoth .

  var U? : [Module] .
  var RlS? : [RuleSet] .

  eq setRls(unitError(QIL), RlS?) = unitError(QIL) .
  eq setRls(U?, ruleError(QIL) RlS?) = unitError(QIL) .
  eq setRls(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, RlS')
    = mod H is IL sorts SS . SSDS OPDS MAS EqS RlS' endm .
  eq setRls(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, RlS')
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS' endth .
  eq setRls(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, RlS)
    = if RlS == none
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      fi .
  eq setRls(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, RlS)
    = if RlS == none
      then fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth
      else th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      fi .
  eq setRls(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
       RlS')
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS' endom .
  eq setRls(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
       RlS')
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS' endoth .

  eq setSorts(unitError(QIL), SS) = unitError(QIL) .
  eq setSorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, SS')
    = mod H is IL sorts SS' . SSDS OPDS MAS EqS RlS endm .
  eq setSorts(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, SS')
    = th MN is IL sorts SS' . SSDS OPDS MAS EqS RlS endth .
  eq setSorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, SS')
    = fmod H is IL sorts SS' . SSDS OPDS MAS EqS endfm .
  eq setSorts(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, SS')
    = fth MN is IL sorts SS' . SSDS OPDS MAS EqS endfth .
  eq setSorts(
        omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, SS')
    = omod H is IL sorts SS' . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setSorts(
        oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, SS')
    = oth MN is IL sorts SS' . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .

  eq setPars(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm, PDL)
    = if PDL == nil
      then mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      fi .
  eq setPars(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm, PDL')
    = if PDL' == nil
      then mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else mod ME{PDL'} is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      fi .
  eq setPars(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, PDL)
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setPars(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm, PDL)
    = if PDL == nil
      then fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm
      else fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm
      fi .
  eq setPars(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm, PDL')
    = if PDL' == nil
      then fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm
      else fmod ME{PDL'} is IL sorts SS . SSDS OPDS MAS EqS endfm
      fi .
  eq setPars(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, PDL)
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setPars(
        omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
        PDL)
    = if PDL == nil
      then omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom
      else omod ME{PDL} is
             IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS
           endom
      fi .
  eq setPars(
       omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
       PDL')
    = if PDL' == nil
      then omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom
      else omod ME{PDL'} is
             IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS
           endom
      fi .
  eq setPars(
        oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
        PDL)
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .

  eq setClasses(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, CDS)
    = if CDS == none
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else omod H is IL sorts SS . SSDS CDS none OPDS none MAS EqS none endom
      fi .
  eq setClasses(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, CDS)
    = if CDS == none
      then fth H is IL sorts SS . SSDS OPDS MAS EqS endfth
      else oth H is IL sorts SS . SSDS CDS none OPDS none MAS EqS none endoth
      fi .
  eq setClasses(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, CDS)
    = if CDS == none
      then mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else omod H is IL sorts SS . SSDS CDS none OPDS none MAS EqS RlS endom
      fi .
  eq setClasses(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, CDS)
    = if CDS == none
      then th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      else oth H is IL sorts SS . SSDS CDS none OPDS none MAS EqS RlS endoth
      fi .
  eq setClasses(
        omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
        CDS')
    = omod H is IL sorts SS . SSDS CDS' SCDS OPDS MDS MAS EqS RlS endom .
  eq setClasses(
        oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
        CDS')
    = oth H is IL sorts SS . SSDS CDS' SCDS OPDS MDS MAS EqS RlS endoth .
  eq setClasses(M, CDS)
    = unitError(header2QidList(getName(M)) 'not 'an 'object-oriented 'module)
    [owise] .

  eq setSubclasses(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, SCDS)
    = if SCDS == none
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else omod H is IL sorts SS . SSDS none SCDS OPDS none MAS EqS none endom
      fi .
  eq setSubclasses(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, SCDS)
    = if SCDS == none
      then fth H is IL sorts SS . SSDS OPDS MAS EqS endfth
      else oth H is IL sorts SS . SSDS none SCDS OPDS none MAS EqS none endoth
      fi .
  eq setSubclasses(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, SCDS)
    = if SCDS == none
      then mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else omod H is IL sorts SS . SSDS none SCDS OPDS none MAS EqS RlS endom
      fi .
  eq setSubclasses(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, SCDS)
    = if SCDS == none
      then th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      else oth H is IL sorts SS . SSDS none SCDS OPDS none MAS EqS RlS endoth
      fi .
  eq setSubclasses(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, SCDS')
    = omod H is IL sorts SS . SSDS CDS SCDS' OPDS MDS MAS EqS RlS endom .
  eq setSubclasses(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
       SCDS')
    = oth H is IL sorts SS . SSDS CDS SCDS' OPDS MDS MAS EqS RlS endoth .
  eq setSubclasses(M, SCDS)
    = unitError(header2QidList(getName(M)) 'not 'an 'object-oriented 'module)
    [owise] .

  eq setMsgs(
       fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, MDS)
    = if MDS == none
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else omod H is IL sorts SS . SSDS none none OPDS MDS MAS EqS none endom
      fi .
  eq setMsgs(
       fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, MDS)
    = if MDS == none
      then fth H is IL sorts SS . SSDS OPDS MAS EqS endfth
      else oth H is IL sorts SS . SSDS none none OPDS MDS MAS EqS none endoth
      fi .
  eq setMsgs(
       mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, MDS)
    = if MDS == none
      then mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else omod H is IL sorts SS . SSDS none none OPDS MDS MAS EqS RlS endom
      fi .
  eq setMsgs(
       th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MDS)
    = if MDS == none
      then th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      else oth H is IL sorts SS . SSDS none none OPDS MDS MAS EqS RlS endoth
      fi .
  eq setMsgs(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, MDS')
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS' MAS EqS RlS endom .
  eq setMsgs(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, MDS')
    = oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS' MAS EqS RlS endoth .
  eq setMsgs(M, MDS)
    = unitError(header2QidList(getName(M)) 'not 'an 'object-oriented 'module)
    [owise] .

  eq setName(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm, ME')
    = mod ME' is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setName(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm, ME')
    = mod ME'{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setName(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm, ME')
    = fmod ME' is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setName(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm, ME')
    = fmod ME'{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setName(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, MN')
    = fth MN' is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setName(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MN')
    = th MN' is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setName(omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, ME')
    = omod ME' is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setName(omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, ME')
    = omod ME'{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setName(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, MN')
    = oth MN' is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .
  eq setName(noModule, ME) = noModule .
  eq setName(unitError(QIL), ME) = unitError(QIL) .

  eq setName(mod nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS endm, ME')
    = mod ME' is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setName(fmod nullHeader is IL sorts SS . SSDS OPDS MAS EqS endfm, ME')
    = fmod ME' is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setName(fth nullHeader is IL sorts SS . SSDS OPDS MAS EqS endfth, MN)
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setName(th nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MN)
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setName(
       omod nullHeader is
         IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS
       endom,
       ME')
    = omod ME' is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setName(
       oth nullHeader is
         IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
       MN)
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .
  eq setName(noModule, ME) = noModule .
  eq setName(unitError(QIL), ME) = unitError(QIL) .

*** Add functions

  eq addSorts(SS, U) = setSorts(U, (SS ; getSorts(U))) .
  eq addSorts(SS, unitError(QIL)) = unitError(QIL) .

  eq addSubsorts(SSDS, U) = setSubsorts(U, (SSDS getSubsorts(U))) .
  eq addSubsorts(subsortDeclError(QIL), U) = unitError(QIL) .
  eq addSubsorts(SSDS, unitError(QIL)) = unitError(QIL) .

  eq addOps(OPDS, U) = setOps(U, (OPDS getOps(U))) .
  eq addOps(OPDS?, unitError(QIL)) = unitError(QIL) .
  eq addOps(OPDS?, U) = U [owise] .

  eq addMbs(MAS, U) = setMbs(U, (MAS getMbs(U))) .
  eq addMbs(MAS, unitError(QIL)) = unitError(QIL) .
  eq addEqs(EqS, U) = setEqs(U, (EqS getEqs(U))) .
  eq addEqs(EqS, unitError(QIL)) = unitError(QIL) .
  eq addRls(RlS, U) = setRls(U, (RlS getRls(U))) .
  eq addRls(RlS, unitError(QIL)) = unitError(QIL) .
  eq addRls(ruleError(QIL), U) = unitError(QIL) .
  eq addImports(IL, U) = setImports(U, (getImports(U) IL)) .
  eq addImports(IL, unitError(QIL)) = unitError(QIL) .
  eq addClasses(CDS, U) = setClasses(U, (getClasses(U) CDS)) .
  eq addClasses(CDS, unitError(QIL)) = unitError(QIL) .
  eq addSubclasses(SCDS, U) = setSubclasses(U, (getSubclasses(U) SCDS)) .
  eq addSubclasses(SCDS, unitError(QIL)) = unitError(QIL) .
  eq addMsgs(MDS, U) = setMsgs(U, (getMsgs(U) MDS)) .
  eq addMsgs(MDS, unitError(QIL)) = unitError(QIL) .

*** Creation of empty units

  eq emptyFModule(ME)
    = fmod header2Qid(ME) is nil sorts none . none none none none endfm .
  eq emptyFModule
    = fmod nullHeader is nil sorts none . none none none none endfm .
  eq emptySModule
    = mod nullHeader is nil sorts none . none none none none none endm .
  eq emptyOModule
    = omod nullHeader is
        nil sorts none . none none none none none none none none
      endom .
  eq emptyFTheory
    = fth nullHeader is nil sorts none . none none none none endfth .
  eq emptySTheory
    = th nullHeader is nil sorts none . none none none none none endth .
  eq emptyOTheory
    = oth nullHeader is
         nil sorts none . none none none none none none none none
      endoth .

*** \texttt{empty} returns an empty unit of the same type of the one given as
*** argument.

  eq empty(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = (mod H is nil sorts none . none none none none none endm) .
  eq empty(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth)
    = (th MN is nil sorts none . none none none none none endth) .
  eq empty(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = (fmod H is nil sorts none . none none none none endfm) .
  eq empty(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth)
    = (fth MN is nil sorts none . none none none none endfth) .
  eq empty(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = (omod H is
         nil sorts none . none none none none none none none none
       endom) .
  eq empty(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = (oth MN is
         nil sorts none . none none none none none none none none
       endoth) .

*** In the following \texttt{addDecls} function, the declarations of the unit
*** given as second argument are added to the unit given as first argument.

  eq addDecls(noModule, U) = U .
  eq addDecls(U, noModule) = U .
  eq addDecls(unitError(QIL), U) = unitError(QIL) .
  eq addDecls(U, unitError(QIL)) = unitError(QIL) .
  eq addDecls(U, U')
    = addImports(getImports(U'),
        addSorts(getSorts(U'),
          addSubsorts(getSubsorts(U'),
            addOps(getOps(U'),
              addMbs(getMbs(U'),
                addEqs(getEqs(U'),
                  if U' :: FModule or U' :: FTheory
                  then U
                  else addRls(getRls(U'),
                         if U' :: SModule or U' :: STheory
                         then U
                         else addClasses(getClasses(U'),
                                addSubclasses(getSubclasses(U'),
                                  addMsgs(getMsgs(U'), U)))
                         fi)
                  fi))))))
    [owise] .

  op removeNonExecs : Module -> Module .
  op removeNonExecs : MembAxSet -> MembAxSet .
  op removeNonExecs : EquationSet -> EquationSet .
  op removeNonExecs : RuleSet -> RuleSet .

  ceq removeNonExecs(M)
    = setRls(M'', removeNonExecs(getRls(M)))
    if M' := setMbs(M, removeNonExecs(getMbs(M)))
    /\ M'' := setEqs(M', removeNonExecs(getEqs(M))) .
  eq removeNonExecs(unitError(QIL)) = unitError(QIL) .

  eq removeNonExecs(mb T : S [nonexec AtS] . MbS) = removeNonExecs(MbS) .
  eq removeNonExecs(cmb T : S if Cd [nonexec AtS] . MbS) = removeNonExecs(MbS) .
  eq removeNonExecs(MbS) = MbS [owise] .

  eq removeNonExecs(eq T = T' [nonexec AtS] . EqS) = removeNonExecs(EqS) .
  eq removeNonExecs(ceq T = T' if Cd [nonexec AtS] . EqS) = removeNonExecs(EqS) .
  eq removeNonExecs(EqS) = EqS [owise] .

  eq removeNonExecs(rl T => T' [nonexec AtS] . RlS) = removeNonExecs(RlS) .
  eq removeNonExecs(crl T => T' if Cd [nonexec AtS] . RlS) = removeNonExecs(RlS) .
  eq removeNonExecs(RlS) = RlS [owise] .

  *** moreGeneralEqs  ******************************
  ---- An equation is more general than other if there is a substitution such that
  ---- the more general equation with such a substitution applied is equal to the
  ---- less general one.
  op moreGeneralEqs : Module -> Module .
  op moreGeneralRls : Module -> Module .
  op $moreGeneralEqs : Module Module EquationSet EquationSet -> Module .
  op $moreGeneralRls : Module Module RuleSet RuleSet -> Module .
  op $moreGeneral : Module Equation Equation -> Bool .
  op $moreGeneral : Module Rule Rule -> Bool .
  op $moreGeneral : Module Condition Condition Term Term -> Bool .

  eq moreGeneralEqs(M)
    = $moreGeneralEqs(
        M,
        addOps((op '@/\@ : '@@@ '@@@ -> '@@@ [assoc] .
                op '@--@ : 'Universal -> '@@@ [poly(1)] .
                op '@--@ : 'Universal 'Universal -> '@@@ [poly(1 2)] .),
               addSorts('@@@, M)),
        getEqs(M), getEqs(M)) .
  eq moreGeneralRls(M)
    = $moreGeneralRls(
        M,
        addOps((op '@/\@ : '@@@ '@@@ -> '@@@ [assoc] .
                op '@--@ : 'Universal -> '@@@ [poly(1)] .
                op '@--@ : 'Universal 'Universal -> '@@@ [poly(1 2)] .),
               addSorts('@@@, M)),
        getRls(M), getRls(M)) .

 ceq $moreGeneralEqs(M, M', Eq EqS, Eq Eq' EqS')
    = $moreGeneralEqs(M, M', EqS, Eq' EqS')
    if $moreGeneral(M', Eq', Eq) .
  eq $moreGeneralEqs(M, M', EqS, EqS') = setEqs(M, EqS') [owise] .

 ceq $moreGeneralRls(M, M', Rl RlS, Rl Rl' RlS')
    = $moreGeneralRls(M, M', RlS, Rl' RlS')
    if $moreGeneral(M', Rl', Rl) .
  eq $moreGeneralRls(M, M', RlS, RlS') = setRls(M, RlS') [owise] .

  eq $moreGeneral(M, Eq, Eq')
    = sameKind(M, leastSort(M, lhs(Eq)), leastSort(M, lhs(Eq')))
      and-then
      $moreGeneral(M, cond(Eq), cond(Eq'), '@--@[lhs(Eq), rhs(Eq)], '@--@[lhs(Eq'), rhs(Eq')]) .

  eq $moreGeneral(M, Rl, Rl')
    = sameKind(M, leastSort(M, lhs(Rl)), leastSort(M, lhs(Rl')))
      and-then
      $moreGeneral(M, cond(Rl), cond(Rl'), '@--@[lhs(Rl), rhs(Rl)], '@--@[lhs(Rl'), rhs(Rl')]) .

  eq $moreGeneral(M, T1 = T1' /\ Cond1, T2 = T2' /\ Cond2, T, T')
    = sameKind(M, leastSort(M, T1), leastSort(M, T2))
      and-then
      $moreGeneral(M, Cond1, Cond2, '@/\@['@--@[T1, T1'], T], '@/\@['@--@[T2, T2'], T']) .
  eq $moreGeneral(M, T1 := T1' /\ Cond1, T2 := T2' /\ Cond2, T, T')
    = sameKind(M, leastSort(M, T1), leastSort(M, T2))
      and-then
      $moreGeneral(M, Cond1, Cond2, '@/\@['@--@[T1, T1'], T], '@/\@['@--@[T2, T2'], T']) .
  eq $moreGeneral(M, T1 => T1' /\ Cond1, T2 => T2' /\ Cond2, T, T')
    = sameKind(M, leastSort(M, T1), leastSort(M, T2))
      and-then
      $moreGeneral(M, Cond1, Cond2, '@/\@['@--@[T1, T1'], T], '@/\@['@--@[T2, T2'], T']) .
  eq $moreGeneral(M, T1 : S /\ Cond1, T2 : S /\ Cond2, T, T')
    = $moreGeneral(M, Cond1, Cond2, '@/\@['@--@[T1], T], '@/\@['@--@[T2], T']) .

  eq $moreGeneral(M, nil, nil, T, T') = metaMatch(M, T, T', nil, 0) =/= noMatch .
  eq $moreGeneral(M, Cond1, Cond2, T, T') = false [owise] .

  op rmVariantAttrs : Module -> Module .
  op $rmVariants : EquationSet -> EquationSet .
  op $rmVariants : RuleSet -> RuleSet .
  op $rmVariants : MembAxSet -> MembAxSet .
  eq rmVariantAttrs(M) = setRls(setEqs(setMbs(M, $rmVariants(getMbs(M))), $rmVariants(getEqs(M))), $rmVariants(getRls(M))) .
  eq rmVariantAttrs(unitError(QIL)) = unitError(QIL) .

  eq $rmVariants(eq T = T' [variant AtS] . EqS) = (eq T = T' [variant AtS] .) $rmVariants(EqS) .
  eq $rmVariants(ceq T = T' if Cond [variant AtS] . EqS) = (ceq T = T' if Cond [variant AtS] .) $rmVariants(EqS) .
  eq $rmVariants(EqS) = EqS [owise] .

  eq $rmVariants(rl T => T' [variant AtS] . RlS) = (rl T => T' [variant AtS] .) $rmVariants(RlS) .
  eq $rmVariants(crl T => T' if Cond [variant AtS] . RlS) = (crl T => T' if Cond [variant AtS] .) $rmVariants(RlS) .
  eq $rmVariants(RlS) = RlS [owise] .

  eq $rmVariants(mb T : S [variant AtS] . MbS) = (mb T : S [variant AtS] .) $rmVariants(MbS) .
  eq $rmVariants(cmb T : S if Cond [variant AtS] . MbS) = (cmb T : S if Cond [variant AtS] .) $rmVariants(MbS) .
  eq $rmVariants(MbS) = MbS [owise] .
endfm

*** To parse some input using the built-in function \texttt{metaParse}, we
*** need to give the metarepresentation of the signature in which the input is
*** going to be parsed.

*** But we do not need to give the complete metarepresentation of such a
*** module. In modules including \texttt{META-LEVEL} it is possible to define
*** terms of sort \texttt{Module} that import built-in modules or any module
*** introduced at the ``object level'' of Core Maude. In this way, it is
*** possible to get the equivalent effect of having the explicit
*** metarepresentation of a module by declaring a constant and adding an
*** equation identifying such a constant with the metarepresentation of an
*** extended module that imports the original module at the object level.

*** The declaration of constructors for bubble sorts at the object level is
*** not supported in the current version of Core Maude. The \texttt{special}
*** attributes linking the constructors for the bubble sorts to the built-in
*** ones are only supported at the metalevel, that is, the declarations of the
*** constructor operators for bubble sorts have to be given in the
*** metarepresentation of a module.

*** To allow the greatest generality and flexibility in future extensions of
*** Full Maude, we have declared its signature as a module
*** \texttt{FULL-MAUDE-SIGN}. Then, in the following module
*** \texttt{META-FULL-MAUDE-SIGN} we declare a constant \texttt{GRAMMAR} of
*** sort \texttt{FModule}, and we give an equation identifying such constant
*** with the metarepresentation of a module \texttt{GRAMMAR} in which there is
*** a declaration importing \texttt{FULL-MAUDE-SIGN}. Declarations for the
*** constructors of the bubble sorts are also included in this module. Note
*** that the bubble sorts \texttt{@Token@}, \texttt{@Bubble@},
*** \texttt{@SortToken@}, and \texttt{@NeTokenList@} are declared in the
*** module \texttt{SIGN\&VIEW-EXPR}, which is imported by
*** \texttt{FULL-MAUDE-SIGN}. These sorts are used in the declarations
*** describing the syntax of the system.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod META-FULL-MAUDE-SIGN is
---  including META-LEVEL + PRE-VARIANT .
  including META-LEVEL .
  including UNIT .

  op BUBBLES : -> FModule .
  op GRAMMAR : -> FModule [memo] .

  eq BUBBLES
    = (fmod 'GRAMMAR is
        including 'QID-LIST .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'viewToken : 'Qid -> '@ViewToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'sortToken : 'Qid -> '@SortToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '`[ '`] '< 'to '`, '. '`( '`) '`{ '`} ': '|
                                  'ditto 'precedence 'prec 'gather
                                  'assoc 'associative 'comm 'commutative
                                  'ctor 'constructor 'id: 'strat 'strategy
                                  'poly 'memo 'memoization 'iter 'frozen
                                  'config 'object 'msg 'metadata 'nonexec 'variant)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '.)))] .
        op 'bubble : 'QidList -> '@Bubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        none
        none
     endfm) .

  eq GRAMMAR = addImports((including 'FULL-MAUDE-SIGN .), BUBBLES) .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------


*** The \texttt{GRAMMAR} module will be used in calls to the \texttt{metaParse}
*** function in order to get the input parsed in this signature. Note that
*** this module is not the data type in which we shall represent the inputs.
*** From the call to \texttt{metaParse} we shall get a term representing the
*** parse tree of the input. This term will then be transformed into terms of
*** other appropriate data types if necessary.

*** Future extensions to Full Maude will require extending the signature as
*** well. The addition of new commands, new module expressions, or additions
*** of any other kind will require adding new declarations to the present Full
*** Maude signature and defining the corresponding extensions to the data
*** types and functions to deal with the new cases introduced by the
*** extensions.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Abstract Data Type \texttt{View}
***

*** In this section we present the data type \texttt{View} for views.
*** Basically, the data elements of sort \texttt{View} are composed by the
*** name of the view, the names of the source and target units, and a set of
*** maps representing the maps asserting how the given target unit is claimed
*** to satisfy the source theory (see Section~\ref{Views}).

*** Internally, renaming maps are considered to be a particular case of view
*** maps. The sort \texttt{ViewMap} is declared as a supersort of
*** \texttt{Map}. The only kind of maps in sort \texttt{ViewMap} not in sort
*** \texttt{Map} are maps of operators going to derived operators. We start
*** introducing the declarations for renaming maps and sTS of renaming maps
*** in Section~\ref{renaming-maps}, we then introduce view maps and sTS of
*** view maps in Section~\ref{view-maps}, and finally we introduce the sort
*** \texttt{View}, its constructor, and some operations on it in
*** Section~\ref{viewADT}.

***
*** View Maps
***

*** In addition to the maps of sort \texttt{Renaming},
*** in views there can also be maps from operators to derived
*** operators, that is, terms with variables (see Section~\ref{Views}). Maps
*** of this kind are given with the constructor \texttt{op_to`term_}, which, in
*** addition to the source and target terms, takes the set of variable
*** declarations for the variables used in the map. The source term must be of
*** the form $\texttt{F(X}_1\texttt{,}\ldots,\texttt{X}_n\texttt{)}$, where
*** \texttt{F} is an operator name declared with $n$ arguments of sorts in the
*** connected components of the variables $\texttt{X}_1\ldots\texttt{X}_n$,
*** respectively. We will see in Section~\ref{view-processing} how in the
*** initial processing of a view the variables declared in it are associated
*** to each of the maps in which they are used.


***
*** Views
***

*** The \texttt{View} sort is introduced in the following module
*** \texttt{VIEW}.  In addition to the constructor for views (\texttt{view}),
*** selector functions are added for each of the components of a
*** view (\texttt{name}, \texttt{source}, \texttt{target}, and
*** \texttt{mapSet}), and a constant \texttt{emptyView}, which is identified
*** in an equation with the empty view, is defined.

*** Although the declaration of the constructor for views includes an argument
*** for the list of parameters, parameterized views are not handled yet, so at
*** present this argument must be set to the \texttt{nil}.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod EXT-RENAMING is
  pr META-MODULE .

  op op_to term_ : Term Term -> Renaming .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod VIEW is
  ex META-VIEW .
  pr VIEW-EXPR .
  inc FMAP .

  *** mappings
  op class_to_. : Sort Sort -> SortMapping .
  op attr_._to_. : Qid Sort Qid -> OpMapping .
  op msg_to_. : Qid Qid -> OpMapping .
  op msg_:_->_to_. : Qid TypeList Sort Qid -> OpMapping .

  subsort ViewExp < Header .

  op null : -> View [ctor] .
  op viewError : QidList -> [View] [ctor format (r o)] .

  eq VE{(nil).ParameterDeclList} = VE .

  vars A A' F F' Q Q' : Qid .
  var QIL : QidList .
  var VH : Header .
  var VE : ViewExp .
  vars PDL PDL' : ParameterDeclList .
  vars ME ME' ME'' : ModuleExpression .
  vars SMS SMS' : SortMappingSet .
  vars OMS OMS' : OpMappingSet .
  vars S S' C : Sort .
  var  Ty : Type .
  var  TyL : TypeList .
  vars T T' : Term .

  op maps2rens : SortMappingSet -> RenamingSet .
  op maps2rens : OpMappingSet -> RenamingSet .
  eq maps2rens(sort S to S' . SMS) = sort S to S', maps2rens(SMS) .
  eq maps2rens(class S to S' . SMS) = class S to S', maps2rens(SMS) .
  eq maps2rens((none).SortMappingSet) = none .

  eq maps2rens(op F to F' . OMS) = op F to F' [none], maps2rens(OMS) .
  eq maps2rens(op F : TyL -> Ty to F' . OMS) = op F : TyL -> Ty to F' [none], maps2rens(OMS) .
  eq maps2rens(op T to  term T' . OMS) = op T to term T', maps2rens(OMS) .
  eq maps2rens(msg F to F' . OMS) = msg F to F' [none], maps2rens(OMS) .
  eq maps2rens(msg F : TyL -> Ty to F' . OMS) = msg F : TyL -> Ty to F' [none], maps2rens(OMS) .
  eq maps2rens(attr A . C to A' . OMS) = attr A . C to A', maps2rens(OMS) .
  eq maps2rens((none).OpMappingSet) = none .

*** projection functions
  op getName : View -> Qid .
  eq getName(view VE from ME to ME' is SMS OMS endv) = VE [owise] .
  eq getName(view VE{PDL} from ME to ME' is SMS OMS endv) = VE .

  op getPars : [View] -> ParameterDeclList .
  eq getPars(view VE from ME to ME' is SMS OMS endv) = nil [owise] .
  eq getPars(view VE{PDL} from ME to ME' is SMS OMS endv) = PDL .
  eq getPars(viewError(QIL)) = nil .

  eq getFrom(view VH from ME to ME' is SMS OMS endv) = ME .
  eq getTo(view VH from ME to ME' is SMS OMS endv) = ME' .
  eq getSortMappings(view VH from ME to ME' is SMS OMS endv) = SMS .
  eq getOpMappings(view VH from ME to ME' is SMS OMS endv) = OMS .

*** injection functions
  op setName : View Qid -> View .
  eq setName(view Q from ME to ME' is SMS OMS endv, Q')
    = view Q' from ME to ME' is SMS OMS endv .
  eq setName(view Q{PDL} from ME to ME' is SMS OMS endv, VH) = view VH{PDL} from ME to ME' is SMS OMS endv .
  eq setName(viewError(QIL), VE) = viewError(QIL) .

  op setPars : [View] ParameterDeclList -> [View] .
  eq setPars(view VH from ME to ME' is SMS OMS endv, PDL)
    = view VH{PDL} from ME to ME' is SMS OMS endv [owise] .
  eq setPars(view VH{PDL} from ME to ME' is SMS OMS endv, PDL') = view VH{PDL'} from ME to ME' is SMS OMS endv .
  eq setPars(viewError(QIL), PDL) = viewError(QIL) .

  op setFrom : View ModuleExpression -> View .
  eq setFrom(view VH from ME to ME' is SMS OMS endv, ME'')
    = view VH from ME'' to ME' is SMS OMS endv .
  eq setFrom(viewError(QIL), ME) = viewError(QIL) .

  op setTo : View ModuleExpression -> View .
  eq setTo(view VH from ME to ME' is SMS OMS endv, ME'')
    = view VH from ME to ME'' is SMS OMS endv .
  eq setTo(viewError(QIL), ME) = viewError(QIL) .

  op setSortMappings : View SortMappingSet -> View .
  eq setSortMappings(view VH from ME to ME' is SMS OMS endv, SMS')
    = view VH from ME to ME' is SMS' OMS endv .
  eq setSortMappings(viewError(QIL), SMS') = viewError(QIL) .

  op setOpMappings : View OpMappingSet -> View .
  eq setOpMappings(view VH from ME to ME' is SMS OMS endv, OMS')
    = view VH from ME to ME' is SMS OMS' endv .
  eq setOpMappings(viewError(QIL), OMS') = viewError(QIL) .

  op emptyView : Qid ModuleExpression ModuleExpression -> View .
  eq emptyView(VH, ME, ME') = view VH from ME to ME' is none none endv .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Abstract Data Type \texttt{Database}
***

*** In this section we present the data type \texttt{Database}, which will be
*** used to store information about the units and views in the system. Before
*** discussing this data type in Section~\ref{databaseADT}, we present the
*** predefined units added in Full Maude to those already available in Core
*** Maude.

***
*** Non-Built-In Predefined Modules
***

*** As we shall see in the following section, except for the
*** \texttt{LOOP-MODE} module, all the predefined modules that are available
*** in Core Maude are also available in Full Maude. In addition to these Core
*** Maude predefined modules, in Full Maude there are some additional
*** predefined units. In the present system, the only units with which the
*** database is initialized are the functional theory \texttt{TRIV}, the
*** module \texttt{CONFIGURATION}, and the module \texttt{UP}, which will be
*** used to evaluate the \texttt{up} functions. We shall see in
*** Section~\ref{main-module} how new predefined modules can be added to the
*** initial database.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod PREDEF-UNITS is
  pr UNIT .

*** The following module \texttt{UP} contains the necessary declarations to
*** be able to parse the \texttt{up} functions presented in
*** Section~\ref{structured-specifications}. We shall see in
*** Section~\ref{evaluation} how a declaration importing the following module
*** \texttt{UP} is added to all the modules importing the predefined module
*** \texttt{META-LEVEL}. With this declaration, it is possible to parse the
*** \texttt{up} commands in the bubbles of such modules or in commands being
*** evaluated in such modules. We shall see in Section~\ref{bubble-parsing}
*** how these commands are then evaluated.

  op #UP# : -> FModule [memo] .
  eq #UP#
    = (fmod '#UP# is
        including 'QID-LIST .
        including 'MOD-EXPRS .
        sorts none .
        none
        op 'upTerm : '@ModExp@ '@Bubble@ -> 'Term [none] .
        op 'upModule : '@ModExp@ -> 'Module [none] .
        op '`[_`] : '@Token@ -> 'Module [none] .
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'viewToken : 'Qid -> '@ViewToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'sortToken : 'Qid -> '@SortToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '`[ '`] '< 'to '`, '. '`( '`) '`{ '`} ':
                                  'ditto 'precedence 'prec 'gather
                                  'assoc 'associative 'comm 'commutative
                                  'ctor 'constructor 'id: 'strat 'strategy
                                  'poly 'memo 'memoization 'iter 'frozen
                                  'config 'object 'msg 'metadata 'nonexec 'variant)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '.)))] .
        op 'bubble : 'QidList -> '@Bubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        none
        none
     endfm) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** 7 The Evaluation of Views
***

*** Before being entered into the database, besides containing bubbles, views
*** have a somewhat different structure from that of the views given in
*** Section~\ref{viewADT}. We introduce in the following module a sort
*** \texttt{PreView} with constructor \texttt{view}, which is declared as the
*** constructor for views of sort \texttt{View}, but with an additional
*** argument, namely, a set of variable declarations to hold the declarations
*** of variables in the view. During the processing of views (see
*** Section~\ref{view-processing}), which takes place once the parsing process
*** has concluded, these variables are associated with the corresponding maps
*** where they are used, generating a term of sort \texttt{View}.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod PRE-VIEW is
  pr VIEW .

  sort PreView .
  op preview_from_to_is___endpv : Header ModuleExpression
       ModuleExpression OpDeclSet SortMappingSet OpMappingSet -> PreView
       [ctor format (nir! o r! o r! o r! o o o r! o)] .
  op null : -> PreView .

  op getName : PreView -> ViewExp .
  op getPars : PreView -> ParameterDeclList .
  op getFrom : PreView -> ModuleExpression .
  op getTo : PreView -> ModuleExpression .
  op getVars : PreView -> OpDeclSet .
  op getSortMappings : PreView -> SortMappingSet .
  op getOpMappings : PreView -> OpMappingSet .

  var  QI : Qid .
  vars ME ME' : ModuleExpression .
  var  VE : ViewExp .
  var  VH : Header .
  vars PDL PDL' : ParameterDeclList .
  vars VDS VDS' : OpDeclSet .
  vars SMS SMS' : SortMappingSet .
  vars OMS OMS' : OpMappingSet .

  eq getName(preview VE from ME to ME' is VDS SMS OMS endpv) = VE .
  eq getName(preview VE{PDL} from ME to ME' is VDS SMS OMS endpv) = VE .
  eq getPars(preview VE from ME to ME' is VDS SMS OMS endpv) = nil .
  eq getPars(preview VE{PDL} from ME to ME' is VDS SMS OMS endpv) = PDL .
  eq getFrom(preview VH from ME to ME' is VDS SMS OMS endpv) = ME .
  eq getTo(preview VH from ME to ME' is VDS SMS OMS endpv) = ME' .
  eq getVars(preview VH from ME to ME' is VDS SMS OMS endpv) = VDS .
  eq getSortMappings(preview VH from ME to ME' is VDS SMS OMS endpv) = SMS .
  eq getOpMappings(preview VH from ME to ME' is VDS SMS OMS endpv) = OMS .

*** The following functions can be used to add new declarations to the set of
*** declarations already in a preview.

  op addMaps : SortMappingSet PreView -> PreView .
  op addMaps : OpMappingSet PreView -> PreView .
  op addVars : OpDeclSet PreView -> PreView .

  eq addMaps(SMS, preview VH from ME to ME' is VDS SMS' OMS endpv)
    = preview VH from ME to ME' is VDS (SMS SMS') OMS endpv .
  eq addMaps(OMS, preview VH from ME to ME' is VDS SMS OMS' endpv)
    = preview VH from ME to ME' is VDS SMS (OMS OMS') endpv .

  eq addVars(VDS, preview VH from ME to ME' is VDS' SMS OMS endpv)
    = preview VH from ME to ME' is (VDS VDS') SMS OMS endpv .

  op setPars : PreView ParameterDeclList -> PreView .
  eq setPars(preview VE from ME to ME' is VDS SMS OMS endpv, PDL)
    = preview VE{PDL} from ME to ME' is VDS SMS OMS endpv .
  eq setPars(preview VE{PDL} from ME to ME' is VDS SMS OMS endpv, PDL')
    = preview VE{PDL'} from ME to ME' is VDS SMS OMS endpv .

  op emptyPreView : Qid ModuleExpression ModuleExpression -> PreView .
  eq emptyPreView(QI, ME, ME')
    = preview QI from ME to ME' is none none none endpv .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Database
***

*** In order to be able to refer to modules by name, which is extremely useful
*** for module definition purposes at the user level, the evaluation of module
*** expressions takes place in the context of a database, in which we keep
*** information about the modules already introduced in the system, and also
*** about those modules generated internally.  This information is stored as
*** a set of elements of sort \texttt{ModuleInfo} and \texttt{ViewInfo}, in
*** which we hold, respectively, the information concerning units and views.
*** For each unit we save:
*** \begin{itemize}
*** \item Its original form, as introduced by the user, or, in case of an
***       internally generated unit, as generated from the original form of
***       some other unit.
*** \item Its internal representation, in which variables have been renamed
***       to avoid collisions with the names of variables in other units in
***       the same hierarchy.  In the case of object-oriented units, we store
***       its equivalent system module, that is, the result of transforming
***       it into a system module.
*** \item Its signature, which is given as a functional module of sort
***       \texttt{FModule} with no axioms, ready to be used in calls to
***       \texttt{metaParse}. There can only be importation declarations
***       including built-in modules in this module. These are the only
***       inclusions handled by the Core Maude engine.
*** \item Its flattened version, for which, as for signatures, only the
***       importation of built-in modules is left unevaluated.
*** \end{itemize}
*** For each view we keep its name and the view itself.

*** As a simple mechanism to keep the database consistent, for each unit we
*** maintain the list of names of all the units and views ``depending'' on it.
*** Similarly, for each view we maintain the list of names of all the units
*** ``depending'' on it. The idea is that if a unit or view is redefined or
*** removed, all those units and/or views depending on it will also be
*** removed. This dependency does not only mean direct importation. For
*** example, the module resulting from the renaming of some module also
*** depends on the module being renamed; the instantiation of a parameterized
*** module also depends on the parameterized module and on all the views used
*** in its instantiation; a view depends on its source and target units, etc.
*** This dependency is transitive: if a module, theory, or view has to be
*** removed, all the units and/or views depending on them will be removed as
*** well. The dependencies derived from the module expressions themselves are
*** established by the function \texttt{setUpModExpDeps}. The function
*** \texttt{setUpModuleDeps} calls \texttt{setUpModExpDeps},
*** and then \texttt{setUpImportSetDeps} to add the \emph{back
*** references} in the modules being imported. The function
*** \texttt{setUpViewDeps} sTS up the back references for the views
*** being introduced.

*** In addition to this set of information cells for units and views, we also
*** keep lists with the names of all the units and views in the database, and
*** a list of quoted identifiers in which we store the messages generated
*** during the process of treatment of the inputs in order to simplify the
*** communication with the read-eval-print loop process.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

view ModuleName from TRIV to MOD-NAME is
  sort Elt to ModuleName .
endv

view ViewExp from TRIV to VIEW-EXPR is
  sort Elt to ViewExp .
endv

view ParameterDecl from TRIV to META-MODULE is
  sort Elt to ParameterDecl .
endv

fmod INFO is
  pr VIEW .
  pr DEFAULT-VALUE{Term} .
  pr (SET * (op _`,_ to _._,
             op empty to emptyModuleNameSet,
             op insert to insertModuleNameSet,
             op delete to deleteModuleNameSet,
             op _in_ to _inModuleNameSet_,
             op |_| to |_|ModuleNameSet,
             op $card to $cardModuleNameSet,
             op union to unionModuleNameSet,
             op intersection to intersectionModuleNameSet,
             op $intersect to $intersectModuleNameSet,
             op _\_ to _\ModuleNameSet_,
             op $diff to $diffModuleNameSet,
             op _subset_ to _subsetModuleNameSet_,
             op _psubset_ to _psubsetModuleNameSet_)){ModuleName} .
  pr (SET * (op _`,_ to _#_,
             op empty to emptyViewExpSet,
             op insert to insertViewExpSet,
             op delete to deleteViewExpSet,
             op _in_ to _inViewExpSet_,
             op |_| to |_|ViewExprSet,
             op $card to $cardViewExprSet,
             op union to unionViewExprSet,
             op intersection to intersectionViewExprSet,
             op $intersect to $intersectViewExprSet,
             op _\_ to _\ViewExprSet_,
             op $diff to $diffViewExprSet,
             op _subset_ to _subsetViewExprSet_,
             op _psubset_ to _psubsetViewExprSet_)){ViewExp} .
  pr (SET * (op _`,_ to _._)){ParameterDecl} .

  var  MN : ModuleName .
  var  MNS : Set{ModuleName} .

  op remove : Set{ModuleName} ModuleName -> Set{ModuleName} .
  eq remove(MN . MNS, MN) = remove(MNS, MN) .
  eq remove(MNS, MN) = MNS [owise] .

  sort ModuleInfo .
  op <_;_;_;_;_;_;_;_> : ModuleName Default{Term} Module Module Module
       OpDeclSet Set{ModuleName} Set{ViewExp} -> ModuleInfo
     [ctor
      format
        (nig o g n+++io g nio g nio g nio g nio g nio g nio n---ig o)] .
  op <_;_;_;_;_;_;_;_> : ModuleName Module Module Module Module
       OpDeclSet Set{ModuleName} Set{ViewExp} -> ModuleInfo
     [ctor
      format
      (nig ur! g n+++io g nio g nio g nio g nio g nio g nio n---ig o)] .

  *** - Modules can be introduced by the user or can be generated internally.
  ***   When introduced by the user the 2nd arg. keeps the term representation
  ***   of the module as given, so that it can be recompiled later. If the
  ***   module is generated internally as the result of the evaluation of a
  ***   module expression, then this second arg. will be null, the default
  ***   term value. The user can also enter modules with the procModule
  ***   function, providing then the metarepresentation of a module, which
  ***   is directly stored in the database as the 2nd arg. of one of these
  ***   ModuleInfo units of the second kind. This is useful for the ITP for
  ***   example, where the interaction with the database takes place at the
  ***   metalevel and the modules given by the "user" are already at the
  ***   metalevel but still wants the same treatment.
  *** - The sixth arg. stores the variables (corresponding ops.) in the top
  ***   module.

  sort ViewInfo .
  op <_;_;_;_;_> : ViewExp Default{Term} View Set{ModuleName}
       Set{ViewExp} -> ViewInfo
       [ctor format (nig o g n+++io g nio g nio g nio n---ig o)] .
  op <_;_;_;_;_> :
       ViewExp View View Set{ModuleName} Set{ViewExp} -> ViewInfo
       [ctor format (nig o g n+++io g nio g nio g nio n---ig o)] .

endfm

view ModuleInfo from TRIV to INFO is
  sort Elt to ModuleInfo .
endv

view ViewInfo from TRIV to INFO is
  sort Elt to ViewInfo .
endv

fmod DATABASE-DECLS is
  pr (SET * (op _`,_ to __, op empty to emptyInfoSet)){ModuleInfo} .
  pr (SET * (op _`,_ to __, op empty to emptyInfoSet)){ViewInfo} .

  sort Database .
  op db :
     Set{ModuleInfo}  *** module info tuples
     Set{ModuleName}  *** names of the modules in the database
     Set{ViewInfo}    *** view info tuples
     Set{ViewExp}     *** names of the views in the db
     Set{ModuleName}  *** modules with set protect on (by default empty)
     Set{ModuleName}  *** modules with set extend on (by default empty)
     Set{ModuleName}  *** modules with set include on (by default empty)
     QidList
       -> Database
     [ctor
      format (nib i++o)] .

  ops getDefPrs getDefExs getDefIncs : Database -> Set{ModuleName} .
  eq getDefPrs(
        db(MIS:Set{ModuleInfo}, MNS:Set{ModuleName}, VIS:Set{ViewInfo},
           VES:Set{ViewExp}, MNS':Set{ModuleName}, MNS'':Set{ModuleName},
           MNS3:Set{ModuleName}, QIL:QidList))
    = MNS':Set{ModuleName} .
  eq getDefExs(
        db(MIS:Set{ModuleInfo}, MNS:Set{ModuleName}, VIS:Set{ViewInfo},
           VES:Set{ViewExp}, MNS':Set{ModuleName}, MNS'':Set{ModuleName},
           MNS3:Set{ModuleName}, QIL:QidList))
    = MNS'':Set{ModuleName} .
  eq getDefIncs(
        db(MIS:Set{ModuleInfo}, MNS:Set{ModuleName}, VIS:Set{ViewInfo},
           VES:Set{ViewExp}, MNS':Set{ModuleName}, MNS'':Set{ModuleName},
           MNS3:Set{ModuleName}, QIL:QidList))
    = MNS3:Set{ModuleName} .
endfm

view Database from TRIV to DATABASE-DECLS is
  sort Elt to Database .
endv

view ModuleExpression from TRIV to META-MODULE is
  sort Elt to ModuleExpression .
endv

fmod DATABASE is
  pr (2TUPLE * (op `(_`,_`) to <_;_>,
                op p1_ to database,
                op p2_ to modExp)) {Database, ModuleExpression} .
  pr PRE-VIEW .
  pr UNIT .
  pr VIEW-EXPR-TO-QID .

  op evalModule : Module OpDeclSet Database -> Database .
  *** its definition is in the module EVALUATION

  op procModule : Qid Database -> Database .
  op procView : Qid Database -> Database .
  op procView : View Database -> Database .
  *** their definitions are in the modules UNIT-PROCESSING and VIEW-PROCESSING

  op evalModExp : ModuleExpression Database -> Tuple{Database, ModuleExpression} .
  *** its definition is in the module MOD-EXPR-EVAL

  vars QI X Y F : Qid .
  vars QIL QIL' : QidList .
  vars NQIL NQIL' : NeQidList .
  vars VE VE' VE'' : ViewExp .
  vars VES VES' VES'' VES3 : Set{ViewExp} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars MNS MNS' MNS'' MNS3 MNS4 MNS5 MNS6 : Set{ModuleName} .
  vars PL PL' : ParameterList .
  vars PDS PDS' PDS'' : Set{ParameterDecl} .
  var  PDL : ParameterDeclList .
  var  PD : ParameterDecl .
  vars ME ME' : ModuleExpression .
  vars VI VI' : View .
  var  SMS : SortMappingSet .
  var  OMS : OpMappingSet .
  vars PU PU' U U' U'' U3 U4 : Module .
  var  M : Module .
  var  DB : Database .
  vars IL IL' : ImportList .
  var  VIf : ViewInfo .
  var  UIf : ModuleInfo .
  vars OPDS VDS VDS' : OpDeclSet .
  var  PV : PreView .
  vars T T' : Term .
  var  DT : Default{Term} .
  var  NL : IntList .
  var  TyL : TypeList .
  var  Ty : Type .
  var  AtS : AttrSet .
  var  B : Bool .
  var  I : Import .
  var  MN MN' : ModuleName .

  ops dincluded : ModuleExpression ImportList -> Bool .

  eq dincluded(ME, IL (protecting ME .) IL') = true .
  eq dincluded(ME, IL (extending ME .) IL') = true .
  eq dincluded(ME, IL (including ME .) IL') = true .
  eq dincluded(ME, IL) = false [owise] .

  ops included includedAux : ModuleExpression ImportList Database -> Bool .

  eq included(ME, IL (protecting ME .) IL', DB) = true .
  eq included(ME, IL (extending ME .) IL', DB) = true .
  eq included(ME, IL (including ME .) IL', DB) = true .
  eq included(ME, nil, DB) = false .
  eq included(ME, IL, DB) = includedAux(ME, IL, DB) [owise] .

  eq includedAux(ME, I IL, DB)
    = included(ME, getImports(getTopModule(moduleName(I), DB)), DB)
      or-else includedAux(ME, IL, DB) .
  eq includedAux(ME, nil, DB) = false .

  op defImports : Module Database -> ImportList .
  op defImports : ImportList ImportList Set{ModuleName} Set{ModuleName}
       Set{ModuleName} -> ImportList .

  eq defImports(M, DB)
    = if theory(M)
      then nil
      else defImports(getImports(M), nil,
             getDefPrs(DB), getDefExs(DB), getDefIncs(DB))
      fi .

  eq defImports(IL, IL', MN . MNS, MNS', MNS'')
    = if dincluded(MN, IL IL')
      then defImports(IL, IL', MNS, MNS', MNS'')
      else defImports(IL, IL' (protecting MN .), MNS, MNS', MNS'')
      fi .
  eq defImports(IL, IL', MNS, MN . MNS', MNS'')
    = if dincluded(MN, IL IL')
      then defImports(IL, IL', MNS, MNS', MNS'')
      else defImports(IL, IL' (extending MN .), MNS, MNS', MNS'')
      fi .
  eq defImports(IL, IL', MNS, MNS', MN . MNS'')
    = if dincluded(MN, IL IL')
      then defImports(IL, IL', MNS, MNS', MNS'')
      else defImports(IL, IL' (including MN .), MNS, MNS', MNS'')
      fi .
  eq defImports(IL, IL',
       emptyModuleNameSet, emptyModuleNameSet, emptyModuleNameSet)
    = IL' .

*** The constant \texttt{emptyDatabase} denotes the empty database, and there
*** are predicates \texttt{viewInDatabase} and \texttt{unitInDb} to check,
*** respectively, whether a view and a unit are in a database or not.

  op emptyDatabase : -> Database .
  eq emptyDatabase
    = db(emptyInfoSet, emptyModuleNameSet, emptyInfoSet, emptyViewExpSet,
         emptyModuleNameSet, emptyModuleNameSet, 'BOOL, nil) .

  op unitInDb : ModuleName Database -> Bool .
  eq unitInDb(MN, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = MN inModuleNameSet MNS .

  op viewInDb : ViewExp Database -> Bool .
  eq viewInDb(VE, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = VE inViewExpSet VES .

  op includeBOOL : Database -> Bool .
  eq includeBOOL(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = 'BOOL inModuleNameSet MNS' .

*** If a module, theory, or view is being redefined, that is, if there was
*** already in the database a module, theory, or view with the same name,
*** then all the units and/or views depending on it are removed using the
*** functions \texttt{delModules} and \texttt{delViews}. Removing a view
*** or a unit from the database means removing its info cell from the set of
*** cells in the database. Those entered by the user are not completely
*** removed, their term form is saved so that it can be recompiled later.

  op delModules : Set{ModuleName} Database -> Database .
  op delViews : Set{ViewExp} Database -> Database .

  eq delModules((MN . MNS),
       db(< MN ; T ; U ; U' ; U'' ; VDS ; MNS' ; VES > MIS,
          MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))
    = delModules((MNS . MNS'),
          delViews(VES,
            db(< MN ; T ; noModule ; noModule ; noModule ; VDS ;
                 emptyModuleNameSet ; emptyViewExpSet > MIS,
               MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))) .
  eq delModules((MN . MNS),
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS' ; VES > MIS,
          MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))
    = delModules((MNS . MNS'),
          delViews(VES,
            db(< MN ; U ; noModule ; noModule ; noModule ; VDS ;
                 emptyModuleNameSet ; emptyViewExpSet > MIS,
               MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))) .
  eq delModules((MN . MNS),
       db(< MN ; null ; U ; U' ; U'' ; VDS ; MNS' ; VES > MIS,
          MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))
    = delModules((MNS . MNS'),
        delViews(VES,
            db(MIS, MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))) .
  eq delModules(emptyModuleNameSet, DB) = DB .
  eq delModules((MN . MNS), DB) = delModules(MNS, DB) [owise] .

  eq delViews(VE # VES,
       db(MIS, MNS, < VE ; T ; VI ; MNS' ; VES' > VIS, VE # VES'',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES # VES',
        delModules(MNS',
          db(MIS, MNS,
             < VE ; T ; null ; emptyModuleNameSet ; emptyViewExpSet > VIS,
             VE # VES'', MNS'', MNS3, MNS4, QIL))) .
  eq delViews(VE # VES,
       db(MIS, MNS,
          < VE ; (null).Default{Term} ; VI ; MNS' ; VES' > VIS, VE # VES'',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES # VES',
        delModules(MNS',
          db(MIS, MNS, VIS, VES'', MNS'', MNS3, MNS4, QIL))) .
  eq delViews(VE # VES,
       db(MIS, MNS, < VE ; VI ; VI' ; MNS' ; VES' > VIS, VE # VES'',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES # VES',
        delModules(MNS',
          db(MIS, MNS,
             < VE ; VI ; null ; emptyModuleNameSet ; emptyViewExpSet > VIS,
             VE # VES'', MNS'', MNS3, MNS4, QIL))) .
  eq delViews(emptyViewExpSet, DB) = DB .
  eq delViews(VE # VES, DB) = delViews(VES, DB) [owise] .

*** The \texttt{warning} function allows us to place messages (warning, error,
*** or any other kind of messages) in the last argument of the database
*** constructor. These messages are given in the form of quoted identifier
*** lists, and will be passed to the third argument of the read-eval-print
*** loop, to be printed in the terminal.

  op warning : Database QidList -> Database .
  eq warning(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, nil), QIL)
    = db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL) .
  eq warning(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, NQIL), QIL)
    = db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, NQIL QIL) .

  op getMsg : Database -> QidList .
  eq getMsg(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL)) = QIL .

*** Core Maude built-in modules are handled in a special way in the current
*** version of the system. They are not explicitly defined in the Full Maude
*** database; their importation is directly handled by Core Maude. This has
*** some drawbacks: Core Maude built-in modules cannot be renamed; they cannot
*** be directly used with built-in functions, such as \texttt{metaReduce} or
*** \texttt{sameComponent}, although they can be imported in modules being
*** used in the calls to these functions; and, in general, any function taking
*** as argument or returning as result the metarepresentation of a module
*** cannot take one of these built-in modules as argument. This is the case,
*** for example, for the \texttt{up} function presented in
*** Section~\ref{changing-levels}, or for functions or commands in which the
*** name of a module has to be specified, as the \texttt{select} or
*** \texttt{down} commands, or the \texttt{up} function presented in
*** Section~\ref{structured-specifications}. Nevertheless, there are also
*** some advantages: The flattening of the built-in part of the structure is
*** accomplished more efficiently, and, since these modules do not have to be
*** stored in the database of Full Maude, the size of the database is reduced.

*** Our plan is to have in the future a hybrid solution. Once we have some way
*** of storing the modules entered to Full Maude in Core Maude's database, it
*** will be enough to keep in the Full Maude database just the original form
*** of the top of all the modules, including built-ins, leaving all the
*** importation declarations to be resolved by the engine. The structures will
*** be normalized as they are now, so that the engine will have to deal just
*** with inclusions, but it will be possible to use the predefined modules as
*** any other module. Moreover, the Full Maude database will be relatively
*** smaller and the flattening will be computed more efficiently.

*** When a new module or theory is entered, the names of all the modules,
*** theories, and views depending on it are included in its lists of
*** dependencies with functions \texttt{setUpModuleDeps} and
*** \texttt{setUpViewDeps}. Notice that if new module expressions are
*** defined, the function \texttt{setUpModExpDeps} will have to be
*** extended accordingly.

  op setUpModuleDeps : Module Database -> Database .
  op setUpModExpDeps : ModuleName Database -> Database .
  op setUpModExpDeps : ModuleName Header Database -> Database .
  op setUpModExpDeps : ModuleName ViewExp Database -> Database .
  op setUpImportDeps : ModuleName ImportList Database -> Database .

  eq setUpModuleDeps(U, DB)
    = setUpImportDeps(getName(U), getImports(U),
        setUpModExpDeps(getName(U), DB)) .

  eq setUpModExpDeps(QI, DB) = DB .

  eq setUpModExpDeps(pd(X :: ME),
       db(< ME ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; DT ; U ; U' ; U'' ; VDS ; (MNS . pd(X :: ME)) ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps(pd(X :: ME),
       db(< ME ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; U ; U' ; U'' ; U3 ; VDS ; (MNS . pd(X :: ME)) ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps(pd(X :: ME), DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n))
    [owise] .

---- This could be a bug in Core Maude.
---- It should work if the next 6 equations are replaced by this single equation.
----  ceq setUpImportDeps(MN, (I IL),
----       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS),
----          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
----    = setUpImportDeps(MN, IL,
----        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS),
----           MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
----    if MN' := moduleName(I) .
  eq setUpImportDeps(MN, ((including MN' .) IL),
       db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((including MN' .) IL),
       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((extending MN' .) IL),
       db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((extending MN' .) IL),
       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((protecting MN' .) IL),
       db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((protecting MN' .) IL),
       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, I IL, DB)
    = warning(DB, '\r 'Error: '\o 'Module header2QidList(moduleName(I)) 'not 'in 'database. '\n)
    [owise] .
  eq setUpImportDeps(MN, nil, DB) = DB .

  op setUpViewDeps : ModuleExpression ViewExp Database -> Database .
  op setUpViewExpDeps : ViewExp Database -> Database .
  op setUpViewExpDeps : ViewExp ParameterList Database -> Database .

  eq setUpViewDeps(ME, VE,
       db((< ME ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db((< ME ; DT ; U ; U' ; U'' ; VDS ; MNS ; VE # VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpViewDeps(ME, VE,
       db((< ME ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db((< ME ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VE # VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpViewDeps(ME, VE, DB)
    = warning(DB, '\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n)
    [owise] .

  eq setUpViewExpDeps(QI, DB) = DB .
  eq setUpViewExpDeps(QI{PL}, DB) = setUpViewExpDeps(QI{PL}, PL, DB) .

  eq setUpViewExpDeps(VE, (QI, PL),
       db(MIS, MNS, < QI ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE, PL,
        db(MIS, MNS, < QI ; DT ; VI ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpDeps(VE, (QI, PL),
       db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE, PL,
        db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpDeps(QI{PL}, PL',
       db(MIS, MNS, < QI ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(MIS, MNS, < QI ; DT ; VI ; MNS' ; QI{PL} # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)
    [owise] .
  eq setUpViewExpDeps(QI{PL}, PL',
       db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; QI{PL} # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)
    [owise] .

  eq setUpViewExpDeps(VE, (QI{PL}, PL'),
       db(MIS, MNS, < QI{PL} ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE, PL',
        db(MIS, MNS, < QI{PL} ; DT ; VI ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpDeps(VE, (QI{PL}, PL'),
       db(MIS, MNS, < QI{PL} ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE, PL',
        db(MIS, MNS, < QI{PL} ; VI ; VI' ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpDeps(VE, (QI{PL}, PL'), DB)
    = setUpViewExpDeps(VE, PL', DB)
    [owise] .
  eq setUpViewExpDeps(VE, empty, DB) = DB .

  op compiledModule : ModuleExpression Database -> Bool .
  op compiledModule : ParameterDecl Database -> Bool .
  op compiledView : ViewExp Database -> Bool .

  eq compiledView(VE,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VI =/= null .
  eq compiledView(ME, DB) = false [owise] .

  eq compiledModule(MN,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U'' =/= noModule .
  eq compiledModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U3 =/= noModule .
  eq compiledModule(MN, DB) = false [owise] .

  op insertTermView : ViewExp Term Database -> Database .
  op insertView : View Database -> Database .
  op getTermView : ViewExp Database -> Default{Term} .
  op getView : ViewExp Database -> View .

  eq insertTermView(VE, T,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES,
        delModules(MNS',
          db(MIS, MNS,
            < VE ; T ; null ; emptyModuleNameSet ; emptyViewExpSet > VIS, VES',
            MNS'', MNS3, MNS4,
            QIL
            '\g 'Advisory: '\o 'View viewExp2QidList(VE) 'redefined. '\n))) .
  eq insertTermView(VE, T,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = db(MIS, MNS,
         < VE ; T ; null ; emptyModuleNameSet ; emptyViewExpSet > VIS,
         (VE # VES), MNS', MNS'', MNS3, QIL)
    [owise] .

  eq insertView(view VE from ME to ME' is SMS OMS endv,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; DT ;
                 view VE from ME to ME' is SMS OMS endv ;
                 MNS' ; VES > VIS,
                 VES', MNS'', MNS3, MNS4, QIL)))) .
  eq insertView(view VE{PDL} from ME to ME' is SMS OMS endv,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; DT ;
                 view VE{PDL} from ME to ME' is SMS OMS endv ;
                 MNS' ; VES > VIS,
                 VES', MNS'', MNS3, MNS4, QIL)))) .
  eq insertView(view VE from ME to ME' is SMS OMS endv,
       db(MIS, MNS, VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; (null).Default{Term} ;
                 view VE from ME to ME' is SMS OMS endv ;
                 emptyModuleNameSet ; emptyViewExpSet > VIS,
                 VE # VES', MNS'', MNS3, MNS4, QIL))))
    [owise] .
  eq insertView(view VE{PDL} from ME to ME' is SMS OMS endv, db(MIS, MNS, VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; (null).Default{Term} ;
                 view VE{PDL} from ME to ME' is SMS OMS endv ;
                 emptyModuleNameSet ; emptyViewExpSet > VIS,
                 VE # VES', MNS'', MNS3, MNS4, QIL))))
    [owise] .
  eq insertView(viewError(QIL), DB) = warning(DB, QIL) .
  ceq insertView(view VE:[ViewExp] from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] endv, DB)
    = warning(DB, 'The 'view QIL QI if QI == '`) then '\s else nil fi 'contains 'errors.)
    if not view VE:[ViewExp] from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] endv :: View
    /\ QIL QI := eMetaPrettyPrint(VE:[ViewExp])
    [owise] .
  ceq insertView(view VE:[ViewExp]{PDL:[ParameterDeclList]} from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] endv, DB)
    = warning(DB, 'The 'view QIL QI if QI == '`) then '\s else nil fi 'contains 'errors.)
    if not view VE:[ViewExp]{PDL:[ParameterDeclList]} from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] endv :: View
    /\ QIL QI := eMetaPrettyPrint(VE:[ViewExp])
    [owise] .

  eq getTermView(VE,
       db(MIS, MNS, (< VE ; DT ; VI ; MNS' ; VES > VIS), VES', MNS'', MNS3, MNS4, QIL))
    = DT .
  eq getTermView(VE, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = qidError('\r 'Error: '\o 'View viewExp2QidList(VE) 'not 'in 'database. '\n)
    [owise] .

  eq getView(VE,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VI .
  eq getView(VE,
       db(MIS, MNS, < VE ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VI' .
  eq getView(VE, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = viewError('\r 'Error: '\o 'View viewExp2QidList(VE) 'not 'in 'database. '\n)
    [owise] .

*** There are functions to insert the different versions of a unit, and to
*** extract them.  We only give here the equations for the insertion of top
*** units to illustrate the way in which the consistency of the database is
*** maintained.  We assume that when the internal version, the signature, or
*** the flat version of a module is entered in the database, its corresponding
*** top module is already present in it.

  pr 3TUPLE{Term,OpDeclSet,Module}
       * (op ((_,_,_)) to <_;_;_>) .

----  sort Tuple{Term,OpDeclSet,Module} .
----  op <_;_;_> : Default{Term} OpDeclSet Module -> Tuple{Term,OpDeclSet,Module} .
  op error : QidList -> [Tuple{Term,OpDeclSet,Module}] .

  op insTermModule : ModuleName Module Database -> Database .
  op insTermModule : ModuleName Term Database -> Database .
  op insertTopModule : ModuleExpression [Module] Database -> Database .
  op insertInternalModule : ModuleExpression [Module] Database -> Database .
  op insertFlatModule : ModuleExpression [Module] Database -> Database .
  op insertVars : ModuleExpression [OpDeclSet] Database -> Database .
  op getTermModule : ModuleExpression Database -> [Tuple{Term,OpDeclSet,Module}] .
  op getTopModule : ModuleExpression Database -> [Module] .
  op getInternalModule : ModuleExpression Database -> [Module] .
  op getFlatModule : ModuleExpression Database -> [Module] .
  op getFlatModuleNeg : ModuleExpression Database -> [Module] .
  op getVars : ModuleExpression Database -> [OpDeclSet] .
  op insertTopModule : ParameterDecl [Module] Database -> Database .
  op insertInternalModule : ParameterDecl [Module] Database -> Database .
  op insertFlatModule : ParameterDecl [Module] Database -> Database .
  op insertVars : ParameterDecl [OpDeclSet] Database -> Database .
  op getTermModule : ParameterDecl Database -> [Tuple{Term,OpDeclSet,Module}] .
  op getTopModule : ParameterDecl Database -> [Module] .
  op getInternalModule : ParameterDecl Database -> [Module] .
  op getFlatModule : ParameterDecl Database -> [Module] .
  op getFlatModuleNeg : ParameterDecl Database -> [Module] .
  op getVars : ParameterDecl Database -> [OpDeclSet] .

  eq insTermModule(MN, T,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; T ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory: '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, T,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; T ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory: '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, T,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = db(< MN ; T ; noModule ; noModule ; noModule ; none ;
           emptyModuleNameSet ; emptyViewExpSet > MIS,
         MN . MNS, VIS, VES, MNS', MNS'', MNS3, QIL)
    [owise] .
  eq insTermModule(MN, qidError(QIL), DB) = warning(DB, QIL) .
  eq insTermModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insTermModule(MN, U,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; U ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory:
               '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; U ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory:
               '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, U,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = db(< MN ; U ; noModule ; noModule ; noModule ; none ;
           emptyModuleNameSet ; emptyViewExpSet > MIS,
         MN . MNS, VIS, VES, MNS', MNS'', MNS3, QIL)
    [owise] .
  eq insTermModule(MN, qidError(QIL), DB) = warning(DB, QIL) .
  eq insTermModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertTopModule(MN, U,
       db(< MN ; null ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; null ; U ; noModule ; noModule ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4,
         QIL
         '\r 'Advisory: '\o
         'Internally 'generated 'module header2QidList(MN) 'redefined. '\n) .
  eq insertTopModule(MN, U,
       db(< MN ; T ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModuleDeps(U,
        db(< MN ; T ; U ; noModule ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq insertTopModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModuleDeps(U,
        db(< MN ; U' ; U ; noModule ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq insertTopModule(MN, U,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = setUpModuleDeps(U,
        db(< MN ; null ; U ; noModule ; noModule ;
              none ; emptyModuleNameSet ; emptyViewExpSet > MIS,
           MN . MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    [owise] .
  eq insertTopModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertInternalModule(MN, U,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; DT ; U' ; U ; U3 ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertInternalModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; U' ; U'' ; U ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertInternalModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertFlatModule(MN, U,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; DT ; U' ; U'' ; U ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertFlatModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; U' ; U'' ; U3 ; U ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertFlatModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertVars(MN, VDS,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS' ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertVars(MN, VDS,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS' ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertVars(MN, opDeclError(QIL), DB) = warning(DB, QIL) .

  eq getTermModule(MN,
       db(< MN ; null ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = error('\r 'Error: '\o header2QidList(MN) 'is 'an 'internal 'module. '\n) .
  eq getTermModule(MN,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = < DT ; none ; noModule > .
  eq getTermModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = < null ; VDS ; U > .
  eq getTermModule(MN, DB)
    = error('\r 'Error: '\o 'Module header2QidList(MN)  '\n)
    [owise] .

  eq getTopModule(MN,
      db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U .
  eq getTopModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U' .
  eq getTopModule(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  eq getInternalModule(MN,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U' .
  eq getInternalModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U'' .
  eq getInternalModule(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  eq getVars(MN,
       db(< MN ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VDS .
  eq getVars(MN,
       db(< MN ; U ; U' ; U'' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VDS .
  eq getVars(MN, DB) = none [owise] .

*** The name of the signature and the flattened module is not the
*** module expression used as the name of the module but the result of
*** converting it into a quoted identifier.

  eq getFlatModule(MN,
       db(< MN ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = if M == noModule
      then unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'compiled. '\n)
      else remNegAnns(M)
      fi .
  eq getFlatModule(MN,
       db(< MN ; U ; U' ; U'' ; M ; VDS ; MNS ; VES > MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = if M == noModule
      then unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'compiled. '\n)
      else remNegAnns(M)
      fi .
  eq getFlatModule(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  *** Handling of negative annotations (by Santiago Escobar)

  eq getFlatModuleNeg(MN,
       db(< MN ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = M .
  eq getFlatModuleNeg(MN,
       db(< MN ; U ; U' ; U'' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = M .
  eq getFlatModuleNeg(MN,
       db(< MN ; DT ; U ; U' ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = unitError('\r 'Error: '\o
                'Module header2QidList(MN) 'not 'compiled. '\n) .
  eq getFlatModuleNeg(MN,
      db(< MN ; U ; U' ; U'' ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = unitError('\r 'Error: '\o
                'Module header2QidList(MN) 'not 'compiled. '\n) .
  eq getFlatModuleNeg(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  *** removeNegAnnotations
  op remNegAnns : Module -> Module .
  op remNegAnns : OpDeclSet -> OpDeclSet .
  op remNegAnns : AttrSet -> AttrSet .
  op remNegAnns : IntList -> IntList .

  eq remNegAnns(M) = setOps(M, remNegAnns(getOps(M))) .

  eq remNegAnns(op F : TyL -> Ty [AtS] . OPDS)
    = op F : TyL -> Ty [remNegAnns(AtS)] . remNegAnns(OPDS) .
  eq remNegAnns((none).OpDeclSet) = (none).OpDeclSet .

  eq remNegAnns(strat(NL:NatList) AtS) = strat(NL:NatList) AtS .
  eq remNegAnns(strat(IL:IntList) AtS) = AtS [owise] .
  eq remNegAnns(AtS) = AtS [owise] .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Evaluation of Modules
***

*** The general principle for the evaluation of units in our design consists in
*** first evaluating any module expression, reducing it to a canonical form in
*** which only unit inclusions appear, that is, to a unit hierarchy, which can
*** be seen as a partial order of unit inclusions. The design of the Full Maude
*** system has been based upon the principle of evaluating all module
*** expressions to irreducible structured units, and on using the flat version
*** of the units only for execution purposes. We have then two different
*** processes clearly distinguished: a first step in which the structured unit
*** is evaluated and reduced to its normal form, and a second step in which
*** this normal form is flattened.

*** As explained in Section~\ref{execution-environment}, the process of
*** evaluation to normal form is also responsible for the parsing of the
*** bubbles in the premodules, which is accomplished once the signature has
*** been built. The parsing of bubbles is discussed in
*** Section~\ref{bubble-parsing}. To be able to handle the \texttt{up}
*** function and the \texttt{down} command presented in
*** Section~\ref{structured-specifications}, it is necessary to be able to
*** move terms and modules from one level of reflection to another. The
*** functionality to move between levels is presented in
*** Section~\ref{changing-levels}, where functions \texttt{up} and
*** \texttt{down} on sorts \texttt{Module} and \texttt{Term} are defined. The
*** transformation of object-oriented modules into system modules in discussed
*** in Section~\ref{omod2modfunction}. The evaluation of module expressions is
*** discussed in Sections~\ref{evalModExp}, \ref{application-of-maps},
*** \ref{instantiation}, and~\ref{renaming}.

***
*** Changing Levels
***

*** Moving terms of sorts \texttt{Term} and \texttt{Module} from one
*** level of reflection to another is possible thanks to the
*** \texttt{up} and \texttt{down} functions, which are defined,
*** respectively, in the following modules \texttt{MOVE-UP} and
*** \texttt{MOVE-DOWN}.

***
*** The \texttt{up} Function
***

*** Given a term of sort \texttt{Module} or \texttt{Term}, the
*** \texttt{up} function, defined in the following module
*** \texttt{MOVE-UP}, returns the term metarepresenting it. The
*** function is just call the \texttt{upTerm} predefined function.

*** We shall see in Section~\ref{bubble-parsing} how the \texttt{up} function
*** is used to evaluate the homonymous function discussed in
*** Section~\ref{structured-specifications}. In Section~\ref{instantiation} we
*** shall discuss how the \texttt{up} function is used to evaluate the
*** \texttt{META-LEVEL} module expression (see
*** Section~\ref{structured-specifications}).

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOVE-UP is
---  pr META-LEVEL + PRE-VARIANT .
  pr META-LEVEL .
  pr CONVERSION .
  op up : Module -> Term .
  op up : Term -> Term .
  op up : EquationSet -> Term .

  eq up(M:Module) = upTerm(M:Module) .
  eq up(T:Term) = upTerm(T:Term) .
  eq up(EqS:EquationSet) = upTerm(EqS:EquationSet) .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The \texttt{down} Function
***

*** Given a term of sort \texttt{Term} metarepresenting a term of sort
*** \texttt{Term} or \texttt{Module}, the \texttt{down} function can be seen
*** as the inverse of the \texttt{up} function discussed in the previous
*** section, that is, it returns the original term that had been
*** metarepresented. There are also \texttt{down} functions for terms
*** metarepresenting terms in other sorts. We present here only some of them.

*** We assume that the \texttt{down} functions are called with valid
*** metarepresentations. In fact, these functions should be declared as
*** partial functions going to error sorts when their arguments are invalid.

*** The main application of the \texttt{down} functions is in the evaluation
*** of the \texttt{down} command (see
*** Section~\ref{structured-specifications}).  However, they are also used in
*** other tasks, as for example in the parsing of some inputs.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOVE-DOWN is
  pr UNIT .
  pr CONVERSION .
  pr INT-LIST .

  op downTerm : Term -> [Term] .
  op downModule : Term -> [Module] .
  op downQid : Term -> [Qid] [memo] .
  op downQidList : Term -> [QidList] .
  op downTypes : Term -> [TypeList] .
  op downSorts : Term -> [SortSet] .
  op downSort : Term -> [Sort] .
  op downModExp : Constant -> [Header] .
  op downNat : Term -> [Int] .
  op downString : Term -> [String] .

  op downResultPair : Term -> [ResultPair] .
  op downTerm : TermList -> [Term] .
  op downImports : TermList -> [ImportList] .
  op downSubsorts : TermList -> [SubsortDeclSet] .
  op downOps : TermList -> [OpDeclSet] .
  op downEqCond : TermList -> [EqCondition] .
  op downCond : TermList -> [Condition] .
  op downMbs : TermList -> [MembAxSet] .
  op downEqs : TermList -> [EquationSet] .
  op downRls : TermList -> [RuleSet] .
  op downAttrs : TermList -> [AttrSet] .
  op downAttr : Term -> [Attr] .
  op downHooks : TermList -> [HookList] .
  op downMetaNat : Term -> [Term] .
  op downNat : TermList -> [IntList] .

  op downClasses : TermList -> [ClassDeclSet] .
  op downMsgs : TermList -> [MsgDeclSet] .
  op downSubclasses : TermList -> [SubclassDeclSet] .
  op downClassAttrs : TermList -> [AttrDeclSet] .

  vars T T' T'' T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Term .
  vars TL TL' : TermList .
  vars QI QI' F V L : Qid .
  var  Ct : Constant .
  var  M : Module .
  var  Tp : Type .

  eq downResultPair('`{_`,_`}[T, T']) = {downTerm(T), downTerm(T')} .

  eq downModule('fmod_is_sorts_.____endfm[T1, T2, T3, T4, T5, T6, T7])
    = (fmod downModExp(T1) is
         downImports(T2)
         sorts downSorts(T3) .
         downSubsorts(T4)
         downOps(T5)
         downMbs(T6)
         downEqs(T7)
       endfm) .
  eq downModule('mod_is_sorts_._____endm[T1, T2, T3, T4, T5, T6, T7, T8])
    = (mod downModExp(T1) is
         downImports(T2)
         sorts downSorts(T3) .
         downSubsorts(T4)
         downOps(T5)
         downMbs(T6)
         downEqs(T7)
         downRls(T8)
       endm) .
  eq downModule('omod_is_sorts_.________endom[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11])
    = (omod downModExp(T1) is
         downImports(T2)
         sorts downSorts(T3) .
         downSubsorts(T4)
         downClasses(T5)
         downSubclasses(T6)
         downOps(T7)
         downMsgs(T8)
         downMbs(T9)
         downEqs(T10)
         downRls(T11)
       endom) .

  eq downModExp(Ct) = downQid(Ct) .

  eq downImports('nil.ImportList) = nil .
  eq downImports('__[TL]) = downImports(TL) .
  eq downImports('including_.[T]) = (including downModExp(T) .) .
  eq downImports('extending_.[T]) = (extending downModExp(T) .) .
  eq downImports('protecting_.[T]) = (protecting downModExp(T) .) .
  ceq downImports((TL, TL')) = (downImports(TL) downImports(TL')) if TL =/= empty /\ TL' =/= empty .

  eq downSubsorts('none.SubsortDeclSet) = none .
  eq downSubsorts('__[TL]) = downSubsorts(TL) .
  eq downSubsorts('subsort_<_.[T, T']) = (subsort downQid(T) < downQid(T') .) .
  ceq downSubsorts((TL, TL')) = (downSubsorts(TL) downSubsorts(TL')) if TL =/= empty /\ TL' =/= empty .

  eq downOps('none.OpDeclSet) = none .
  eq downOps('__[TL]) = downOps(TL) .
  eq downOps('op_:_->_`[_`].[Ct, T, T', T''])
    = (op downQid(Ct) : downTypes(T) -> downQid(T') [downAttrs(T'')] .) .
  ceq downOps((TL, TL')) = (downOps(TL) downOps(TL')) if TL =/= empty /\ TL' =/= empty .

  eq downAttrs('none.AttrSet) = none .
  eq downAttrs('__[TL]) = downAttrs(TL) .
  ceq downAttrs((TL, TL')) = (downAttr(TL) downAttrs(TL')) if TL =/= empty /\ TL' =/= empty .
  ceq downAttrs(T)
    = downAttr(T)
    if T =/= 'none.AttrSet .

  eq downAttr('assoc.Attr) = assoc .
  eq downAttr('comm.Attr) = comm .
  eq downAttr('idem.Attr) = idem .
  eq downAttr('id[T]) = id(downTerm(T)) .
  eq downAttr('left-id[T]) = left-id(downTerm(T)) .
  eq downAttr('right-id[T]) = right-id(downTerm(T)) .
  eq downAttr('poly[T]) = poly(downNat(T)) .
  eq downAttr('strat[T]) = strat(downNat(T)) .
  eq downAttr('memo.Attr) = memo .
  eq downAttr('prec[T]) = prec(downNat(T)) .
  eq downAttr('gather[T]) = gather(downQidList(T)) .
  eq downAttr('ctor.Attr) = ctor .
  eq downAttr('special[T]) = special(downHooks(T)) .
  eq downAttr('iter.Attr) = iter .
  eq downAttr('frozen[T]) = frozen(downNat(T)) .
  eq downAttr('label[T]) = label(downQid(T)) .
  eq downAttr('config.Attr) = config .
  eq downAttr('object.Attr) = object .
  eq downAttr('msg.Attr) = msg .
  eq downAttr('nonexec.Attr) = nonexec .
  eq downAttr('variant.Attr) = variant .
----  eq downAttr('metadata`(_`)['token[T]]) = metadata(downString(downQid(T))) .
  eq downAttr('owise.Attr) = owise .
  eq downAttr('metadata[T]) = metadata(substr(string(T), 1, find(string(T), "\".String", 0) + (- 1))) .
  eq downAttr('format[T]) = format(downQidList(T)) .

  eq downHooks('__[TL]) = downHooks(TL) .
  eq downHooks('id-hook[T, T']) = id-hook(downQid(T), downQidList(T')) .
  eq downHooks('op-hook[T, T', T'', T3])
    = op-hook(downQid(T), downQid(T'), downQidList(T''), downQid(T3)) .
  eq downHooks('term-hook[T, T']) = term-hook(downQid(T), downTerm(T')) .
  ceq downHooks((TL, TL')) = downHooks(TL) downHooks(TL') if TL =/= empty /\ TL' =/= empty .

----  eq downTerm(T) = downTerm(T, qidError('\r 'Error: '\o 'Incorrect 'term. '\n)) .
  eq downTerm(QI) = downQid(QI) .
  eq downTerm('_`[_`][T, T']) = downQid(T)[downTerm(T')] .
  eq downTerm('_`,_[T, TL]) = (downTerm(T), downTerm(TL)) .
  ceq downTerm((T, TL)) = (downTerm(T), downTerm(TL)) if TL =/= empty .
  eq downTerm(F[TL])
    = qidError('\r 'Error: '\o 'Incorrect 'term. '\n) [owise] .

  eq downEqCond('_/\_[TL]) = downEqCond(TL) .
  eq downEqCond('_=_[T, T']) = downTerm(T) = downTerm(T') .
  eq downEqCond('_:_[T, T']) = downTerm(T) : downSort(T') .
  eq downEqCond('_:=_[T, T']) = downTerm(T) := downTerm(T') .
  ceq downEqCond((TL, TL')) = downEqCond(TL) /\ downEqCond(TL') if TL =/= empty /\ TL' =/= empty .

  eq downCond('_/\_[TL]) = downCond(TL) .
  eq downCond('_=_[T, T']) = downEqCond('_=_[T, T']) .
  eq downCond('_:_[T, T']) = downEqCond('_:_[T, T']) .
  eq downCond('_:=_[T, T']) = downEqCond('_:=_[T, T']) .
  eq downCond('_=>_[T, T']) = downTerm(T) => downTerm(T') .
  ceq downCond((TL, TL')) = downCond(TL) /\ downCond(TL') if TL =/= empty /\ TL' =/= empty .

  eq downMbs('none.MembAxSet) = none .
  eq downMbs('__[TL]) = downMbs(TL) .
  eq downMbs('mb_:_`[_`].[T, T', T''])
    = (mb downTerm(T) : downSort(T') [downAttrs(T'')] .) .
  eq downMbs('cmb_:_if_`[_`].[T, T', T'', T3])
    = (cmb downTerm(T) : downSort(T') if downEqCond(T'') [downAttrs(T3)] .) .
  ceq downMbs((TL, TL')) = (downMbs(TL) downMbs(TL')) if TL =/= empty /\ TL' =/= empty .

  eq downEqs('none.EquationSet) = none .
  eq downEqs('__[TL]) = downEqs(TL) .
  eq downEqs('eq_=_`[_`].[T, T', T''])
    = (eq downTerm(T) = downTerm(T') [downAttrs(T'')] .) .
  eq downEqs('ceq_=_if_`[_`].[T, T', T'', T3])
    = (ceq downTerm(T) = downTerm(T') if downEqCond(T'') [downAttrs(T3)] .) .
  ceq downEqs((TL, TL')) = (downEqs(TL) downEqs(TL')) if TL =/= empty /\ TL' =/= empty .

  eq downRls('none.RuleSet) = none .
  eq downRls('__[TL]) = downRls(TL) .
  eq downRls('rl_=>_`[_`].[T, T', T''])
    = (rl downTerm(T) => downTerm(T') [downAttrs(T'')] .) .
  eq downRls('crl_=>_if_`[_`].[T, T', T'', T3])
    = (crl downTerm(T) => downTerm(T') if downCond(T'') [downAttrs(T3)] .) .
  ceq downRls((TL, TL')) = (downRls(TL) downRls(TL')) if TL =/= empty /\ TL' =/= empty .

  eq downSorts('none.EmptyTypeSet) = none .
----  eq downSorts('none.SortSet) = none .
  eq downSorts('_;_[TL]) = downSorts(TL) .
  ceq downSorts((TL, TL')) = (downSorts(TL) ; downSorts(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downSorts(QI) = downSort(QI) [owise] .

  eq downSort(Ct) = downQid(Ct) .

  eq downTypes('nil.TypeList) = nil .
  eq downTypes('__[TL]) = downTypes(TL) .
  ceq downTypes((TL, TL'))
    = (downTypes(TL) downTypes(TL'))
    if TL =/= empty /\ TL' =/= empty .
  eq downTypes(QI) = downSort(QI) [owise] .

  eq downQidList('nil.TypeList) = nil .
  eq downQidList('__[TL]) = downQidList(TL) .
  ceq downQidList((TL, TL')) = (downQidList(TL) downQidList(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downQidList(QI) = downQid(QI) [owise] .

  eq downQid(Ct)
    = qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))) .
----  eq downQid(Ct) = downTerm(Ct) .

  eq downMetaNat(QI)
    = qid(substr(string(getName(QI)), 1, length(string(getName(QI))))
          + ".Nat") .

----  eq downNat(T) = downTerm(T, numberError('Error: 'non 'valid 'metaterm)) .
  ceq downNat(QI)
    = trunc(rat(string(getName(QI)), 10))
    if getType(QI) == 'Nat or getType(QI) == 'NzNat .
  ceq downNat(QI)
    = if substr(string(getName(QI)), 0 ,1) == "-"
      then - trunc(rat(substr(string(getName(QI)), 1,
                            length(string(getName(QI)))), 10))
      else trunc(rat(string(getName(QI)), 10))
      fi
    if getType(QI) == 'Int or getType(QI) == 'NzInt .
  eq downNat('0.Zero) = 0 .
  eq downNat('s_['0.Zero]) = 1 .
  ceq downNat(F['0.Zero])
    = trunc(rat(substr(string(F), 3, 2), 10))
    if substr(string(F), 0, 3) = "s_^" .

  eq downString(QI) = substr(string(QI), 1, _-_(length(string(QI)), 2)) .

  eq downNat('__[TL]) = downNat(TL) .
  ceq downNat((TL, TL')) = (downNat(TL) downNat(TL')) if TL =/= empty /\ TL' =/= empty .

  eq downClasses('none.ClassDeclSet) = none .
  eq downClasses('__[TL]) = downClasses(TL) .
  ceq downClasses((TL, TL')) = (downClasses(TL) downClasses(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downClasses('class_|_.[T, T']) = (class downSort(T) | downClassAttrs(T') .) .

  eq downClassAttrs('none.AttrDeclSet) = none .
  eq downClassAttrs('_`,_[TL]) = downClassAttrs(TL) .
  ceq downClassAttrs((TL, TL')) = (downClassAttrs(TL), downClassAttrs(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downClassAttrs('attr_:_[T, T']) = (attr downQid(T) : downSort(T')) .

  eq downSubclasses('none.SubclassDeclSet) = none .
  eq downSubclasses('__[TL]) = downSubclasses(TL) .
  ceq downSubclasses((TL, TL')) = (downSubclasses(TL) downSubclasses(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downSubclasses('subclass_<_.[T, T']) = (subclass downQid(T) < downQid(T') .) .

  eq downMsgs('none.MsgDeclSet) = none .
  eq downMsgs('__[TL]) = downMsgs(TL) .
  ceq downMsgs((TL, TL')) = (downMsgs(TL) downMsgs(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downMsgs('msg_:_->_.[Ct, T, T'])
    = (msg downQid(Ct) : downTypes(T) -> downQid(T') .) .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Parsing of Bubbles
***

*** As discussed in Section~\ref{implementation-introduction}, in Full Maude,
*** the parsing process is split into two phases. In a first stage, the input
*** is parsed using the top-level grammar for Full Maude modules, theories,
*** views, and commands. Once this first stage is completed, we get a term
*** with bubbles in it, which is converted into a module, theory, or view.
*** This unit or view may still have the bubbles in it. We say that a module
*** with bubbles is a premodule, a view with bubbles a preview, and so on. The
*** second stage of the process consists in taking this preunit or preview and
*** converting the bubbles in it into terms by parsing them in the appropriate
*** signatures, obtaining a `valid' unit or view out of it, or otherwise a
*** parsing error. In the case of commands, if they contain any bubble, the
*** same will have to be done. All bubbles have to be parsed in the
*** appropriate signature before any further processing can be done with the
*** module, view, or command in which they appear.

***
*** Parsing of Module Expressions
***

*** Before introducing the \texttt{parseDecl} function, we present some
*** auxiliary functions. For example, the following functions
*** \texttt{parseType}, \texttt{parseSortSet}, and \texttt{parseTypeList}
*** return, respectively, the sort, set of sorts, and list of sorts
*** represented by the term given as argument. Note that these functions, as
*** most of the functions in this module, are partial functions. We assume
*** that the term given as argument is in fact the representation of, for
*** example, a valid sort, or set of sorts, etc. In the case of
*** \texttt{parseDecl} we assume that the term is the representation of a
*** predeclaration.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-EXP-PARSING is
  pr MOVE-DOWN .
  pr INT-LIST .
  pr VIEW-EXPR-TO-QID .

  vars T T' T'' T3 T4 : Term .
  vars T? T?' : [Term] .
  var  TL TL' : TermList .
  var  QIL  : QidList .
  var  Ct : Constant .
  var  AtS : AttrSet .
  vars QI F : Qid .
  var  CD? : [Condition] .
  vars S S' : Sort .
  var  TyL : TypeList .

  op parseSort : Term ~> Sort .
  op parseType : Term ~> Type .
  op parseSortSet : Term ~> SortSet .
  op parseTypeList : Term ~> TypeList .
  op parseViewExp : Term ~> ViewExp .
  op parseParameterList : Term ~> ParameterList .

  eq parseSort('sortToken[T])
    = if downQid(T) :: Type
      then downQid(T)
      else qidError('\r 'Warning: '\o downQid(T) 'is 'not 'a 'valid 'sort. '\n)
      fi .
  eq parseSort('_`{_`}[T, T'])
    = qid(string(parseSort(T))
          + "{" + string(parameterList2Qid(parseParameterList(T'))) + "}") .
  eq parseSort(T) = qidError('\r 'Warning: '\o 'invalid 'sort. '\n) [owise] .

  eq parseType('`[_`][T])
    ---- = kind(parseSort(T)) .
    = qid("[" + string(parseSort(T)) + "]") .
  eq parseType(T) = parseSort(T) [owise] .

  eq parseSortSet('__[T, T']) = (parseSort(T) ; parseSortSet(T')) .
  eq parseSortSet(T) = parseSort(T) [owise].

  eq parseTypeList('__[T, T']) = (parseType(T) parseTypeList(T')) .
  eq parseTypeList(T) = parseType(T) [owise] .

  eq parseViewExp('viewToken[T])
    = if downQid(T) :: Sort
      then downQid(T)
      else qidError('\r 'Warning: '\o downQid(T) 'is 'not 'a 'valid 'sort. '\n)
      fi .
  eq parseViewExp('_`{_`}[T, T'])
    = parseViewExp(T){parseParameterList(T')} .
  eq parseViewExp(T)
    = qidError('\r 'Warning: '\o 'invalid 'view 'expression. '\n)
    [owise] .

  eq parseParameterList('_`,_[T, T'])
    = parseViewExp(T), parseParameterList(T') .
  eq parseParameterList(T) = parseViewExp(T) [owise] .

*** The function \texttt{parseModExp} takes a term representing a
*** module expression and returns the corresponding term in sort
*** \texttt{ModuleExpression}. In case of adding new constructors for module
*** expressions, as it will be done in Section~\ref{extension}, new equations d
*** efining the semantics of the function on them will have to be given.

  op parseModExp : Term -> ModuleExpression .
  op parseMaps : Term -> RenamingSet .

  op parseAttrs : Term -> AttrSet .

  eq parseModExp('token[T]) = downQid(T) .
  eq parseModExp('`(_`)[T]) = parseModExp(T) .
  eq parseModExp('_`{_`}[T, T'])
    = _`{_`}(parseModExp(T), parseParameterList(T')) .
  eq parseModExp('_*`(_`)[T, T']) = _*`(_`)(parseModExp(T), parseMaps(T')) .
  eq parseModExp('_+_[T, T']) = parseModExp(T) + parseModExp(T') .
  eq parseModExp('TUPLE`[_`]['token[T]]) = TUPLE[parseNat(T)] .
  eq parseModExp('POWER`[_`]['token[T]]) = POWER[parseNat(T)] .

  eq parseMaps('_`,_[T, T']) = (parseMaps(T), parseMaps(T')) .

  eq parseMaps('sort_to_[T, T']) = (sort parseType(T) to parseType(T')) .
  eq parseMaps('label_to_['token[T], 'token[T']])
    = (label downQid(T) to downQid(T')) .
  eq parseMaps('class_to_[T, T']) = (class parseType(T) to parseType(T')) .
  eq parseMaps('attr_._to_[T, 'token[T'], 'token[T'']])
    = (attr downQid(T') . parseType(T) to downQid(T'')) .
  eq parseMaps('msg_to_['token[T], 'token[T']])
    = (msg downQid(T) to downQid(T')) .
  eq parseMaps('msg_:_->_to_['token[T], T', T'', 'token[T3]])
    = (msg downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3)) .
  eq parseMaps('msg_:`->_to_['token[T], T', 'token[T'']])
    = (msg downQid(T) : nil -> parseType(T') to downQid(T'')) .
  eq parseMaps('op_to_`[_`]['token[T], 'token[T'], T''])
    = (op downQid(T) to downQid(T') [parseAttrs(T'')]) .
  eq parseMaps('op_:_->_to_`[_`]['token[T], T', T'', 'token[T3], T4])
    = (op downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3)
            [parseAttrs(T4)]) .
  eq parseMaps('op_:`->_to_`[_`]['token[T], T', 'token[T''], T3])
    = (op downQid(T) : nil -> parseType(T') to downQid(T'')
          [parseAttrs(T3)]) .
  eq parseMaps('op_:_~>_to_`[_`]['token[T], T', T'', 'token[T3], T4])
    = (op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
            to downQid(T3) [parseAttrs(T4)]) .
  eq parseMaps('op_:`~>_to_`[_`]['token[T], T', 'token[T''], T3])
    = (op downQid(T) : nil -> kind(parseType(T')) to downQid(T'')
          [parseAttrs(T3)]) .
  eq parseMaps('op_to_['token[T], 'token[T']])
    = (op downQid(T) to downQid(T') [none]) .
  eq parseMaps('op_:_->_to_['token[T], T', T'', 'token[T3]])
    = (op downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3)
          [none]) .
  eq parseMaps('op_:`->_to_['token[T], T', 'token[T'']])
    = (op downQid(T) : nil -> parseType(T') to downQid(T'') [none]) .
  eq parseMaps('op_:_~>_to_['token[T], T', T'', 'token[T3]])
    = (op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
          to downQid(T3) [none]) .
  eq parseMaps('op_:`~>_to_['token[T], T', 'token[T'']])
    = (op downQid(T) : nil -> kind(parseType(T')) to downQid(T'') [none]) .

  eq parseAttrs('__[T, T']) = (parseAttrs(T) parseAttrs(T')) .
  eq parseAttrs('assoc.@Attr@) = assoc .
  eq parseAttrs('associative.@Attr@) = assoc .
  eq parseAttrs('comm.@Attr@) = comm .
  eq parseAttrs('commutative.@Attr@) = comm .
  eq parseAttrs('idem.@Attr@) = idem .
  eq parseAttrs('idempotent.@Attr@) = idem .
  eq parseAttrs('id:_[T]) = none .
  eq parseAttrs('identity:_[T]) = none .
  eq parseAttrs('left`id:_[T]) = none .
  eq parseAttrs('left`identity:_[T]) = none .
  eq parseAttrs('right`id:_[T]) = none .
  eq parseAttrs('right`identity:_[T]) = none .
  eq parseAttrs('poly`(_`)[T]) = poly(parseInt(T)) .
  eq parseAttrs('strat`(_`)[T]) = none .
  eq parseAttrs('strategy`(_`)[T]) = none .
  eq parseAttrs('memo.@Attr@) = none .
  eq parseAttrs('memoization.@Attr@) = none .
  eq parseAttrs('prec_['token[T]]) = prec(parseNat(T)) .
  eq parseAttrs('precedence_['token[T]]) = prec(parseNat(T)) .
  eq parseAttrs('prec_['`(_`)['token[T]]]) = prec(parseNat(T)) .
  eq parseAttrs('precedence_['`(_`)['token[T]]]) = prec(parseNat(T)) .
  eq parseAttrs('gather`(_`)['neTokenList[T]]) = gather(downQidList(T)) .
  eq parseAttrs('gathering`(_`)['neTokenList[T]]) = gather(downQidList(T)) .
  eq parseAttrs('format`(_`)['neTokenList[T]]) = none .
  eq parseAttrs('ctor.@Attr@) = ctor .
  eq parseAttrs('constructor.@Attr@) = ctor .
  eq parseAttrs('frozen.@Attr@) = none .
  eq parseAttrs('frozen`(_`)[T]) = none .
  eq parseAttrs('iter.@Attr@) = iter .
  eq parseAttrs('ditto.@Attr@) = ditto .
  eq parseAttrs('special`(_`)[T]) = parseSpecial(parseHookList(T)) .
  eq parseAttrs('config.@Attr@) = config .
  eq parseAttrs('object.@Attr@) = object .
  eq parseAttrs('msg.@Attr@) = msg .
  eq parseAttrs('message.@Attr@) = msg .
  eq parseAttrs('metadata_['token[T]]) = metadata(downString(downQid(T))) .
  eq parseAttrs('variant.@Attr@) = variant .
  eq parseAttrs('nonexec.@Attr@) = nonexec .

  op parseSpecial : Set<Hook> -> Attr .
  op parseHookList : Term -> Set<Hook> .
  op hookList : Set<Hook> -> HookList .
  sort Set<Hook> .
  subsort Hook < Set<Hook> .
  op none : -> Set<Hook> .
  op _._ : Set<Hook> Set<Hook> -> Set<Hook> [assoc comm id: none] .
  var  SH : Set<Hook> .
  var  H : Hook .

  eq parseSpecial(none) = none .
  eq parseSpecial(SH) = special(hookList(SH)) [owise] .

  eq parseHookList('__[T, TL]) = parseHookList(T) . parseHookList(TL) .
  eq parseHookList('id-hook_['token[T]]) = id-hook(downQid(T), nil) .
  eq parseHookList('id-hook_`(_`)['token[T], 'neTokenList[T']])
    = id-hook(downQid(T), downQidList(T')) .
  eq parseHookList(
       'op-hook_`(_:_->_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parseHookList('op-hook_`(_:`->_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parseHookList(
       'op-hook_`(_:_~>_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parseHookList('op-hook_`(_:`~>_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parseHookList('term-hook_`(_`)['token[T], T']) = none .

  eq hookList(H) = H .
  eq hookList(H . SH) = H hookList(SH) [owise] .

*** Given a term representing a machine integer, the function
*** \texttt{parseInt} returns the corresponding integer.

  op parseNat : Term -> Nat .

  op parseInt : Term -> Int .
  op parseInt : TermList -> IntList .

  eq parseInt(('neTokenList['__[TL]], TL')) = parseInt(TL) parseInt(TL') .
  eq parseInt(('neTokenList[QI], TL)) = parseInt(QI) parseInt(TL) .
  eq parseInt(empty) = nil .

  eq parseInt((T, TL)) = parseInt(T) parseInt(TL) [owise] .
  eq parseInt(nil) = nil .

  eq parseInt(Ct)
    = downNat(
        qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))
            + ".Int")) .

  eq parseNat(Ct)
    = downNat(
        qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))
            + ".Nat")) .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Parsing of Bubbles
***

*** In the following module \texttt{BUBBLE-PARSING}, the definitions for the
*** basic processing of bubbles are introduced. In it we declare a function
*** \texttt{solveBubbles} which takes a bubble and some other arguments and
*** returns the term resulting from parsing it.


-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod BUBBLE-PARSING is
  pr DATABASE .
  pr MOVE-UP .
  pr MOVE-DOWN .
  pr MOD-EXP-PARSING .
  pr PRINT-SYNTAX-ERROR .

  vars T T' : Term .
  vars M M' : Module .
  var  B : Bool .
  var  QIL : QidList .
  vars DB DB' : Database .
  var  TL : TermList .
  var  S : Sort .
  vars QI QI' F : Qid .
  var  VDS : OpDeclSet .
  var  C : Constant .
  var  V : Variable .
  var  N : Nat .
  var  Tp : Type .
  var  RP : [ResultPair] .
  var  MN : ModuleName .
  var  ME : ModuleExpression .
  var  U : Module .
  var  Cond : Condition .

  op resultPairError : QidList -> [ResultPair] [ctor] .

*** As we shall see in Section~\ref{evaluation}, a declaration importing the
*** predefined module \texttt{UP} (see Section~\ref{non-built-in-predefined})
*** is added to all modules importing the \texttt{META-LEVEL} module. The
*** \texttt{solveBubbles} function is called with a `flag' indicating whether
*** the module can contain calls to the \texttt{up} function or not. Thus,
*** when we call \texttt{metaParse} with some bubble and the module in which
*** such bubble has to be parsed, if there are occurrences of the function
*** \texttt{up} in it, they will be of the form \verb~'token[T]]~ or
*** \verb~'up['token[T], 'bubble[T']]~ for terms \texttt{T} and \texttt{T'}.
*** The function \texttt{solveUps} will evaluate them.

  op solveBubbles : Term Module Bool OpDeclSet Database -> [Term] .
  op solveUps : TermList Database -> [TermList] .
  op solveUpsCondition : Condition Database -> Condition .
  op solveUpsModExp : TermList Database -> [TermList] .
  op constsToVars : Term OpDeclSet -> Term [memo] .
  op constsToVars : TermList OpDeclSet -> TermList [memo] .
  op constsToVarsAux : Constant OpDeclSet -> Qid [memo] .

  eq constsToVars(F[TL], VDS) = F[constsToVars(TL, VDS)] .
  eq constsToVars(C, VDS) = constsToVarsAux(C, VDS) .
  eq constsToVars(V, VDS) = V .
  eq constsToVars(qidError(QIL), VDS) = qidError(QIL) .
  ceq constsToVars((T, TL), VDS)
    = (constsToVars(T, VDS), constsToVars(TL, VDS))
    if TL =/= empty .

  eq constsToVarsAux(C, (op F : nil -> Tp [none] .) VDS)
    = if getName(C) == F
      then qid(string(F) + ":" + string(Tp))
      else constsToVarsAux(C, VDS)
      fi .
  eq constsToVarsAux(C, none) = C .

  ceq solveBubbles('bubble[T], M, true, VDS, DB)
    *** if META-LEVEL is a submodule the ups need to be solved
    = if RP :: ResultPair
      then solveUps(constsToVars(getTerm(RP), VDS), DB)
      else qidError('\r 'Warning: '\o printSyntaxError(RP, QIL) '\n
                    '\r 'Error: '\o 'no 'parse 'for QIL '\n)
      fi
    if M' := addOps(VDS, M)
       /\ QIL := downQidList(T)
       /\ RP := metaParse(M', QIL, anyType) .

  ceq solveBubbles('bubble[T], M, false, VDS, DB)
    = if RP :: ResultPair
      then constsToVars(getTerm(RP), VDS)
      else qidError('\r 'Warning: '\o printSyntaxError(RP, QIL) '\n
                    '\r 'Error: '\o 'no 'parse 'for QIL '\n)
      fi
    if M' := addOps(VDS, M)
       /\ QIL := downQidList(T)
       /\ RP := metaParse(M', QIL, anyType) .

*** The \texttt{solveBubbles1} function is in charge of calling the function
*** \texttt{metaParse}. The flag indicating the inclusion of the module
*** \texttt{META-LEVEL} in the module in which the term appears decides
*** whether the function \texttt{solveUps} is called or not, so the extra
*** price of searching for calls to the \texttt{up} function is paid only
*** when an occurrence of the function is possible. This function takes care
*** of the occurrences of the \texttt{up} function that may exist in such
*** bubbles.

*** The function \texttt{solveUps} goes through the term looking for a term
*** with \texttt{'up} as top operator and \texttt{'token} as top operator of
*** its unique argument if there is only one argument, or with \texttt{'token}
*** and \texttt{'bubble} as top operators of its first and second arguments,
*** respectively, if there are two. If a term of the form
*** \mbox{\texttt{'up['token[T]]}} is reached, it is replaced by the
*** metarepresentation of the flat version of the module in the database with
*** the name given by the token. If a term of form
*** \mbox{\texttt{'up['token[T], 'bubble[T']]}} is reached, the
*** metarepresentation of the result of parsing the bubble in the signature
*** of the module with the name given by the token, after solving possible
*** nested calls to the \texttt{up} function, is returned.

  eq solveUps(QI, DB) = QI .
  eq solveUps(F[TL], DB) = F[solveUps(TL, DB)] [owise] .
  ceq solveUps((T, TL), DB)
    = (solveUps(T, DB), solveUps(TL, DB))
    if TL =/= empty .

  eq solveUps('upModule['token[T]], DB)
    = solveUpsModExp('upModule['token[T]], DB) .
  eq solveUps('upModule['`(_`)[T]], DB)
    = solveUpsModExp('upModule['`(_`)[T]], DB) .
  eq solveUps('upModule['_`{_`}[T, T']], DB)
    = solveUpsModExp('upModule['_`{_`}[T, T']], DB) .
  eq solveUps('upModule['_*`(_`)[T, T']], DB)
    = solveUpsModExp('upModule['_*`(_`)[T, T']], DB) .
  eq solveUps('upModule['_+_[T, T']], DB)
    = solveUpsModExp('upModule['_+_[T, T']], DB) .
  eq solveUps('upModule['TUPLE`[_`]['token[T]]], DB)
    = solveUpsModExp('upModule['TUPLE`[_`]['token[T]]], DB) .
  eq solveUps('upModule['POWER`[_`]['token[T]]], DB)
    = solveUpsModExp('upModule['POWER`[_`]['token[T]]], DB) .

  eq solveUpsCondition(T = T' /\ Cond, DB)
    = solveUps(T, DB) = solveUps(T', DB) /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(T : S /\ Cond, DB)
    = solveUps(T, DB) : S /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(T := T' /\ Cond, DB)
    = T := solveUps(T', DB) /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(T => T' /\ Cond, DB)
    = solveUps(T, DB) => solveUps(T', DB) /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(nil, DB) = nil .

  ceq solveUpsModExp('upModule[T], DB)
    = up(getFlatModule(MN, DB'))
    if < DB' ; MN > := evalModExp(parseModExp(T), DB)
    /\ unitInDb(MN, DB') .
  ceq solveUpsModExp('upModule[T], DB)
    = qidError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    if MN := parseModExp(T)
    [owise] .

  eq solveUps('upTerm['token[T], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['token[T], 'bubble[T']], DB) .
  eq solveUps('upTerm['`(_`)[T], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['`(_`)[T], 'bubble[T']], DB) .
  eq solveUps('upTerm['_`{_`}[T, T'], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['_`{_`}[T, T'], 'bubble[T']], DB) .
  eq solveUps('upTerm['_*`(_`)[T, T'], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['_*`(_`)[T, T'], 'bubble[T']], DB) .
  eq solveUps('upTerm['_+_[T, T'], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['_+_[T, T'], 'bubble[T']], DB) .
  eq solveUps('upTerm['TUPLE`[_`]['token[T]], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['TUPLE`[_`]['token[T]], 'bubble[T']], DB) .
  eq solveUps('upTerm['POWER`[_`]['token[T]], 'bubble[T']], DB)
    = solveUpsModExp('upTerm['POWER`[_`]['token[T]], 'bubble[T']], DB) .

  ceq solveUpsModExp('upTerm[T, 'bubble[T']], DB)
    = if included('META-MODULE, getImports(getInternalModule(MN, DB')), DB')
      then if metaParse(U, QIL, anyType) :: ResultPair
           then up(solveUps(getTerm(metaParse(U, QIL, anyType)), DB'))
           else qidError('\r 'Warning: '\o
                  'No 'parse 'for 'argument 'of 'up
                  printSyntaxError(metaParse(U, QIL, anyType), QIL)
                  '\n)
           fi
      else if metaParse(U, QIL, anyType) :: ResultPair
           then up(getTerm(metaParse(U, QIL, anyType)))
           else qidError('\r 'Warning: '\o
                  'No 'parse 'for 'argument 'of 'up
                  printSyntaxError(metaParse(U, QIL, anyType), QIL)
                  '\n)
           fi
      fi
    if < DB' ; MN > := evalModExp(parseModExp(T), DB)
       /\ U := getFlatModule(MN, DB')
       /\ QIL := downQidList(T').
  ceq solveUpsModExp('upTerm[T, 'bubble[T']], DB)
    = qidError('\r 'Error: 'op '\o 'Module header2QidList(ME) 'not 'in 'database. '\n)
    if ME := parseModExp(T)
    [owise] .

  eq solveUps('`[_`][QI], DB) = '`[_`][QI] .
  ceq solveUps('`[_`]['token[T]], DB)
    = up(getFlatModule(QI, database(evalModExp(QI, DB))))
    if QI := downQid(T) .
  eq solveUps('`[_`][F[TL]], DB) = '`[_`][F[solveUps(TL, DB)]] [owise] .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Parsing the Bubbles in a Module
***

*** The \texttt{solveBubbles} function defined in the
*** \texttt{UNIT-BUBBLE-PARSING} module takes a term of sort \texttt{Module} (a
*** preunit in fact) and a signature, and returns the unit resulting from the
*** evaluation (parsing) of all the bubbles in it.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

view AttrSet from TRIV to META-LEVEL is
  sort Elt to AttrSet .
endv


fmod UNIT-BUBBLE-PARSING is
  pr BUBBLE-PARSING .
  pr DATABASE .
  pr MOVE-UP .
  pr MOVE-DOWN .
  pr PRINT-SYNTAX-ERROR .

  vars T T' T'' T3 T4 : Term .
  vars T? T?' : [Term] .
  vars TL TL' TL'' : TermList .
  vars TL? TL?' : [TermList] .
  var  B : Bool .
  vars M M' M'' : Module .
  var  DB : Database .
  vars PU U U' : Module .
  var  K : Kind .
  var  KS : KindSet .
  vars S S' : Sort .
  var  SS : SortSet .
  var  VE : ViewExp .
  vars Ty Ty' Tp : Type .
  vars TyL TyL' : TypeList .
  var  At : Attr .
  vars AtS AtS' AtS'' : AttrSet .
  var  NL : IntList .
  var  QI QI' QI'' QI3 QI4 QI5 F L : Qid .
  vars QIL QIL' : QidList .
  var  I : Nat .
  var  Hk : Hook .
  var  HkL : HookList .
  var  MAS : MembAxSet .
  var  Eq : Equation .
  var  EqS : EquationSet .
  var  Rl : Rule .
  var  RlS : RuleSet .
  var  OPD : OpDecl .
  vars OPDS OPDS' OPDS'' VDS : OpDeclSet .
  var  CD? : [Condition] .
  var  Ct : Constant .
  var  RP : [ResultPair] .
  var  St : String .

*** In the parsing of bubbles themselves, we consider three different cases:
*** The case of having one single bubble in which no context is
*** considered (used to parse bubbles in term maps in views and in the
*** special attributes of operators); the case of two bubbles to be parsed in
*** the same connected component (used for bubbles in equations and rules),
*** and the case of one bubble to be parsed in a specific sort (used for the
*** bubbles appearing in the identity element attributes in the declarations
*** of operators, and in membership axioms). These three cases are reduced to
*** the case of one single bubble without context, which is handled by the
*** function \texttt{solveBubbles3}.

  op solveBubblesEq : Term Term Module Bool OpDeclSet Database -> Term .
  op solveBubblesCEq : Term Term Module Bool OpDeclSet Database -> Term .
  op solveBubblesRl : Term Term Module Bool OpDeclSet Database -> Term .
  op solveBubblesCRl : Term Term Module Bool OpDeclSet Database -> Term .
  op solveBubbles2 : Term [Type] Module Bool OpDeclSet Database -> Term .
  op solveBubblesCond : Term Module Module Bool OpDeclSet Database -> [Condition] .

  op conditionError : QidList -> [Condition] [ctor format (r o)] .

*** The case of two bubbles, generated in the case of equations and rules, is
*** reduced to the case with one single bubble using the polymorphic operator
*** \verb~_==_~ and enclosing each of the bubbles in parentheses. Below, we
*** shall see how after calling this function the terms corresponding to each
*** of the bubbles is extracted.

  ceq solveBubblesEq('bubble[T], 'bubble[T'], M, B, VDS, DB)
    = if RP :: ResultPair
      then if B
           then solveUps(constsToVars(getTerm(RP), VDS), DB)
           else constsToVars(getTerm(RP), VDS)
           fi
      else qidError('\r 'Warning:
                 '\o printSyntaxError(RP, '`( QIL '`) '= '`( QIL' '`)) '\n
                 '\r 'Error: '\o 'no 'parse 'for 'eq QIL '\s '= '\s QIL' '\n)
      fi
    if M' := addOps((VDS
                     op '_@@@=@@@_ : 'Universal 'Universal -> '@@@ [poly(1 2)] .),
               addSorts('@@@, M))
       /\ QIL := downQidList(T)
       /\ QIL' := downQidList(T')
       /\ RP := metaParse(M', '`( QIL '`) '@@@=@@@ '`( QIL' '`), '@@@) .

  ceq solveBubblesCEq('bubble[T], 'bubble[T'], M, B, VDS, DB)
    = if RP :: ResultPair
      then if B
           then solveUps(constsToVars(getTerm(RP), VDS), DB)
           else constsToVars(getTerm(RP), VDS)
           fi
      else qidError('\r 'Warning:
                 '\o printSyntaxError(RP, '`( QIL '`) '= '`( QIL' '`)) '\n
                 '\r 'Error: '\o 'no 'parse 'for 'ceq QIL '\s '= '\s QIL' '\n)
      fi
    if M' := addOps((VDS
                     op '_@@@=@@@_ : 'Universal 'Universal -> '@@@ [poly(1 2)] .),
               addSorts('@@@, M))
       /\ QIL := downQidList(T)
       /\ QIL' := downQidList(T')
       /\ RP := metaParse(M', '`( QIL '`) '@@@=@@@ '`( QIL' '`), '@@@) .

  ceq solveBubblesRl('bubble[T], 'bubble[T'], M, B, VDS, DB)
    = if RP :: ResultPair
      then if B
           then solveUps(constsToVars(getTerm(RP), VDS), DB)
           else constsToVars(getTerm(RP), VDS)
           fi
      else qidError('\r 'Warning:
                 '\o printSyntaxError(RP, '`( QIL '`) '=> '`( QIL' '`)) '\n
                 '\r 'Error: '\o 'no 'parse 'for 'rl QIL '\s '=> '\s QIL' '\n)
      fi
    if M' := addOps((VDS
                     op '_@@@=>@@@_ : 'Universal 'Universal -> '@@@ [poly(1 2)] .),
               addSorts('@@@, M))
       /\ QIL := downQidList(T)
       /\ QIL' := downQidList(T')
       /\ RP := metaParse(M', '`( QIL '`) '@@@=>@@@ '`( QIL' '`), '@@@) .
  ceq solveBubblesCRl('bubble[T], 'bubble[T'], M, B, VDS, DB)
    = if RP :: ResultPair
      then if B
           then solveUps(constsToVars(getTerm(RP), VDS), DB)
           else constsToVars(getTerm(RP), VDS)
           fi
      else qidError('\r 'Warning:
                 '\o printSyntaxError(RP, '`( QIL '`) '=> '`( QIL' '`)) '\n
                 '\r 'Error: '\o 'no 'parse 'for 'crl QIL '\s '=> '\s QIL' '\n)
      fi
    if M' := addOps((VDS
                     op '_@@@=>@@@_ : 'Universal 'Universal -> '@@@ [poly(1 2)] .),
               addSorts('@@@, M))
       /\ QIL := downQidList(T)
       /\ QIL' := downQidList(T')
       /\ RP := metaParse(M', '`( QIL '`) '@@@=>@@@ '`( QIL' '`), '@@@) .


  ceq solveBubbles2('bubble[T], T?:Type?, M, true, VDS, DB)
    = if RP :: ResultPair
      then solveUps(constsToVars(getTerm(RP), VDS), DB)
      else qidError('\r 'Warning:
                 '\o printSyntaxError(RP, QIL) '\n
                 '\r 'Error: 'No 'parse 'for QIL '\n)
      fi
    if QIL := downQidList(T)
       /\ RP := metaParse(M, QIL, T?:Type?) .
  ceq solveBubbles2('bubble[T], T?:Type?, M, false, VDS, DB)
    = if RP :: ResultPair
      then constsToVars(getTerm(RP), VDS)
      else qidError('\r 'Warning: '\o printSyntaxError(RP, QIL) '\n
                 '\r 'Error: 'No 'parse 'for QIL '\n)
      fi
    if QIL := downQidList(T)
       /\ RP := metaParse(M, QIL, T?:Type?) .

  op addInfoConds : Module -> [Module] .
  op addInfoConds : Module SortSet -> Module .

  eq addInfoConds(M) = addInfoConds(M, getAllSorts(M)) .

  eq addInfoConds(M, '@Token@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@Bubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, S ; SS)
    = addInfoConds(
        addOps(op qid(string(S)) : nil -> '@Sort@ [ctor] .
               op '_:_ : S '@Sort@ -> '@Condition@ [ctor prec(71)] ., M),
        SS)
    [owise] .
  eq addInfoConds(M, none)
    = addOps(op '_/\_ : '@Condition@ '@Condition@ -> '@Condition@
                               [ctor assoc prec(73)] .
             op '_=_  : 'Universal 'Universal -> '@Condition@
                               [ctor poly(1 2) prec(71)] .
             op '_:=_ : 'Universal 'Universal -> '@Condition@
                               [ctor poly(1 2) prec(71)] .
             op '_=>_ : 'Universal 'Universal -> '@Condition@
                               [ctor poly(1 2) prec(71)] .,
        addSorts('@Condition@ ; '@Sort@,
          if 'Bool in getSorts(M)
          then addSubsorts(subsort 'Bool < '@Condition@ ., M)
          else M
          fi)) .

  ceq solveBubblesCond('bubble[T], M, M', B, VDS, DB)
    = if 'Bool in getSorts(M)
         and-then metaParse(M, QIL, 'Bool) :: ResultPair
      then if B
           then solveUps(constsToVars(getTerm(metaParse(M, QIL, 'Bool)), VDS), DB)
                = 'true.Bool
           else constsToVars(getTerm(metaParse(M, QIL, 'Bool)), VDS)
                = 'true.Bool
           fi
      else if metaParse(M', QIL, '@Condition@) :: ResultPair
           then if B
                then solveUpsCondition(
                       parseCond(getTerm(metaParse(M', QIL, '@Condition@)), VDS), DB)
                else parseCond(getTerm(metaParse(M', QIL, '@Condition@)), VDS)
                fi
           else conditionError('\r 'Warning: '\o
                  printSyntaxError(metaParse(M', QIL, '@Condition@), QIL) '\n)
           fi
      fi
    if QIL := downQidList(T) .

  op parseCond : Term OpDeclSet -> Condition .

  eq parseCond('_/\_[T, T'], VDS) = parseCond(T, VDS) /\ parseCond(T', VDS) .
  eq parseCond('_=_[T, T'], VDS)
    = constsToVars(T, VDS) = constsToVars(T', VDS) .
  eq parseCond('_:_[T, T'], VDS) = constsToVars(T, VDS) : getName(T') .
  eq parseCond('_:=_[T, T'], VDS)
    = constsToVars(T, VDS) := constsToVars(T', VDS) .
  eq parseCond('_=>_[T, T'], VDS)
    = constsToVars(T, VDS) => constsToVars(T', VDS) .
  eq parseCond(T, VDS) = constsToVars(T, VDS) = 'true.Bool [owise] .

*** Since bubbles can only appear in the identity or special attributes in the
*** declaration of operators, in equations, membership axioms, and rules, the
*** evaluation of bubbles on a preunit is reduced to calls to the
*** \texttt{solveBubbles} functions on each of these sTS of declarations.

  op solveBubblesMod : Module OpDeclSet Module Bool OpDeclSet Database -> Module .

  op solveBubbles : EquationSet Module [Module] Bool OpDeclSet Database -> EquationSet .
  op solveBubbles : RuleSet Module [Module] Bool OpDeclSet Database -> RuleSet .
  op solveBubbles : MembAxSet Module [Module] Bool OpDeclSet Database -> MembAxSet .
  op solveBubbles : Condition Module Bool OpDeclSet Database -> Condition .
  op solveBubblesOps : OpDeclSet OpDeclSet Module Module -> OpDeclSet .
  op solveBubblesOps : OpDeclSet OpDeclSet Module -> OpDeclSet .
  op solveBubblesOpsAux : OpDeclSet Module -> OpDeclSet .
  op solveBubblesAts : AttrSet TypeList Type Module -> AttrSet .
  op solveBubblesHooks : HookList Type Module -> HookList .

  ceq solveBubblesMod(PU, OPDS, M, B, VDS, DB)
    = setOps(
       (if getMbs(PU) == none and getEqs(PU) == none and getRls(PU) == none
        then PU
        else setEqs(
               setMbs(
                 setRls(PU,
                   solveBubbles(getRls(PU), M', addInfoConds(M'), B, VDS, DB)),
                 solveBubbles(getMbs(PU), M', addInfoConds(M'), B, VDS, DB)),
               solveBubbles(getEqs(PU), M', addInfoConds(M'), B, VDS, DB))
        fi),
       solveBubblesOps(getOps(PU), OPDS, M'))
    if M' := addOps(VDS, M) .

*** To avoid the parsing ambiguities in the identity elements we add the sort
*** of the operator to be used as context in which doing the parsing. We
*** assume that the term given as identity element of an operator is in the
*** kind of the sort of such operator.

  eq solveBubblesOps(OPDS, OPDS', M)
    = solveBubblesOps(OPDS, OPDS',
        setSubsorts(
          setSorts(emptyFModule('DUMMY), getSorts(M)), getSubsorts(M)), M) .

  ceq solveBubblesOps(op F : TyL -> Ty [ditto AtS] . op F : TyL' -> Ty' [AtS'] . OPDS, OPDS', M, M')
    = solveBubblesOps(
        op F : TyL -> Ty [AtS removeCtorMetadata(AtS'')] . op F : TyL' -> Ty' [AtS''] . OPDS,
        OPDS', M, M')
    if not ditto in AtS'
    /\ sameKind(M, TyL Ty, TyL' Ty')
----    /\ AtS'' := solveBubblesAts(AtS', TyL', Ty', M') .
    /\ AtS'' := AtS' .
  ceq solveBubblesOps(op F : TyL -> Ty [ditto AtS] . OPDS, op F : TyL' -> Ty' [AtS'] . OPDS', M, M')
    = solveBubblesOps(op F : TyL -> Ty [AtS removeCtorMetadata(AtS'')] . OPDS, op F : TyL' -> Ty' [AtS''] . OPDS', M, M')
    if not ditto in AtS'
    /\ sameKind(M, TyL Ty, TyL' Ty')
----       /\ AtS'' := solveBubblesAts(AtS', TyL, Ty, M')
    /\ AtS'' := AtS' .
----    [owise] .
  eq solveBubblesOps(OPDS, OPDS', M, M')
    = solveBubblesOpsAux(OPDS, M')
    [owise] .

  op removeCtorMetadata : AttrSet -> AttrSet .
  eq removeCtorMetadata(ctor AtS) = removeCtorMetadata(AtS) .
  eq removeCtorMetadata(metadata(St) AtS) = removeCtorMetadata(AtS) .
  eq removeCtorMetadata(AtS) = AtS [owise] .

  eq solveBubblesOpsAux(op F : TyL -> Ty [AtS] . OPDS, M)
    = op F : TyL -> Ty [solveBubblesAts(AtS, TyL, Ty, M)] .
      solveBubblesOpsAux(OPDS, M) .
  eq solveBubblesOpsAux(none, M) = none .

  eq solveBubblesAts(id('bubble[T]) AtS, TyL, Ty, M)
    = (id(solveBubbles2('bubble[T], Ty, M, false, none, emptyDatabase))
       solveBubblesAts(AtS, TyL, Ty, M)) .
  eq solveBubblesAts(left-id('bubble[T]) AtS, Ty TyL, Ty', M)
    = (left-id(solveBubbles2('bubble[T], Ty, M, false, none, emptyDatabase))
       solveBubblesAts(AtS, Ty TyL, Ty', M)) .
  eq solveBubblesAts(right-id('bubble[T]) AtS, TyL Ty, Ty', M)
    = (right-id(solveBubbles2('bubble[T], Ty, M, false, none, emptyDatabase))
       solveBubblesAts(AtS, TyL Ty, Ty', M)) .
  eq solveBubblesAts(special(HkL) AtS, TyL, Ty, M)
    = (special(solveBubblesHooks(HkL, Ty, M))
       solveBubblesAts(AtS, TyL, Ty, M)) .
  eq solveBubblesAts(AtS, TyL, Ty, M) = AtS [owise] .

  eq solveBubblesHooks(term-hook(QI, 'bubble[T]) HkL, Ty, M)
    = term-hook(QI,
        solveBubbles2('bubble[T], anyType, M, false, none, emptyDatabase))
      solveBubblesHooks(HkL, Ty, M) .
  eq solveBubblesHooks(Hk HkL, Ty, M)
    = Hk solveBubblesHooks(HkL, Ty, M)
    [owise] .
  eq solveBubblesHooks(nil, Ty, M) = nil .

*** Since both sides of any equation or rule have to be in the same connected
*** component of sorts, we parse the two bubbles together using the
*** polymorphic operator \verb~_==_~\footnote{Note that if including
*** \texttt{BOOL} the operator \texttt{\_\,==\_\,} is added for each kind.}.
*** That is, given for example an equation as \verb~eq T = T' .~, we parse
*** \verb~T == T'~, forcing them to be parsed in the same connected component,
*** if possible. We add functions \texttt{lhs} and \texttt{rhs} to extract,
*** respectively, the lefthand and righthand side terms from the result. Note
*** that these are partial functions.

  pr 2TUPLE{Term,AttrSet}
       * (op p1_ to term, op p2_ to attrSet,
          op `(_`,_`) : Term AttrSet -> Tuple{Term,AttrSet} to `{_`,_`}) .

  op pullStmtAttrOut : Term OpDeclSet -> [Tuple{Term,AttrSet}] .
  op pullStmtAttrOutAux : Term TermList AttrSet OpDeclSet -> [Tuple{Term,AttrSet}] .
  op pullLabelOut : Term -> [Tuple{Term,AttrSet}] .

  eq pullStmtAttrOut('bubble[QI], VDS) = {'bubble[QI], none} .
  eq pullStmtAttrOut('bubble['__[QI, QI']], VDS) = {'bubble['__[QI, QI']], none} .
  eq pullStmtAttrOut('bubble['__[QI, QI', QI'']], VDS)
    = {'bubble['__[QI, QI', QI'']], none} .
  eq pullStmtAttrOut('bubble['__[QI, QI', TL, QI'']], VDS)
    = if QI'' =/= ''`].Qid
      then {'bubble['__[QI, QI', TL, QI'']], none}
      else pullStmtAttrOutAux('bubble['__[QI, QI', TL, QI'']], (QI, QI', TL), none, VDS)
      fi .

  eq pullStmtAttrOutAux(T, (TL, ''`[.Qid), AtS, VDS)
    = if AtS =/= none
      then {'bubble['__[TL]], AtS}
      else {T, none}
      fi .
  eq pullStmtAttrOutAux(T, (TL, QI, ''nonexec.Qid), AtS, VDS)
    = pullStmtAttrOutAux(T, (TL, QI), AtS nonexec, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''variant.Qid), AtS, VDS)
    = pullStmtAttrOutAux(T, (TL, QI), AtS variant, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''owise.Qid), AtS, VDS)
    = pullStmtAttrOutAux(T, (TL, QI), AtS owise, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''otherwise.Qid), AtS, VDS)
    = pullStmtAttrOutAux(T, (TL, QI), AtS owise, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''label.Qid, QI'), AtS, VDS)
    = if downQid(QI') :: Qid
      then pullStmtAttrOutAux(T, (TL, QI), AtS label(downQid(QI')), VDS)
      else {T, none}
      fi .
  eq pullStmtAttrOutAux(T, (TL, QI, ''metadata.Qid, QI'), AtS, VDS)
    = if downString(downQid(QI')) :: String
      then pullStmtAttrOutAux(T, (TL, QI), AtS metadata(downString(downQid(QI'))), VDS)
      else {T, none}
      fi .
  ceq pullStmtAttrOutAux(T, (TL, QI, ''`[.Qid, TL',  ''print.Qid, TL''), AtS, VDS)
    = pullStmtAttrOutAux(T, (TL, QI, ''`[.Qid, TL'), AtS print(printArg(TL'', VDS)), VDS)
    if printArg(TL'', VDS) : QidList .
  eq pullStmtAttrOutAux(T, TL, AtS, VDS) = {T, none} [owise] .

  op printArg : TermList OpDeclSet ~> QidList .
  ceq printArg((T, TL), op QI : nil -> Tp [AtS] . VDS)
    = qid(string(downQid(T)) + ":" + string(Tp)) printArg(TL, VDS)
    if QI = downQid(T) .
  ceq printArg((T, TL), VDS)
    = downQid(T) printArg(TL, VDS)
    if downString(downQid(T)) : String .
  eq printArg(empty, VDS) = nil .

  eq pullLabelOut('bubble[QI]) = {'bubble[QI], none} .
  eq pullLabelOut('bubble['__[QI, QI']]) = {'bubble['__[QI, QI']], none} .
  eq pullLabelOut('bubble['__[QI, QI', QI'']])
    = {'bubble['__[QI, QI', QI'']], none} .
  eq pullLabelOut('bubble['__[QI, QI', QI'', QI3]])
    = {'bubble['__[QI, QI', QI'', QI3]], none} .
  eq pullLabelOut('bubble['__[QI, QI', QI'', QI3, TL]])
    = if QI == ''`[.Qid and-then (QI'' == ''`].Qid and-then QI3 == '':.Qid)
      then {'bubble['__[TL]], label(downQid(QI'))}
      else {'bubble['__[QI, QI', QI'', QI3, TL]], none}
      fi .

  ops lhs rhs : Term -> Term .
  eq lhs(F[T, T']) = T .
  eq lhs(F[T, T']) = T .
  eq rhs(F[T, T']) = T' .
  eq rhs(F[T, T']) = T' .
  eq lhs(qidError(QIL)) = qidError(QIL) .
  eq rhs(qidError(QIL)) = qidError(QIL) .

  eq solveBubbles(EqS, M, unitError(QIL), B, VDS, DB) = equationError(QIL) .
  eq solveBubbles(RlS, M, unitError(QIL), B, VDS, DB) = ruleError(QIL) .
  eq solveBubbles(MAS, M, unitError(QIL), B, VDS, DB) = membAxError(QIL) .

  eq solveBubbles(((eq T = T' [AtS] .) EqS), M, M', B, VDS, DB)
    = ((eq lhs(solveBubblesEq(term(pullLabelOut(T)), term(pullStmtAttrOut(T', VDS)),
                 M, B, VDS, DB))
          = rhs(solveBubblesEq(term(pullLabelOut(T)), term(pullStmtAttrOut(T', VDS)),
                  M, B, VDS, DB))
            [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T', VDS)) AtS] .)
       solveBubbles(EqS, M, M', B, VDS, DB)) .
  eq solveBubbles(((ceq T = T' if T'' = 'true.Bool [AtS] .) EqS),
       M, M', B, VDS, DB)
    = ((ceq lhs(solveBubblesCEq(term(pullLabelOut(T)), T', M, B, VDS, DB))
          = rhs(solveBubblesCEq(term(pullLabelOut(T)), T', M, B, VDS, DB))
          if solveBubblesCond(term(pullStmtAttrOut(T'', VDS)), M, M', B, VDS, DB)
          [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T'', VDS)) AtS] .)
       solveBubbles(EqS, M, M', B, VDS, DB)) .
  eq solveBubbles((none).EquationSet, M, M', B, VDS, DB) = none .

  eq solveBubbles(((rl T => T' [AtS] .) RlS), M, M', B, VDS, DB)
    = ((rl lhs(solveBubblesRl(term(pullLabelOut(T)),
                 term(pullStmtAttrOut(T', VDS)), M, B, VDS, DB))
        => rhs(solveBubblesRl(term(pullLabelOut(T)),
                 term(pullStmtAttrOut(T', VDS)), M, B, VDS, DB))
             [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T', VDS)) AtS] .)
       solveBubbles(RlS, M, M', B, VDS, DB)) .
  eq solveBubbles(
       ((crl T => T' if T'' = 'true.Bool [AtS] .) RlS), M, M', B, VDS, DB)
    = ((crl lhs(solveBubblesCRl(term(pullLabelOut(T)), T', M, B, VDS, DB))
          => rhs(solveBubblesCRl(term(pullLabelOut(T)), T', M, B, VDS, DB))
          if solveBubblesCond(term(pullStmtAttrOut(T'', VDS)), M, M', B, VDS, DB)
          [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T'', VDS)) AtS] .)
       solveBubbles(RlS, M, M', B, VDS, DB)) .
  eq solveBubbles((none).RuleSet, M, M', B, VDS, DB) = none .

*** In the call to solve the bubbles in membership axioms we add the sort to
*** which it is constrained to be used as context.

  eq solveBubbles(((mb T : S [AtS] .) MAS), M, M', B, VDS, DB)
    = ((mb solveBubbles2(term(pullLabelOut(T)), S, M, B, VDS, DB) : S
           [attrSet(pullLabelOut(T)) AtS] .)
       solveBubbles(MAS, M, M', B, VDS, DB)) .
  eq solveBubbles(((cmb T : S if T' = 'true.Bool [AtS] .) MAS),
       M, M', B, VDS, DB)
    = ((cmb solveBubbles2(term(pullLabelOut(T)), S, M, B, VDS, DB) : S
          if solveBubblesCond(T', M, M', B, VDS, DB)
          [attrSet(pullLabelOut(T)) AtS] .)
       solveBubbles(MAS, M, M', B, VDS, DB)) .
  eq solveBubbles((none).MembAxSet, M, M', B, VDS, DB) = none .

*** The parsing process may generate error terms. Since in the
*** current version of the system Core Maude is generating the appropriate
*** error messages, we just have to worry about the elimination of these
*** terms. The effect is the same one as introducing a module at the object
*** level of Core Maude: If there is any term in an identity attribute in an
*** operator declaration, equation, rule, or membership axiom with a parsing
*** error a message is generated and the axiom is eliminated.

  eq (op F : TyL -> Ty [id(qidError(QIL)) AtS] .) = opDeclError(QIL) .
  eq (op F : TyL -> Ty [left-id(qidError(QIL)) AtS] .) = opDeclError(QIL) .
  eq (op F : TyL -> Ty [right-id(qidError(QIL)) AtS] .) = opDeclError(QIL) .

  eq (conditionError(QIL) /\ T = T' /\ CD?) = conditionError(QIL) .
  eq (conditionError(QIL) /\ T : S /\ CD?) = conditionError(QIL) .
  eq (conditionError(QIL) /\ T := T' /\ CD?) = conditionError(QIL) .
  eq (conditionError(QIL) /\ T => T' /\ CD?) = conditionError(QIL) .

  eq (eq qidError(QIL) = T? [AtS] .) = equationError(QIL) .
  eq (eq T? = qidError(QIL) [AtS] .) = equationError(QIL) .
  eq (ceq qidError(QIL) = T? if CD? [AtS] .) = equationError(QIL) .
  eq (ceq T? = qidError(QIL) if CD? [AtS] .) = equationError(QIL) .
  eq (ceq T? = T?' if conditionError(QIL) [AtS] .) = equationError(QIL) .

  eq (mb qidError(QIL) : S [AtS] .) = membAxError(QIL) .
  eq (cmb qidError(QIL) : S if CD? [AtS] .) = membAxError(QIL) .
  eq (cmb T? : S if conditionError(QIL) [AtS] .) = membAxError(QIL) .

  eq (rl qidError(QIL) => T? [AtS] .) = ruleError(QIL) .
  eq (rl T? => qidError(QIL) [AtS] .) = ruleError(QIL) .
  eq (crl qidError(QIL) => T? if CD? [AtS] .) = ruleError(QIL) .
  eq (crl T? => qidError(QIL) if CD? [AtS] .) = ruleError(QIL) .
  eq (crl T? => T?' if conditionError(QIL) [AtS] .) = ruleError(QIL) .

  eq F[qidError(QIL), TL?] = qidError(QIL) .
  eq F[TL?, qidError(QIL)] = qidError(QIL) .
  eq F[TL?, qidError(QIL), TL?'] = qidError(QIL) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** The function \texttt{solveBubbles} defined in the following
*** \texttt{VIEW-BUBBLE-PARSING} module parses the bubbles in a set of preview
*** maps. It takes two modules, the signature of the view's source theory,
*** with the variables declared in the view, to parse the source term in the
*** term maps, and the target theory, with the mappings of the variable
*** declarations in the view, to parse the target terms.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod VIEW-BUBBLE-PARSING is
  pr BUBBLE-PARSING .
  pr PRE-VIEW .

  var  OMS : OpMappingSet .
  vars T T' : Term .
  vars M M' : Module .
  var  U : Module .
  var  QIL : QidList .
  vars VDS VDS' : OpDeclSet .

  op solveBubbles : OpMappingSet OpDeclSet OpDeclSet Module Module -> OpMappingSet .

  eq solveBubbles(OMS, VDS, VDS', U, unitError(QIL)) = none .
  eq solveBubbles(OMS, VDS, VDS', unitError(QIL), U) = none .
  eq solveBubbles(OMS, VDS, VDS', M, M') = OMS [owise] .
  eq solveBubbles((op_to`term_.(T, T') OMS), VDS, VDS', M, M')
    = (op_to`term_.(
         solveBubbles(T, M, false, VDS, emptyDatabase),
         solveBubbles(T', M', false, VDS', emptyDatabase))
      solveBubbles(OMS, VDS, VDS', M, M')) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Module Expression Evaluation
***

*** So far we have not introduced more module expressions than those given by
*** simple quoted identifiers. We will introduce some later, but the scheme
*** followed for evaluating them is very simple and can be presented in a
*** generic way. Given a module expression and a database state, the
*** evaluation of a module expression results in the generation of a new
*** module, which is introduced in the database, with the module expression
*** as its name. The resulting database is then returned. If there is already
*** a module in the database with that name, the function returns the original
*** database without any change. The evaluation of a module expression may
*** produce the evaluation of other module expressions contained in the
*** modules involved in the process. This is the case, for example, for the
*** renaming of modules, in which not only the top module is renamed but,
*** perhaps, some of its submodules as well; it is also the case for the
*** instantiation of parameterized modules, where the module being
*** instantiated may contain submodules which are parameterized by some of
*** the parameter theories of the parameterized module in which are imported.
*** We shall discuss in more detail the renaming and instantiation of module
*** expressions in Sections~\ref{renaming} and~\ref{instantiation},
*** respectively.

*** We saw in Section~\ref{module-expressions} how it is possible to import a
*** module expression in which a parameterized module is instantiated by some
*** of the formal parameters of the parameterized module into which it is
*** imported. To be able to evaluate this kind of module expression, the list
*** of parameters of the module in which the module expression appears has to
*** be given.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-EXPR-EVAL is
  pr DATABASE .

  *** decl. moved to module DATABASE
  *** op evalModExp : ModuleExpression Database -> Database .
  op evalModExp : ModuleExpression ParameterDeclList Database -> Tuple{Database, ModuleExpression} .
  op evalViewExp : ViewExp ParameterDeclList Database -> Database .
  op evalViewExp : ParameterList ParameterDeclList Database -> Database .

  var  S : Sort .
  var  QI : Qid .
  var  ME : ModuleExpression .
  var  PDL : ParameterDeclList .
  var  DB : Database .
  vars VE VE' VE'' : ViewExp .
  vars PL PL' : ParameterList .

  eq evalModExp(ME, DB) = evalModExp(ME, nil, DB) .

  eq evalModExp(ME, PDL, DB) = < DB ; ME > [owise] .

  eq evalModExp(QI, PDL, DB)
    = if unitInDb(QI, DB)
      then if compiledModule(QI, DB)
           then < DB ; QI >
           else < procModule(QI, DB) ; QI >
           fi
      else if upModule(QI, false) :: Module
           then < procModule(QI, insTermModule(QI, upModule(QI, false), DB)) ; QI >
           else < warning(DB, '\r 'Error: '\o 'Module QI 'not 'in 'database. '\n) ; QI >
           fi
      fi .

  eq evalViewExp(QI, PDL, DB)
    = if labelInParameterDeclList(QI, PDL)
      then DB
      else if viewInDb(QI, DB)
           then if compiledView(QI, DB)
                then DB
                else procView(QI, DB)
                fi
           else if upView(QI) :: View
                then procView(upView(QI), DB)
                else warning(DB, ('\r 'Error: '\o 'View QI 'not 'in 'database. '\n))
                fi
           fi
      fi .
  eq evalViewExp(S{PL}, PDL, DB)
    = if viewInDb(S{PL}, DB)
      then DB
      else viewInst(S, PL, PDL, evalViewExp(S, PDL, evalViewExp(PL, PDL, DB)))
      fi .
  ceq evalViewExp(VE ;; VE', PDL, DB)
    = evalViewExp(VE, PDL, evalViewExp(VE', PDL, DB))
    if VE =/= mtViewExp /\ VE' =/= mtViewExp .
  eq evalViewExp((S, PL), PDL, DB)
    = evalViewExp(S, PDL, evalViewExp(PL, PDL, DB))
    [owise] .
  eq evalViewExp((S{PL}, PL'), PDL, DB)
    = evalViewExp(S{PL}, PDL, evalViewExp(PL', PDL, DB))
    [owise] .
  eq evalViewExp(nil, PDL, DB) = DB .

  op viewInst : ViewExp ViewExp ParameterDeclList Database -> Database .

*******************************************************************************
*** The equations specifying its behavior are later, in INST-EXPR-EVALUATION **
*******************************************************************************

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Transformation of Object-Oriented Modules to System Modules
***

*** The transformation of object-oriented modules into system modules has
*** already been discussed in Section~\ref{omod2mod}, and also in
*** \cite{Meseguer93b,ClavelDuranEkerLincolnMarti-OlietMeseguerQuesada99}.
*** We focus here on the part of the process accomplished by each of the main

*** functions involved in the transformation. The transformation discussed
*** in~\cite{DuranMeseguer98} assumed that object-oriented modules were
*** flattened before being transformed into system modules. However, doing it
*** in this way, the transformations already made for the modules in the
*** structure were not reused. In the current system, the transformation is
*** done only for the module being introduced, the top of the structure, and
*** dusing the `internal' representations of the submodules stored in the
*** ddatabase for the rest of the structure.

*** This approach requires gathering all class and subclass relation
*** declarations in the structure before starting with the transformation
*** process itself. The function \texttt{prepClasses} collects all these
*** declarations in the structure, and completes all the declarations of
*** classes with the attributes inherited from their superclasses.
*** \begin{comment}
*** This function makes use of a `dummy' module, in which the classes are
*** introduced as sorts and the subclass relations as subsort relations to be
*** able to compute all the operations on the subclass relation using the
*** built-in functions on sorts.
*** \end{comment}

*** Once all the class declarations in the structure have been collected and
*** completed, the transformation is accomplished in two stages. First, the
*** function \texttt{omod2modAux} carries out the
*** following tasks:
*** \begin{itemize}
*** \item For each class declaration of the form
***       $\texttt{class }C\texttt{ | }a_1\texttt{:} S_1\texttt{,}
***       \ldots\texttt{,} a_n\texttt{:} S_n$, the following items are
***       introduced: a subsort $C$ of sort \texttt{Cid}, a constant
***       $C$ of sort $C$, and declarations of operations $a_i
***       \texttt{\ :\_} \texttt{ :\,\,} S_i \texttt{ -> Attribute}$
***       for each attribute $a_i$ (the function
***       \texttt{ops4Attr} creates these declarations).
*** \item For each subclass relation of the form
***       $\texttt{subclass\ }C\texttt{\ <\ }C'$, a subsort
***       declaration $\texttt{subsort\ }C\texttt{\ <\ }C'$ is
***       introduced.
*** \item For each message declaration of the form \verb~msg F : TyL
***       -> S~, an operator declaration \verb~op F : TyL -> S~ is added.
*** \end{itemize}
*** When this process has been completed, the function \texttt{prepAxs} is
***  called.  This function applies to the membership axioms, equations, and
*** rewriting rules in the module the transformations indicated in
*** Section~\ref{omod2mod}, so that they become applicable to all the objects
*** of the given class and of their subclasses. The set of attributes of the
*** objects appearing in the membership axioms, equations, and rewriting rules
*** are completed, so that the default convention of not having to
*** exhaustively mention the set of attributes of a class is supported.

*** Note that in Meseguer's paper~\cite{Meseguer93b} a parallel hierarchy of
*** sorts was defined to deal with objects in different classes, and membership
*** axioms constraining the objects to their corresponding sorts were added.
*** The transformation could be easily completed with sorts, subsort relations,
*** and membership constraints as indicated there. In fact, these declarations
*** were added in an initial version and were then removed because they were
*** computationally expensive. However, there are examples in which it would
*** be interesting to have them; when needed, these declarations can be
*** explicitly added by the user in the current version.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod EXT-TERMSET is
  protecting TERMSET .
  op |_| : TermSet -> Nat .
  eq | X:Term | T:TermSet | = 1 + | T:TermSet | .
  eq | emptyTermSet | = 0 .
endfm

view TermSet from TRIV to EXT-TERMSET is
  sort Elt to TermSet .
endv

fmod O-O-TO-SYSTEM-MOD-TRANSF is
  pr DATABASE .
  pr CONVERSION .
  pr EXT-TERMSET .

  var  DB : Database .
  var  I : Nat .
  var  ME : Header .
  vars S S' S'' C C' : Sort .
  vars SS SS' SS'' : SortSet .
  var  Ty : Type .
  var  TyL : TypeList .
  vars T T' T'' T3 : Term .
  vars TL TL' : TermList .
  var  PL : ParameterList .
  vars IL IL' IL'' : ImportList .
  vars CDS CDS' : ClassDeclSet .
  vars ADS ADS' : AttrDeclSet .
  var  SSDS : SubsortDeclSet .
  vars SCDS SCDS' : SubclassDeclSet .
  var  OPDS : OpDeclSet .
  var  MDS : MsgDeclSet .
  vars MAS MAS' : MembAxSet .
  vars EqS EqS' : EquationSet .
  vars RlS RlS' : RuleSet .
  var  QIL : QidList .
  var  NQIL : NeQidList .
  vars O O' : Term .
  vars M U : Module .
  vars QI A A' L F : Qid .
  var  V V' : Variable .
  var  CD : ClassDecl .
  vars SCD SCD' : SubclassDecl .
  vars Ct Ct' Ct'' : Constant .
  var  Cond : Condition .
  var  AtS : AttrSet .
  var  H : Header .
  var  PD : ParameterDecl .
  var  PDL : ParameterDeclList .
  var  MN : ModuleName .
  var  CH : ClassHierarchy .
  var  C'' : Sort .
  vars TS TS' : TermSet .


  op newVar : Sort Nat -> Variable .
  eq newVar(S, I) = qid("V#" + string(I, 10) + ":" + string(S)) .

*** The function \texttt{prepClasses} completes all classes in the module with
*** all the attributes they inherit from their superclasses.

  op prepClasses : ClassDeclSet SubclassDeclSet ImportList ParameterDeclList
       Database -> ClassDeclSet .
  op prepClasses2 : ClassDeclSet SubclassDeclSet ImportList
       ImportList Database -> ClassDeclSet .
  op prepClasses3 : ClassDeclSet SubclassDeclSet -> ClassDeclSet .

  eq prepClasses(CDS, SCDS, IL, (PD, PDL), DB)
    = prepClasses(CDS, SCDS, (IL protecting pd(PD) .), PDL, DB) .
  eq prepClasses(CDS, SCDS, IL, nil, DB)
    = prepClasses2(CDS, SCDS, IL, nil, DB) .

  eq prepClasses2(CDS, SCDS, ((including MN .) IL), IL', DB)
    = if (including MN . ) in IL'
      then prepClasses2(CDS, SCDS, IL, IL', DB)
      else prepClasses2(
             (getClasses(getTopModule(MN, DB)) CDS),
             (getSubclasses(getTopModule(MN, DB)) SCDS),
             (getImports(getTopModule(MN, DB)) IL),
             ((including MN .) IL'), DB)
      fi .
  eq prepClasses2(CDS, SCDS, ((extending MN .) IL), IL', DB)
    = if (extending MN . ) in IL'
      then prepClasses2(CDS, SCDS, IL, IL', DB)
      else prepClasses2(
             (getClasses(getTopModule(MN, DB)) CDS),
             (getSubclasses(getTopModule(MN, DB)) SCDS),
             (getImports(getTopModule(MN, DB)) IL),
             ((extending MN .) IL'), DB)
      fi .
  eq prepClasses2(CDS, SCDS, ((protecting MN .) IL), IL', DB)
    = if (protecting MN . ) in IL'
      then prepClasses2(CDS, SCDS, IL, IL', DB)
      else prepClasses2(
             (getClasses(getTopModule(MN, DB)) CDS),
             (getSubclasses(getTopModule(MN, DB)) SCDS),
             (getImports(getTopModule(MN, DB)) IL),
             ((protecting MN .) IL'), DB)
      fi .
  eq prepClasses2(CDS, SCDS, nil, IL, DB) = prepClasses3(CDS, SCDS) .

  eq prepClasses3(CDS, SCDS)
    = addAttrs(buildHierarchy(CDS, SCDS, none, empty), SCDS) .

  sort ClassHierarchy ClassStruct .
  subsort ClassStruct < ClassHierarchy .

  op [_,_] : ClassDecl SortSet -> ClassStruct .

  op empty : -> ClassHierarchy .
  op __ : ClassHierarchy ClassHierarchy -> ClassHierarchy
       [assoc comm id: empty] .

  op buildHierarchy :
       ClassDeclSet SubclassDeclSet SortSet ClassHierarchy -> ClassHierarchy .
  op addAttrs : ClassHierarchy SubclassDeclSet -> ClassDeclSet .
  op addAttrsToItsSons :
       ClassDecl ClassHierarchy SubclassDeclSet -> ClassHierarchy .

  eq buildHierarchy(((class C | ADS .) CDS), SCDS, SS, CH)
    = if C in SS
      then buildHierarchy(CDS, SCDS, SS, CH)
      else buildHierarchy(CDS, SCDS, C ; SS, [(class C | ADS .), none] CH)
      fi .
  eq buildHierarchy(none, (subclass C < C' .) SCDS, SS,
       [(class C | ADS .), SS'] [(class C' | ADS' .), SS''] CH)
    = buildHierarchy(none, SCDS, SS,
        [(class C | ADS .), C' ; SS'] [(class C' | ADS' .), SS''] CH) .
  eq buildHierarchy(none, none, SS, CH) = CH .

  eq addAttrs([(class C | ADS .), none] CH, SCDS)
    = (class C | ADS .)
      addAttrs(addAttrsToItsSons((class C | ADS .), CH, SCDS), SCDS) .
  eq addAttrs(empty, SCDS) = none .

  eq addAttrsToItsSons((class C | ADS .), [(class C' | ADS' .), C ; SS] CH,
       (subclass C' < C .) SCDS)
    = addAttrsToItsSons((class C | ADS .), [(class C' | ADS, ADS' .), SS] CH,
        SCDS) .
  ceq addAttrsToItsSons((class C | ADS .), CH, (subclass C' < C'' .) SCDS)
    = addAttrsToItsSons((class C | ADS .), CH, SCDS)
    if C =/= C'' .
  eq addAttrsToItsSons((class C | ADS .), CH, none) = CH .

----  op inAttrDeclSet : Qid AttrDeclSet -> Bool .
----
----  eq inAttrDeclSet(A, ((attr A' : S), ADS))
----    = (A == A') or-else inAttrDeclSet(A, ADS) .
----  eq inAttrDeclSet(A, none) = false .

*** Given a set of attribute declarations, the \texttt{ops4Attr}
*** function returns a set of operator declarations as indicated above. That
*** is, for each attribute $a\texttt{:} S$, an operator of the form
*** $a \texttt{\ :\_} \texttt{ :\,\,} S \texttt{ -> Attribute}$ is declared.

  op ops4Attr : AttrDeclSet -> OpDeclSet .

  eq ops4Attr(((attr A : S), ADS))
    = ((op qid(string(A) + "`:_") : S -> 'Attribute [gather('&)] .)
       ops4Attr(ADS)) .
  eq ops4Attr(none) = none .

*** The function \texttt{prepLHS} takes the term in the lefthand side of a
*** rule, equation, or membership axiom, and replaces each object
***
***   $\texttt{<\ }O\texttt{\ :\ }C\texttt{\ |\ }ADS\texttt{\ >}$
***
*** in it---with $O$ of sort \texttt{Oid}, $C$ the name of a class, and $ADS$
*** a set of attributes with their corresponding values---by an object
***
***   $\texttt{<\ }O\texttt{\ :\ }V\texttt{\ |\ }ADS\ ADS'\ Atts\texttt{\ >}$
***
*** where the identifier of the class is replaced by a variable $V$ of sort
*** $C$, which is not used in the axiom, and where the set of attributes is
*** completed with attributes $ADS'$ as indicated in Section~\ref{omod2mod}, so
*** that each attribute declared in class $C$ or in any of its superclasses is
*** added with a new variable as value. $Atts$ is a new variable of sort
*** \texttt{AttributeSet}, which is used to range over the additional
*** attributes that may appear in objects of a subclass.

*** The function \texttt{prepLHS} takes as arguments a term (in the initial
*** call, the term in the lefthand side of a rule, equation, or membership
*** axiom), the set of variable declarations of those variables declared in the
*** module that are not used in the axiom---new variables are created only if
*** there are no variables in the module with the appropriate sort---the set of
*** attributes in the* occurrences of the objects---and an index---to make sure
*** that the variables being added have not occurrences of the objects---and an
*** index---to make sure that the variables being added have not been added
*** previously. In the initial call this index is set to zero. \texttt{prepLHS}
*** gives as result a tuple composed of the resulting term, the set of objects
*** in the term (so that the modification of the objects in the righthand side
*** of the rule is simplified), the set of variable declarations corresponding
*** to the new added variables, the set of variable declarations of the
*** variables in the module that have not been used, and the index for the
*** creation of new variables.

*** change (03/20/2002): a new variable is created everytime one is needed

*** The set of objects in the lefthand side will be given as a set of terms.

  pr 4TUPLE{TermList, TermSet, Nat, QidList}
       * (op p1_ to term, op p2_ to objects, op p3_ to index, op p4_ to messages,
          op ((_,_,_,_)) : TermList TermSet Nat QidList -> Tuple{TermList,TermSet,Nat,QidList} to <_;_;_;_>) .

  op prepLHS : TermList ClassDeclSet Nat -> Tuple{TermList, TermSet, Nat, QidList} .

  op crtObject : Term Sort AttrDeclSet Tuple{TermList, TermSet, Nat, QidList} -> Tuple{TermList, TermSet, Nat, QidList} .
  op crtObject2 : Term Variable TermList TermList AttrDeclSet TermSet Nat QidList -> Tuple{TermList, TermSet, Nat, QidList} .
  op crtObject3 : Term Qid TermList AttrDeclSet TermSet Nat QidList -> Tuple{TermList, TermSet, Nat, QidList} .

  eq prepLHS(qidError(QIL), CDS, I) = < qidError(QIL) ; emptyTermSet ; I ; nil > .
  eq prepLHS(F, CDS, I) = < F ; emptyTermSet ; I ; nil > .
  eq prepLHS(Ct, CDS, I) = < Ct ; emptyTermSet ; I ; nil > .

*** \texttt{prepLHS} on a list of terms $\texttt{(}T\texttt{,\ }TL\texttt{)}$,
*** with $T$ a term and $TL$ a list of terms, has to make a call to itself with
*** $T$ and with $TL$. The call with $TL$ has to be made with the result of
*** the call with $T$ so that the variables and the index are right.

  ceq prepLHS((T, TL), CDS, I)
    = < (term(prepLHS(T, CDS, I)),
         term(prepLHS(TL, CDS, index(prepLHS(T, CDS, I))))) ;
        _|_(objects(prepLHS(T, CDS, I)),
                objects(prepLHS(TL, CDS, index(prepLHS(T, CDS, I))))) ;
        index(prepLHS(TL, CDS, index(prepLHS(T, CDS, I)))) ;
        (messages(prepLHS(T, CDS, I))
         messages(prepLHS(TL, CDS, index(prepLHS(T, CDS, I))))) >
    if TL =/= empty .
  ceq prepLHS(F[TL], CDS, I)
    = < F[term(prepLHS(TL, CDS, I))] ;
        objects(prepLHS(TL, CDS, I)) ;
        index(prepLHS(TL, CDS, I)) ;
        messages(prepLHS(TL, CDS, I)) >
      if (F =/= '<_:_|_>) /\ (F =/= '<_:_|`>) .

  ceq prepLHS('<_:_|_>[O, Ct, T], ((class C | ADS .) CDS), I)
    = crtObject(O, C, ADS, prepLHS(T, ((class C | ADS .) CDS), I))
    if getName(Ct) == C .
  ceq prepLHS('<_:_|`>[O, Ct], ((class C | ADS .) CDS), I)
    = crtObject(O, C, ADS,
        prepLHS('none.AttributeSet, ((class C | ADS .) CDS), I))
    if getName(Ct) == C .
  eq prepLHS('<_:_|_>[O, V, T], CDS, I)
    = < '<_:_|_>[O, V, T] ; emptyTermSet ; I ; nil > .
                                                      *** is this eq necessary?
  eq prepLHS('<_:_|`>[O, T], CDS, I)
    = prepLHS('<_:_|_>[O, T, 'none.AttributeSet], CDS, I) .

  eq prepLHS('<_:_|_>[O, T, T'], none, I)
    = < qidError('Error: 'undefined 'class T '\n) ; emptyTermSet ; I ; nil > .

  eq crtObject(O, C, ADS, < T ; TS ; I ; QIL >)
    = crtObject2(O, newVar(C, I), T, 'none.AttributeSet, ADS, TS, (I + 1), QIL) .

*** The function \texttt{crtObject2} is called with the metarepresentation of
*** the list of attributes appearing in the current object (third argument)
*** and the set of attribute declarations of the class to which such object
*** belongs + all the attributes declared in its superclasses (fifth
*** argument). The function proceeds recursively removing the attribute
*** declarations from the set of declarations of attributes for those
*** attributes that appear in the object. Each time an attribute is found, it
*** is passed with its actual value to the fourth argument of
*** \texttt{crtObject2}, which initially has value \verb~'none.AttributeSet~,
*** composing a list of terms with them.

*** We assume that:
*** \begin{itemize}
*** \item The metarepresentation of a list of attributes is always given with
***       form \verb~'_`,_[F[T], T]~, \verb~F[T]~, or
***       \verb~'none.AttributeSet~, where \texttt{TL} is the
***       metarepresentation of a list of attributes with the same form (this
***       is ensured by the \verb~(e E)~ gathering pattern in the corresponding
***       declaration in the signature in which the parsing is done), and
*** \item that all the attributes appearing in an object have been declared in
***       the corresponding class declaration or in one of its superclasses.
*** \end{itemize}

  eq crtObject2(O, V, '_`,_[F[T], TL], TL', ADS, TS, I, QIL)
    = crtObject2(O, V, (F[T], TL), TL', ADS, TS, I, QIL) .

  ceq crtObject2(O, V, (F[T], TL), TL', ((attr A : S), ADS), TS, I, QIL)
    = crtObject2(O, V, TL, (F[T], TL'), ADS, TS, I, QIL)
    if qid(string(A) + "`:_") == F .
  eq crtObject2(O, V, (F[T], TL), TL', ADS, TS, I, QIL)
    = crtObject2(O, V, TL, TL', ADS, TS, I,
        (QIL '\r 'Warning: '\o 'Attribute F 'not 'valid '\n))
    [owise] .

  ceq crtObject2(O, V, F[T], TL, ((attr A : S), ADS), TS, I, QIL)
    = crtObject3(O, V, (F[T], TL), ADS, TS, I, QIL)
    if qid(string(A) + "`:_") == F .
  eq crtObject2(O, V, F[T], TL, ADS, TS, I, QIL)
    = crtObject3(O, V, TL, ADS, TS, I,
        (QIL '\r 'Warning: '\o 'Attribute F 'not 'valid '\n))
    [owise] .

  eq crtObject2(O, V, V', TL, ADS, TS, I, QIL)
    = crtObject3(O, V, TL, ADS, TS, I,
        QIL '\r 'Warning: '\o
            'Variables 'are 'not 'allowed 'in 'the 'set 'of 'attributes
            'of 'an 'object '`( V' '`) '\n) .

  eq crtObject2(O, V, 'none.AttributeSet, TL, ADS, TS, I, QIL)
    = crtObject3(O, V, TL, ADS, TS, I, QIL) .
  eq crtObject2(O, V, empty, TL, ADS, TS, I, QIL)
    = crtObject3(O, V, TL, ADS, TS, I, QIL) .

*** When the function \texttt{crtObject2} has gone through all the
*** attributes in the current object, the function \texttt{crtObject3} is
*** in charge of returning the metarepresentation of the current object
*** completed with the attributes that did not appear in it. These attributes
*** are added with new variables not used in the axiom as value.
*** \texttt{crtObject3} returns a pair composed by this resulting object,
*** and the set of terms representing all the objects in the lefthand
*** side (the current object is added to this set).

  eq crtObject3(O, V, TL, ((attr A : S), ADS), TS, I, QIL)
    = crtObject3(O, V, (qid(string(A) + "`:_")[newVar(S, I)], TL),
        ADS, TS, (I + 1), QIL) .

  eq crtObject3(O, V, TL, none, TS, I, QIL)
    = < '<_:_|_>[O, V, '_`,_[TL, newVar('AttributeSet, I)]] ;
        _|_('<_:_|_>[O, V, '_`,_[TL, newVar('AttributeSet, I)]], TS) ;
        (I + 1) ;
        QIL > .

*** Once the lefthand side of a rule or equation has been `prepared', the
*** function \texttt{prepRHS} is called with the set of objects returned by
*** \texttt{prepLHS} and the term in the righthand side of such rule or
*** equation. The function \texttt{prepRHS} proceeds recursively throughout the
*** term looking for objects. Each time an object is found, its set of
*** attributes is completed with those in the modified object of the lefthand
*** side which do not appear in it.

  op prepRHS : TermSet TermList -> TermList .
  op prepRHS : TermSet Condition -> Condition .

  op adjustObject : TermSet Term -> Term .

  op adjustObjectRHS : TermSet Term -> [Term] .
  op adjustAttrsObjectRHS : Term Term -> [Term] .
  op adjustAttrsObjectRHSAux : TermSet Term -> [Term] .

  op termAttrListToTermSet : TermList -> TermSet .
  op _attrInTermSet_ : Qid TermSet -> Bool .

  eq prepRHS(TS, T = T' /\ Cond)
    = prepRHS(TS, T) = prepRHS(TS, T') /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, T : S /\ Cond)  = prepRHS(TS, T) : S /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, T := T' /\ Cond)
    = prepRHS(TS, T) := prepRHS(TS, T') /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, T => T' /\ Cond)
    = prepRHS(TS, T) => prepRHS(TS, T') /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, (nil).Condition) = nil .

  eq prepRHS(TS, qidError(QIL)) = qidError(QIL) .
  eq prepRHS(TS, F) = F .
  eq prepRHS(TS, Ct) = Ct .
  ceq prepRHS(TS, F[TL])
    = F[prepRHS(TS, TL)]
    if (F =/= '<_:_|_>) and (F =/= '<_:_|`>) .
  eq prepRHS(TS, '<_:_|_>[O, Ct, T])
    = adjustObjectRHS(TS, '<_:_|_>[O, Ct, prepRHS(TS, T)]) .
  eq prepRHS(TS, '<_:_|_>[O, V, T]) = '<_:_|_>[O, V, prepRHS(TS, T)] .
  eq prepRHS(TS, '<_:_|`>[O, Ct])
    = adjustObjectRHS(TS, '<_:_|_>[O, Ct, prepRHS(TS, 'none.AttributeSet)]) .
  eq prepRHS(TS, '<_:_|`>[O, V])
    = '<_:_|_>[O, V, prepRHS(TS, 'none.AttributeSet)] .
  ceq prepRHS(TS, (T, TL))
    = (prepRHS(TS, T), prepRHS(TS, TL))
    if TL =/= empty .

  eq adjustObjectRHS(_|_('<_:_|_>[O, V, T], TS), '<_:_|_>[O', Ct, T'])
    = if O == O'
      then if getType(V) == getType(Ct)
           then '<_:_|_>[O, V, adjustAttrsObjectRHS(T, T')]
           else '<_:_|_>[O', Ct, T']
           fi
      else adjustObjectRHS(TS, '<_:_|_>[O', Ct, T'])
      fi .
  eq adjustObjectRHS(emptyTermSet, '<_:_|_>[O, Ct, T]) = '<_:_|_>[O, Ct, T] .

***  eq adjustObjectRHS(_|_('<_:_|_>[Ct, C, T], TS), '<_:_|_>[O, Ct', T'])
***    = adjustObjectRHS(TS, '<_:_|_>[O, Ct', T']) .
***  eq adjustObjectRHS(
***       _|_('<_:_|_>[Ct, C, T], TS), '<_:_|_>[Ct', Ct'', T'])
***    = if Ct == Ct'
***      then '<_:_|_>[Ct, Ct'', adjustAttrsObjectRHS(T, T')]
***      else adjustObjectRHS(TS, '<_:_|_>[Ct', Ct'', T'])
***      fi .
***  eq adjustObjectRHS(emptyTermSet, '<_:_|_>[Ct, Ct', T])
***    = '<_:_|_>[Ct, Ct', T] .

*** The function \texttt{adjustAttrsObjectRHS} completes the set of
*** attributes of an object in the righthand side with those in the object in
*** the lefthand side or in the class not used in the lefthand side, which
*** have been completed by the function \texttt{crtObject}.

  eq adjustAttrsObjectRHS('_`,_[TL], T)
    = adjustAttrsObjectRHSAux(termAttrListToTermSet(TL), T) .

  eq adjustAttrsObjectRHSAux(_|_(A[T], TS), '_`,_[A[T'], T''])
    = '_`,_[A[T'], adjustAttrsObjectRHSAux(TS, T'')] .
  ceq adjustAttrsObjectRHSAux(TS, '_`,_[A[T], T'])
    = qidError(A 'is 'not 'a 'valid 'attribute)
    if not A attrInTermSet TS .
  eq adjustAttrsObjectRHSAux(_|_(A[T], TS), A[T'])
    = '_`,_[A[T'], adjustAttrsObjectRHSAux(TS, 'none.AttributeSet)] .
  ceq adjustAttrsObjectRHSAux(TS, A[T])
    = qidError(A 'is 'not 'a 'valid 'attribute)
    if not A attrInTermSet TS .
  eq adjustAttrsObjectRHSAux(_|_(A[T], TS), 'none.AttributeSet)
    = '_`,_[A[T], adjustAttrsObjectRHSAux(TS, 'none.AttributeSet)] .
  eq adjustAttrsObjectRHSAux(V, 'none.AttributeSet) = V .

  eq A attrInTermSet _|_(V, TS) = A attrInTermSet TS .
  eq A attrInTermSet _|_(A'[T], TS)
    = (A == A') or-else (A attrInTermSet TS) .
  eq A attrInTermSet emptyTermSet = false .

  ceq termAttrListToTermSet((T, TL))
    = if T == 'none.AttributeSet
      then termAttrListToTermSet(TL)
      else _|_(T, termAttrListToTermSet(TL))
      fi
    if TL =/= empty .
  eq termAttrListToTermSet(T)
    = if T == 'none.AttributeSet
      then emptyTermSet
      else T
      fi .

*** In the case of equations and rules, the function \texttt{prepAxs} calls the
*** function \texttt{prepLHS} with the term in the lefthand side of the axiom,
*** and then use the generated set of objects to call the \texttt{prepRHS}
*** function. For conditional equations, rules, and membership axioms, this set
*** of terms representing the objects in the lefthand side is also used in the
*** calls to \texttt{prepRHS} with each of the terms in the conditions. The
*** term in the lefthand side of the equation, rule, or membership axiom is
*** replaced by the term returned by \texttt{prepLHS}. The index is used in
*** the recursive calls to \texttt{prepAxs}.

*** \texttt{prepLHS} returns as second argument the set of objects (as a set of
*** terms) appearing in it. These objects are returned after extending their
*** set of attributes by those of the class to which they belong not already
*** specified.

  op prepAxs : Module MembAxSet EquationSet RuleSet ClassDeclSet Nat QidList
       -> Module .

  eq prepAxs(U, ((mb T : S [AtS] .) MAS), EqS, RlS, CDS, I, QIL)
    = prepAxs(
        addMbs(mb term(prepLHS(T, CDS, I)) : S [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, ((cmb T : S if Cond [AtS] .) MAS), EqS, RlS, CDS, I, QIL)
    = prepAxs(
        addMbs(cmb term(prepLHS(T, CDS, I)) : S
                 if prepRHS(objects(prepLHS(T, CDS, I)), Cond) [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, MAS, ((eq T = T' [AtS] .) EqS), RlS, CDS, I, QIL)
    = prepAxs(
        addEqs(eq term(prepLHS(T, CDS, I))
                 = prepRHS(objects(prepLHS(T, CDS, I)), T') [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, MAS, ((ceq T = T' if Cond [AtS] .) EqS), RlS, CDS, I, QIL)
    = prepAxs(
        addEqs(ceq term(prepLHS(T, CDS, I))
                 = prepRHS(objects(prepLHS(T, CDS, I)), T')
                 if prepRHS(objects(prepLHS(T, CDS, I)), Cond) [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .

  eq prepAxs(U, MAS, EqS, ((rl T => T' [AtS] .) RlS), CDS, I, QIL)
    = prepAxs(
        addRls(rl term(prepLHS(T, CDS, I))
                 => prepRHS(objects(prepLHS(T, CDS, I)), T') [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, MAS, EqS, ((crl T => T' if Cond [AtS] .) RlS), CDS, I, QIL)
    = prepAxs(
        addRls(crl term(prepLHS(T, CDS, I))
                 => prepRHS(objects(prepLHS(T, CDS, I)), T')
                 if prepRHS(objects(prepLHS(T, CDS, I)), Cond) [AtS] ., U),
        MAS, EqS, RlS, CDS,
        index(prepLHS(T, CDS, I)),
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, none, none, none, CDS, I, nil) = U .
  eq prepAxs(U, none, none, none, CDS, I, NQIL) = unitError(NQIL) .
  eq prepAxs(unitError(QIL), MAS, EqS, RlS:[RuleSet], CDS, I, QIL':QidList) = unitError(QIL':QidList QIL) .

*** After completing the set of classes in the module with the attributes from
*** their superclasses, the function \texttt{omod2mod} calls the function
*** \texttt{omod2modAux} with the same module and the set of class
*** declarations. The definition of the \texttt{omod2mod} function is given by
*** the five equations below.

  op omod2mod : OModule Database -> SModule .
  op omod2modAux : OModule ClassDeclSet -> SModule .
  op omod2mod : OTheory Database -> SModule .
  op omod2modAux : OTheory ClassDeclSet -> SModule .

  eq omod2mod(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
       DB)
    = omod2modAux(
        omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
        prepClasses(CDS, SCDS, IL, getParDecls(H), DB)) .
  eq omod2mod(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
       DB)
    = omod2modAux(
        oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
        prepClasses(CDS, SCDS, IL, getParDecls(H), DB)) .

  eq omod2modAux(
       omod H is
          IL sorts SS . SSDS ((class C | ADS .) CDS) SCDS OPDS MDS MAS EqS RlS
       endom,
       CDS')
    = omod2modAux(
        omod H is
           IL sorts (SS ; C) .
           (subsort C < 'Cid . SSDS)
           CDS SCDS
           ((op C : nil -> C [none] .)
            ops4Attr(ADS) OPDS)
           MDS MAS EqS RlS
        endom,
        CDS') .
  eq omod2modAux(
       omod H is
          IL sorts SS . SSDS CDS ((subclass C < C' .) SCDS)
          OPDS MDS MAS EqS RlS
       endom,
       CDS')
    = omod2modAux(
        omod H is
           IL sorts SS . ((subsort C < C' .) SSDS)
           CDS SCDS OPDS MDS MAS EqS RlS
        endom,
        CDS') .
  eq omod2modAux(
        omod H is
           IL sorts SS . SSDS CDS SCDS OPDS
           ((msg F : TyL -> Ty .) MDS) MAS EqS RlS
        endom,
        CDS')
    = omod2modAux(
         omod H is
            IL sorts SS . SSDS CDS SCDS
            ((op F : TyL -> Ty [msg] .) OPDS) MDS MAS EqS RlS
         endom,
         CDS') .
  eq omod2modAux(
       omod H is IL sorts SS . SSDS none none OPDS none MAS EqS RlS endom,
       CDS)
    = prepAxs(mod H is IL sorts SS . SSDS OPDS none none none endm,
        MAS, EqS, RlS, CDS, 0, nil) .

  eq omod2modAux(
       oth H is
          IL sorts SS . SSDS ((class C | ADS .) CDS)
          SCDS OPDS MDS MAS EqS RlS
       endoth,
       CDS')
    = omod2modAux(
        oth H is
           IL sorts (SS ; C) .
           (subsort C < 'Cid . SSDS)
           CDS SCDS
           ((op C : nil -> C [none] .)
            ops4Attr(ADS) OPDS)
           MDS MAS EqS RlS
        endoth,
        CDS') .
  eq omod2modAux(
       oth H is
          IL sorts SS . SSDS CDS ((subclass C < C' .) SCDS)
          OPDS MDS MAS EqS RlS
       endoth,
       CDS')
    = omod2modAux(
        oth H is
           IL sorts SS . ((subsort C < C' .) SSDS)
           CDS SCDS OPDS MDS MAS EqS RlS
        endoth,
        CDS') .
  eq omod2modAux(
        oth H is
           IL sorts SS . SSDS CDS SCDS OPDS
           ((msg F : TyL -> Ty .) MDS) MAS EqS RlS
        endoth,
        CDS')
    = omod2modAux(
         oth H is
            IL sorts SS . SSDS CDS SCDS
            ((op F : TyL -> Ty [msg] .) OPDS) MDS MAS EqS RlS
         endoth,
         CDS') .
  eq omod2modAux(
       oth H is IL sorts SS . SSDS none none OPDS none MAS EqS RlS endoth,
       CDS)
    = prepAxs(
        th H is IL sorts SS . SSDS OPDS none none none endth,
        MAS, EqS, RlS, CDS, 0, nil) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Evaluation of Modules and Theories
***

*** As explained in Section~\ref{evaluation-overview}, in our approach
*** transforming a module from its possibly complex structured version to its
*** unstructured form is a two-step process.  First, all module expressions
*** are evaluated, generating an intermediate form in which there are only
*** simple inclusion relationships among the modules. This first step can be
*** seen as the reduction of a structured specification to its structured
*** \emph{normal form}. Then, in a second step, this structured normal form is
*** flattened into an unstructured specification.  Note, however, that the
*** importation of built-in modules is left explicit in the flattened form.
*** The function \texttt{normalize} is in charge of normalizing the
*** structure.

*** The process of evaluation of a preunit has to take into account the
*** possibility of bubbles being contained in it. Depending on whether it is
*** dealing with a preunit or with a unit, the evaluation process is
*** accomplished by two different functions, namely, \texttt{evalPreModule} and
*** \texttt{evalModule}. One function or the other will be called in each case.
*** Evaluating a module already in the database, which is done by
*** \texttt{evalModule}, does not require bubble handling. Besides this
*** difference, both functions proceed in a similar way. Before presenting the
*** functions \texttt{evalPreModule} and \texttt{evalModule} we introduce some
*** auxiliary declarations.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod EVALUATION is
  pr O-O-TO-SYSTEM-MOD-TRANSF .
  pr MOD-EXPR-EVAL .
  pr UNIT-BUBBLE-PARSING .

  sort List<Module> .
  subsort Module < List<Module> .

  op nil : -> List<Module> .
  op __ : List<Module> List<Module> -> List<Module> [assoc id: nil] .
  eq unitError(QIL) UL unitError(QIL') = unitError(QIL QIL') UL .

  vars M PU U U' U'' : Module .
  vars UL UL' : List<Module> .
  vars DB  DB' : Database .
  vars ME ME' : ModuleExpression .
  var  P : ViewExp .
  var  PD : ParameterDecl .
  vars PL PL' PL'' : ParameterList .
  vars IL IL' IL'' : ImportList .
  var  I : Import .
  var  CDS : ClassDeclSet .
  var  SSDS : SubsortDeclSet .
  var  SCDS : SubclassDeclSet .
  var  OPD : OpDecl .
  vars OPDS VDS : OpDeclSet .
  var  MDS : MsgDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  B : Bool .
  vars QI QI' V L L' L'' A A' A'' F F' F'' X Y W Z : Qid .
  vars QIL QIL' SL : QidList .
  vars S S' S'' C C' C'' : Sort .
  vars SS SS' : SortSet .
  vars Ty Ty' : Type .
  vars TyL TyL' : TypeList .
  vars AtS AtS' : AttrSet .
  var  Rl : Rule .
  var  CD : ClassDecl .
  var  ADS : AttrDeclSet .
  var  MD : MsgDecl .
  vars T T' T'' T3 : Term .
  var  TL : TermList .
  var  MAP : Renaming .
  var  MAPS : RenamingSet .
  vars VE VE' VE'' : ViewExp .
  var  HkL : HookList .
  vars PDL PDL' : ParameterDeclList .
  var  St : String .

*** The \texttt{subunitImports} function returns the list of all the
*** subunits of a given unit. It is called with the list of importations of
*** the given unit as first argument, and proceeds recursively through its
*** structure collecting all the subunits in it.

*** The function \texttt{subunitImports} proceeds storing the importations
*** considered up to that point, so it does not have to go through the same
*** part of the structure more than once. When the function is initially
*** called the second argument is set to \texttt{nil}.

  op subunitImports : ParameterDeclList ImportList Database -> ImportList .
  op subunitImports : ImportList ImportList Database -> ImportList .

  eq subunitImports((PD, PDL), IL, DB)
    = subunitImports(PDL, IL (protecting pd(PD) .), DB) .
  eq subunitImports((nil).ParameterDeclList, IL, DB)
    = subunitImports(IL, nil, DB) .

  eq subunitImports(I IL, IL' I IL'', DB)
    = subunitImports(IL, IL' I IL'', DB)  .
  eq subunitImports(I IL, IL', DB)
    = subunitImports(getImports(getTopModule(moduleName(I), DB)) IL, I IL', DB)
    [owise] .
  eq subunitImports((nil).ImportList, IL, DB) = IL .

*** The function \texttt{getModules} returns the list of those units
*** in the list of importations given as argument which are not built-in.

  op getModules : ImportList Database -> List<Module> .
  op getModules : ImportList List<Module> Database -> List<Module> .

  eq getModules(IL, DB) = getModules(IL, nil, DB) .

  eq getModules(((including ME .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(ME, DB)), DB) .
  eq getModules(((including pd(PD) .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(pd(PD), DB)), DB) .
  eq getModules(((extending ME .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(ME, DB)), DB) .
  eq getModules(((extending pd(PD) .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(pd(PD), DB)), DB) .
  eq getModules(((protecting ME .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(ME, DB)), DB) .
  eq getModules(((protecting pd(PD) .) IL), UL, DB)
    = getModules(IL, (UL getInternalModule(pd(PD), DB)), DB) .
  eq getModules(IL, UL unitError(QIL) UL', DB) = unitError(QIL) .
  eq getModules(nil, UL, DB) = UL .

*** The normalization of a structure consists in evaluating each of the module
*** expressions appearing in it. Note that, if the \texttt{evalModExp} function
*** generates new modules, they will be evaluated using the \texttt{evalModule}
*** function, producing recursive calls on the part of the structure not
*** previously normalized. Parameters are handled separatedly. They are
*** folded out when analyzing the interface of a module.

  pr 3TUPLE{ImportList,ParameterDeclList,Database}
       * (op ((_,_,_)) to <_;_;_>,
          op p1_ to importList,
          op p2_ to parameterDeclList,
          op p3_ to database) .

----  sort Tuple{ImportList,ParameterDeclList,Database} .
----  op <_;_;_> : ImportList ParameterDeclList Database
----       -> Tuple{ImportList,ParameterDeclList,Database} .
----  op importList : Tuple{ImportList,ParameterDeclList,Database} -> ImportList .
----  op parameterDeclList :
----       Tuple{ImportList,ParameterDeclList,Database} -> ParameterDeclList .
----  op database : Tuple{ImportList,ParameterDeclList,Database} -> Database .
----  eq importList(< IL ; PDL ; DB >) = IL .
----  eq parameterDeclList(< IL ; PDL ; DB >) = PDL .
----  eq database(< IL ; PDL ; DB >) = DB .

  op normalize : ImportList ParameterDeclList Database
       -> Tuple{ImportList,ParameterDeclList,Database} .
  op normalize : ImportList ImportList ParameterDeclList ParameterDeclList
       Database -> Tuple{ImportList,ParameterDeclList,Database} .
  op createCopy : ParameterDecl Database -> Database .
  ---- its definition is in INST-EXPR-EVALUATION

  eq normalize(IL, PDL, DB) = normalize(nil, IL, nil, PDL, DB) .

  eq normalize(IL, IL', PDL, (X :: ME, PDL'), DB)
    = normalize(IL, IL',
        (PDL, X :: modExp(evalModExp(ME, nil, DB))), PDL',
        createCopy((X :: modExp(evalModExp(ME, nil, DB))),
          database(evalModExp(ME, nil, DB)))) .
  eq normalize(IL, (including ME .) IL', PDL, PDL', DB)
    = normalize(IL (including modExp(evalModExp(ME, PDL, DB)) .), IL',
        PDL, PDL', database(evalModExp(ME, PDL, DB))) .
  eq normalize(IL, (extending ME .) IL', PDL, PDL', DB)
    = normalize(IL (extending modExp(evalModExp(ME, PDL, DB)) .), IL',
        PDL, PDL', database(evalModExp(ME, PDL, DB))) .
  eq normalize(IL, (protecting ME .) IL', PDL, PDL', DB)
    = normalize(IL (protecting modExp(evalModExp(ME, PDL, DB)) .), IL',
        PDL, PDL', database(evalModExp(ME, PDL, DB))) .
  eq normalize(IL, I IL', PDL, PDL', DB)
    = normalize(IL I, IL', PDL, PDL', DB)
    [owise] .
  eq normalize(IL, nil, PDL, nil, DB) = < IL ; PDL ; DB > .

*** \texttt{checkSortClashes} checks whether the intersection of the two sTS
*** of sorts given as arguments is empty or not. If it is nonempty, then there
*** is a clash of names, and a warning message is passed to the database.  The
*** check is very simple, and only reports the name of one of the modules from
*** which the sorts come. Only the name of the module from which the sorts
*** given as second argument come is known at this point. This is the module
*** name given as first argument.
***
***   op checkSortClashes : Header SortSet SortSet Database -> Database .
***
***   eq checkSortClashes(ME, (S ; SS), (S ; SS'), DB)
***     = checkSortClashes(ME, SS, SS',
***         warning(DB,
***           '\g 'Advisory: '\o
***           'Clash 'of 'sort eSortToSort(S) 'from header2Qid(ME) '\n)) .
***   ceq checkSortClashes(ME, (S ; SS), SS', DB)
***     = checkSortClashes(ME, SS, SS', DB)
***     if not (S in SS') .
***   eq check(ME, none, SS, DB) = DB .

*** In the current system, the only transformation handled by the
*** \texttt{transform} function is the one from object-oriented modules to
*** system modules, which is accomplished by the
*** \texttt{omod2mod} function presented in
*** Section~\ref{omod2modfunction}. However, \texttt{transform} has been
*** defined as a general transformation that could affect other kinds of
*** modules in a future extension.

  op transform : Module Database -> Module .

  eq transform(unitError(QIL), DB) = unitError(QIL) .
  ceq transform(U, DB) = rmVariantAttrs(U) if U :: SModule or U :: STheory .
  ceq transform(U, DB) = rmVariantAttrs(omod2mod(U, DB))
    if not U :: SModule /\ not U :: STheory /\ U :: OModule or U :: OTheory .

*** The function \texttt{signature} generates a functional module of sort
*** \texttt{FModule}, without equations, by ``forgetting'' the appropriate
*** declarations and converting extended sorts and module names into quoted
*** identifiers.

  op removeIds : OpDeclSet Module -> OpDeclSet .
  eq removeIds(op F : TyL -> Ty [id(T) AtS] . OPDS, M)
    = removeIds(op F : TyL -> Ty [AtS] . OPDS, M) .
  eq removeIds(op F : TyL -> Ty [right-id(T) AtS] . OPDS, M)
    = removeIds(op F : TyL -> Ty [AtS] . OPDS, M) .
  eq removeIds(op F : TyL -> Ty [left-id(T) AtS] . OPDS, M)
    = removeIds(op F : TyL -> Ty [AtS] . OPDS, M) .
  eq removeIds(op F : TyL -> Ty [special(term-hook(QI, T) HkL) AtS] . OPDS, M)
    = removeIds(op F : TyL -> Ty [special(HkL) AtS] . OPDS, M) .
  eq removeIds(OPDS, M) = OPDS [owise] .

  op removeDittos : OpDeclSet Module -> OpDeclSet .
  ceq removeDittos(
        op F : TyL -> Ty [ditto AtS] . op F : TyL' -> Ty' [AtS'] . OPDS, M)
    = removeDittos(
        op F : TyL -> Ty [AtS removeCtorMetadata(AtS')] . op F : TyL' -> Ty' [AtS'] . OPDS, M)
    if not ditto in AtS' /\ sameKind(M, TyL Ty, TyL' Ty') .
  eq removeDittos(OPDS, M) = OPDS [owise] .

  op signature : Module -> Module .
  eq signature(unitError(QIL)) = unitError(QIL) .
  eq signature(U)
    = fmod header2Qid(getName(U)) is
         convertModuleExpressions(getImports(U))
         sorts getSorts(U) .
         getSubsorts(U)
         removeIds(
           removeDittos(getOps(U),
             setSubsorts(
               setSorts(emptyFModule('DUMMY), getSorts(U)),
               getSubsorts(U))),
           setSubsorts(
             setSorts(emptyFModule('DUMMY), getSorts(U)),
             getSubsorts(U)))
         none
         none
      endfm
    [owise] .

*** The function \texttt{flatModule} generates a module of sort \texttt{Module}
*** by ``forgetting'' declarations and converting extended sorts and module
*** identifiers into quoted identifiers.

  op flatModule : Module -> Module .
  eq flatModule(unitError(QIL)) = unitError(QIL) .
  eq flatModule(U)
    = if U :: FModule or U :: FTheory
      then (fmod header2Qid(getName(U)) is
               getImports(U)
               sorts getSorts(U) .
               getSubsorts(U)
               getOps(U)
               getMbs(U)
               getEqs(U)
            endfm)
      else (mod header2Qid(getName(U)) is
               getImports(U)
               sorts getSorts(U) .
               getSubsorts(U)
               getOps(U)
               getMbs(U)
               getEqs(U)
               getRls(U)
            endm)
      fi
    [owise] .

  op convertModuleExpressions : ImportList -> ImportList .
  eq convertModuleExpressions(((protecting ME * (MAPS) .) IL))
    = (protecting ME * (renamings(MAPS)) .) convertModuleExpressions(IL) .
  eq convertModuleExpressions(((extending ME * (MAPS) .) IL))
    = (extending ME * (renamings(MAPS)) .) convertModuleExpressions(IL) .
  eq convertModuleExpressions(((including ME * (MAPS) .) IL))
    = (including ME * (renamings(MAPS)) .) convertModuleExpressions(IL) .
  eq convertModuleExpressions(I IL) = I convertModuleExpressions(IL) [owise] .
  eq convertModuleExpressions(nil) = nil .

  op renamings : RenamingSet -> RenamingSet .
  eq renamings(op F to F' [AtS]) = op F to F' [AtS] .
  eq renamings((op F to F' [AtS], MAPS))
    = (op F to F' [AtS], renamings(MAPS))
    [owise] .
  eq renamings(op F : TyL -> Ty to F' [AtS])
    = op F : TyL -> Ty to F' [AtS] .
  eq renamings((op F : TyL -> Ty to F' [AtS], MAPS))
    = (op F : TyL -> Ty to F' [AtS],
       renamings(MAPS))
    [owise] .
  eq renamings(sort S to S') = sort S to S' .
  eq renamings(((sort S to S'), MAPS))
    = ((sort S to S'), renamings(MAPS))
    [owise] .
  eq renamings(label L to L') = label L to L' .
  eq renamings(((label L to L'), MAPS))
    = ((label L to L'), renamings(MAPS))
    [owise] .
  eq renamings((MAP, MAPS)) = renamings(MAPS) [owise] .
  eq renamings(none) = none .

*** The evaluation process for units without bubbles is as follows. After
*** normalizing the structure, the function \texttt{evalModule} calls
*** \texttt{evalModule1} with an empty copy of the module to which the list of
*** declarations of importations of built-in modules is added, and with the
*** list of its nonbuilt-in subunits.

*** \texttt{evalModule1} accumulates all the declarations in all the
*** nonbuilt-insubmodules in the copy of the module passed as second argument.
*** The top module is then introduced in the database, and, after calling the
*** \texttt{transform} function and renaming all the variables in it, the
*** internal version of such a module is entered in the database as well.

*** Finally, \texttt{evalModule2} generates the signature and the flat version
*** of the module and enters them in the database.

  *** op evalModule : Module Database -> Database .
  ***  moved to MOD-EXPR-EVAL to solve dependency
  op evalModule1 : Module Module List<Module> OpDeclSet Database -> Database .
  op evalModule2 : Module Module Database -> Database .

  ceq evalModule(U, VDS, DB)
    = evalModule1(setPars(setImports(U, IL), PDL), empty(U),
        getModules(IL', DB'), VDS, DB')
    if < IL ; PDL ; DB' > := normalize(getImports(U), getPars(U), DB)
    /\ IL' := subunitImports(PDL, IL, DB') .
   eq evalModule(U, VDS, DB) = DB [owise] .

  eq evalModule1(U, U', (U'' UL), VDS, DB)
    = evalModule1(U, addDecls(U', setImports(U'', nil)), UL, VDS, DB) .
  eq evalModule1(U, U', nil, VDS, DB)
    = evalModule2(
        setImports(transform(U, DB), nil),
        U',
        insertVars(getName(U), VDS,
          insertInternalModule(getName(U), transform(U, DB),
            insertTopModule(getName(U), U, DB)))) .
  eq evalModule1(U, U', unitError(QIL), VDS, DB) = warning(DB, QIL) .

  eq evalModule2(U, U', DB)
    = insertFlatModule(getName(U), flatModule(addDecls(U, U')), DB) .
  eq evalModule2(unitError(QIL), U, DB) = warning(DB, QIL) .

*** The function \texttt{evalPreModule} has to take care of the bubbles in the
*** unit. As we explained in Section~\ref{evaluation-overview}, both the
*** signature and the flattened version of the module are created
*** simultaneously, completing the parsing of the bubbles once the signature
*** has been built, and then completing the flattened module.

*** The \texttt{evalPreModule} function takes as arguments two copies of the
*** module and a database. We shall see in Section~\ref{unit-processing} how
*** these two modules are generated; the one passed as first argument has
*** still bubbles in it, while the other one, which will be used to build the
*** signature, does not contain any bubbles. This module without bubbles is
*** the result of removing the bubbles from the declarations in it, or of
*** removing the declarations themselves when they contain bubbles, as in the
*** case of equations, for example.

*** The \texttt{evalPreModule} function is quite similar to the function
*** \texttt{evalModule}. First, the structure is normalized by calling the
*** \texttt{normalize} function, and then all the subunits in the
*** structure are collected (accomplished by \texttt{subunitImports} and
*** \texttt{getModules}) and the list of importations is updated
*** with the sublist of importations of built-in
*** modules (\texttt{selectBuiltInImports}). Second, the structure of all the
*** subunits below the top is flattened to a single unit. This unit is used to
*** create a first version of the signature (without identity elements of
*** operators) in which all the bubbles in the top preunit are
*** parsed (\texttt{solveBubbles}). The final version of the signature and
*** the flat unit are generated once the bubbles have been parsed. The
*** `internal' version of the module is also generated by renaming the
*** variables in it (\texttt{renameVars}). All these versions of the module
*** are finally entered in the database.

*** Note that if the \texttt{META-LEVEL} module is imported in the module
*** being evaluated, a declaration importing the predefined module
*** \texttt{UP} Section~\ref{non-built-in-predefined}) is added. With the
*** declarations in this module it will be possible to parse bubbles
*** containing calls to the \texttt{up} functions (see
*** Section~\ref{structured-specifications}) in them.

  op evalPreModule : Module Module OpDeclSet Database -> Database .
  op evalPreModule1 :
       Module Module List<Module> Module OpDeclSet Database -> Database .
  op evalPreModule2 : Module Module Module OpDeclSet Database -> Database .
  op evalPreModule3 : Module Module Module Database -> Database .

  *** evalPreModule just calls evalPreModule1 with a set of the units in the
  *** structure of the given module. Depending on whether the module is
  *** importing META-LEVEL or not UP will be added. BOOL will be added if
  *** the include BOOL flag is set and the module doesn't include it already.

  ceq evalPreModule(PU, U, VDS, DB)
    *** PU  : top unit with bubbles (preunit)
    *** U   : top unit without bubbles (decls with bubbles were removed)
    *** VDS : ops corresponding to the vbles in the top unit
    = evalPreModule1(
        setPars(setImports(PU, IL'), PDL'),
        setName(empty(U), getName(U)),
        getModules(IL'', DB'),
        setImports(U, nil),
        VDS,
        DB')
    if IL := getImports(PU)
    /\ PDL := getPars(PU)
    /\ < IL' ; PDL' ; DB' > := normalize(defImports(PU, DB) IL, PDL, DB)
    /\ IL'' := subunitImports(PDL, IL', DB') .
  eq evalPreModule(PU, U, VDS, DB) = DB [owise] .

  *** evalPreModule1 joins all the units in the structure into a single unit,
  *** the one given as second argument; recall that the fourth one is the
  *** top module without bubbles but with the complete list of subunits
  *** being imported explicitly

  eq evalPreModule1(PU, U, (U' UL), U'', VDS, DB)
    = evalPreModule1(PU, addDecls(U, U'), UL, U'', VDS, DB) .
  eq evalPreModule1(PU, U, nil, U', VDS, DB)
    = evalPreModule2(PU, U, signature(transform(addDecls(U', setImports(U, nil)), DB)), VDS, DB)
    [owise] .
  eq evalPreModule1(PU, unitError(QIL), UL, U', VDS, DB) = warning(DB, QIL) .
  eq evalPreModule1(unitError(QIL), U, UL, U', VDS, DB) = warning(DB, QIL) .
  eq evalPreModule1(PU, U, unitError(QIL), U', VDS, DB) = warning(DB, QIL) .

  eq evalPreModule2(PU, U, M, VDS, DB)
    *** PU : top module with bubbles
    *** U  : everything below
    *** M  : complete signature
    = evalPreModule3(
        solveBubblesMod(PU, getOps(U), M,
          included('META-MODULE, getImports(PU), DB), VDS, DB),
        U, M,
        insertVars(getName(PU), VDS,
          insertTopModule(getName(PU),
            solveBubblesMod(PU, getOps(U), M,
              included('META-MODULE, getImports(PU), DB), VDS, DB), DB))) .

  eq evalPreModule3(PU, U, M, DB)
    *** PU : top module without bubbles
    *** U  : everything below
    *** M  : complete signature
    = insertFlatModule(getName(PU),
        flatModule(setImports(transform(addDecls(PU, U), DB), nil)),
        insertInternalModule(getName(PU), transform(PU, DB), DB)) .
  eq evalPreModule3(unitError(QIL), U, M, DB) = warning(DB, QIL) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** Note that in both \texttt{evalModule} and \texttt{evalPreModule}, the function
*** \texttt{transform} has to be invoked to transform the module into a
*** functional or system module. In the current system, the only
*** transformation available is from object-oriented modules to system modules.

***
*** 6.8 Application of Map STS
***

*** The following two modules deal with the application of a set of renaming
*** maps to a module. Except for the proof obligations and additional checks
*** associated with views---almost none of these checks are performed, and
*** none of these proof obligations is generated in the current version---the
*** way of applying a renaming map and a view map on a module is the same.
*** Internally, they are treated in the same way; the only difference between
*** them consists in the way of calling the function to accomplish this
*** application.

*** Note that there might be some `interference' between sort maps, and
*** operator maps and message maps when they are applied. Let us consider for
*** example a module with an operator declaration
***
***  op f : Foo -> Foo .
***
*** and a renaming map set
***
***  (sort Foo to Bar, op f : Foo -> Foo to g)
***
*** These renamings have to be applied carefully to avoid unintended behaviors.
*** Depending on which of the maps is applied first, the other will be
*** applicable or not.  All the maps must be applied to the original module.
*** To avoid the interference between the sort maps and other maps, the map set
*** is divided into two sTS: The first one contains the sort maps, and the
*** second one contains the other maps.

*** We assume that there are no ambiguous mappings, that is, that we do not
*** have, for example, maps \verb~op f to g~ and \verb~op f to h~. In case of
*** such ambiguity, one of the maps will be arbitrarily chosen.

***
*** 6.8.1 Map STS on Terms
***

*** The application of a set of view maps to a term is defined in the following
*** module \texttt{RENAMING-SET-APPL-ON-TERM}. The function
*** \texttt{applyMapsToTerm} is used to apply a given view map set to terms
*** appearing in equations, rules, identity element declarations, and
*** membership axioms, as part of the process of applying a map set to a unit.

*** Some of the auxiliary functions introduced in this module will also be used
*** in the application of maps to operator and message declarations in the
*** \texttt{RENAMING-SET-APPL-ON-UNIT} module.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod RENAMING-SET-APPL-ON-TERM is
  pr UNIT .
  pr FMAP .
  pr EXT-SORT .

  var  R : Renaming .
  vars RS RS' RS'' SRS ORS : RenamingSet .
  var  M : Module .
  vars F F' F'' A A' A'' : Qid .
  vars T T' T'' O : Term .
  vars TL TL' TL'' TL3 : TermList .
  vars S S' S'' C C' C'' : Sort .
  var  SS : SortSet .
  var  K : Kind .
  vars TyL TyL' : TypeList .
  vars Ty Ty' : Type .
  vars Subst Subst' Subst'' : Substitution .
  var  AtS : AttrSet .
  var  OPDS : OpDeclSet .
  vars V V' : Variable .
  vars Ct Ct' : Constant .
  var  QIL : QidList .
  var  Cd : Condition .

*** The following functions \texttt{applyMapsToSort} and
*** \texttt{applyMapsToClassSort} apply a set of maps, respectively, to a
*** sort a to a class name in its single identifier form, that is, when they
*** appear qualifying constants. Functions \texttt{applyMapsToType} and
*** \texttt{applyMapsToClassName} are similar but being applied to sort or
*** class names in their normal form.

  op applyMapsToSort : RenamingSet Sort -> Sort .
  eq applyMapsToSort((sort S to S'), S) = S' .
  eq applyMapsToSort((sort S to S'), S'') = S'' [owise] .
  eq applyMapsToSort(((sort S to S'), SRS), S) = S' .
  eq applyMapsToSort(((sort S to S'), SRS), S'')
    = applyMapsToSort(SRS, S'')
    [owise] .
  eq applyMapsToSort(R, S) = S [owise].
  eq applyMapsToSort((R, SRS), S) = applyMapsToSort(SRS, S) [owise].
  eq applyMapsToSort(none, S) = S .

  op applyMapsToSortSet : RenamingSet SortSet -> SortSet .
  eq applyMapsToSortSet(SRS, (S ; SS))
    = (applyMapsToType(SRS, S) ; applyMapsToSortSet(SRS, SS)) .
  eq applyMapsToSortSet(SRS, none) = none .

  op applyMapsToType : RenamingSet Type -> Type .
  eq applyMapsToType((sort S to S'), S) = S' .
  eq applyMapsToType(((sort S to S'), SRS), S) = S' .
  eq applyMapsToType((sort S to S'), K)
    = qid("[" + string(applyMapsToType(sort S to S', getSort(K))) + "]") .
  eq applyMapsToType(((sort S to S'), SRS), K)
    = qid("["
       + string(applyMapsToType(((sort S to S'), SRS), getSort(K)))
       + "]") .
  eq applyMapsToType(SRS, Ty) = Ty [owise] .

  op applyMapsToClassName : RenamingSet Sort -> Sort .
  eq applyMapsToClassName((class C to C'), C) = C' .
  eq applyMapsToClassName(((class C to C'), SRS), C) = C' .
  eq applyMapsToClassName(SRS, C) = C [owise] .

*** \texttt{applyOpMapsToOpId} applies a map set to an operator name.

  op applyOpMapsToOpId : Qid RenamingSet -> Qid .
  eq applyOpMapsToOpId(F, (op F to F' [AtS])) = F' .
  eq applyOpMapsToOpId(F, (op F : TyL -> Ty to F' [AtS])) = F' .
  eq applyOpMapsToOpId(F, RS) = F [owise] .

*** Note that all maps introduced in Sections~\ref{renaming-maps}
*** and~\ref{view-maps}, except for label maps, may affect a term. For example,
*** sort maps will be applied to the qualifications of terms, and class and
*** attribute maps have to be applied to the objects appearing in the term.
*** Operator and message maps in which an explicit arity and coarity is given,
*** and operator maps going to derived operators (see Section~\ref{Views})
*** must be applied to the complete family of subsort-overloaded operators.

*** The function \texttt{applyMapsToTerm} takes as arguments two sTS of
*** view maps (the first set for sort maps, and the second for the other maps),
*** the term to which the maps will be applied, and a module to be used in the
*** matching of terms, sort comparisons, etc. Its declaration is as follows.

  op applyMapsToTerm2 : RenamingSet RenamingSet Term Module -> Term .

*** If the term on which the maps have to be applied is not an object,
*** different cases have to be considered for each of the possible forms of a
*** term. If it is a variable or \texttt{error*}, the same term is returned
*** without change (term maps are a special case for this). If it is a sort
*** test or a lazy sort test, with forms \verb~T : S~ and \verb~T :: S~,
*** respectively, the maps are applied to the term \texttt{T} and to the sort
*** \texttt{S}.  In case of being of forms \verb~F.S~ or \verb~F[TL]~ with
*** \texttt{F} an operator name, \texttt{S} a sort, and \texttt{TL} a list of
*** terms, the function \texttt{getRightOpMaps} will return the subset of
*** maps which are applicable on such term. If \texttt{none} is returned then
*** no map is applicable. If more than one map is returned then there is an
*** ambiguity, and any of them will be arbitrarily taken. The function
*** \texttt{imagTerm} is called with the term and the maps applicable on
*** it and return the image of the term. In case of a term of the form
*** \texttt{F[TL]}, \texttt{imageOfTerm} will make recursive calls with the
*** arguments in \texttt{TL}.

*** The application of a term map to a term requires the `matching' of the
*** source term in the map with the term on which the map is applied, and then
*** the application of the obtained substitution. Note, however, that a
*** complete matching algorithm is not required. Given the form of the pattern
*** we can choose beforehand the appropriate map, that is, we know that in
*** fact there is a match when the function is called. Note also that the map
*** has to be applied to the whole family of subsort overloaded operators. We
*** just have to check that the sort of the given variable and the
*** corresponding term are in the same connected component of sorts.  In
*** addition to getting the appropriate substitution, the only thing we need
*** to check is that there are no variables with different assignments, that
*** is, that in case of having a nonlinear pattern, the terms being assigned
*** to each variable are equal. We call \texttt{pseudoMatch} to the function
*** doing this task.

  op applyMapsToTerm2 : RenamingSet RenamingSet TermList Module -> TermList .

  op imageOfTerm : RenamingSet RenamingSet Term RenamingSet Module -> Term .
  op applyMapsToSubst : RenamingSet RenamingSet Substitution Module -> Substitution .
  op pseudoMatch : TermList TermList Module Substitution -> Substitution .
  op pseudoMatch2 : TermList TermList Module Substitution -> Substitution .
  op pseudoMatchResult : Substitution -> Substitution .
  op pseudoMatchResult : Substitution Assignment Substitution Substitution -> Substitution .

  op getRightOpMaps : Qid TypeList Type RenamingSet Module -> RenamingSet .
  op applyMapsToObjectAttrSet : RenamingSet RenamingSet Sort Term Module -> Term .
  op applyMapsToAttrNameInTerm : RenamingSet Sort Qid Module -> Qid .

  eq applyMapsToTerm2(SRS, ORS, Ct, M)
    = imageOfTerm(SRS, ORS, Ct,
        getRightOpMaps(getName(Ct), nil, getType(Ct), ORS, M), M) .
  eq applyMapsToTerm2(SRS, ORS, V, M)
    = qid(string(getName(V)) + ":"
          + string(applyMapsToType(SRS, getType(V)))) .
  eq applyMapsToTerm2(SRS, ORS, qidError(QIL), M) = qidError(QIL) .
  eq applyMapsToTerm2(SRS, ORS, F[TL], M)
    = imageOfTerm(SRS, ORS, F[TL],
        getRightOpMaps(F, eLeastSort(M, TL), leastSort(M, F[TL]), ORS, M),
        M)
    [owise] .
    ---- if (F =/= '<_:_|_>) and (F =/= '<_:_|`>) .
  eq applyMapsToTerm2(SRS, ORS, '<_:_|_>[O, Ct, T], M)
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M),
               qid(string(applyMapsToClassName(SRS, getName(Ct)))
                  + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               applyMapsToObjectAttrSet(SRS, ORS, getName(Ct), T, M)].
  ceq applyMapsToTerm2(SRS, ORS, '<_:_|_>[O, C, T], M)
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M),
               applyMapsToClassName(SRS, C),
               applyMapsToObjectAttrSet(SRS, ORS, C, T, M)]
    if not C :: Constant .
  eq applyMapsToTerm2(SRS, ORS, '<_:_|`>[O, Ct], M)
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M),
               qid(string(applyMapsToClassName(SRS, getName(Ct)))
                 + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               'none.AttributeSet] .
  ceq applyMapsToTerm2(SRS, ORS, '<_:_|`>[O, C], M)
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M),
         applyMapsToClassName(SRS, C), 'none.AttributeSet]
    if not C :: Constant .
  ceq applyMapsToTerm2(SRS, ORS, F[TL], M)
    = qid("_::`" + string(applyMapsToType(SRS, qid(substr(string(F), 4, length(string(F))))))) [
        applyMapsToTerm2(SRS, ORS, TL, M)]
    if substr(string(F), 0, 4) == "_::`" .
----    /\ substr(string(F), sd(length(string(F)), 2), 2) = "`}" .

  ceq applyMapsToTerm2(SRS, ORS, (T, TL), M)
    = (applyMapsToTerm2(SRS, ORS, T, M),
       applyMapsToTerm2(SRS, ORS, TL, M))
    if TL =/= empty .

*** Application of a map set to the name of an attribute in an object

  eq applyMapsToAttrNameInTerm((attr A . S to A'), C, A'', M)
    = if sameKind(M, S, C) and-then (qid(string(A) + "`:_") == A'')
      then qid(string(A') + "`:_")
      else A''
      fi .
  eq applyMapsToAttrNameInTerm(((attr A . S to A'), ORS), C, A'', M)
    = if sameKind(M, S, C) and-then (qid(string(A) + "`:_") == A'')
      then qid(string(A') + "`:_")
      else applyMapsToAttrNameInTerm(ORS, C, A'', M)
      fi .
  eq applyMapsToAttrNameInTerm(R, C, A, M) = A [owise] .
  eq applyMapsToAttrNameInTerm((R, ORS), C, A, M)
    = applyMapsToAttrNameInTerm(ORS, C, A, M)
    [owise] .
  eq applyMapsToAttrNameInTerm(none, S, A, M) = A .

*** Selection of all the operator or message maps that are applicable on an
*** operator with a given arity and coarity.

  eq getRightOpMaps(F, TyL, Ty, (msg F' to F''), M)
    = getRightOpMaps(F, TyL, Ty, (op F' to F'' [none]), M) .
  eq getRightOpMaps(F, TyL, Ty, ((msg F' to F''), RS), M)
    = getRightOpMaps(F, TyL, Ty, ((op F' to F'' [none]), RS), M) .
  eq getRightOpMaps(F, TyL, Ty, (msg F' : TyL' -> Ty' to F''), M)
    = getRightOpMaps(F, TyL, Ty, op F' : TyL' -> Ty' to F'' [none], M) .
  eq getRightOpMaps(F, TyL, Ty, ((msg F' : TyL' -> Ty' to F''), RS), M)
    = getRightOpMaps(F, TyL, Ty,
        (op F' : TyL' -> Ty' to F'' [none], RS), M) .
  eq getRightOpMaps(F, TyL, Ty, (op F to F' [AtS]), M) = (op F to F' [AtS]) .
  eq getRightOpMaps(F, TyL, Ty, (op F to F' [AtS], RS), M)
    = (op F to F' [AtS], getRightOpMaps(F, TyL, Ty, RS, M)) .
  eq getRightOpMaps(F, TyL, Ty, op F : TyL' -> Ty' to F' [AtS], M)
    = if (size(TyL') == 2 and-then (sameKindAll(M, Ty', TyL) and-then assoc in attrs2SameKind(F, TyL, M)))
         or-else
         sameKind(M, TyL Ty, TyL' Ty')
      then (op F : TyL' -> Ty' to F' [AtS])
      else none
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op F : TyL' -> Ty' to F' [AtS], RS), M)
    = if (size(TyL') == 2 and-then (sameKindAll(M, Ty', TyL) and-then assoc in attrs2SameKind(F, TyL, M)))
         or-else
         sameKind(M, TyL Ty, TyL' Ty')
      then (op F : TyL' -> Ty' to F' [AtS],
            getRightOpMaps(F, TyL, Ty, RS, M))
      else getRightOpMaps(F, TyL, Ty, RS, M)
      fi .
  eq getRightOpMaps(F, TyL, Ty, op_to`term_(F[TL], T), M)
    = if sameKind(M, TyL, varListSort(TL))
      then (op_to`term_(F[TL], T))
      else none
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op_to`term_(F[TL], T), RS), M)
    = if sameKind(M, TyL, varListSort(TL))
      then (op_to`term_(F[TL], T), getRightOpMaps(F, TyL, Ty, RS, M))
      else getRightOpMaps(F, TyL, Ty, RS, M)
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op_to`term_(Ct, T)), M)
    = if TyL == nil
         and-then (F == getName(Ct)
         and-then sameKind(M, Ty, getType(Ct)))
      then (op_to`term_(Ct, T))
      else none
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op_to`term_(Ct, T), RS), M)
    = if TyL == nil
         and-then (F == getName(Ct)
         and-then sameKind(M, Ty, getType(Ct)))
      then (op_to`term_(Ct, T), getRightOpMaps(F, TyL, Ty, RS, M))
      else getRightOpMaps(F, TyL, Ty, RS, M)
      fi .
  eq getRightOpMaps(F, TyL:[Type], Ty:[Type], RS, M) = none [owise].

  op varListSort : TermList -> TypeList .
  eq varListSort((V, TL)) = (getType(V) varListSort(TL)) .
  eq varListSort(empty) = nil .

  op attrs2SameKind : Qid TypeList Module -> AttrSet .
  op attrs2SameKind : Qid TypeList OpDeclSet Module -> AttrSet .
  eq attrs2SameKind(F, Ty Ty' TyL, M) = attrs2SameKind(F, Ty Ty', getOps(M), M) .
 ceq attrs2SameKind(F, TyL, op F : TyL' -> Ty' [AtS] . OPDS, M) ---- all subsort overloaded operators have the same equational attributes
    = AtS
    if sameKind(M, TyL, TyL') .
  eq attrs2SameKind(F, TyL, OPDS, M) = none [owise] .

*** Application of a map set to the set of attributes in an object

  eq applyMapsToObjectAttrSet(RS, RS', C, '_`,_[A[T], TL], M)
    = '_`,_[applyMapsToAttrNameInTerm(RS', C, A, M)
              [applyMapsToTerm2(RS, RS', T, M)],
            applyMapsToObjectAttrSet(RS, RS', C, TL, M)] .
  eq applyMapsToObjectAttrSet(RS, RS', C, A[T], M)
    = applyMapsToAttrNameInTerm(RS', C, A, M)
        [applyMapsToTerm2(RS, RS', T, M)] .
  eq applyMapsToObjectAttrSet(RS, RS', C,
       '_`,_['none.AttributeSet, TL], M)
    = '_`,_['none.AttributeSet,
            applyMapsToObjectAttrSet(RS, RS', C, TL, M)] .
  eq applyMapsToObjectAttrSet(RS, RS', C, 'none.AttributeSet, M)
    = 'none.AttributeSet .

*** Image of a term

  eq imageOfTerm(RS, RS', Ct, none, M)
    = qid(string(getName(Ct)) + "."
          + string(applyMapsToType(RS, getType(Ct)))) .
  eq imageOfTerm(RS, RS', F[TL], none, M)
    = F [ applyMapsToTerm2(RS, RS', TL, M) ] .

  eq imageOfTerm(RS, RS', F[TL], (op F to F' [AtS]), M)
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', F[TL], ((op F to F' [AtS]), RS''), M)
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', F[TL], (op F : TyL -> Ty to F'[AtS]), M)
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', F[TL], (op F : TyL -> Ty to F'[AtS], RS''),M)
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', T, op_to`term_(T', T''), M)
    = applySubst(T'',
        applyMapsToSubst(RS, RS', pseudoMatch(T', T, M, none), M)) .
  eq imageOfTerm(RS, RS', T, (op_to`term_(T', T''), RS''), M)
    = applySubst(T'',
        applyMapsToSubst(RS, RS', pseudoMatch(T', T, M, none), M)) .
  ceq imageOfTerm(RS, RS', Ct, (op F to F' [AtS]), M)
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct))))
    if getName(Ct) = F .
  ceq imageOfTerm(RS, RS', Ct, ((op F to F' [AtS]), RS''), M)
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct))))
    if getName(Ct) = F .
  ceq imageOfTerm(RS, RS', Ct, (op F : TyL -> Ty to F' [AtS]), M)
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct))))
    if getName(Ct) = F .
  ceq imageOfTerm(RS, RS', Ct, (op F : TyL -> Ty to F' [AtS], RS''),M)
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct))))
    if getName(Ct) = F .

*** Application of a Substitution on a term

  op applySubst : TermList Substitution -> TermList .
  eq applySubst(T, none) = T .
  eq applySubst(V, ((V' <- T) ; Subst))
    = if getName(V) == getName(V')
      then T
      else applySubst(V, Subst)
      fi .
  eq applySubst(F[TL], Subst) = F[applySubst(TL, Subst)] .
  eq applySubst(Ct, Subst) = Ct .
  ceq applySubst((T, TL), Subst)
    = (applySubst(T, Subst), applySubst(TL,Subst))
    if TL =/= empty .

*** Application of a Substitution to a condition

  op applySubst : Condition Substitution -> Condition .
  eq applySubst(T = T' /\ Cd, Subst)
    = (applySubst(T, Subst) = applySubst(T', Subst)) /\ applySubst(Cd, Subst) .
  eq applySubst(T => T' /\ Cd, Subst)
    = (applySubst(T, Subst) => applySubst(T', Subst)) /\ applySubst(Cd, Subst) .
  eq applySubst(T : S /\ Cd, Subst)
    = (applySubst(T, Subst) : S) /\ applySubst(Cd, Subst) .
  eq applySubst((nil).EqCondition, Subst) = nil .

*** PseudoMatch

  eq pseudoMatch(T, T', M, Subst)
    = pseudoMatchResult(pseudoMatch2(T, T', M, Subst)) .

  eq pseudoMatch2(Ct, Ct', M, Subst) = none .
  eq pseudoMatch2(F[TL], F'[TL'], M, Subst)
    = if F == F'
      then pseudoMatch2(TL, TL', M, Subst)
      else none
      fi .
  eq pseudoMatch2((V, TL), (T, TL'), M, Subst)
    = if sameKind(M, getType(V), leastSort(M, T))
      then pseudoMatch2(TL, TL', M, (V <- T ; Subst))
      else none
      fi .
  eq pseudoMatch2(V, T, M, Subst)
    = if sameKind(M, getType(V), leastSort(M, T))
      then (V <- T ; Subst)
      else none
      fi .

  eq pseudoMatch2((V, TL), (T, TL'), M, Subst)
    = if sameKind(M, getType(V), leastSort(M, T))
      then pseudoMatch2(TL, TL', M, (V <- T ; Subst))
      else none
      fi .
  eq pseudoMatch2((Ct, TL), (Ct', TL'), M, Subst)
    = if getName(Ct) == getName(Ct')
      then pseudoMatch2(TL, TL', M, Subst)
      else none
      fi .
  eq pseudoMatch2((F[TL], TL'), (F'[TL''], TL3), M, Subst)
    = if F == F'
      then pseudoMatch2(TL', TL3, M, pseudoMatch2(TL, TL'', M, none) ; Subst)
      else none
      fi .
  eq pseudoMatch2(empty, empty, M, Subst) = Subst .

  *** pseudoMatchResult detects conflicts and eliminates duplicates

  eq pseudoMatchResult((V <- T) ; Subst)
    = pseudoMatchResult(none, (V <- T), none, Subst) .
  eq pseudoMatchResult(none) = none .

  eq pseudoMatchResult(Subst, (V <- T), Subst', (V' <- T') ; Subst'')
    = if V == V'
      then if T == T'
           then pseudoMatchResult(Subst, (V <- T), Subst', Subst'')
           else none
           fi
      else pseudoMatchResult(Subst, (V <- T), Subst' ; (V' <- T'), Subst'')
      fi .
  eq pseudoMatchResult(Subst, (V <- T), (V' <- T') ; Subst', none)
    = pseudoMatchResult(Subst ; (V <- T), (V' <- T'), none, Subst') .
  eq pseudoMatchResult(Subst, (V <- T), none, none) = (Subst ; (V <- T)) .

*** Application of a set of maps to a substitution

  eq applyMapsToSubst(RS, RS', ((V <- T) ; Subst), M)
    = ((applyMapsToTerm2(RS, RS', V, M) <- applyMapsToTerm2(RS, RS', T, M)) ;
       applyMapsToSubst(RS, RS', Subst, M)) .
  eq applyMapsToSubst(RS, RS', none, M) = none .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** We do not include here the equations defining the semantics of the function
*** \texttt{applyMapsToTerm}. Instead, we present an example illustrating
*** the meaning of the function. Renaming maps and view maps were already
*** discussed in Sections~\ref{Views} and~\ref{module-expressions}.

*** Let us consider the following configuration in the module
*** \texttt{STACK2[Accnt]} presented in Section~\ref{module-expressions}. In
*** this configuration we have objects in the class \texttt{Accnt} which
*** represent the accounts of different clients of a bank, which is
*** represented as an object \texttt{'bank} of class \texttt{Stack[Accnt]}.
*** The object \texttt{'bank} in the example configuration below keeps a stack
*** with the accounts of the bank represented as a linked list of nodes, each
*** of which corresponds to the account of one of the clients.

***   ('bank push 'john)
***   ('peter elt 2000)
***   < 'bank : Stack[Accnt] | first : o ('bank, 1) >
***   < 'paul : Accnt | bal : 5000 >
***   < 'peter : Accnt | bal : 2000 >
***   < 'mary : Accnt | bal : 7200 >
***   < 'john : Accnt | bal : 100 >
***   < o('bank, 0) : Node[Accnt] | node : 'peter, next : null >
***   < o('bank, 1) : Node[Accnt] | node : 'mary, next : o('bank, 0) > .
***
*** Let us apply the following renaming to the previous term.
***
***   (op o to id,
***    class Stack[Accnt] to Bank,
***    msg _push_ : Oid Oid -> Msg to open`account`in_to_,
***    msg _pop to close`account`of_,
***    msg _elt_ to _owns_dollars,
***    attr node . Node[Accnt] to client,
***    attr bal . Accnt to balance)
***
*** The resulting term is as follows.
***
***   (open account in 'bank to 'john)
***   ('peter owns 2000 dollars)
***   < 'bank : Bank | first : id('bank, 1) >
***   < 'paul : Accnt | balance : 5000 >
***   < 'peter : Accnt | balance : 2000 >
***   < 'mary : Accnt | balance : 7200 >
***   < 'john : Accnt | balance : 100 >
***   < id('bank, 0) : Node[Accnt] | client : 'peter, next : null >
***   < id('bank, 1) : Node[Accnt] | client : 'mary, next : id('bank, 0) >

*** The function \texttt{applyMapsToTerm} treats the object constructor
*** \verb~<_:_|_>~ in a special way. It cannot be renamed, and, when an
*** occurrence of such a constructor is found, class and attribute maps require
*** a particular handling. Inside terms these maps are only triggered when
*** this constructor is found, and they are applied in a very restricted way,
*** according to the general pattern for objects.  We assume that the operator
*** \verb~<_:_|_>~ is only used for objects and that objects constructed using
*** it are well-formed.

***
*** 6.8.2 Map STS on Modules
***

*** The application of view maps to modules and theories of the different types
*** is defined in the following module \texttt{RENAMING-SET-APPL-ON-UNIT}. The
*** function \texttt{applyMapsToModule} is defined recursively by applying it
*** to the different components of a unit. When the terms in the different
*** declarations are reached, the function \texttt{applyMapsToTerm} is
*** called. This call is made with the set of maps split conveniently, as
*** explained above.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod RENAMING-SET-APPL-ON-UNIT is
  pr RENAMING-SET-APPL-ON-TERM .
  pr INT-LIST .
  pr VIEW-EXPR .

  op applyMapsToModule : RenamingSet Module Module -> Module .
  op applyMapsToModuleAux : RenamingSet RenamingSet Module Module -> Module .
  op splitMaps : RenamingSet -> Tuple{RenamingSet,RenamingSet} .
  op splitMapsAux : RenamingSet RenamingSet RenamingSet
       -> Tuple{RenamingSet,RenamingSet} .

  op applyMapsToTypeList : RenamingSet TypeList -> TypeList .
  op applyMapsToSubsorts : RenamingSet SubsortDeclSet -> SubsortDeclSet .
  op applyMapsToOps : RenamingSet RenamingSet OpDeclSet Module -> OpDeclSet .
  op applyMapsToOp : RenamingSet RenamingSet RenamingSet OpDecl Module -> OpDecl .
  op applyMapsToAttrs : RenamingSet RenamingSet AttrSet Module -> AttrSet .
  op applyMapToAttrs : Renaming AttrSet -> AttrSet .
  op applyMapToAttrsAux : AttrSet AttrSet AttrSet -> AttrSet .
  op applyMapsToHooks : RenamingSet RenamingSet HookList Module -> HookList .
  op applyMapsToHooksAux : RenamingSet RenamingSet Hook Module -> Hook .
  op applyMapsToMbs : RenamingSet RenamingSet MembAxSet Module -> MembAxSet .
  op applyMapsToEqs : RenamingSet RenamingSet EquationSet Module -> EquationSet .
  op applyMapsToRls : RenamingSet RenamingSet RuleSet Module -> RuleSet .
  op applyMapsToCond : RenamingSet RenamingSet Condition Module -> Condition .
  op applyMapsToLabel : RenamingSet Qid -> Qid .
  op applyMapsToClassDeclSet : RenamingSet RenamingSet ClassDeclSet -> ClassDeclSet .
  op applyMapsToSubclassDeclSet : RenamingSet SubclassDeclSet -> SubclassDeclSet .
  op applyMapsToMsgDeclSet : RenamingSet RenamingSet MsgDeclSet Module -> MsgDeclSet .
  op applyMapsToMsgDecl : RenamingSet RenamingSet MsgDecl Module -> MsgDecl .
  op applyMapsToAttrName : RenamingSet Sort Qid -> Qid .
  op applyMapsToAttrDeclSet : RenamingSet RenamingSet Sort AttrDeclSet -> AttrDeclSet .

  vars M U : Module .
  vars QI QI' QI'' L L' L'' F F' F'' A A' A'' : Qid .
  vars V V' : Variable .
  vars QIL QIL' : QidList .
  var  VE : ViewExp .
  var  H : Header .
  var  ME : ModuleExpression .
  var  PDL : ParameterDeclList .
  var  IL : ImportList .
  vars S S' S'' C C' C'' : Sort .
  var  Ty : Type .
  vars TyL TyL' : TypeList .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  CDS : ClassDeclSet .
  var  SCDS : SubclassDeclSet .
  var  MDS : MsgDeclSet .
  var  ADS : AttrDeclSet .
  vars T T' T'' T3 O : Term .
  vars TL TL' : TermList .
  var  At : Attr .
  vars AtS AtS' AtS'' : AttrSet .
  vars I I' : Nat .
  vars NL NL' : IntList .
  var  Hk : Hook .
  var  HkL : HookList .
  var  R : Renaming .
  vars RS RS' RS'' SRS ORS : RenamingSet .
  var  Subst : Substitution .
  var  Cond : Condition .
  var  St : String .
  var  MN : ModuleName .

  sort Tuple{RenamingSet,RenamingSet} .
  op <_;_> : RenamingSet RenamingSet -> Tuple{RenamingSet, RenamingSet} .
  ops sortMaps otherMaps : Tuple{RenamingSet, RenamingSet} -> RenamingSet .
  eq sortMaps(< RS ; RS' >) = RS .
  eq otherMaps(< RS ; RS' >) = RS' .

  eq splitMaps(RS) = splitMapsAux(RS, none, none) .
  eq splitMapsAux((sort S to S'), RS', RS'')
    = splitMapsAux(none, ((sort S to S'), RS'), RS'') .
  eq splitMapsAux(((sort S to S'), RS), RS', RS'')
    = splitMapsAux(RS, ((sort S to S'), RS'), RS'') .
  eq splitMapsAux((class S to S'), RS', RS'')
    = splitMapsAux(none, ((class S to S'), RS'), RS'') .
  eq splitMapsAux(((class S to S'), RS), RS', RS'')
    = splitMapsAux(RS, ((class S to S'), RS'), RS'') .
  eq splitMapsAux(R, RS', RS'')
    = splitMapsAux(none, RS', (R, RS'')) [owise] .
  eq splitMapsAux((R, RS), RS', RS'')
    = splitMapsAux(RS, RS', (R, RS'')) [owise] .
  eq splitMapsAux(none, RS, RS') = < RS ; RS' > .

*** To avoid the interference between the sort and class maps with other maps, the map
*** set is divided in two sets.

  ceq applyMapsToModule(RS, U, M)
    = applyMapsToModuleAux(SRS, ORS, U, M)
    if < SRS ; ORS > := splitMaps(RS) .
  eq applyMapsToModule(RS, U, unitError(QIL)) = unitError(QIL) .

  eq applyMapsToModuleAux(SRS, ORS, mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, M)
    = mod H is
          IL
          sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
          applyMapsToRls(SRS, ORS, RlS, M)
      endm .
  eq applyMapsToModuleAux(SRS, ORS, th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, M)
    = th MN is
          IL sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
          applyMapsToRls(SRS, ORS, RlS, M)
      endth .
  eq applyMapsToModuleAux(SRS, ORS, fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, M)
    = fmod H is
          IL
          sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
      endfm .
  eq applyMapsToModuleAux(SRS, ORS, fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, M)
    = fth MN is
          IL
          sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
      endfth .
  eq applyMapsToModuleAux(SRS, ORS, omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, M)
    = omod H is
           IL
           sorts applyMapsToSortSet(SRS, SS) .
           applyMapsToSubsorts(SRS, SSDS)
           applyMapsToClassDeclSet(SRS, ORS, CDS)
           applyMapsToSubclassDeclSet(SRS, SCDS)
           applyMapsToOps(SRS, ORS, OPDS, M)
           applyMapsToMsgDeclSet(SRS, ORS, MDS, M)
           applyMapsToMbs(SRS, ORS, MAS, M)
           applyMapsToEqs(SRS, ORS, EqS, M)
           applyMapsToRls(SRS, ORS, RlS, M)
      endom .
  eq applyMapsToModuleAux(SRS, ORS, oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, M)
    = oth MN is
           IL
           sorts applyMapsToSortSet(SRS, SS) .
           applyMapsToSubsorts(SRS, SSDS)
           applyMapsToClassDeclSet(SRS, ORS, CDS)
           applyMapsToSubclassDeclSet(SRS, SCDS)
           applyMapsToOps(SRS, ORS, OPDS, M)
           applyMapsToMsgDeclSet(SRS, ORS, MDS, M)
           applyMapsToMbs(SRS, ORS, MAS, M)
           applyMapsToEqs(SRS, ORS, EqS, M)
           applyMapsToRls(SRS, ORS, RlS, M)
      endoth .

  eq applyMapsToOps(RS, RS', (op F : TyL -> Ty [AtS] . OPDS), M)
    = (applyMapsToOp(RS, getRightOpMaps(F, TyL, Ty, RS', M), RS', (op F : TyL -> Ty [AtS] .), M)
       applyMapsToOps(RS, RS', OPDS, M)) .
  eq applyMapsToOps(RS, RS', none, M) = none .

  eq applyMapsToOp(RS, R, RS', (op F : TyL -> Ty [AtS] .), M)
    = (op applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty)
         [applyMapsToAttrs(RS, RS', applyMapToAttrs(R, AtS), M)] .) .
  eq applyMapsToOp(RS, (R, RS'), RS'', (op F : TyL -> Ty [AtS] .), M)
    *** In case of ambiguous mappings we take one of them arbitrarily
    = (op applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty)
         [applyMapsToAttrs(RS, RS'', applyMapToAttrs(R, AtS), M)] .) .
  eq applyMapsToOp(RS, none, RS', (op F : TyL -> Ty [AtS] .), M)
    *** No map for this declaration
    = (op F : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty)
         [applyMapsToAttrs(RS, RS', AtS, M)] .) .

  eq applyMapsToMsgDeclSet(RS, RS', ((msg F : TyL -> Ty .) MDS), M)
    = (applyMapsToMsgDecl(RS, getRightOpMaps(F, TyL, Ty, RS', M), (msg F : TyL -> Ty .), M)
       applyMapsToMsgDeclSet(RS, RS', MDS, M)) .
  eq applyMapsToMsgDeclSet(RS, RS', none, M) = none .

  eq applyMapsToMsgDecl(RS, R, (msg F : TyL -> Ty .), M)
    = (msg applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty) .) .
  eq applyMapsToMsgDecl(RS, (R, RS'), (msg F : TyL -> Ty .), M)
    *** In case of ambiguous mappings we take one of them arbitrarily
    = (msg applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty) .) .
  eq applyMapsToMsgDecl(RS, none, (msg F : TyL -> Ty .), M)
    *** No map for this declaration
    = (msg F : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty) .) .

*** The function \texttt{applyMapToAttrs} just takes care of changing the
*** attributes of the operators as indicated in the renamings. The renamings
*** properly said is accomplished by the function
*** \texttt{applyMapsToAttrs}.

  eq applyMapToAttrs((msg F to F'), AtS) = AtS .
  eq applyMapToAttrs((msg F : TyL -> Ty to F'), AtS) = AtS .
  eq applyMapToAttrs(op_to`term_(T, T'), AtS) = AtS .
  eq applyMapToAttrs((op F to F' [AtS]), AtS')
    = applyMapToAttrsAux(AtS, AtS', none) .
  eq applyMapToAttrs((op F : TyL -> Ty to F' [AtS]), AtS')
    = applyMapToAttrsAux(AtS, AtS', none) .

  *** add the new syntactic attributes
  eq applyMapToAttrsAux((gather(QIL) AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', (gather(QIL) AtS'')) .
  eq applyMapToAttrsAux((format(QIL) AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', (format(QIL) AtS'')) .
  eq applyMapToAttrsAux((prec(I) AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', (prec(I) AtS'')) .
  eq applyMapToAttrsAux((At AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'')
    [owise] .

  *** remove the old syntactic attributes
  eq applyMapToAttrsAux(AtS, (format(QIL) AtS'), AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'') .
  eq applyMapToAttrsAux(AtS, (gather(QIL) AtS'), AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'') .
  eq applyMapToAttrsAux(AtS, (prec(I) AtS'), AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'') .

  eq applyMapToAttrsAux(none, (At AtS), AtS')
    = applyMapToAttrsAux(none, AtS, (At AtS')) .
  eq applyMapToAttrsAux(none, none, AtS) = AtS .

  eq applyMapsToTypeList(RS, (Ty TyL))
    = (applyMapsToType(RS, Ty) applyMapsToTypeList(RS, TyL)) .
  eq applyMapsToTypeList(RS, nil) = nil .

  eq applyMapsToSubsorts(RS, ((subsort S < S' .) SSDS))
    = ((subsort applyMapsToType(RS, S) < applyMapsToType(RS, S') .)
       applyMapsToSubsorts(RS, SSDS)) .
  eq applyMapsToSubsorts(RS, none) = none .

  eq applyMapsToAttrs(RS, RS', (id(T) AtS), M)
    = (id(applyMapsToTerm2(RS, RS', T, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (left-id(T) AtS), M)
    = (left-id(applyMapsToTerm2(RS, RS', T, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (right-id(T) AtS), M)
    = (right-id(applyMapsToTerm2(RS, RS', T, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (special(HkL) AtS), M)
    = (special(applyMapsToHooks(RS, RS', HkL, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (label(L) AtS), M)
    = (label(applyMapsToLabel(RS, L))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', AtS, M) = AtS [owise] .

  eq applyMapsToHooks(RS, RS', id-hook(QI, QIL) HkL, M)
    = id-hook(QI, QIL)
      applyMapsToHooks(RS, RS', HkL, M).
  eq applyMapsToHooks(RS, RS', op-hook(QI, QI', QIL, QI'') HkL, M)
    = applyMapsToHooksAux(RS,
         getRightOpMaps(QI', QIL, QI'', RS', M),
         op-hook(QI, QI', QIL, QI''), M)
      applyMapsToHooks(RS, RS', HkL, M).
  eq applyMapsToHooks(RS, RS', term-hook(QI, T) HkL, M)
    = term-hook(QI, applyMapsToTerm2(RS, RS', T, M))
      applyMapsToHooks(RS, RS', HkL, M).
  eq applyMapsToHooks(RS, RS', nil, M) = nil .

  eq applyMapsToHooksAux(RS, R, op-hook(QI, F, TyL, Ty), M)
    = op-hook(QI, applyOpMapsToOpId(F, R),
         applyMapsToTypeList(RS, TyL), applyMapsToType(RS, Ty)) .
  eq applyMapsToHooksAux(RS, (R, RS'), op-hook(QI, F, TyL, Ty), M)
    *** In case of ambiguous mappings we take any of them arbitrarily
    = op-hook(QI, applyOpMapsToOpId(F, R),
         applyMapsToTypeList(RS, TyL), applyMapsToType(RS, Ty)) .
  eq applyMapsToHooksAux(RS, none, op-hook(QI, F, TyL, Ty), M)
    = op-hook(QI, F, applyMapsToTypeList(RS, TyL),
        applyMapsToType(RS, Ty)) .

  eq applyMapsToMbs(RS, RS', ((mb T : S [AtS] .) MAS), M)
    = ((mb applyMapsToTerm2(RS, RS', T, M) : applyMapsToType(RS, S)
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToMbs(RS, RS', MAS, M)) .
  eq applyMapsToMbs(RS, RS', ((cmb T : S if Cond [AtS] .) MAS), M)
    = ((cmb applyMapsToTerm2(RS, RS', T, M) : applyMapsToType(RS, S)
          if applyMapsToCond(RS, RS', Cond, M)
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToMbs(RS, RS', MAS, M)) .
  eq applyMapsToMbs(RS, RS', none, M) = none .

  eq applyMapsToEqs(RS, RS', ((ceq T = T' if Cond [AtS] .) EqS), M)
    = ((ceq applyMapsToTerm2(RS, RS', T, M)
          = applyMapsToTerm2(RS, RS', T', M)
          if applyMapsToCond(RS, RS', Cond, M)
        [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToEqs(RS, RS', EqS, M)) .
  eq applyMapsToEqs(RS, RS', ((eq T = T' [AtS] .) EqS), M)
    = ((eq applyMapsToTerm2(RS, RS', T, M)
          = applyMapsToTerm2(RS, RS', T', M)
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToEqs(RS, RS', EqS, M)) .
  eq applyMapsToEqs(RS, RS', none, M) = none .

  eq applyMapsToRls(RS, RS', ((crl T => T' if Cond [AtS] .) RlS), M)
    = ((crl applyMapsToTerm2(RS, RS', T, M)
          => applyMapsToTerm2(RS, RS', T', M)
          if applyMapsToCond(RS, RS', Cond, M)
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToRls(RS, RS', RlS, M)) .
  eq applyMapsToRls(RS, RS', ((rl T => T' [AtS] .) RlS), M)
    = ((rl applyMapsToTerm2(RS, RS', T, M)
          => applyMapsToTerm2(RS, RS', T', M)
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToRls(RS, RS', RlS, M)) .
  eq applyMapsToRls(RS, RS', none, M) = none .

  eq applyMapsToCond(RS, RS', T = T' /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) = applyMapsToTerm2(RS, RS', T', M)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', T : S /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) : applyMapsToSort(RS, S)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', T := T' /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) := applyMapsToTerm2(RS, RS', T', M)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', T => T' /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) => applyMapsToTerm2(RS, RS', T', M)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', nil, M) = nil .

  eq applyMapsToLabel((label L to L'), L'')
    = if L == L''
      then L'
      else L''
      fi .
  eq applyMapsToLabel(((label L to L'), RS), L'')
    = if L == L''
      then L'
      else applyMapsToLabel(RS, L'')
      fi .
  eq applyMapsToLabel(R, L) = L [owise] .
  eq applyMapsToLabel((R, RS), L)
    = applyMapsToLabel(RS, L)
    [owise] .
  eq applyMapsToLabel(none, L) = L .

  eq applyMapsToClassDeclSet(RS, RS', class C | ADS . CDS)
    = (class applyMapsToClassName(RS, C) | applyMapsToAttrDeclSet(RS, RS', C, ADS) .
       applyMapsToClassDeclSet(RS, RS', CDS)) .
  eq applyMapsToClassDeclSet(RS, RS', none) = none .

  eq applyMapsToAttrDeclSet(RS, RS', C, ((attr A : Ty), ADS))
    = ((attr applyMapsToAttrName(RS', C, A) : applyMapsToType(RS, Ty)),
       applyMapsToAttrDeclSet(RS, RS', C, ADS)) .
  eq applyMapsToAttrDeclSet(RS, RS', C, none) = none .

  eq applyMapsToAttrName((attr A . C to A'), C', A'')
    = if (C == C') and (A == A'')
      then A'
      else A''
      fi .
  eq applyMapsToAttrName(((attr A . C to A'), RS), C', A'')
    = if (C == C') and (A == A'')
      then A'
      else applyMapsToAttrName(RS, C', A'')
      fi .
  eq applyMapsToAttrName(R, C, A) = A [owise] .
  eq applyMapsToAttrName((R, RS), C, A)
    = applyMapsToAttrName(RS, C, A)
    [owise] .
  eq applyMapsToAttrName(none, C, A) = A .

  eq applyMapsToSubclassDeclSet(RS, subclass C < C' . SCDS)
    = (subclass applyMapsToClassName(RS, C) < applyMapsToClassName(RS, C') .
       applyMapsToSubclassDeclSet(RS, SCDS)) .
  eq applyMapsToSubclassDeclSet(RS, none) = none .
endfm

*******************************************************************************

***
*** 6.9 Instantiation of Parameterized Modules and the
***     \texttt{META-LEVEL} Module Expression

*** A parameterized module
*** $\texttt{M[L}_1\texttt{\ ::\ T}_1\texttt{,\}\ldots\texttt{, L}_n
*** \texttt{ :: T}_n\texttt{]}$, with \mbox{$\texttt{L}_1\ldots\texttt{L}_n$}
*** labels and \mbox{$\texttt{T}_1\ldots\texttt{T}_n$} theory identifiers, is
*** represented as a module with name \texttt{M} which contains parameter
*** declarations  \mbox{$\texttt{par\ L}_i\texttt{\ ::\ T}_i$} for
*** $1\leq i\leq n$, and an importation declaration
*** \mbox{$\texttt{inc\ par\ L}_i\texttt{\ ::\ T}_i\texttt{\ .}$} for each
*** parameter \mbox{$\texttt{L}_i\texttt{\ ::\ T}_i$} in its interface.  Note
*** that all modules are handled in a uniform way: nonparameterized modules
*** and theories have their list of parameters set to \texttt{nil}.

*** The instantiation of the formal parameters of a parameterized module with
*** actual modules or theories requires a view from each formal parameter
*** theory to its corresponding actual unit. The process of instantiation
*** results in the replacement of each interface theory by its corresponding
*** actual parameter, using the views to bind actual names to formal names.

*** The naming conventions for sorts have to be taken into account in the
*** instantiation process: every occurrence of a sort coming from a theory in
*** the interface of a module must be qualified by its theory's label, and
*** sorts defined in the body of a parameterized module can be parameterized
*** by the labels in the interface of the module (see
*** Section~\ref{parameterized-modules}).

*** The labeling convention for theories and for the sorts coming from them is
*** very useful to avoid collisions of sort names coming from the parameter
*** theories, and also to allow different uses of the same theory several
*** times in the interface of a module. We assume that all sorts coming from
*** the theory part of the parameter theories are used in their qualified form
*** to manipulate the maps defined in the views before being applied to the
*** body of the module being instantiated. If the target of a view is a
*** theory, the sorts from the theory part of the target theory appearing in
*** the targTS of the maps in the view will be qualified as well, following
*** the same convention.

*** When a parameterized module
*** $\texttt{M[L}_1\texttt{\ ::\ T}_1\texttt{,\ }
***            \ldots\texttt{,\ L}_n\texttt{\ ::\ T}_n\texttt{]}$
*** is instantiated with views $\texttt{V}_1\ldots\texttt{V}_n$, each
*** parameterized sort $\texttt{S[L}_1\texttt{,}\ldots\texttt{,L}_n\texttt{]}$
*** in the body of the parameterized module is renamed to
*** $\texttt{S[V}_1\texttt{,}\ldots\texttt{,V}_n\texttt{]}$.

*** The discussion on the qualification of sorts in views before being used in
*** the instantiation process applies in a completely similar way to class
*** names in parameterized object-oriented modules.

*** As we saw in Section~\ref{module-expressions}, it is possible to import a
*** module expression in which a parameterized module is instantiated by some
*** of the formal parameters of the parameterized module in which it is
*** imported. This is done by using the label of some of the parameters in the
*** interface of a module, say \mbox{$\texttt{L}_k\texttt{\ ::\ T}_k$}, in a
*** module expression in which some parameterized module \texttt{N} with formal
*** parameter $\texttt{T}_k$ is instantiated with $\texttt{L}_k$, that is, we
*** have the module expression $\texttt{N[}\ldots\texttt{L}_k\ldots\texttt{]}$.
*** In this case, $\texttt{L}_k$ is considered as the identity view for the
*** theory $\texttt{T}_k$ with $\texttt{L}_k$ as name. Note that to be able to
*** check whether a label in the interface of a module is used in an
*** instantiation of this form, in the evaluation of a module expression the
*** list of parameters of the module in which the module expression appears
*** must be available. This is the reason why the \texttt{evalModExp} function
*** was defined with \texttt{ParameterList} as one of the sorts in its
*** arity (see Section~\ref{evalModExp}). For module expressions appearing
*** outside of any module, that is, in commands, etc., this list will be set
*** to \texttt{nil}.

*** Note that this kind of instantiation may produce a `cascade' effect. The
*** module being instantiated may itself import other module expressions in
*** which labels of some of its parameter theories are used in the
*** instantiation of some of these imported module expressions. This is handled
*** by `preparing' the module expressions appearing in the importation
*** declarations of the module (\texttt{prepImports}). This process
*** consists in changing the labels of the interface of the module being
*** instantiated which are used in the importations of module expressions by
*** the corresponding view names (\texttt{prepHeader}). After completing the
*** generation of the module resulting from the evaluation of the module
*** expression, this module will be evaluated with the \texttt{evalModule}
*** function, producing the evaluation of these new module expressions. In any
*** extension of the language, new equations for the function
*** \texttt{prepHeader} will have to be added for each new kind of module
*** expression being defined.

*** In Sections~\ref{renaming} and~\ref{extension} we shall see how new
*** equations completing the semantics of \texttt{prepHeader} are added for
*** each new module expression being defined. In the case of the renaming
*** module expression, the renaming maps will have to be prepared as well, to
*** adjust the sort names being renamed to the conventions discussed above.

*** As for any other module expression being defined, in addition to the
*** operator declaration for the constructor of the instantiation module
*** expression, equations completing the semantics of operators
*** \texttt{evalModExp}, \texttt{header2QidList}, and
*** \texttt{setUpModExpDeps} have to be given.

fmod INST-EXPR-EVALUATION is
  pr EVALUATION .
  pr RENAMING-SET-APPL-ON-UNIT .
  inc MOD-EXPR .
  inc MOD-NAME .
  pr DATABASE .

*** We start by giving the new constructor for sort \texttt{ModuleExpression}.
*** Note thatthe modules \texttt{MOD-EXPR} and \texttt{MOD-NAME} have been
*** imported in \texttt{including} mode.

  vars QI QI' QI'' X Y W Z C F F' A A' L L' : Qid .
  var  QIL : QidList .
  vars M M' PU U U' U'' DM : Module .
  var  Th : OTheory .
  vars ME ME' ME'' : ModuleExpression .
  var  H : Header .
  vars MN MN' : ModuleName .
  vars MNS MNS' MNS'' MNS3 MNS4 MNS5 : Set{ModuleName} .
  vars VE VE' VE'' VE3 VE4 : ViewExp .
  vars VES VES' : Set{ViewExp} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars DB DB' DB'' : Database .
  var  PD : ParameterDecl .
  vars PDL PDL' PDL'' PDL3 PDL4 PDL5 : ParameterDeclList .
  var  PDS : Set{ParameterDecl} .
  vars PL PL' PL'' PL3 : ParameterList .
  vars S S' P P' P'' : Sort .
  vars IL IL' IL'' IL3 : ImportList .
  vars SMS SMS' SMS'' SMS3 : SortMappingSet .
  vars OMS OMS' OMS'' OMS3 : OpMappingSet .
  var  V : Variable .
  var  Ct : Constant .
  var  SL : QidList .
  var  Ty : Type .
  var  TyL : TypeList .
  vars SS SS' SS'' : SortSet .
  var  K : Kind .
  vars T T' O : Term .
  var  DT : Default{Term} .
  var  TL : TermList .
  var  CDS : ClassDeclSet .
  var  ADS : AttrDeclSet .
  var  B : Bool .
  var  AtS : AttrSet .
  var  N : Nat .
  var  PV : PreView .
  var  VI : View .
  var  VDS : OpDeclSet .
  vars RS RS' RS'' SRS SRS' ORS ORS' : RenamingSet .

*** In the input given by the user, the operator \verb~_(_)~ is used both for
*** the instantiation of module expressions, and for expressions
*** parameterizing the module \texttt{META-LEVEL} with a list of module names.
*** The function \texttt{evalModExp} distinguishes these two cases, calling
*** the function \texttt{unitInst} in the former and the function
*** \texttt{prepMetalevel} in the latter.

  op unitInst : Header ParameterList ParameterDeclList Database -> Database .
  op prepMetalevel : ParameterList Database -> Database .

  eq evalModExp(ME{PL}, PDL, DB)
    = if unitInDb(ME{PL}, DB)
      then < DB ; ME{PL} >
      else if ME == 'META-LEVEL
           then < prepMetalevel(PL, DB) ; ME{PL} >
           else < unitInst(
                    modExp(evalModExp(ME, PDL, evalViewExp(PL, PDL, DB))),
                    PL, PDL,
                    database(evalModExp(ME, PDL, evalViewExp(PL, PDL, DB))))
                  ;
                  modExp(evalModExp(ME, PDL, evalViewExp(PL, PDL, DB))){PL} >
           fi
      fi .

*** The function \texttt{prepMetalevel} creates a new module with the
*** module expression being evaluated as name, which imports the predefined
*** \texttt{META-LEVEL} module. For each module name \texttt{I} in the list
*** given as parameter of the expression, the declaration of a constant
*** \texttt{I} of sort \texttt{Module} and an equation identifying such
*** constant with the metarepresentation of the module with such name in the
*** database are added to the module being created.

  op prepMetalevelAux : ParameterList Module Database -> Database .

  eq prepMetalevel(PL, DB)
    = prepMetalevelAux(PL,
        addImports((including 'META-LEVEL .),
          setName(emptyFModule, 'META-LEVEL{PL})), DB) .

  eq prepMetalevelAux((QI), U, DB)
    = prepMetalevelAux(nil,
        addOps((op qid("META-" + string(QI)) : nil -> 'Module [none] .),
          addEqs((eq qid("META-" + string(QI) + ".Module")
                    = up(getFlatModule(QI, database(evalModExp(QI, DB))))
                    [none] .),
            U)),
        DB) .
  eq prepMetalevelAux((QI, PL), U, DB)
    = prepMetalevelAux(PL,
        addOps((op qid("META-" + string(QI)) : nil -> 'Module [none] .),
          addEqs((eq qid("META-" + string(QI) + ".Module")
                    = up(getFlatModule(QI, database(evalModExp(QI, DB))))
                    [none] .),
            U)),
        DB) .
  eq prepMetalevelAux(nil, U, DB) = evalModule(U, none, DB) .

*** The function \texttt{getClassNames} returns the set of the names of
*** the classes in a set of class declarations.

  op getClassNames : ClassDeclSet -> SortSet .

  eq getClassNames(((class S | ADS .) CDS))
    = (S ; getClassNames(CDS)) .
  eq getClassNames(none) = none .

*** The following `getTh' functions return the corresponding elements in the
*** theory part of the structure of the given unit. For example, the function
*** \texttt{getThSorts} returns the set of sorts declared in the ``loose
*** part'' of the structure of the unit in the database having the name
*** indicated as first argument.

  op getThSorts : ModuleExpression Database -> SortSet .
  op getThClasses : ModuleExpression Database -> SortSet .
  op getThSortsAux : ImportList Database -> SortSet .
  op getThClassesAux : ImportList Database -> SortSet .

  eq getThSorts(ME, DB)
    = if theory(getTopModule(ME, DB))
      then (getThSortsAux(getImports(getTopModule(ME, DB)), DB) ;
            getSorts(getTopModule(ME, DB)))
      else none
      fi .

  eq getThSortsAux(((including MN .) IL), DB)
    = (getThSorts(MN, DB) ; getThSortsAux(IL, DB)) .
  eq getThSortsAux(((extending MN .) IL), DB)
    = (getThSorts(MN, DB) ; getThSortsAux(IL, DB)) .
  eq getThSortsAux(((protecting MN .) IL), DB)
    = (getThSorts(MN, DB) ; getThSortsAux(IL, DB)) .
  eq getThSortsAux(nil, DB) = none .

  eq getThClasses(ME, DB)
    = if getTopModule(ME, DB) :: OTheory
         and-then not getTopModule(ME, DB) :: STheory
      then (getThClassesAux(getImports(getTopModule(ME, DB)), DB) ;
            getClassNames(getClasses(getTopModule(ME, DB))))
      else none
      fi .

  eq getThClassesAux(((including MN .) IL), DB)
    = (getThClasses(MN, DB) ; getThClassesAux(IL, DB)) .
  eq getThClassesAux(((extending MN .) IL), DB)
    = (getThClasses(MN, DB) ; getThClassesAux(IL, DB)) .
  eq getThClassesAux(((protecting MN .) IL), DB)
    = (getThClasses(MN, DB) ; getThClassesAux(IL, DB)) .
  eq getThClassesAux(nil, DB) = none .

*** The `get' functions return the corresponding elements in the structure of
*** the given unit. For example, \texttt{getSortSet} returns all the sorts
*** declared in the structure of the unit in the database having the name
*** given as first argument.

  op getSortSet : ModuleName Database -> SortSet .
  op getClassSet : ModuleName Database -> SortSet .

  op getSortSetAux : ImportList Database -> SortSet .
  op getClassSetAux : ImportList Database -> SortSet .

  eq getSortSet(MN, DB)
    = (getSortSetAux(getImports(getTopModule(MN, DB)), DB) ;
       getSorts(getTopModule(MN, DB))) .

  eq getSortSetAux(((including MN .) IL), DB)
    = (getSortSet(MN, DB) ; getSortSetAux(IL, DB)) .
  eq getSortSetAux(((extending MN .) IL), DB)
    = (getSortSet(MN, DB) ; getSortSetAux(IL, DB)) .
  eq getSortSetAux(((protecting MN .) IL), DB)
    = (getSortSet(MN, DB) ; getSortSetAux(IL, DB)) .
  eq getSortSetAux(nil, DB) = none .

  eq getClassSet(MN, DB)
    = (getClassSetAux(getImports(getTopModule(MN, DB)), DB) ;
       getClassNames(getClasses(getTopModule(MN, DB)))) .

  eq getClassSetAux(((including MN .) IL), DB)
    = (getClassSet(MN, DB) ; getClassSetAux(IL, DB)) .
  eq getClassSetAux(((extending MN .) IL), DB)
    = (getClassSet(MN, DB) ; getClassSetAux(IL, DB)) .
  eq getClassSetAux(((protecting MN .) IL), DB)
    = (getClassSet(MN, DB) ; getClassSetAux(IL, DB)) .
  eq getClassSetAux(nil, DB) = none .

*** As pointed out in Section~\ref{parameterized-modules}, in a parameterized
*** module all occurrences of sorts or classes coming from the parameter
*** theories have to be qualified. \texttt{createCopy} is the function used
*** for creating these renamed copies of the parameters. As also explained in
*** Section~\ref{parameterized-modules}, if a parameter theory is structured,
*** the renaming is carried out not only at the top level, but for the entire
*** ``theory part'' in the structure.

*** The function \texttt{createCopy} calls an auxiliary function,
*** \texttt{prepPar}, which recursively proceeds through all the subtheories
*** of the given theory. For each theory in the structure, the required set of
*** maps is generated and applied to such a theory using the
*** \texttt{applyMapsToModule} function discussed in
*** Section~\ref{applyMapsToModule}, which is then evaluated and entered into
*** the database. Note that the renamings to which a theory is subjected must
*** also be applied to the theories importing it. The new database and the
*** renaming maps applied to the theory will have to be returned by the
*** function.

*** The function \texttt{prepPar} makes a copy of the theory specified by the
*** name given as first argument and of all its subtheories (only theories, no
*** modules), and qualifies all the sorts appearing in it with the label given
*** in the declaration of the parameter, which is given as second argument.

  pr 2TUPLE{ViewExp,ViewExp}
       * (op ((_,_)) to <_;_>,
          op p1_ to 1st,
          op p2_ to 2nd).

  sorts ---- Tuple{ViewExp,ViewExp}
        Set{Tuple{ViewExp,ViewExp}}
        prepParResult  .
  subsort Tuple{ViewExp,ViewExp} < Set{Tuple{ViewExp,ViewExp}} .
----  op <_;_> : ViewExp ViewExp -> Tuple{ViewExp,ViewExp} .
----  ops 1st 2nd : Tuple{ViewExp,ViewExp} -> ViewExp .
  op none : -> Set{Tuple{ViewExp,ViewExp}} .
  op __ : Set{Tuple{ViewExp,ViewExp}} Set{Tuple{ViewExp,ViewExp}}
      -> Set{Tuple{ViewExp,ViewExp}} [assoc comm id: none] .

  vars VEPS VEPS' : Set{Tuple{ViewExp,ViewExp}} .

----  eq 1st(< VE ; VE' >) = VE .
----  eq 2nd(< VE ; VE' >) = VE' .

  op prepPar : Qid Qid ModuleExpression Database -> prepParResult .
  op prepParImports : ImportList ImportList Qid Qid SortMappingSet OpMappingSet
        Set{Tuple{ViewExp,ViewExp}} ParameterDeclList Database -> prepParResult .

  op <_;_;_;_;_;_;_;_> : SortMappingSet OpMappingSet Database ViewExp ViewExp Set{Tuple{ViewExp,ViewExp}} Bool ImportList -> prepParResult .
  op sortMappingSet : prepParResult -> SortMappingSet .
  op opMappingSet : prepParResult -> OpMappingSet .
  op database : prepParResult -> Database .
  op sourceViewExp : prepParResult -> ViewExp .
  op targetViewExp : prepParResult -> ViewExp .
  op viewExpPairSet : prepParResult -> Set{Tuple{ViewExp,ViewExp}} .
  op theoryFlag : prepParResult -> Bool .
  op getImports : prepParResult -> ImportList .
  eq opMappingSet(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = OMS .
  eq sortMappingSet(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = SMS .
  eq database(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = DB .
  eq sourceViewExp(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = VE .
  eq targetViewExp(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = VE' .
  eq viewExpPairSet(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = VEPS .
  eq theoryFlag(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = B .
  eq getImports(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = IL .

  ----op createCopy : ParameterDecl Database -> Database .
  op prepPar : Qid ModuleExpression Database  -> prepParResult .
  op prepParImports : ImportList ImportList Qid SortMappingSet OpMappingSet
        Set{Tuple{ViewExp,ViewExp}} ParameterDeclList Database -> prepParResult .

  eq createCopy(X :: ME, DB)
    = if unitInDb(pd(X :: ME), DB)
      then DB
      else database(prepPar(X, ME, database(evalModExp(ME, DB))))
      fi .

  ceq prepPar(X, ME, DB)
    = < SMS' ;
        OMS ;
        (if unitInDb(pd(X :: ME), DB)
         then DB
         else evalModule(
                setImports(
                  setName(
                    applyMapsToModule(maps2rens(SMS'), maps2rens(OMS), Th, getFlatModule(ME, DB)),
                    pd(X :: ME)),
                  IL),
                applyMapsToOps(maps2rens(SMS'), maps2rens(OMS), getVars(ME, DB), getFlatModule(ME, DB)),
                DB')
         fi) ;
        mtViewExp ; mtViewExp ; none ; true ; nil >
    if Th := getTopModule(ME, DB)
       /\ < SMS ; OMS ; DB' ; VE ; VE' ; VEPS ; B ; IL > := prepParImports(getImports(Th), nil, X, none, none, none, X :: ME, DB)
       /\ SMS' := (SMS
                   sortMapsPar(X, getSorts(Th), none)
                   classMapsPar(X, classSet(getClasses(Th)), none)) .
  eq prepPar(X, ME, DB)
    = < none ; none ; warning(DB, '\r 'Error: '\o 'Incorrect 'parameter '\n) ;
        mtViewExp ; mtViewExp ; none ; false ; nil >
      [owise] .

  ceq prepParImports(((including ME .) IL), IL', X, SMS, OMS, VEPS, PDL, DB)
    = if B
      then prepParImports(IL, (IL' (including pd(X :: ME') .)), X, (SMS SMS'), (OMS OMS'), VEPS, PDL, DB')
      else prepParImports(IL, (IL' (including ME .)), X, SMS, OMS, VEPS, PDL, DB)
      fi
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((extending ME .) IL), IL', X, SMS, OMS, VEPS, PDL, DB)
    = if B
      then *** A theory shouldn't be imported in protecting mode
           prepParImports(IL, (IL' (extending pd(X :: ME') .)), X, (SMS SMS'), (OMS OMS'), VEPS, PDL, DB')
      else prepParImports(IL, (IL' (extending ME .)), X, SMS, OMS, VEPS, PDL, DB)
      fi
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((protecting ME .) IL), IL', X, SMS, OMS, VEPS, PDL, DB)
    = if B
      then *** A theory shouldn't be imported in protecting mode
           prepParImports(IL, (IL' (protecting pd(X :: ME') .)), X, (SMS SMS'), (OMS OMS'), VEPS, PDL, DB')
      else prepParImports(IL, (IL' (protecting ME .)), X, SMS, OMS, VEPS, PDL, DB)
      fi
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((including pd(X :: ME) .) IL), IL', Y, SMS, OMS, (< X ; Z > VEPS), PDL, DB)
    = prepParImports(IL, (IL' (including pd(Z :: ME') .)), Y, (SMS SMS'), (OMS OMS'), (< X ; Z > VEPS), PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((extending pd(X :: ME) .) IL), IL', Y, SMS, OMS, (< X ; Z > VEPS), PDL, DB)
    = prepParImports(IL, (IL' (extending pd(Z :: ME') .)), Y, (SMS SMS'), (OMS OMS'), (< X ; Z > VEPS), PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((protecting pd(X :: ME) .) IL), IL', Y, SMS, OMS, (< X ; Z > VEPS), PDL, DB)
    = prepParImports(IL, (IL' (protecting pd(Z :: ME') .)), Y, (SMS SMS'), (OMS OMS'), (< X ; Z > VEPS), PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  eq prepParImports(nil, IL, X, SMS, OMS, VEPS, PDL, DB)
    = < SMS ; OMS ; DB ; mtViewExp ; mtViewExp ; none ; false ; IL > .

  ceq prepPar(X, Y, ME, DB)
    = (< SMS' ; OMS ;
        (if unitInDb(pd(Y :: ME), DB)
         then DB
         else evalModule(
                setImports(
                  setName(
                    applyMapsToModule(maps2rens(SMS'), maps2rens(OMS), getTopModule(pd(X :: ME), DB), getFlatModule(pd(X :: ME), DB)),
                    pd(Y :: ME)),
                  IL),
                applyMapsToOps(maps2rens(SMS'), maps2rens(OMS), getVars(pd(X :: ME), DB), getFlatModule(pd(X :: ME), DB)),
                DB')
         fi) ;
        X ; Y ; < X ; Y > ; true ; nil >)
    if Th := getTopModule(ME, DB)
    /\ (< SMS ; OMS ; DB' ; VE ; VE' ; VEPS ; B ; IL >) := prepParImports(getImports(Th), nil, X, Y, none, none, < X ; Y >, X :: ME, DB)
    /\ SMS' := (SMS
                genMapsQualSorts(X, Y, getSorts(Th), none)
                genMapsQualClasses(X, Y, classSet(getClasses(Th)), none)) .

  eq prepParImports(((including ME .) IL), IL', X, Y, SMS, OMS, VEPS, PDL, DB)
    = prepParImports(IL, (IL' including ME .), X, Y, SMS, OMS, VEPS, PDL, DB) .
  eq prepParImports(((extending ME .) IL), IL', X, Y, SMS, OMS, VEPS, PDL, DB)
    = prepParImports(IL, (IL' extending ME .), X, Y, SMS, OMS, VEPS, PDL, DB) .
  eq prepParImports(((protecting ME .) IL), IL', X, Y, SMS, OMS, VEPS, PDL, DB)
    = prepParImports(IL, (IL' protecting ME .), X, Y, SMS, OMS, VEPS, PDL, DB) .
  ceq prepParImports(including pd(X :: ME) . IL, IL', Y, Z, SMS, OMS, VEPS, PDL, DB)
    = prepParImports(IL, IL' including pd(X :: ME') ., Y, Z, (SMS SMS'), (OMS OMS'), VEPS, PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(Y, Z, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(extending pd(X :: ME) . IL, IL', Y, Z, SMS, OMS, VEPS, PDL, DB)
    = prepParImports(IL, IL' extending pd(X :: ME') ., Y, Z, (SMS SMS'), (OMS OMS'), VEPS, PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(Y, Z, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(protecting pd(X :: ME) . IL, IL', Y, Z, SMS, OMS, VEPS, PDL, DB)
    = prepParImports(IL, IL' protecting pd(X :: ME') ., Y, Z, (SMS SMS'), (OMS OMS'), VEPS, PDL, DB')
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(Y, Z, ME', database(evalModExp(ME', PDL, DB))) .
  eq prepParImports(nil, IL, X, Y, SMS, OMS, VEPS, PDL, DB)
    = < SMS ; OMS ; DB ; mtViewExp ; mtViewExp ; none ; false ; IL > .

  op sortMapsPar : Qid SortSet Set{Tuple{ViewExp,ViewExp}} -> SortMappingSet .
  op classMapsPar : Qid SortSet Set{Tuple{ViewExp,ViewExp}} -> SortMappingSet .

  op qualify : Qid Sort -> Sort .
  op qualify : Qid Sort Set{Tuple{ViewExp,ViewExp}} -> Sort .
  op qualify : Qid Sort ParameterList ParameterList Set{Tuple{ViewExp,ViewExp}} -> Sort .

  eq qualify(X, S) = qualify(X, getName(S), getPars(S), empty, none) .

  eq qualify(X, S, VEPS) = qualify(X, getName(S), getPars(S), empty, VEPS) .

  eq qualify(X, S, (P, PL), PL', < P ; P' > VEPS)
    = qualify(X, S, PL, PL' P', < P ; P' > VEPS) .
  eq qualify(X, S, (P, PL), PL', VEPS)
    = qualify(X, S, PL, PL' P, VEPS)
    [owise] .
  eq qualify(X, S, empty, PL, VEPS)
    = qid(string(X) + "$" + string(makeSort(S, PL))) .

  eq sortMapsPar(X, (S ; SS), VEPS)
    = (sort S to qualify(X, S, VEPS) . sortMapsPar(X, SS, VEPS)) .
  eq sortMapsPar(X, none, VEPS) = none .

  eq classMapsPar(X, (S ; SS), VEPS)
    = (class S to qualify(X, S, VEPS) . classMapsPar(X, SS, VEPS)) .
  eq classMapsPar(X, none, VEPS) = none .

*** When one of the labels of the interface of a module is being used in a
*** module expression to instantiate some formal parameter of a module, then,
*** in the evaluation of such module expression the qualification of all sorts
*** and class names coming from the theory part of the parameter theory have
*** to be changed according to such a label. In the evaluation of an
*** instantiation module expression this is done by generating the
*** corresponding renaming maps, which are then applied to the module being
*** instantiated. Given labels \texttt{L} and \texttt{L'}, for each sort or
*** class name \texttt{S} in the set given as argument, a map of the form
*** \verb~L$S to L'$S~ is generated.

  op genMapsQualSorts : Qid Qid SortSet Set{Tuple{ViewExp,ViewExp}} -> SortMappingSet .
  op genMapsQualClasses : Qid Qid SortSet Set{Tuple{ViewExp,ViewExp}} -> SortMappingSet .

  eq genMapsQualSorts(X, Y, (S ; SS), VEPS)
    = (sort qualify(X, S, VEPS) to qualify(Y, S, VEPS) .
       genMapsQualSorts(X, Y, SS, VEPS)) .
  eq genMapsQualSorts(X, Y, none, VEPS) = none .

  eq genMapsQualClasses(X, Y, (S ; SS), VEPS)
    = (class qualify(X, S, VEPS) to qualify(Y, S, VEPS) .
       genMapsQualClasses(X, Y, SS, VEPS)) .
  eq genMapsQualClasses(X, Y, none, VEPS) = none .

*** The function \texttt{prepare} takes the map set of a view and
*** prepares it to be used in an instantiation by transforming sort and class
*** names into their qualified form, if required (sorts and class names in a
*** view have to be qualified only if they were defined in a theory).

*** The \texttt{prepare} function takes six arguments: The sets of maps
*** to be prepared, the label with which the sorts to be renamed have to be
*** qualified, the set of sorts in the theory part of the source of the view,
*** and the set of sorts and class names in the theory part of the target of
*** the view.

*** Note that we assume that there is a sort map and a class map for each sort
*** and class in the theory part of the source of the view. Therefore, sorts
*** and class names appearing as sources of sort and class maps are
*** systematically qualified. The sorts or class names used in the targets of
*** the maps will be qualified only if they were declared in a theory. In maps
*** for operators in which the arity and coarity are specified, or for those
*** going to derived terms, the sorts appearing in the arity or coarity of an
*** operator and those used to qualify terms, or in sort tests in terms, must
*** also be qualified. However, in these cases the qualification cannot be
*** done on all sorts, but only on those defined in the theory parts. This is
*** the reason why the sets of sorts in the theory parts of the source and
*** target and the set of class names in the target of the view are given when
*** calling \texttt{prepare}.

  op prepare : SortMappingSet Qid SortSet SortSet SortSet -> SortMappingSet .
  op prepare : OpMappingSet Qid SortSet SortSet SortSet -> OpMappingSet .

  op prepare : TypeList Qid SortSet -> TypeList .
  op prepTerm : TermList Qid SortSet -> TermList .

  eq prepare(sort S to S' . SMS, X, SS, SS', SS'')
    = (if S' in SS'
       then sort qualify(X, S) to qualify(X, S') .
       else sort qualify(X, S) to S' .
       fi
       prepare(SMS, X, SS, SS', SS'')) .
  eq prepare(class S to S' . SMS, X, SS, SS', SS'')
    = (if S' in SS''
       then (class qualify(X, S) to qualify(X, S') .)
       else (class qualify(X, S) to S' .)
       fi
       prepare(SMS, X, SS, SS', SS'')) .
  eq prepare((none).SortMappingSet, X, SS, SS', SS'') = none .

  eq prepare(op F to F' . OMS, X, SS, SS', SS'')
    = (op F to F' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(op F : TyL -> Ty to F' . OMS, X, SS, SS', SS'')
    = (op F : prepare(TyL, X, SS) -> prepare(Ty, X, SS) to F' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(op T to term T' . OMS, X, SS, SS', SS'')
    = (op prepTerm(T, X, SS) to term prepTerm(T', X, SS') .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(msg F to F' . OMS, X, SS, SS', SS'')
    = (msg F to F' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(msg F : TyL -> Ty to F' . OMS, X, SS, SS', SS'')
    = (msg F : prepare(TyL, X, SS) -> prepare(Ty, X, SS) to F' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(attr A . S to A' . OMS, X, SS, SS', SS'')
    = (attr A . qualify(X, S) to A' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare((none).OpMappingSet, X, SS, SS', SS'') = none .

  eq prepare((S TyL), X, (S ; SS)) = (qualify(X, S) prepare(TyL, X, (S ; SS))) .
  eq prepare((K TyL), X, SS) = prepare((getSort(K) TyL), X, SS) .
  eq prepare((S TyL), X, SS) = (S prepare(TyL, X, SS)) [owise] .
  eq prepare(nil, X, SS) = nil .

  eq prepTerm(F[TL], X, SS) = F[prepTerm(TL, X, SS)] .
  eq prepTerm(V, X, SS)
    = if getType(V) in SS
      then qid(string(getName(V)) + ":" + string(qualify(X, getType(V))))
      else qid(string(getName(V)) + ":" + string(getType(V)))
      fi .
  eq prepTerm(Ct, X, SS)
    = if getType(Ct) in SS
      then qid(string(getName(Ct)) + "." + string(qualify(X, getType(Ct))))
      else qid(string(getName(Ct)) + "." + string(getType(Ct)))
      fi .
  ceq prepTerm((T, TL), X, SS)
    = (prepTerm(T, X, SS), prepTerm(TL, X, SS))
    if TL =/= empty .
  eq prepTerm(qidError(QIL), X, SS) = qidError(QIL) .

*** For each parameterized sort
*** $\texttt{S[L}_1\texttt{,}\ldots\texttt{,L}_n\texttt{]}$ in the
*** body of a parameterized module with
*** $\texttt{L}_1\ldots\texttt{L}_n$ the labels of the parameters in
*** the interface of the module, a map of the form 9
*** $\texttt{sort\ S[L}_1\texttt{,}\ldots\texttt{,L}_n\texttt{]\
***      to\ S[V}_1\texttt{,}\ldots\texttt{,V}_n\texttt{]}$
*** is generated, where $\texttt{V}_i$ is the name of the view associated to
*** the label $\texttt{L}_i$ in the set of pairs given as argument.

  op genMapsSorts : SortSet Set{Tuple{ViewExp,ViewExp}} -> SortMappingSet .
  op genMapsClasses : SortSet Set{Tuple{ViewExp,ViewExp}} -> SortMappingSet .

  op prepSort : Sort Set{Tuple{ViewExp,ViewExp}} -> Sort .
  op prepSort : Sort ParameterList ParameterList Set{Tuple{ViewExp,ViewExp}} -> Sort .

  eq genMapsSorts((S ; SS), VEPS)
    = (if prepSort(S, VEPS) == S
       then none
       else (sort S to prepSort(S, VEPS) .)
       fi)
      genMapsSorts(SS, VEPS) .
  eq genMapsSorts(none, VEPS) = none .

  eq genMapsClasses((S ; SS), VEPS)
    = (if prepSort(S, VEPS) == S
       then none
       else (class S to prepSort(S, VEPS) .)
       fi)
      genMapsClasses(SS, VEPS) .
  eq genMapsClasses(none, VEPS) = none .

  eq prepSort(S, VEPS) = prepSort(getName(S), empty, getPars(S), VEPS) .
  eq prepSort(Ty, VEPS) = Ty [owise] .

  eq prepSort(S, PL, P, < P ; VE > VEPS)
    = prepSort(S, (PL, VE), empty, < P ; VE > VEPS) .
  eq prepSort(S, PL, (P, PL'), < P ; VE > VEPS)
    = prepSort(S, (PL, VE), PL', < P ; VE > VEPS) .
  eq prepSort(S, PL, P, VEPS)
    = prepSort(S, (PL, prepSort(P, VEPS)), empty, VEPS)
    [owise] .
  eq prepSort(S, PL, (P, PL'), VEPS)
    = prepSort(S, (PL, prepSort(P, VEPS)), PL', VEPS)
    [owise] .
  eq prepSort(S, PL, empty, VEPS)
    = if getPars(S) == empty
      then makeSort(S, PL)
      else makeSort(prepSort(S, VEPS), PL)
      fi .

*** The function \texttt{prepImports} takes a list of importation
*** declarations and a set of pairs composed of a label and a view name, and
*** returns the list of importations resulting from changing in each of the
*** module expressions the occurrences of the labels of the interface of the
*** module being instantiated by the names of the views associated to them in
*** the list of pairs.

  op prepImports : ImportList Set{Tuple{ViewExp,ViewExp}} -> ImportList .

  op prepModExp :
       ModuleExpression Set{Tuple{ViewExp,ViewExp}} -> ModuleExpression .
  op prepModExp : ModuleExpression ViewExp ViewExp ViewExp
       Set{Tuple{ViewExp,ViewExp}} -> ModuleExpression .
  op prepParameterDecl :
       ParameterDecl Set{Tuple{ViewExp,ViewExp}} -> ParameterDecl .
  op prepViewExp : ViewExp Set{Tuple{ViewExp,ViewExp}} -> ViewExp .
  op prepViewExp : ParameterList Set{Tuple{ViewExp,ViewExp}} -> ParameterList .

  eq prepImports(((including ME .) IL), VEPS)
    = (including prepModExp(ME, VEPS) .)
      prepImports(IL, VEPS) .
  eq prepImports(((including pd(PD) .) IL), VEPS)
    = (including pd(prepParameterDecl(PD, VEPS)) .)
      prepImports(IL, VEPS) .
  eq prepImports(((extending ME .) IL), VEPS)
    = (extending prepModExp(ME, VEPS) .)
      prepImports(IL, VEPS) .
  eq prepImports(((extending pd(PD) .) IL), VEPS)
    = (extending pd(prepParameterDecl(PD, VEPS)) .)
      prepImports(IL, VEPS) .
  eq prepImports(((protecting ME .) IL), VEPS)
    = (protecting prepModExp(ME, VEPS) .)
      prepImports(IL, VEPS) .
  eq prepImports(((protecting pd(PD) .) IL), VEPS)
    = (protecting pd(prepParameterDecl(PD, VEPS)) .)
      prepImports(IL, VEPS) .
  eq prepImports(nil, VEPS) = nil .

  eq prepModExp(QI, VEPS) = QI .
  eq prepModExp(ME{PL}, VEPS) = prepModExp(ME, empty, empty, PL, VEPS) .
  eq prepModExp(ME + ME', VEPS)
    = prepModExp(ME, VEPS) + prepModExp(ME', VEPS) .
  eq prepModExp(ME, VEPS) = ME [owise] .

  eq prepModExp(ME, PL, PL', (P, PL''), < P ; S > VEPS)
    = prepModExp(ME, (PL, S), PL', PL'', < P ; S > VEPS) .
  eq prepModExp(ME, PL, PL', (P, PL''), < P ; S{PL3} > VEPS)
    = prepModExp(ME, (PL, S{PL3}), PL', PL'', < P ; S{PL3} > VEPS) .
  ceq prepModExp(ME, PL, PL', (P, PL''), < P ; P' ;; VE > VEPS)
    = prepModExp(ME, (PL, P'), (PL', VE), PL'', < P ; P' ;; VE > VEPS)
    if VE =/= mtViewExp .
  eq prepModExp(ME, PL, PL', (P, PL''), VEPS)
    = prepModExp(ME, (PL, P), PL', PL'', VEPS)
    [owise] .
  eq prepModExp(ME, PL, PL', (QI{PL''}, PL3), VEPS)
    = prepModExp(ME, (PL, prepViewExp(QI{PL''}, VEPS)), PL', PL3, VEPS) .
  eq prepModExp(ME, PL, empty, empty, VEPS) = ME{PL} .
  eq prepModExp(ME, PL, PL', empty, VEPS) = ME{PL}{PL'} [owise] .

  eq prepParameterDecl(X :: ME, < Y ; Z > VEPS)
    = if X == Y
      then (Z :: ME)
      else prepParameterDecl(X :: ME, VEPS)
      fi .
  eq prepParameterDecl(X :: ME, none) = X :: ME .

  eq prepViewExp(VE, < VE ; VE' > VEPS) = VE' .
  eq prepViewExp(QI, VEPS) = QI [owise] .
  eq prepViewExp(X{PL}, VEPS) = X{prepViewExp(PL, VEPS)} [owise] .
  ceq prepViewExp((VE, PL), VEPS)
    = prepViewExp(VE, VEPS), prepViewExp(PL, VEPS)
    if VE =/= nil /\ PL =/= nil [owise] .

*** The function \texttt{unitInst} calls the auxiliary function
*** \texttt{unitInstAux}, which proceeds recursively on each of the parameters
*** in the interface of the module being instantiated. For each view, a set of
*** maps to be applied to the module is generated, which are accumulated in
*** the third argument of the function.

*** In the base case, when there are no more parameters and no more views, the
*** maps for the parameterized sorts are also generated, and all maps are
*** then applied.

*** \texttt{unitInstAux} proceeds accumulating also the list of parameters
*** being modified, the list of importations, and a list of label-view
*** pairs (\texttt{QidTuple{ViewExp,ViewExp}}) associating each label in
*** the interface to the view used in the instantiation of the theory with
*** such label. This list of pairs is used to generate the set of maps of the
*** parameterized  sorts and to `prepare' the list of importations as
***  indicated above.

  sort TreatParResult .

  op <_;_;_;_;_;_> : SortMappingSet OpMappingSet ParameterDeclList ImportList
       Set{Tuple{ViewExp,ViewExp}} Database -> TreatParResult .
  op getSortMappings : TreatParResult -> SortMappingSet .
  op getOpMappings : TreatParResult -> OpMappingSet .
  op getPars : TreatParResult -> ParameterDeclList .
  op getImports : TreatParResult -> ImportList .
  op viewExpPairSet : TreatParResult -> Set{Tuple{ViewExp,ViewExp}} .
  op db : TreatParResult -> Database .

  eq getSortMappings(< SMS ; OMS ; PDL ; IL ; VEPS ; DB >) = SMS .
  eq getOpMappings(< SMS ; OMS ; PDL ; IL ; VEPS ; DB >) = OMS .
  eq getPars(< SMS ; OMS ; PDL ; IL ; VEPS ; DB >) = PDL .
  eq getImports(< SMS ; OMS ; PDL ; IL ; VEPS ; DB >) = IL .
  eq viewExpPairSet(< SMS ; OMS ; PDL ; IL ; VEPS ; DB >) = VEPS .
  eq db(< SMS ; OMS ; PDL ; IL ; VEPS ; DB >) = DB .

  op unitInstAux : Module Module OpDeclSet SortMappingSet OpMappingSet ParameterDeclList
        ParameterDeclList  ImportList  ImportList  ParameterList
        Set{Tuple{ViewExp,ViewExp}}  ParameterDeclList  Database
        ->  Database .
  op treatPar : ParameterDecl ViewExp  Set{Tuple{ViewExp,ViewExp}}
        ParameterDeclList  Database  ->  TreatParResult .
  op treatPar2 : ParameterDecl ViewExp  Set{Tuple{ViewExp,ViewExp}}
        ParameterDeclList  Database  ->  TreatParResult .
  op treatParAux : Qid ModuleExpression ParameterDeclList ViewExp Qid ViewExp
        ViewExp  ParameterDeclList  SortMappingSet OpMappingSet  ParameterDeclList
        ImportList  Set{Tuple{ViewExp,ViewExp}}  Database
        -> TreatParResult .
  op treatParAux2 : Qid ModuleExpression ParameterDeclList ViewExp Qid ViewExp
        ViewExp ParameterDeclList SortMappingSet OpMappingSet ParameterDeclList ImportList
        Set{Tuple{ViewExp,ViewExp}} Database -> TreatParResult .

  eq unitInst(ME, PL, PDL, DB)
    = unitInstAux(setName(getTopModule(ME, DB), ME{PL}),
        signature(getFlatModule(ME, DB)), getVars(ME, DB), none, none,
        getPars(getTopModule(ME, DB)), nil,
        getImports(getTopModule(ME, DB)), nil, PL, none, PDL, DB) .

  ceq unitInstAux(U, M, VDS, SMS, OMS, (X :: ME, PDL), PDL', IL, IL'', (QI, PL), VEPS, PDL'', DB)
    = unitInstAux(U, M, VDS, (SMS SMS'), (OMS OMS'), PDL, (PDL', PDL3), IL, (IL'' IL3), PL, (VEPS VEPS'), PDL'', DB')
    if < SMS' ; OMS' ; PDL3 ; IL3 ; VEPS' ; DB' > := treatPar(X :: ME, QI, VEPS, PDL'', DB) .
  ceq unitInstAux(U, M, VDS, SMS, OMS, (X :: ME, PDL), PDL', IL, IL'', (QI{PL}, PL'), VEPS, PDL'', DB)
    = unitInstAux(U, M, VDS, (SMS SMS'), (OMS OMS'), PDL, (PDL', PDL3), IL, (IL'' IL3), PL', (VEPS VEPS'), PDL'', DB')
    if < SMS' ; OMS' ; PDL3 ; IL3 ; VEPS' ; DB' > := treatPar(X :: ME, QI{PL}, VEPS, PDL'', DB) .
  ceq unitInstAux(U, M, VDS, SMS, OMS, nil, PDL, IL, IL', empty, VEPS, PDL', DB)
    = evalModule(
        setImports(setPars(applyMapsToModule(maps2rens(SMS'), maps2rens(OMS), U, M), PDL), (prepImports(IL, VEPS) IL')),
        applyMapsToOps(maps2rens(SMS'), maps2rens(OMS), VDS, M),
        DB)
    if SMS' := (SMS
                genMapsSorts((getSorts(U) ; getSortSetAux(getImports(U), DB)), VEPS)
                genMapsClasses((getClassNames(getClasses(U)) ; getClassSetAux(getImports(U), DB)), VEPS)) .
  eq unitInstAux(unitError(QIL), UK:[Module], SDV:[OpDeclSet], SMS, OMS, PDL, PDL', IL, IL', PL, VEPS, PDL'', DB)
    = warning(DB, QIL) .
  eq unitInstAux(noModule, unitError(QIL), VDS, SMS, OMS, PDL, PDL', IL, IL', VE, VEPS, PDL'', DB)
    = warning(DB, QIL) .
  eq unitInstAux(U, M, VDS, SMS, OMS, (X :: ME, PDL), PDL', IL, IL', empty, VEPS, PDL'', DB)
    = warning(DB, '\r 'Error: '\o 'Incorrect 'module header2QidList(getName(U)) '. '\n) .
  eq unitInstAux(U, M, VDS, SMS, OMS, nil, PDL, IL, IL', (QI, VE, PL), VEPS, PDL', DB)
    = warning(DB, '\r 'Error: '\o 'Incorrect 'module header2QidList(getName(U)) '. '\n) .
  eq unitInstAux(U, M, VDS, SMS, OMS, PDL, PDL', IL, IL', PL, VEPS, PDL'', DB)
    = DB
    [owise] .

  eq treatParView(X :: ME, VE, ME', VEPS, PDL, DB)
    = if labelInModExp(X, ME')
      then treatPar(X :: ME, VE, VEPS, PDL, DB)
      else < none ;
             none ;
             getPars(treatPar(X :: ME, VE, VEPS, PDL, DB)) ;
             getImports(treatPar(X :: ME, VE, VEPS, PDL, DB)) ;
             viewExpPairSet(treatPar(X :: ME, VE, VEPS, PDL, DB)) ;
             db(treatPar(X :: ME, VE, VEPS, PDL, DB)) >
      fi .

  op labelInModExp : Qid ModuleExpression -> Bool .
  op labelInViewExp : Qid ViewExp -> Bool .

  eq labelInModExp(X, QI) = X == QI .
  eq labelInModExp(X, ME{VE}) = labelInViewExp(X, VE) .
  eq labelInModExp(X, TUPLE[N]) = false .
  eq labelInModExp(X, POWER[N]) = false .

  eq labelInViewExp(X, QI) = X == QI .
  eq labelInViewExp(X, ((VE, VE')))
    = labelInViewExp(X, VE) or-else labelInViewExp(X, VE') .
  eq labelInViewExp(X, QI{VE}) = X == QI or-else labelInViewExp(X, VE) .

  eq treatPar(X :: ME, VE, VEPS, PDL, DB)
    = if VE :: Qid and-then labelInParameterDeclList(VE, PDL)
      then < (genMapsQualSorts(X, VE, getThSorts(ME, DB), VEPS)
              genMapsQualClasses(X, VE, getThClasses(ME, DB), VEPS)) ;
             none ;
             VE :: ME ;
             nil ;
             < X ; VE > ;
             createCopy((VE :: ME), DB) >
      else if viewInDb(VE, DB)
           then if theory(getTopModule(getTo(getView(VE, DB)), DB))
                then < prepare(
                         getSortMappings(getView(VE, DB)),
                         X,
                         getThSorts(ME, DB),
                         getThSorts(getTo(getView(VE, DB)), DB),
                         getThClasses(getTo(getView(VE, DB)), DB)) ;
                       prepare(
                         getOpMappings(getView(VE, DB)),
                         X,
                         getThSorts(ME, DB),
                         getThSorts(getTo(getView(VE, DB)), DB),
                         getThClasses(getTo(getView(VE, DB)), DB)) ;
                       X :: getTo(getView(VE, DB)) ;
                       nil ;
                       < X ; (VE ;; X) > ;
                       createCopy((X :: getTo(getView(VE, DB))), DB) >
                else < prepare(
                         getSortMappings(getView(VE, DB)),
                         X,
                         getThSorts(ME, DB), none, none) ;
                       prepare(
                         getOpMappings(getView(VE, DB)),
                         X,
                         getThSorts(ME, DB), none, none) ;
                       getPars(getTopModule(getTo(getView(VE, DB)), DB)) ;
                       (protecting getTo(getView(VE, DB)) .) ;
                       < X ; VE > ;
                       DB >
                fi
           else < none ; none ; nil ; nil ; none ; warning(DB, '\r 'Error: '\o 'View VE 'not 'in 'database. '\n) >
           fi
      fi .

  op viewInstAux : View SortMappingSet OpMappingSet ParameterDeclList ParameterDeclList
       ParameterList Set{Tuple{ViewExp,ViewExp}} ParameterDeclList Database
       -> Database .
  op treatParView : ParameterDecl ParameterList ModuleExpression
       Set{Tuple{ViewExp,ViewExp}} ParameterDeclList Database
       -> TreatParResult .
  op treatParAux : Qid ModuleExpression ParameterList Qid ViewExp ViewExp
       ParameterList SortMappingSet OpMappingSet ParameterList ImportList
       Set{Tuple{ViewExp,ViewExp}} Database -> TreatParResult .

  eq viewInst(VE, PL, PDL, DB)
    = viewInstAux(setName(getView(VE, DB), VE{PL}),
        none, none, getPars(getView(VE, DB)), nil, PL, none, PDL, DB) .

  ceq viewInstAux(VI, SMS, OMS, (X :: ME, PDL), PDL', (QI, PL), VEPS, PDL'', DB)
    = viewInstAux(VI, (SMS SMS'), (OMS OMS'), PDL, (PDL', PDL3), PL, (VEPS VEPS'), PDL'', DB')
    if < SMS' ; OMS' ; PDL3 ; IL ; VEPS' ; DB' > := treatParView(X :: ME, QI, getFrom(VI), VEPS, PDL'', DB) .
  ceq viewInstAux(VI, SMS, OMS, (X :: ME, PDL), PDL', (QI{PL}, PL'), VEPS, PDL'', DB)
    = viewInstAux(VI, SMS SMS', OMS OMS', PDL, (PDL', PDL3), PL', (VEPS VEPS'), PDL'', DB')
    if < SMS' ; OMS' ; PDL3 ; IL ; VEPS' ; DB' > := treatParView(X :: ME, QI{PL}, getFrom(VI), VEPS, PDL'', DB) .
  ceq viewInstAux(VI, SMS, OMS, nil, PDL, empty, VEPS, PDL', DB)
    = insertView(
        setPars(
          setFrom(
            setTo(
              setSortMappings(
                setOpMappings(VI,
                  applyMapsToMaps(
                    maps2rens(genMapsSorts(getSortSet(getFrom(VI), DB''), VEPS)
                              genMapsClasses(getClassSet(getFrom(VI), DB''), VEPS)),
                    maps2rens(SMS
                              genMapsSorts(getSortSet(getTo(VI), DB''), VEPS)
                              genMapsClasses(getClassSet(getTo(VI), DB''), VEPS)),
                    getOpMappings(VI))),
                applyMapsToMaps(
                  maps2rens(genMapsSorts(getSortSet(getFrom(VI), DB''), VEPS)
                            genMapsClasses(getClassSet(getFrom(VI), DB''), VEPS)),
                  maps2rens(SMS
                            genMapsSorts(getSortSet(getTo(VI), DB''), VEPS)
                            genMapsClasses(getClassSet(getTo(VI), DB''), VEPS)),
                  getSortMappings(VI))),
              prepModExp(getTo(VI), VEPS)),
            prepModExp(getFrom(VI), VEPS)),
          PDL),
        DB'')
    if < DB'  ; ME'  > := evalModExp(prepModExp(getFrom(VI), VEPS), PDL', DB)
    /\ < DB'' ; ME'' > := evalModExp(prepModExp(getTo(VI), VEPS), PDL', DB') .
  eq viewInstAux(viewError(QIL), SMS, OMS, PDL0:[ParameterDeclList], PDL, PL, VEPS, PDL', DB)
    = warning(DB, QIL) .
  eq viewInstAux(VI, SMS, OMS, (X :: ME, PDL), PDL', empty, VEPS, PDL'', DB)
    = warning(DB, ('\r 'Error: '\o 'Incorrect 'view getName(VI) '. '\n)) .
  eq viewInstAux(VI, SMS, OMS, nil, PDL, (QI, PL), VEPS, PDL', DB)
    = warning(DB, ('\r 'Error: '\o 'Incorrect 'view getName(VI) '. '\n)) .
  eq viewInstAux(VI, SMS, OMS, (X :: ME, PDL), PDL', (QI{PL}, PL'), VEPS, PDL'', DB)
    = warning(DB, ('\r 'Error: '\o 'Wrong 'instantiation getName(VI) '. '\n)) .

  op applyMapsToMaps : RenamingSet RenamingSet SortMappingSet -> SortMappingSet .
  op applyMapsToMaps : RenamingSet RenamingSet OpMappingSet -> OpMappingSet .
  op applyMapsToTerm : RenamingSet TermList -> TermList .

  eq applyMapsToMaps(SRS, SRS', sort S to S' . SMS)
    = (sort applyMapsToType(SRS, S) to applyMapsToType(SRS', S') .
       applyMapsToMaps(SRS, SRS', SMS)) .
  eq applyMapsToMaps(SRS, SRS', class S to S' . SMS)
    = (class applyMapsToType(SRS, S) to applyMapsToType(SRS',S') .
       applyMapsToMaps(SRS, SRS', SMS)) .
  eq applyMapsToMaps(SRS, SRS', SMS) = SMS [owise] .

  eq applyMapsToMaps(SRS, SRS', op_to`term_.(T, T') OMS)
    = (op_to`term_.(applyMapsToTerm(SRS, T), applyMapsToTerm(SRS', T'))
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', op F : TyL -> Ty to F' . OMS)
    = (op F : applyMapsToTypeList(SRS, TyL) -> applyMapsToType(SRS, Ty) to F' .
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', msg F : TyL -> S to F' . OMS)
    = (msg F : applyMapsToTypeList(SRS, TyL) -> applyMapsToType(SRS, S) to F' .
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', attr A . S to A' . OMS)
    = (attr A . applyMapsToType(SRS, S) to A' .
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', OMS) = OMS [owise] .

  eq applyMapsToTerm(SRS, Ct)
    = qid(string(getName(Ct)) + "." + string(applyMapsToType(SRS, getType(Ct)))) .
  eq applyMapsToTerm(SRS, V)
    = qid(string(getName(V)) + "." + string(applyMapsToType(SRS, getType(V)))) .
  eq applyMapsToTerm(SRS, qidError(QIL)) = qidError(QIL) .
  ceq applyMapsToTerm(SRS, F[TL])
    = F[applyMapsToTerm(SRS, TL)]
    if (F =/= '<_:_|_>) and (F =/= '<_:_|`>) .
  eq applyMapsToTerm(SRS, '<_:_|_>[O, Ct, T])
    = '<_:_|_>[applyMapsToTerm(SRS, O),
               qid(string(applyMapsToClassName(SRS, getName(Ct)))
                   + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               applyMapsToTerm(SRS, T)] .
  ceq applyMapsToTerm(SRS, '<_:_|_>[O, C, T])
    = '<_:_|_>[applyMapsToTerm(SRS, O),
               applyMapsToClassName(SRS, C),
               applyMapsToTerm(SRS, T)]
    if not C :: Constant .
  eq applyMapsToTerm(SRS, '<_:_|`>[O, Ct])
    = '<_:_|_>[applyMapsToTerm(SRS, O),
               qid(string(applyMapsToClassName(SRS, getName(Ct)))
                   + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               'none.AttributeSet] .
  ceq applyMapsToTerm(SRS, '<_:_|`>[O, C])
    = '<_:_|_>[applyMapsToTerm(SRS, O),
               applyMapsToClassName(SRS, C),
               'none.AttributeSet]
    if not C :: Constant .

  ceq applyMapsToTerm(SRS, (T, TL))
    = (applyMapsToTerm(SRS, T), applyMapsToTerm(SRS, TL))
    if TL =/= empty .

*** As pointed out in Section~\ref{module-names}, for each new module
*** expression constructor being introduced, we need to add equations for the
*** operator \texttt{header2Qid}. Since the function to transform view
*** expressions into lists of quoted identifiers was already defined in
*** Section~\ref{VIEW-EXPR}, we just need to add the following equation.

  eq header2Qid((ME { PL }))
    = qidList2Qid(header2Qid(ME) '`{ parameterList2Qid(PL) '`}) .
  ceq header2QidList((ME { PL }))
    = (if QI == '\s then QIL else QIL QI fi
       '`{ parameterList2QidList(PL) '`} '\s)
    if QIL QI := header2QidList(ME) .

*** Given a module expression of the form \verb~ME{VE}~ such that
*** \texttt{ME} is in the database, we need to add \verb~ME{VE}~ to the set
*** of names of the modules depending on \texttt{ME} and on \texttt{VE}.
*** Since \texttt{VE} may be a composed view expression, we have to add the
*** name of the module  to each of the views in it. In this way, if \texttt{ME}
*** or any of the  views in \texttt{VE} is redefined or removed from the
*** database,  \verb~ME{VE}~ will be removed as well.

  eq setUpModExpDeps(ME{PL},
      db(< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = viewExpDeps(ME{PL}, PL,
        db(< ME ; DT ; U ; U' ; M ; VDS ; (MNS . ME{PL}) ; VES > MIS,
           MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps(ME{PL},
      db(< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
         VIS, VES', MNS'', MNS3, MNS4, QIL))
    = viewExpDeps(ME{PL}, PL,
        db(< ME ; DM ; U ; U' ; M ; VDS ; (MNS . ME{PL}) ; VES > MIS,
           MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps('META-LEVEL{PL}, DB)
    = setUpModExpDeps('META-LEVEL{PL}, PL, DB) .
  eq setUpModExpDeps('META-LEVEL{QI},
       db(< QI ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< QI ; DT ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{QI} ; VES >
          MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps('META-LEVEL{QI},
       db(< QI ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< QI ; DM ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{QI} ; VES >
          MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  ceq setUpModExpDeps(ME{PL}, DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n))
    if (ME =/= 'META-LEVEL) /\ (not unitInDb(ME, DB)) .

  eq setUpModExpDeps('META-LEVEL{PL}, (QI, PL'),
       db(< QI ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModExpDeps('META-LEVEL{PL}, PL',
        db(< QI ; DT ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{PL} ; VES >
           MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps('META-LEVEL{PL}, (QI, PL'),
       db(< QI ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModExpDeps('META-LEVEL{PL}, PL',
        db(< QI ; DM ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{PL} ; VES >
           MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps('META-LEVEL{PL}, nil, DB) = DB .

  op viewExpDeps : Header ViewExp Database -> Database .

----  eq viewExpDeps(ME, VE,
----        db(MIS, MNS,
----           < VE ; DT ; VI ; MNS' ; VES > VIS, VES',
----           MNS'', MNS3, MNS4, QIL))
----    = db(MIS, MNS, < VE ; DT ; VI ; MNS' . ME ; VES > VIS, VES',
----         MNS'', MNS3, MNS4, QIL) .
  eq viewExpDeps(ME, (VE, PL),
        db(MIS, MNS,
           < VE ; DT ; VI ; MNS' ; VES > VIS, VES',
           MNS'', MNS3, MNS4, QIL))
    = viewExpDeps(ME, PL,
        db(MIS, MNS,
           < VE ; DT ; VI ; MNS' . ME ; VES > VIS, VES',
           MNS'', MNS3, MNS4, QIL)) .
----  eq viewExpDeps(ME, VE, DB) = DB [owise] .
  eq viewExpDeps(ME, (VE, PL), DB) = viewExpDeps(ME, PL, DB) [owise] .
  eq viewExpDeps(ME, empty, DB) = DB .

endfm

*******************************************************************************

***
*** 6.10 Renaming of Modules
***

*** In addition to the declaration of the constructor for renaming module
*** expressions, the following module \texttt{RENAMING-EXPR-EVALUATION}
*** introduces equations to treat this new case in the definition of functions
*** \texttt{evalModExp}, \texttt{header2QidList}, \texttt{prepHeader}, and
*** \texttt{setUpModuleDeps}.

*** A renaming expression is evaluated by applying the renaming maps, not only
*** to the top unit, but also to the part of the structure \emph{affected} by
*** the maps. The renaming process propagates downwards in the unit hierarchy
*** while the units in the structure are affected by the renamings. We say that
*** a unit is affected by a set of maps (checked by the \texttt{modAffd}
*** function) when any of the maps is applicable to any of the declarations in
*** the unit, or in any of its subunits. The application of a set of maps to a
*** single unit is accomplished by the \texttt{applyMapsToModule} function,
*** discussed in Section~\ref{applyMapsToModule}.

fmod RENAMING-EXPR-EVALUATION is
  pr DATABASE .
  pr RENAMING-SET-APPL-ON-UNIT .
  pr EVALUATION .
  inc MOD-EXPR .
  pr MOD-EXPR-EVAL .
  pr INST-EXPR-EVALUATION .
  pr FMAP .

  vars ME ME' : ModuleExpression .
  var  MNS MNS' MNS'' MNS3 MNS4 : Set{ModuleName} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars M M' : Module .
  vars PU U U' DM : Module .
  vars DB DB' : Database .
  var  QIL : QidList .
  vars VES VES' : Set{ViewExp} .
  var  PL : ParameterList .
  var  PDL : ParameterDeclList .
  vars PDS PDS' : Set{ParameterDecl} .
  var  I : Import .
  vars IL IL' : ImportList .
  var  R : Renaming .
  vars RS RS' RS'' RS3 : RenamingSet .
  var  VEPS : Set{Tuple{ViewExp,ViewExp}} .
  vars X QI QI' QI'' F F' F'' L L' L'' A A' A'' : Qid .
  vars S S' S'' C C' C'' : Sort .
  var  K : Kind .
  vars SS : SortSet .
  vars TyL TyL' : TypeList .
  vars Ty Ty' : Type .
  vars T T' T'' T3 : Term .
  var  DT : Default{Term} .
  var  TL : TermList .
  var  OPD : OpDeclSet .
  vars OPDS VDS : OpDeclSet .
  vars AtS AtS' : AttrSet .
  var  Rl : Rule .
  var  RlS : RuleSet .
  var  CD : ClassDecl .
  var  CDS : ClassDeclSet .
  var  ADS : AttrDeclSet .
  var  MD : MsgDecl .
  var  MDS : MsgDeclSet .
  var  N : Nat .
  var  NL : IntList .
  var  Hk : Hook .
  var  HkL : HookList .
  var  B : Bool .
  var  St : String .

*** The function \texttt{crtCopyRen} creates a copy of the part of the
*** structure of the specified module which is affected by the renaming,
*** applying to each of the generated modules in the new structure the subset
*** of maps affecting each one of them. The equation extending the
*** \texttt{evalModExp} function to the renaming module expression is then
*** reduced to a call to \texttt{crtCopyRen} with the appropriate
*** arguments.

  eq labelInModExp(X, ME * (RS)) = labelInModExp(X, ME) .

  op crtCopyRen : ModuleExpression RenamingSet Database -> Database .

  ceq evalModExp(ME * (RS), PDL, DB)
    = if unitInDb(ME' * (RS''), DB')
      then < DB' ; ME' * (RS'') >
      else < crtCopyRen(ME', RS', DB') ; ME' * (RS'') >
      fi
    if < DB' ; ME' > := evalModExp(ME, PDL, DB)
       /\ RS' := fixMaps(RS, ME', DB')
       /\ RS'' := canMaps(RS', getFlatModule(ME', DB')) .

  eq crtCopyRen(ME, none, DB) = DB .
  ceq crtCopyRen(ME, RS, DB)
    = if unitInDb(_*`(_`)(ME, RS'), DB)
      then DB
      else applyMapsRec(
             RS,
             getImports(getTopModule(ME, DB)),
             nil,
             setName(
               applyMapsToModuleAux(RS'', RS3,
                 getTopModule(ME, DB), getFlatModule(ME, DB)),
               _*`(_`)(ME, RS')),
             applyMapsToOps(RS'', RS3,
               getVars(ME, DB), getFlatModule(ME, DB)),
             DB)
      fi
    if RS' := canMaps(RS, getFlatModule(ME, DB))
       /\ < RS'' ; RS3 > := splitMaps(RS') .

  op canMaps : RenamingSet Module -> RenamingSet .
  eq canMaps(op F : TyL -> Ty to F' [AtS], M)
    = op F : canKinds(TyL, M) -> canKinds(Ty, M) to F' [AtS] .
  eq canMaps((op F : TyL -> Ty to F' [AtS], RS), M)
    = (op F : canKinds(TyL, M) -> canKinds(Ty, M) to F' [AtS],
       canMaps(RS, M)) .
  eq canMaps(msg F : TyL -> Ty to F', M)
    = msg F : canKinds(TyL, M) -> canKinds(Ty, M) to F' .
  eq canMaps((msg F : TyL -> Ty to F', RS), M)
    = (msg F : canKinds(TyL, M) -> canKinds(Ty, M) to F',
       canMaps(RS, M)) .
  eq canMaps(R:Renaming, M) = R:Renaming [owise] .
  eq canMaps((R:Renaming, RS), M)
    = (R:Renaming, canMaps(RS, M))
    [owise] .
  eq canMaps(none, M) = none .

  op canKinds : TypeList Module -> [TypeList] .
  ---- eq canKinds(K:Kind TyL, M)
  ----   = kind(maximalSorts(M, K:Kind)) canKinds(TyL, M) .
  eq canKinds(nil, M) = nil .
  eq canKinds(cc(S ; SS) TyL, M)
    = kind(maximalSorts(M, getKind(M, S))) canKinds(TyL, M) .
  ----eq canKinds(TyL, M) = nil [owise] .

*** We proceed downwards while the set of maps affects the module, but we do so
*** restricting the set of maps to the subset affecting the module. Since
*** operator and message maps in which arity and coarity are specified must be
*** applied to the whole subsort-overloaded family of operators or messages, we
*** have to carry along the signature of the module at the top to make all the
*** calls to the engine. Note that we may have maps of operations or messages
*** with the domain given by sorts that are not in the submodules but which
*** have other sorts in the submodules in the same connected components.

  op applyMapsRec : RenamingSet ImportList ImportList Module OpDeclSet Database -> Database .

  eq applyMapsRec(RS, ((including ME .) IL), IL', U, VDS, DB)
   = applyMapsRec(
       RS, IL,
       including ME *( canMaps(fixMaps(RS, ME, DB),
                               getFlatModule(ME, DB)) ) . IL',
       U, VDS,
       crtCopyRen(ME, fixMaps(RS, ME, DB), DB)) .
  eq applyMapsRec(RS, ((extending ME .) IL), IL', U, VDS, DB)
   = applyMapsRec(
       RS, IL,
       extending ME *( canMaps(fixMaps(RS, ME, DB),
                               getFlatModule(ME, DB)) ) . IL',
       U, VDS,
       crtCopyRen(ME, fixMaps(RS, ME, DB), DB)) .
  eq applyMapsRec(RS, ((protecting ME .) IL), IL', U, VDS, DB)
   = applyMapsRec(
       RS, IL,
       protecting ME *( canMaps(fixMaps(RS, ME, DB),
                               getFlatModule(ME, DB)) ) . IL',
       U, VDS,
       crtCopyRen(ME, fixMaps(RS, ME, DB), DB)) .
  eq applyMapsRec(RS, (I IL), IL', U, VDS, DB)
    = applyMapsRec(RS, IL, (I IL'), U, VDS, DB)
    [owise] .
  eq applyMapsRec(RS, nil, IL, U, VDS, DB)
    = evalModule(setImports(U, IL), VDS, DB) .
  eq applyMapsRec(RS, IL, IL', unitError(QIL), VDS, DB)
    = warning(DB, QIL) .

  op fixMaps : [RenamingSet] ModuleExpression Database -> RenamingSet .
  op fixMaps2 : [RenamingSet] Module ClassDeclSet MsgDeclSet -> RenamingSet .

  ceq fixMaps(RS, ME, DB)
    = fixMaps2(RS, getFlatModule(ME, DB), CDS, MDS)
    if < CDS ; MDS > := getAllClassesAndMsgs(ME, DB) .

  eq fixMaps2(op F to F' [AtS], M, CDS, MDS)
    = opsAffd(getOps(M), op F to F' [AtS], M) .
  eq fixMaps2((op F to F' [AtS], RS), M, CDS, MDS)
    = (opsAffd(getOps(M), op F to F' [AtS], M),
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(op F : TyL -> Ty to F' [AtS], M, CDS, MDS)
    = opsAffd(getOps(M), op F : TyL -> Ty to F' [AtS], M) .
  eq fixMaps2((op F : TyL -> Ty to F' [AtS], RS), M, CDS, MDS)
    = (opsAffd(getOps(M), op F : TyL -> Ty to F' [AtS], M),
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(msg F to F', M, CDS, MDS)
    = msgsAffd(MDS, msg F to F', M) .
  eq fixMaps2((msg F to F', RS), M, CDS, MDS)
    = (msgsAffd(MDS, msg F to F', M), fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(msg F : TyL -> Ty to F', M, CDS, MDS)
    = msgsAffd(MDS, msg F : TyL -> Ty to F', M) .
  eq fixMaps2((msg F : TyL -> Ty to F', RS), M, CDS, MDS)
    = (msgsAffd(MDS, msg F : TyL -> Ty to F', M),
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(sort Ty to Ty', M, CDS, MDS)
    = if sortsAffd(getSorts(M), sort Ty to Ty')
      then (sort Ty to Ty')
      else none
      fi .
  eq fixMaps2(((sort Ty to Ty'), RS), M, CDS, MDS)
    = (if sortsAffd(getSorts(M), sort Ty to Ty')
       then (sort Ty to Ty')
       else none
       fi,
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(class Ty to Ty', M, CDS, MDS)
    = if classesAffd(CDS, class Ty to Ty')
      then (class Ty to Ty')
      else none
      fi .
  eq fixMaps2(((class Ty to Ty'), RS), M, CDS, MDS)
    = (if classesAffd(CDS, class Ty to Ty')
       then (class Ty to Ty')
       else none
       fi,
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(attr A . Ty to Ty', M, CDS, MDS)
    = if classesAffd(CDS, attr A . Ty to Ty')
      then (attr A . Ty to Ty')
      else none
      fi .
  eq fixMaps2(((class A . Ty to Ty'), RS), M, CDS, MDS)
    = (if classesAffd(CDS, attr A . Ty to Ty')
       then (attr A . Ty to Ty')
       else none
       fi,
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(R:Renaming, M, CDS, MDS) = R:Renaming [owise] .
  eq fixMaps2((R:Renaming, RS), M, CDS, MDS)
    = (R:Renaming, fixMaps2(RS, M, CDS, MDS))
    [owise] .
  eq fixMaps2(none, M, CDS, MDS) = none .

  sort Tuple{ClassDeclSet, MsgDeclSet} .
  op <_;_> : ClassDeclSet MsgDeclSet -> Tuple{ClassDeclSet, MsgDeclSet} .
  op getClasses : Tuple{ClassDeclSet, MsgDeclSet} -> ClassDeclSet .
  op getMsgs : Tuple{ClassDeclSet, MsgDeclSet} -> MsgDeclSet .
  eq getClasses(< CDS ; MDS >) = CDS .
  eq getMsgs(< CDS ; MDS >) = MDS .

  op getAllClassesAndMsgs :
       ModuleExpression Database -> Tuple{ClassDeclSet, MsgDeclSet} .
  op getAllClassesAndMsgs :
       ImportList Database -> Tuple{ClassDeclSet, MsgDeclSet} .

  eq getAllClassesAndMsgs(ME, DB)
    = if getTopModule(ME, DB) :: OModule
         and-then not getTopModule(ME, DB) :: SModule
      then < getClasses(
               getAllClassesAndMsgs(getImports(getTopModule(ME, DB)), DB))
             getClasses(getTopModule(ME, DB))
             ;
             getMsgs(
               getAllClassesAndMsgs(getImports(getTopModule(ME, DB)), DB))
             getMsgs(getTopModule(ME, DB)) >
      else < none ; none >
      fi .

  eq getAllClassesAndMsgs(I IL, DB)
    = < getClasses(getAllClassesAndMsgs(moduleName(I), DB))
        getClasses(getAllClassesAndMsgs(IL, DB))
        ;
        getMsgs(getAllClassesAndMsgs(moduleName(I), DB))
        getMsgs(getAllClassesAndMsgs(IL, DB)) > .
  eq getAllClassesAndMsgs((nil).ImportList, DB) = < none ; none > .

----  sorts NeSet<TypeList> Set<TypeList> .
----  subsort TypeList < NeSet<TypeList> < Set<TypeList> .
----  op noneTLS : -> Set<TypeList> [ctor] .
----  op _!_ : Set<TypeList> Set<TypeList> -> Set<TypeList>
----     [ctor assoc comm id: noneTLS] .
----  op _!_ : NeSet<TypeList> NeSet<TypeList> -> NeSet<TypeList>
----     [ctor assoc comm id: noneTLS] .

----  sort Set<Type> .
----  subsorts Type SortSet < Set<Type> .
----  op _o_ : Set<Type> Set<Type> -> Set<Type> [ctor assoc comm id: none] .
----
----  eq Ty o Ty = Ty .

  sort TypeSetList .
  subsort TypeSet < TypeSetList .
  op nilTSL : -> TypeSetList [ctor] .
  op _l_ : TypeSetList TypeSetList -> TypeSetList
     [ctor assoc id: nilTSL] .

  var  TS : TypeSet .
  var  TSL : TypeSetList .
  var  TLS : TypeListSet .
----  var  NTLS : NeTypeListSet .

----  eq TyL ! TyL = TyL .

  ----eq _!_(qidError(QIL), NTLS) = qidError(QIL) .

  op fixKinds : TypeList Module -> TypeListSet .
  op fixKinds : TypeList TypeSetList Module -> TypeListSet .
  op fixKindsAux : Type Module -> TypeSet .
  op fixKindsAux2 : SortSet Module -> TypeSet .
  op unfold : TypeSetList -> TypeListSet .
  op add : TypeSet TypeListSet -> TypeListSet .

  eq fixKinds(TyL, M) = fixKinds(TyL, nilTSL, M) .

  eq fixKinds(Ty TyL, TSL, M)
    = if fixKindsAux(Ty, M) == nil
      then none
      else fixKinds(TyL, TSL l fixKindsAux(Ty, M), M)
      fi .
  eq fixKinds(nil, TSL, M) = unfold(TSL) .

  eq fixKindsAux(S, M)
    = if S in getSorts(M)
      then cc(connectedSorts(M, S))
      else none
      fi .
  eq fixKindsAux(K, M) = fixKindsAux2(getSorts(K), M) .
  eq fixKindsAux(cc(SS), M) = fixKindsAux2(SS, M) .

  eq fixKindsAux2((S ; SS), M)
    = (if S in getSorts(M)
       then cc(connectedSorts(M, S))
       else none
       fi
       ;
       fixKindsAux2(SS, M)) .
  eq fixKindsAux2(none, M) = none .

  ceq unfold(TS l TSL) = add(TS, unfold(TSL)) if TS =/= none .
  eq unfold(nilTSL) = none .

  ceq add(Ty, TyL ; TLS) = add(Ty, TyL) ; add(Ty, TLS) if TLS =/= none .
  eq add(Ty ; Ty' ; TS, TLS) = add(Ty, TLS) ; add(Ty' ; TS, TLS) .
  eq add(none, TLS) = nilTSL .
  eq add(Ty, none) = Ty .
  eq add(Ty, TyL) = Ty TyL .

  op connectedSorts : Module Type -> SortSet .
  op connectedSorts : Module SortSet Type -> SortSet .
  eq connectedSorts(M, Ty) = connectedSorts(M, getSorts(M), Ty) .
  eq connectedSorts(M, S ; SS, Ty)
    = if sameKind(M, S, Ty)
      then S
      else none
      fi ; connectedSorts(M, SS, Ty) .
  eq connectedSorts(M, none, Ty) = none .

  op sortsAffd : SortSet Renaming -> Bool .
  op opsAffd : OpDeclSet Renaming Module -> RenamingSet .
  op opsAffdAux : OpDeclSet Qid TypeListSet Qid AttrSet Module -> RenamingSet .

  eq sortsAffd((S ; SS), (sort S to S')) = true .
  eq sortsAffd(SS, (sort S to S')) = false [owise] .

  eq opsAffd(op F : TyL -> Ty [AtS] . OPDS, op F to F' [AtS'], M)
    = op F to F' [AtS'] .
  eq opsAffd(OPDS, op F : TyL -> Ty to F' [AtS], M)
    = opsAffdAux(OPDS, F, fixKinds(TyL Ty, M), F', AtS, M) .
  eq opsAffd(OPDS, RS:[RenamingSet], M) = none [owise] .

  eq opsAffdAux(op F : TyL -> Ty [AtS] . OPDS,
       F, (TyL' Ty') ; TLS, F', AtS', M)
    = if sameKind(M, (TyL Ty), (TyL' Ty'))
      then (op F : TyL' -> Ty' to F' [AtS'],
            opsAffdAux(OPDS, F, TLS, F', AtS', M))
      else (opsAffdAux(OPDS, F, (TyL' Ty') ; TLS, F', AtS', M),
            opsAffdAux(op F : TyL -> Ty [AtS] . OPDS, F, TLS, F', AtS', M))
      fi .
  eq opsAffdAux(OPDS, F, TLS, F', AtS, M) = none [owise] .

*** The predicate \texttt{modAffd} checks whether the module with the
*** name given as first argument in the database is affected by the set of maps
*** given as second argument. A module is affected by a map set if any of the
*** maps is applicable to the module or to any of its submodules.

  op modAffd : Header RenamingSet Module Database -> Bool .

  op modAffdAux : Module RenamingSet Module Database -> Bool .
  op rlsAffd : RuleSet RenamingSet -> Bool .
  op importsAffd : ImportList RenamingSet Module Database -> Bool .
  op classesAffd : ClassDeclSet RenamingSet -> Bool .
  op msgsAffd : MsgDeclSet RenamingSet Module -> RenamingSet .
  op msgsAffdAux : MsgDeclSet Qid TypeListSet Qid Module -> RenamingSet .

  eq modAffd(ME, RS, M, DB)
    = modAffdAux(getTopModule(ME, DB), RS, M, DB) .

  eq modAffdAux(U, RS, M, DB)
    = sortsAffd(getSorts(U), RS)
      or-else
      (opsAffd(getOps(U), RS, M) == none
       or-else
       ((not U :: FModule
         and-then
         (rlsAffd(getRls(U), RS)
          or-else
          (not U :: SModule
           and-then
           (classesAffd(getClasses(U), RS)
            or-else
            msgsAffd(getMsgs(U), RS, M) == none))))
        or-else
        importsAffd(getImports(U), RS, M, DB))) .

  eq importsAffd(((including ME .) IL), RS, M, DB)
    = modAffd(ME, RS, M, DB)
      or-else importsAffd(IL, RS, M, DB) .
  eq importsAffd(((extending ME .) IL), RS, M, DB)
    = modAffd(ME, RS, M, DB)
      or-else importsAffd(IL, RS, M, DB) .
  eq importsAffd(((protecting ME .) IL), RS, M, DB)
    = modAffd(ME, RS, M, DB)
      or-else importsAffd(IL, RS, M, DB) .
  eq importsAffd(nil, RS, M, DB) = false .

  eq rlsAffd(((rl T => T' [label(L) AtS] .) RlS), (label L' to L''))
    = (L == L') or-else rlsAffd(RlS, label L' to L'') .
  eq rlsAffd(((rl T => T' [label(L) AtS] .) RlS),
       ((label L' to L''), RS))
    = (L == L') or-else
      (rlsAffd((rl T => T' [label(L) AtS] .), RS) or-else
       rlsAffd(RlS, ((label L' to L''), RS))) .
  eq rlsAffd(((crl T => T' if T'' = T3 [label(L) AtS] .) RlS),
       (label L' to L''))
    = (L == L') or-else rlsAffd(RlS, (label L' to L'')) .
  eq rlsAffd(((crl T => T' if T'' = T3 [label(L) AtS] .) RlS),
       ((label L' to L''), RS))
    = (L == L')
      or-else
      (rlsAffd((crl T => T' if T'' = T3 [label(L) AtS] .), RS)
      or-else
      rlsAffd(RlS, ((label L' to L''), RS))) .
  eq rlsAffd(RlS, RS) = false [owise] .

  eq classesAffd(((class C | ADS .) CDS), (class C' to C''))
    = (C == C')
      or-else
      classesAffd(CDS, (class C' to C'')) .
  eq classesAffd(((class C | ADS .) CDS), ((class C' to C''), RS))
    = (C == C')
      or-else
      (classesAffd((class C | ADS .), RS)
      or-else
      classesAffd(CDS, ((class C' to C''), RS))) .
  eq classesAffd(((class C | ((attr A : S), ADS) .) CDS),
       (attr A' . C' to A''))
    = if C == C'
      then (A == A')
           or-else
           classesAffd(((class C | ADS .) CDS), (attr A' . C' to A''))
      else classesAffd(CDS, (attr A' . C' to A''))
      fi .
  eq classesAffd(((class C | ((attr A : S), ADS) .) CDS),
       ((attr A' . C' to A''), RS))
    = if C == C'
      then (A == A')
           or-else
           (classesAffd(((class C | ADS .) CDS),
              ((attr A' . C' to A''), RS))
           or-else
           classesAffd(CDS, RS))
      else classesAffd((class C | ((attr A : S), ADS) .), RS)
           or-else
           classesAffd(CDS, ((attr A' . C' to A''), RS))
      fi .
  eq classesAffd(CDS, RS) = false [owise] .

  eq msgsAffd(msg F : TyL -> Ty . MDS, msg F to F', M) = msg F to F' .
  eq msgsAffd(MDS, msg F : TyL -> Ty to F', M)
    = msgsAffdAux(MDS, F, fixKinds(TyL Ty, M), F', M) .
  eq msgsAffd(MDS, RS:[RenamingSet], M) = none [owise] .

  eq msgsAffdAux(msg F : TyL -> Ty . MDS, F, (TyL' Ty') ; TLS, F', M)
    = if sameKind(M, (TyL Ty), (TyL' Ty'))
      then (msg F : TyL' -> Ty' to F',
            msgsAffdAux(MDS, F, TLS, F', M))
      else (msgsAffdAux(MDS, F, (TyL' Ty') ; TLS, F', M),
            msgsAffdAux(msg F : TyL -> Ty . MDS, F, TLS, F', M))
      fi .
  eq msgsAffdAux(MDS, F, TLS, F', M) = none [owise] .

*** The function \texttt{mapsRestrict} returns the subset of the view
*** maps given as second argument that affect the given module.

  op mapsRestrict : Module RenamingSet Module Database -> RenamingSet .
  op mapsRestrict : Header RenamingSet Module Database -> RenamingSet .

  eq mapsRestrict(ME, RS, M, DB)
    = mapsRestrict(getTopModule(ME, DB), RS, M, DB) .

  eq mapsRestrict(U, R, M, DB)
    = if modAffdAux(U, R, M, DB)
      then R
      else none
      fi .
  eq mapsRestrict(U, (R, RS), M, DB)
    = if modAffdAux(U, R, M, DB)
      then (R, mapsRestrict(U, RS, M, DB))
      else mapsRestrict(U, RS, M, DB)
      fi .
  eq mapsRestrict(U, none, M, DB) = none .

*** The definition of the function \texttt{header2QidList} on the renaming
*** module expression has to take care of transforming into a quoted identifier
*** list the set of view maps given in the module expression.

  op maps2QidList : RenamingSet -> QidList .

  op attrSet2QidList : AttrSet -> QidList .
  op hookList2QidList : HookList -> QidList .
  op termList2QidList : TermList -> QidList .
  op intList2QidList : IntList -> QidList .
  op typeList2QidList : TypeList -> QidList .

  eq maps2QidList(((op F to F' [AtS]), RS))
    = if AtS == none
      then ('op F 'to F' '`, '\s maps2QidList(RS))
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`] '`, '\s
            maps2QidList(RS))
      fi
    [owise] .
  eq maps2QidList((op F to F' [AtS]))
    = if AtS == none
      then ('op F 'to F')
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`])
      fi .
  eq maps2QidList(((op F : TyL -> Ty to F' [AtS]), RS))
    = if AtS == none
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F' '`,
            '\s maps2QidList(RS))
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F'
            '`[ attrSet2QidList(AtS) '`] '`, '\s maps2QidList(RS))
      fi
    [owise] .
  eq maps2QidList((op F : TyL -> Ty to F' [AtS]))
    = if AtS == none
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F')
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F'
            '`[ attrSet2QidList(AtS) '`])
      fi .
  eq maps2QidList(((sort S to S'), RS))
    = ('sort S 'to S' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((sort S to S')) = ('sort S 'to S') .

  eq maps2QidList(((label L to L'), RS))
    = ('label L 'to L' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((label L to L')) = ('label L 'to L') .

  eq maps2QidList(((msg F to F'), RS))
    = ('msg F 'to F' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((msg F to F')) = ('msg F 'to F') .

  eq maps2QidList(((msg F : TyL  -> Ty to F'), RS))
    = ('msg F ': typeList2QidList(TyL) '-> Ty 'to F' '`, '\s
       maps2QidList(RS))
    [owise] .
  eq maps2QidList((msg F : TyL -> Ty to F'))
    = ('msg F ': typeList2QidList(TyL) '-> Ty 'to F') .

  eq maps2QidList(((class S to S'), RS))
    = ('class S 'to S' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((class S to S')) = ('class S 'to S') .

  eq maps2QidList(((attr QI . S to QI'), RS))
    = ('attr S '. QI 'to QI' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((attr QI . S to QI')) = ('attr S '. QI 'to QI') .

  eq maps2QidList(none) = nil .

  eq attrSet2QidList(none) = nil .
  eq attrSet2QidList((assoc AtS)) = ('assoc attrSet2QidList(AtS)) .
  eq attrSet2QidList((comm AtS))  = ('comm attrSet2QidList(AtS)) .
  eq attrSet2QidList((idem AtS))  = ('idem attrSet2QidList(AtS)) .
  eq attrSet2QidList((iter AtS))  = ('iter attrSet2QidList(AtS)) .
  eq attrSet2QidList((id(T) AtS))
    = ('id: termList2QidList(T) attrSet2QidList(AtS)) .
  eq attrSet2QidList((right-id(T) AtS))
    = ('right-id: termList2QidList(T) attrSet2QidList(AtS)) .
  eq attrSet2QidList((left-id(T) AtS))
    = ('left-id: termList2QidList(T) attrSet2QidList(AtS)) .
  eq attrSet2QidList((poly(NL) AtS))
    = ('poly '`( intList2QidList(NL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((strat(NL) AtS))
    = ('strat '`( intList2QidList(NL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((memo AtS))  = ('memo attrSet2QidList(AtS)) .
  eq attrSet2QidList((prec(N) AtS))
    = ('prec intList2QidList(N) attrSet2QidList(AtS)) .
  eq attrSet2QidList((gather(QIL) AtS))
    = ('gather QIL attrSet2QidList(AtS)) .
  eq attrSet2QidList((format(QIL) AtS))
    = ('format QIL attrSet2QidList(AtS)) .
  eq attrSet2QidList((ctor AtS))  = ('ctor attrSet2QidList(AtS)) .
  eq attrSet2QidList((frozen(NL) AtS))
    = ('frozen '`( intList2QidList(NL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((config AtS))  = ('config attrSet2QidList(AtS)) .
  eq attrSet2QidList((object AtS))  = ('object attrSet2QidList(AtS)) .
  eq attrSet2QidList((msg AtS))  = ('msg attrSet2QidList(AtS)) .
  eq attrSet2QidList((special(HkL) AtS))
    = ('special '`( hookList2QidList(HkL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((none).AttrSet) = nil .
  eq attrSet2QidList((metadata(St) AtS)) = (('metadata qid("\"" + St + "\"")) attrSet2QidList(AtS)) .
  eq attrSet2QidList((nonexec AtS))  = ('nonexec attrSet2QidList(AtS)) .
  eq attrSet2QidList((variant AtS))  = ('variant attrSet2QidList(AtS)) .

  eq hookList2QidList((id-hook(QI, QIL) HkL))
    = ('id-hook QI '`, '`( QIL '`) hookList2QidList(HkL)) .
  eq hookList2QidList((op-hook(QI, QI', QIL, QI'') HkL))
    = ('op-hook QI '`( QI' ': QIL '-> QI'' '`) hookList2QidList(HkL)) .
  eq hookList2QidList((term-hook(QI, T) HkL))
    = ('term-hook '`( QI '`, termList2QidList(T) '`) hookList2QidList(HkL)) .

  eq termList2QidList(QI) = QI .
  eq termList2QidList(F[TL]) = (F '`( termList2QidList(TL) '`)) .
  ceq termList2QidList((T, TL))
    = (termList2QidList(T) '`, termList2QidList(TL))
    if TL =/= empty .

  eq intList2QidList((N NL)) = (qid(string(N, 10)) intList2QidList(NL)) .
  eq intList2QidList(nil) = nil .

  eq typeList2QidList(Ty TyL) = type2qid(Ty) typeList2QidList(TyL) .
  eq typeList2QidList(nil) = nil .

*** Let us now give the equations for \texttt{setUpModExpDeps} on the
*** renaming module expression.  Given a module expression of the form
*** \verb~ME *< RS >~ such that \texttt{ME} is in the database, we just need
*** to add \verb~ME *< RS >~ to the set of names of the modules depending on
*** \texttt{ME}. In this way, if \texttt{ME} is redefined or removed from the
*** database, \verb~ME *< RS >~ will be removed as well.

  eq setUpModExpDeps(ME * (RS),
       db(< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; DT ; U ; U' ; M ; VDS ; MNS . ME * (RS) ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps(ME * (RS),
       db(< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; DM ; U ; U' ; M ; VDS ; MNS . ME * (RS) ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  ceq setUpModExpDeps(ME * (RS), DB)
    = warning(DB, '\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n)
    if not unitInDb(ME, DB) .

*** The definition of the \texttt{prepHeader} function on a renaming module
*** expression must take into account the possibility of having parameterized
*** sorts or parameterized class names in the maps of a renaming module
*** expression.  The preparation of a renaming module expression must take
*** into account this fact and prepare accordingly all parameterized sorts and
*** classes appearing in it.

  op prepare : RenamingSet Set{Tuple{ViewExp,ViewExp}} -> RenamingSet .

  op prepare : TypeList Set{Tuple{ViewExp,ViewExp}} -> TypeList .

  eq prepModExp(ME * (RS), VEPS)
    = _*`(_`)(prepModExp(ME, VEPS), prepare(RS, VEPS)) .

*** For example, for sort maps the equation is as follows.

  eq prepare((sort S to S'), VEPS)
    = (sort prepSort(S, VEPS) to prepSort(S', VEPS)) .
  eq prepare(((sort S to S'), RS), VEPS)
    = ((sort prepSort(S, VEPS) to prepSort(S', VEPS)),
       prepare(RS, VEPS)) .


  eq prepare((class S to S'), VEPS)
    = (class prepSort(S, VEPS) to prepSort(S', VEPS)) .
  eq prepare(((class S to S'), RS), VEPS)
    = ((class prepSort(S, VEPS) to prepSort(S', VEPS)),
       prepare(RS, VEPS)) .
  eq prepare((attr QI . S to QI'), VEPS)
    = (attr QI . prepSort(S, VEPS) to QI') .
  eq prepare(((attr QI . S to QI'), RS), VEPS)
    = ((attr QI . prepSort(S, VEPS) to QI'), prepare(RS, VEPS)) .
  eq prepare((op F to F' [AtS]), VEPS) = (op F to F' [AtS]) .
  eq prepare(((op F to F' [AtS]), RS), VEPS)
    = ((op F to F' [AtS]), prepare(RS, VEPS)) .
  eq prepare((op F : TyL -> Ty to F' [AtS]), VEPS)
    = (op F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F' [AtS]) .
  eq prepare(((op F : TyL -> Ty to F' [AtS]), RS), VEPS)
    = (op F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F' [AtS],
       prepare(RS, VEPS)) .
  eq prepare((label L to L'), VEPS) = (label L to L') .
  eq prepare(((label L to L'), RS), VEPS)
    = ((label L to L'), prepare(RS, VEPS)) .
  eq prepare((msg F to F'), VEPS) = (msg F to F') .
  eq prepare(((msg F to F'), RS), VEPS)
    = ((msg F to F'), prepare(RS, VEPS)) .
  eq prepare((msg F : TyL -> Ty to F'), VEPS)
    = (msg F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F') .
  eq prepare(((msg F : TyL -> Ty to F'), RS), VEPS)
    = ((msg F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F'),
       prepare(RS, VEPS)) .
  eq prepare((none).RenamingSet, VEPS) = none .

  eq prepare((Ty TyL), VEPS) = (prepSort(Ty, VEPS) prepare(TyL, VEPS)) .
  eq prepare(nil, VEPS) = nil .

  eq header2Qid(ME * (RS))
    = qid(string(header2Qid(ME))
          + " * (" + string(qidList2Qid(maps2QidList(RS))) + ")")
    [owise] .

  ceq header2QidList(ME * (RS))
    = (if QI == '\s then QIL QI else QIL QI '\s fi
       '* '\s '`( maps2QidList(RS) '`))
    if QIL QI := header2QidList(ME)
    [owise] .

endfm

*******************************************************************************

***
*** The Union Module Expression
***

*** The syntax used for the union of module expressions is

***   op _+_ : ModuleExpression ModuleExpression -> ModuleExpression
***       [assoc prec 42] .

*** Its evaluation consists in generating a unit importing the two module
*** expressions given as arguments~\cite{Winkler91,OBJ92}.

*** As we explained in Sections~\ref{instantiation} and~\ref{renaming} for the
*** cases of the instantiation and the renaming module expressions,
*** respectively, the declaration of any new kind of module expression must
*** come together with the definition of the functions \texttt{evalModExp},
*** \texttt{header2QidList}, and \texttt{setUpModExpDeps} on the new
*** module operator. As discussed in Sections~\ref{instantiation}
*** and~\ref{parsing-unit-declarations}, equations for the \texttt{prepHeader}
*** and \texttt{parseModExp} functions have to be given as well.

fmod UNION-EXPR is
  inc MOD-EXPR .
  pr INST-EXPR-EVALUATION .
  pr RENAMING-EXPR-EVALUATION .
  pr EVALUATION .

  vars QI X : Qid .
  var  PDL : ParameterDeclList .
  vars DB DB' DB'' : Database .
  vars T T' : Term .
  vars DT DT' : Default{Term} .
  var  IL : ImportList .
  var  VEPS : Set{Tuple{ViewExp,ViewExp}} .
  vars ME ME' ME'' ME3 : ModuleExpression .
  vars PU PU' U U' U'' U3 DM DM' : Module .
  vars M M' M'' M3 : Module .
  vars MNS MNS' MNS'' MNS3 MNS4 MNS5 : Set{ModuleName} .
  vars VES VES' VES'' : Set{ViewExp} .
  vars PDS PDS' PDS'' : Set{ParameterDecl} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars QIL QIL' : QidList .
  var  VDS VDS' : OpDeclSet .
  var  B : Bool .
  var  MAPS : RenamingSet .

*** As mentioned above, the evaluation of a union module expression consists
*** in the creation of a new unit, with such a module expression as name,
*** which imports the two module expressions being united. Note, however,
*** that the unit being created has to be of the right type. The new unit
*** will be generated having one type or another, depending on the types of
*** the arguments of the union module expression.

*** The function \texttt{rightEmptyModule} generates an empty unit of the
*** lowest of the sorts of its two arguments. In case of having a nonstructured
*** module as argument, the corresponding structured one is considered. If one
*** of the two module expressions corresponds to a theory, then a theory is
*** generated, and the lowest sort is taken between the sort of such a theory
*** and the \texttt{Module} sort immediately above the sort of the other unit;
*** that is, sorts \texttt{FModule}, \texttt{SModule}, or \texttt{OModule} are
*** considered to do the comparison.

----  ceq evalModExpAux(ME + ME', PDL, DB)
----    = if unitInDb(ME'' + ME3, DB'') or-else not (unitInDb(ME'', DB'') and-then unitInDb(ME3, DB''))
----      then < DB'' ; ME'' + ME3 >
----      else < evalModule(
----                    addImports(including ME'' . including ME3 .,
----                      setName(
----                        rightEmptyModule(
----                          getTopModule(ME'', DB''),
----                          getTopModule(ME3, DB'')),
----                        ME'' +  ME3)),
----                    none,
----                    DB'') ;
----                  ME'' +  ME3 >
----      fi
----    if < DB' ; ME3 > := evalModExpAux(ME', PDL, DB)
----    /\ < DB'' ; ME'' > := evalModExpAux(ME, PDL, DB') .

  ceq evalModExp(ME + ME', PDL, DB)
    = if unitInDb(ME'', DB') or-else not summandsInDB(ME'', DB')
      then < DB' ; ME'' >
      else < evalModule(
               addImports(unfoldSummands(ME''),
                 setName(rightEmptyModule(ME'', DB'), ME'')),
               none,
               DB')
             ; ME'' >
      fi
    if < DB' ; ME'' > := evalModExp+(ME + ME', PDL, DB) .

  op summandsInDB : ModuleExpression Database -> Bool .
  eq summandsInDB(ME + ME', DB)
    = summandsInDB(ME, DB) and-then summandsInDB(ME', DB) .
  eq summandsInDB(ME, DB) = unitInDb(ME, DB) [owise] .

  op unfoldSummands : ModuleExpression -> ImportList .
  eq unfoldSummands(ME + ME') = unfoldSummands(ME) unfoldSummands(ME') .
  eq unfoldSummands(ME) = (including ME .) [owise] .

  op rightEmptyModule : ModuleExpression Database -> Module .
  eq rightEmptyModule(ME, DB) = emptyModule(kindOfModule(ME, DB)) .

  op evalModExp+ : ModuleExpression ParameterDeclList Database -> Tuple{Database, ModuleExpression} .
  eq evalModExp+(ME + ME', PDL, DB)
    = < database(evalModExp+(ME', PDL, database(evalModExp+(ME, PDL, DB))))
      ; modExp(evalModExp+(ME', PDL, database(evalModExp+(ME, PDL, DB))))
        + modExp(evalModExp+(ME, PDL, DB)) > .
  eq evalModExp+(ME, PDL, DB) = evalModExp(ME, PDL, DB) [owise] .

  op kindOfModule : ModuleExpression Database -> Qid .
  eq kindOfModule(ME + ME', DB) = greaterLowest(kindOfModule(ME, DB), kindOfModule(ME', DB)) .
  eq kindOfModule(ME, DB) = kindOfModule(getTopModule(ME, DB)) [owise] .

  op kindOfModule : Module -> Qid .
  eq kindOfModule(U:OModule)
    = if U:OModule :: FModule
      then 'fmod
      else if U:OModule :: SModule
           then 'mod
           else 'omod
           fi
      fi .
  eq kindOfModule(U:OTheory)
    = if U:OTheory :: FTheory
      then 'fmod
      else if U:OTheory :: STheory
           then 'mod
           else 'omod
           fi
      fi .
  eq kindOfModule(unitError(QIL)) = qidError(QIL) .

  op greaterLowest : Qid Qid ~> Qid [comm] .
  eq greaterLowest('fmod, 'fmod) = 'fmod .
  eq greaterLowest('fmod, 'fth) = 'fth .
  eq greaterLowest('fth, 'fth) = 'fth .
  eq greaterLowest('mod, 'fmod) = 'mod .
  eq greaterLowest('mod, 'mod) = 'mod .
  eq greaterLowest('mod, 'fth) = 'th .
  eq greaterLowest('fmod, 'th) = 'th .
  eq greaterLowest('mod, 'th) = 'th .
  eq greaterLowest('th, 'th) = 'th .
  eq greaterLowest('omod, 'fmod) = 'omod .
  eq greaterLowest('omod, 'mod) = 'omod .
  eq greaterLowest('omod, 'omod) = 'omod .
  eq greaterLowest('omod, 'fth) = 'oth .
  eq greaterLowest('omod, 'th) = 'oth .
  eq greaterLowest('omod, 'oth) = 'oth .
  eq greaterLowest('fmod, 'oth) = 'oth .
  eq greaterLowest('mod, 'oth) = 'oth .
  eq greaterLowest('oth, 'th) = 'oth .
  eq greaterLowest('oth, 'fth) = 'oth .
  eq greaterLowest('oth, 'oth) = 'oth .

  op emptyModule : Qid ~> Module .
  eq emptyModule('fmod) = emptyFModule .
  eq emptyModule('fth) = emptyFTheory .
  eq emptyModule('mod) = emptySModule .
  eq emptyModule('th) = emptySTheory .
  eq emptyModule('omod) = emptyOModule .
  eq emptyModule('oth) = emptyOTheory .

----  op rightEmptyModule : Module Module -> Module [comm] .
----
----  eq rightEmptyModule(U1:FModule, U2:FModule) = emptyFModule .
----  eq rightEmptyModule(U1:FModule, U2:FTheory) = emptyFTheory .
----  eq rightEmptyModule(U1:FTheory, U2:FModule) = emptyFTheory .
----  eq rightEmptyModule(U1:FTheory, U2:FTheory) = emptyFTheory .
----  ceq rightEmptyModule(U1:SModule, U2:SModule) = emptySModule if not U1:SModule :: FModule or not U2:SModule :: FModule .
----  ceq rightEmptyModule(U1:STheory, U2:SModule) = emptySTheory if not U1:STheory :: FTheory or not U2:SModule :: FModule .
----  ceq rightEmptyModule(U1:SModule, U2:STheory) = emptySTheory if not U1:SModule :: FModule or not U2:STheory :: FTheory .
----  ceq rightEmptyModule(U1:STheory, U2:STheory) = emptySTheory if not U1:STheory :: FTheory or not U2:STheory :: FTheory .
----  ceq rightEmptyModule(U1:OModule, U2:OModule) = emptyOModule if not U1:OModule :: SModule or not U2:OModule :: SModule .
----  ceq rightEmptyModule(U1:OTheory, U2:OModule) = emptyOTheory if not U1:OTheory :: STheory or not U2:OModule :: SModule .
----  ceq rightEmptyModule(U1:OModule, U2:OTheory) = emptyOTheory if not U1:OModule :: SModule or not U2:OTheory :: STheory .
----  ceq rightEmptyModule(U1:OTheory, U2:OTheory) = emptyOTheory if not U1:OTheory :: STheory or not U2:OTheory :: STheory .
----  eq rightEmptyModule(unitError(QIL), U) = unitError(QIL) .
----  eq rightEmptyModule(U, unitError(QIL)) = unitError(QIL) .
----  eq rightEmptyModule(unitError(QIL), unitError(QIL')) = unitError(QIL QIL') .

*** As pointed out in Section~\ref{module-names}, for each new module
*** expression operator being introduced, we need to add equations for the
*** \texttt{header2Qid} function. For the union module expression we only
*** need the following equation:

  eq header2Qid(ME + ME')
    = qidList2Qid(header2QidList(ME) '+ header2QidList(ME')) .
  eq header2Qid(_*`(_`)(ME + ME', MAPS))
    = qid("(" + string(header2Qid(ME + ME')) + ")"
          + " * (" + string(qidList2Qid(maps2QidList(MAPS))) + ")") .

  eq header2QidList(ME + ME')
    = (header2QidList(ME) '+ header2QidList(ME')) .
  ceq header2QidList(_*`(_`)(ME + ME', MAPS))
    = (if QI == '\s then '`( QIL '`) QI else '`( QIL QI '`) '\s fi
       '* '\s '`( maps2QidList(MAPS) '`))
    if QIL QI := header2QidList(ME + ME') .

*** Given a module
*** expression of the form \verb~ME + ME'~ such that \texttt{ME} and
*** \texttt{ME'} are in the database, we need to add \verb~ME + ME'~ to
*** the set of names of the modules depending on \texttt{ME} and \texttt{ME'}.
*** In this way, if \texttt{ME} or \texttt{ME'} are redefined or removed from
*** the database, \verb~ME + ME'~ will be removed as well.

  op setUpModExpDepsAux : ModuleExpression ModuleExpression Database -> Database .
  eq setUpModExpDeps(ME + ME', DB) = setUpModExpDepsAux(ME + ME', ME + ME', DB) .

  eq setUpModExpDepsAux(ME, ME' + ME'', DB)
   = setUpModExpDepsAux(ME, ME', setUpModExpDepsAux(ME, ME'', DB)) .
  eq setUpModExpDepsAux(ME, ME',
      db(< ME' ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db(< ME' ; DT ; U ; U' ; M ; VDS ; MNS . ME ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL)
   [owise] .
  eq setUpModExpDepsAux(ME, ME',
      db(< ME' ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db(< ME' ; DM ; U ; U' ; M ; VDS ; MNS . ME ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL)
   [owise] .

---(  eq setUpModExpDeps((ME + ME'),
      db((< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES >
          < ME' ; DT' ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS),
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DT ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES >
         < ME' ; DT' ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' >
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  eq setUpModExpDeps((ME + ME'),
      db((< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES >
          < ME' ; DM ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS),
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DT ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES >
         < ME' ; DM ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' >
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  eq setUpModExpDeps((ME + ME'),
      db((< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES >
          < ME' ; DT ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS),
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DM ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES >
         < ME' ; DT ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' >
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  eq setUpModExpDeps((ME + ME'),
      db((< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES >
          < ME' ; DM' ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS),
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DM ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES >
         < ME' ; DM' ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' >
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  ceq setUpModExpDeps((ME + ME'), DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n))
    if not unitInDb(ME, DB) .
  ceq setUpModExpDeps((ME + ME'), DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME') 'not 'in 'database. '\n))
    if not unitInDb(ME', DB) .
---)

*** The \texttt{prepHeader} function on a union module expression makes
*** recursive calls with each of the module expressions given as arguments.

  eq prepModExp(ME + ME', VEPS)
    = prepModExp(ME, VEPS) + prepModExp(ME', VEPS) .

*** Finally, the equation for the \texttt{parseModExp} function is as follows:

  eq labelInModExp(X, ME + ME')
    = labelInModExp(X, ME) or-else labelInModExp(X, ME') .
endfm

*******************************************************************************

***
*** The $n$-tuple Module Expression
***

*** The syntax used for the $n$-tuple module expression is as follows:

***   op TUPLE[_] : Token -> ModuleExpression .

*** Its evaluation consists in the generation of a parameterized functional
*** module with the number of \texttt{TRIV} parameters specified by the
*** argument. A sort for tuples of such size, and the corresponding constructor
*** and selector operators, are also defined. Note that the \texttt{TRIV}
*** theory is predefined in Full Maude (see Sections~\ref{main-module}
*** and~\ref{non-built-in-predefined}). For example, the module expression
*** \verb~TUPLE[3]~ produces the following module.

*** fmod TUPLE[3][C1 :: TRIV, C2 :: TRIV, C3 :: TRIV] is
***    sorts 3Tuple .
***    op (_,_,_) : Elt.C1 Elt.C2 Elt.C3 -> 3Tuple .
***    op p1_ : 3Tuple -> Elt.C1 .
***    op p2_ : 3Tuple -> Elt.C2 .
***    op p3_ : 3Tuple -> Elt.C3 .
***    var E1 : Elt.C1 .
***    var E2 : Elt.C2 .
***    var E3 : Elt.C3 .
***    eq p1(E1, E2, E3) = E1 .
***    eq p2(E1, E2, E3) = E2 .
***    eq p3(E1, E2, E3) = E3 .
*** endfm

*** Even though the $n$-tuple module expression is in principle of a completely
*** different nature, the way of handling it is the same as the way of handling
*** any other module expression. Its evaluation produces a new unit, a
*** parameterized functional module in this case, wtupleParList(N)ith the module expression as
*** name. New equations defining the semantics of functions
*** \texttt{evalModExp}, \texttt{header2QidList},
*** \texttt{setUpModExpDeps}, \texttt{prepHeader}, and
*** \texttt{parseModExp} are given for this module expression.


fmod N-TUPLE-EXPR is
  inc MOD-EXPR .
  pr INST-EXPR-EVALUATION .
  pr EVALUATION .

  vars N N' : NzNat .
  var  PDL : ParameterDeclList .
  var  DB : Database .
  var  T : Term .
  var  IL : ImportList .
  var  VEPS : Set{Tuple{ViewExp,ViewExp}} .
  var  X : Qid .
  var  S : Sort .

*** The equation for the \texttt{evalModExp} is reduced to the creation of a
*** module as indicated above. Some auxiliary functions are defined in order
*** to generate the different declarations in the module.

  op tupleParList : NzNat -> ParameterDeclList .
  op tupleImportList : NzNat -> ImportList .
  op createCopyPars : NzNat Database -> Database .
  op tupleOps : NzNat -> OpDeclSet .
  op tupleOpsCtor : NzNat -> OpDecl .
  op tupleOpsCtorName : NzNat -> String .
  op tupleOpsCtorArity : NzNat -> QidList .
  op tupleOpsSelectors : NzNat NzNat -> OpDeclSet .
  op tupleEqSet : NzNat -> EquationSet .
  op tupleEqSetAux : NzNat Term -> EquationSet .
  op tupleTermArgs : NzNat -> TermList .
  ops tupleSort tupleSortAux : NzNat -> Sort .

  eq evalModExp(TUPLE[N], PDL, DB)
    = if unitInDb(TUPLE[N], DB)
      then < DB ; TUPLE[N] >
      else < evalModule(
               fmod TUPLE[N]{tupleParList(N)} is
                 nil  ---- tupleImportList(N)
                 sorts tupleSort(N) .
                 none
                 tupleOps(N)
                 none
                 tupleEqSet(N)
               endfm,
               none,
               createCopyPars(N, DB)) ;
             TUPLE[N] >
      fi .

  eq createCopyPars(N, DB)
    = if N == 1
      then createCopy((qid("C" + string(N, 10)) :: 'TRIV), DB)
      else createCopyPars(_-_(N, 1),
             createCopy((qid("C" + string(N, 10)) :: 'TRIV), DB))
      fi .

  eq tupleParList(N)
    = if N == 1
      then (qid("C" + string(N, 10)) :: 'TRIV)
      else (tupleParList(_-_(N, 1)), (qid("C" + string(N, 10)) :: 'TRIV))
      fi .

  eq tupleImportList(N)
    = if N == 1
      then (including pd(qid("C" + string(N, 10)) :: 'TRIV) .)
      else (tupleImportList(_-_(N, 1))
            (including pd(qid("C" + string(N, 10)) :: 'TRIV) .))
      fi .

  eq tupleSort(N) = makeSort('Tuple, tupleSortAux(N)) .

  eq tupleSortAux(N)
    = if N == 1
      then qid("C" + string(N, 10))
      else (tupleSortAux(_-_(N, 1)), qid("C" + string(N, 10)))
      fi .

  eq tupleOps(N)
    = (tupleOpsCtor(N) tupleOpsSelectors(N, N)) .

  eq tupleOpsCtor(N)
    = (op qid("(" + tupleOpsCtorName(N) + ")") :
            tupleOpsCtorArity(N) -> tupleSort(N) [none] .) .

  eq tupleOpsCtorName(N)
    = if N == 1
      then "_"
      else "_," + tupleOpsCtorName(_-_(N, 1))
      fi .

  eq tupleOpsCtorArity(N)
    = if N == 1
      then qid("C" + string(N, 10) + "$Elt")
      else tupleOpsCtorArity(_-_(N, 1)) qid("C" + string(N, 10) + "$Elt")
      fi .

  eq tupleOpsSelectors(N, N')
    = if N == 1
      then (op qid("p" + string(N, 10) + "_") :
                 tupleSort(N') -> qid("C" + string(N, 10) + "$Elt") [none] .)
      else (tupleOpsSelectors(_-_(N, 1), N')
            (op qid("p" + string(N, 10) + "_") :
                  tupleSort(N') -> qid("C" + string(N, 10) + "$Elt") [none] .))
      fi .

  eq tupleEqSet(N)
    = tupleEqSetAux(N,
        (qid("(" + tupleOpsCtorName(N) + ")") [ tupleTermArgs(N) ])) .

  eq tupleTermArgs(N)
    = if N == 1
      then qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt")
      else (tupleTermArgs(_-_(N, 1)),
            qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt"))
      fi .

  eq tupleEqSetAux(N, T)
    = if N == 1
      then (eq qid("p" + string(N, 10) + "_")[T]
              = qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt")
              [none] .)
      else (tupleEqSetAux(_-_(N, 1), T)
            (eq qid("p" + string(N, 10) + "_")[T]
               = qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt")
               [none] .))
      fi .

*** The equations for the \texttt{header2QidList},
*** \texttt{parseModExp}, \texttt{prepHeader}, and
*** \texttt{setUpModExpDeps} functions on the $n$-tuple module
*** expression are as follows:

  eq header2Qid(TUPLE[N]) = qid("TUPLE[" + string(N, 10) + "]") .
  eq header2QidList(TUPLE[N]) = ('TUPLE '`[ qid(string(N, 10)) '`]) .

  eq prepModExp(TUPLE[N], VEPS) = TUPLE[N] .

  eq setUpModExpDeps(TUPLE[N], DB) = DB .

endfm

fmod N-POWER-EXPR is
  inc MOD-EXPR .
  pr INST-EXPR-EVALUATION .
  pr EVALUATION .

  vars N N' : NzNat .
  var  PDL : ParameterDeclList .
  var  DB : Database .
  var  T : Term .
  var  IL : ImportList .
  var  VEPS : Set{Tuple{ViewExp,ViewExp}} .
  var  X : Qid .
  var  S : Sort .

*** As for TUPLE, the equation for the \texttt{evalModExp} is reduced to the
*** creation of a new module. A module expression POWER[n]{Nat} produces a
*** module
***
*** fmod POWER[n]{X :: TRIV} is
***   inc TUPLE[n]{X, X, ..., X} .
*** endfm
***
*** which is then instantiated by the Nat view.

*** Some auxiliary functions are defined in order
*** to generate the different declarations in the module.

  op powImportList : NzNat -> ImportList .
  op powTupleImportation : NzNat -> ViewExp .

  eq evalModExp(POWER[N], PDL, DB)
    = if unitInDb(POWER[N], DB)
      then < DB ; POWER[N] >
      else < evalModule(
               fmod POWER[N]{'X :: 'TRIV} is
                 powImportList(N)
                 sorts none .
                 none
                 none
                 none
                 none
               endfm,
               none,
               createCopy('X :: 'TRIV, DB)) ;
             POWER[N] >
      fi .

  eq powImportList(N)
    = (including TUPLE[N]{powTupleImportation(N)} .) .

  eq powTupleImportation(N)
    = if N == 1
      then 'X
      else ('X, powTupleImportation(sd(N, 1)))
      fi .

*** The equations for the \texttt{header2QidList},
*** \texttt{parseModExp}, \texttt{prepHeader}, and
*** \texttt{setUpModExpDeps} functions on the $n$-tuple module
*** expression are as follows:

  eq header2Qid(POWER[N]) = qid("POWER[" + string(N, 10) + "]") .
  eq header2QidList(POWER[N]) = ('POWER '`[ qid(string(N, 10)) '`]) .

  eq prepModExp(POWER[N], VEPS) = POWER[N] .

  eq setUpModExpDeps(POWER[N], DB) = DB .

endfm

*******************************************************************************

***
*** 8 Input/Output Processing
***

*** In this section we discuss how the preterm resulting from the call to the
*** function \texttt{metaParse} with the input and the top-level signature of
*** Full Maude is transformed into a term of sort \texttt{Module}, representing
*** a preunit or a term of sort \texttt{PreView}. In the case of commands,
*** they are evaluated giving the corresponding results in the appropriate
*** form.

***
*** 8.1 Input Parsing
***

*** Let us recall here the example presented in Section~\ref{bubbles}. Calling
*** \texttt{metaParse} with the module \texttt{NAT3} given there and the
*** signature of Full Maude presented in Section~\ref{sec:signature}, we
*** obtain the following term.

***    'fmod_is_endfm[
***       'token[{''NAT3}'Qid],
***       '__['sort_.['token[{''Nat3}'Qid]],
***           '__['op_:_->_.['token[{''s_}'Qid],
***                          'neTokenList[{''Nat3}'Qid],
***                          'token[{''Nat3}'Qid]],
***               '__['op_:`->_.['token[{''0}'Qid],
***                              'token[{''Nat3}'Qid]],
***                   'eq_=_.['bubble['__[{''s}'Qid, {''s}'Qid,
***                                       {''s}'Qid, {''0}'Qid]],
***                           'bubble[{''0}'Qid]]]]]]

*** Given each one of the subterms representing declarations in terms
*** representing modules as the previous one, the function \texttt{parseDecl}
*** generates the corresponding declaration, with no bubbles in it, and the
*** corresponding predeclaration, with the bubbles appearing in the term. For
*** example, for the term
***
***   'op_:_->_.['token[{''s_}'Qid],
***              'neTokenList[{''Nat3}'Qid],
***              'token[{''Nat3}'Qid]]
***
*** the following operator declaration is generated:
***
***   op 's_ : 'Nat3 -> 'Nat3 [none] .
***
*** Note that in this case, since the operator is declared without identity
*** element (the only place a bubble might appear), the declaration and the
*** predeclaration generated by \texttt{parseDecl} coincide.

*** In the following sections we shall see how this approach is followed for
*** declarations appearing in units and in views.

***
*** 8.1.1 Parsing of Module Declarations
***

*** The \texttt{parseDecl} function takes a term (which corresponds to a
*** declaration to be parsed), a preunit (to which the parsed declaration with
*** its bubbles in it will be added), and a unit (to which the parsed
*** declaration without bubbles will be added to build up the signature). For
*** example, a term corresponding to an unconditional equation, that is, a term
*** of the form \verb~'eq_=_.[T, T']~ will be added to the set of equations of
*** the preunit as \verb~eq T = T' .~, but nothing will be added to the unit.
*** Note that according to the signature used in the call to
*** \texttt{metaParse} (see Sections~\ref{sec:signature}
*** and~\ref{main-module}), \texttt{T} and \texttt{T'} are bubbles.
*** Declarations of sorts, subsort relations, operators, classes, subclass
*** relations, messages, and variables will be added to both of them. In the
*** case of operator declarations, identity element attributes, which in
*** general can be terms, are not included in the added declaration.

*** As in Core Maude, declarations in a module can be given in any order, and
*** therefore we follow a two-step approach consisting in first building the
*** signature to parse the bubbles, and then generating the unit without
*** bubbles in it. It could be different for other languages. For example, in
*** some languages we may be able to assume that each operator and sort has
*** been defined before being used, allowing then an incremental processing of
*** the input.

---- fmod MAYBE{X :: TRIV} is
----   sort Maybe{X} .
----   subsort X$Elt < Maybe{X} .
----   op maybe : -> Maybe{X} .
---- endfm

fmod UNIT-DECL-PARSING is
  pr DATABASE .
  pr MOVE-DOWN .
  pr INST-EXPR-EVALUATION .
  pr RENAMING-EXPR-EVALUATION .
  pr UNION-EXPR .
  pr N-TUPLE-EXPR .
  pr N-POWER-EXPR .
  pr DEFAULT-VALUE{Term} .
  pr META-FULL-MAUDE-SIGN .
  pr UNIT-BUBBLE-PARSING .

  vars PU U : Module .
  vars T T' T'' T''' T3 T4 : Term .
  vars QI QI' QI'' L F : Qid .
  vars QIL QIL' : QidList .
  vars S S' : Sort .
  vars SS SS' : TypeSet .
  vars TyL TyL' : TypeList .
  var  TSL : TypeSetList .
  var  AtS : AttrSet .
  vars TL TL' TL'' : TermList .
  var  Ct : Constant .
  var  VDS : OpDeclSet .
  vars Ty Tp : Type .
  var  N : Nat .
  var  DT : Default{Term} .

*** Similarly, auxiliary functions parsing other elements in units
*** are defined.

  op parsePreAttrs : Term Nat -> AttrSet .
  op parsePreHookList : Term -> HookList .
  op parseVars : QidList [Type] -> OpDeclSet .
  op parseSubsortRel : Term -> TypeListSet .

  op parseAttrDeclList : Term -> AttrDeclSet .
  op unfoldOpDecl : QidList TypeList Sort AttrSet -> OpDeclSet .
  op unfoldMultipleMsgDecl : QidList TypeList Sort -> MsgDeclSet .
  op unfoldSubsortRel : TypeSetList ~> SubsortDeclSet .
  op unfoldSubclassRel : TypeSetList ~> SubclassDeclSet .

  eq parseSubsortRel('_<_[T, T'])
    = _l_(parseSortSet(T), parseSubsortRel(T')) .
  eq parseSubsortRel('__[T, T']) = parseSortSet('__[T, T']) .
  eq parseSubsortRel('sortToken[T]) = downQid(T) .
  eq parseSubsortRel('_`{_`}['sortToken[T], T'])
    = makeSort(downQid(T), parseParameterList(T')) .
  eq parseSubsortRel('_`{_`}['_`{_`}[T, T'], T''])
    = makeSort(parseSubsortRel('_`{_`}[T, T']), parseParameterList(T'')) .

  eq unfoldOpDecl((QI QIL), TyL, Ty, AtS)
    = ((op QI : TyL -> Ty [AtS] .) unfoldOpDecl(QIL, TyL, Ty, AtS)) .
  eq unfoldOpDecl(nil, TyL, Ty, AtS) = none .

  eq unfoldMultipleMsgDecl((QI QIL), TyL, Ty)
    = ((msg QI : TyL -> Ty .) unfoldMultipleMsgDecl(QIL, TyL, Ty)) .
  eq unfoldMultipleMsgDecl(nil, TyL, Ty) = none .

  eq unfoldSubsortRel(_l_((S ; SS), (S' ; SS'), TSL))
    = ((subsort S < S' .)
       unfoldSubsortRel(_l_(S, SS'))
       unfoldSubsortRel(_l_(SS, (S' ; SS')))
       unfoldSubsortRel(_l_((S' ; SS'), TSL))) .
  eq unfoldSubsortRel(_l_(SS, none)) = none .
  eq unfoldSubsortRel(_l_(none, SS)) = none .
  eq unfoldSubsortRel(SS) = none .
  eq unfoldSubsortRel(qidError(QIL)) = subsortDeclError(QIL) .

  eq unfoldSubclassRel(_l_((S ; SS), (S' ; SS'), TSL))
    = ((subclass S < S' .)
       unfoldSubclassRel(_l_(S, SS'))
       unfoldSubclassRel(_l_(SS, (S' ; SS')))
       unfoldSubclassRel(_l_((S' ; SS'), TSL))) .
  eq unfoldSubclassRel(_l_(SS, none)) = none .
  eq unfoldSubclassRel(_l_(none, SS)) = none .
  eq unfoldSubclassRel(SS) = none .
  eq unfoldSubclassRel(qidError(QIL)) = subclassDeclError(QIL) .

  eq parseVars((QI QIL), Tp)
    = ((op QI : nil -> Tp [none] .) parseVars(QIL, Tp)) .
  eq parseVars(nil, Tp) = none .
  eq parseVars(QIL, qidError(QIL')) = opDeclError(QIL') .

  eq parsePreAttrs('__[T, T'], N)
    = (parsePreAttrs(T, N) parsePreAttrs(T', N)) .
  eq parsePreAttrs('assoc.@Attr@, N) = assoc .
  eq parsePreAttrs('associative.@Attr@, N) = assoc .
  eq parsePreAttrs('comm.@Attr@, N) = comm .
  eq parsePreAttrs('commutative.@Attr@, N) = comm .
  eq parsePreAttrs('idem.@Attr@, N) = idem .
  eq parsePreAttrs('idempotent.@Attr@, N) = idem .
  eq parsePreAttrs('id:_[T], N) = id(T) .
  eq parsePreAttrs('identity:_[T], N) = id(T) .
  eq parsePreAttrs('left`id:_[T], N) = left-id(T) .
  eq parsePreAttrs('left`identity:_[T], N) = left-id(T) .
  eq parsePreAttrs('right`id:_[T], N) = right-id(T) .
  eq parsePreAttrs('right`identity:_[T], N) = right-id(T) .
  eq parsePreAttrs('poly`(_`)[T], N) = poly(parseInt(T)) .
  eq parsePreAttrs('strat`(_`)[T], N) = strat(parseInt(T)) .
  eq parsePreAttrs('strategy`(_`)[T], N) = strat(parseInt(T)) .
  eq parsePreAttrs('frozen.@Attr@, N)
    = if N == 0
      then none
      else frozen(from 1 to N list)
      fi .
  eq parsePreAttrs('frozen`(_`)[T], N) = frozen(parseInt(T)) .
  eq parsePreAttrs('memo.@Attr@, N) = memo .
  eq parsePreAttrs('memoization.@Attr@, N) = memo .
  eq parsePreAttrs('ctor.@Attr@, N) = ctor .
  eq parsePreAttrs('constructor.@Attr@, N) = ctor .
  eq parsePreAttrs('prec_['token[T]], N) = prec(parseNat(T)) .
  eq parsePreAttrs('gather`(_`)['neTokenList[T]], N) = gather(downQidList(T)) .
  eq parsePreAttrs('special`(_`)[T], N) = special(parsePreHookList(T)) .
  eq parsePreAttrs('format`(_`)['neTokenList[T]], N) = format(downQidList(T)) .
  eq parsePreAttrs('iter.@Attr@, N) = iter .
  eq parsePreAttrs('ditto.@Attr@, N) = ditto .
  eq parsePreAttrs('config.@Attr@, N) = config .
  eq parsePreAttrs('object.@Attr@, N) = object .
  eq parsePreAttrs('msg.@Attr@, N) = msg .
  eq parsePreAttrs('message.@Attr@, N) = msg .
  eq parsePreAttrs('metadata_['token[T]], N) = metadata(downString(downQid(T))) .
  eq parsePreAttrs('nonexec.@Attr@, N) = nonexec .
  eq parsePreAttrs('variant.@Attr@, N) = variant .

  eq parsePreHookList('__[T, TL]) = parsePreHookList(T) parsePreHookList(TL) .
  eq parsePreHookList('id-hook_['token[T]]) = id-hook(downQid(T), nil) .
  eq parsePreHookList('id-hook_`(_`)['token[T], 'neTokenList[T']])
    = id-hook(downQid(T), downQidList(T')) .
  eq parsePreHookList(
       'op-hook_`(_:_->_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parsePreHookList('op-hook_`(_:`->_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parsePreHookList(
       'op-hook_`(_:_~>_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parsePreHookList('op-hook_`(_:`~>_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parsePreHookList('term-hook_`(_`)['token[T], T'])
    = term-hook(downQid(T), T') .

  eq parseAttrDeclList('_`,_[T, T'])
    = (parseAttrDeclList(T), parseAttrDeclList(T')) .
  eq parseAttrDeclList('_:_['token[T], T'])
    = (attr downQid(T) : parseType(T')) .

*** Given a term representing a declaration or a predeclaration, the function
*** \texttt{parseDecl} must generate and update both the unit and the preunit
*** that it takes as arguments. Note that in the case of rules, for example,
*** only a prerule is generated.

*** Since the preunit and the unit may be modified, they have to be returned as
*** a pair, which will be used to extract the corresponding arguments for the
*** following calls. Note that the \texttt{parseDecl} functions are in fact
*** partial functions. Each parsing function assumes that it is possible to
*** parse the given term.

  sort ParseDeclResult .
  op <_;_;_> : Module Module OpDeclSet -> ParseDeclResult .
  op preModule : ParseDeclResult -> Module .
  op unit : ParseDeclResult -> Module .
  op vars : ParseDeclResult -> OpDeclSet .

  eq preModule(< PU ; U ; VDS >) = PU .
  eq preModule(< unitError(QIL) ; V:[Module] ; V:[OpDeclSet] >) = unitError(QIL) .
  eq preModule(< V:[Module] ; unitError(QIL) ; V:[OpDeclSet] >) = unitError(QIL) .
  eq preModule(< V:[Module] ; V':[Module] ; opDeclError(QIL) >) = unitError(QIL) .
  eq unit(< PU ; U ; VDS >) = U .
  eq unit(< unitError(QIL) ; V':[Module] ; V:[OpDeclSet] >) = unitError(QIL) .
  eq unit(< V:[Module] ; unitError(QIL) ; V:[OpDeclSet] >) = unitError(QIL) .
  eq unit(< V:[Module] ; V':[Module] ; opDeclError(QIL) >) = unitError(QIL) .
  eq vars(< PU ; U ; VDS >) = VDS .
  eq vars(< unitError(QIL) ; V:[Module] ; V:[OpDeclSet] >) = opDeclError(QIL) .
  eq vars(< V:[Module] ; unitError(QIL) ; V:[OpDeclSet] >) = opDeclError(QIL) .
  eq vars(< V:[Module] ; V':[Module] ; opDeclError(QIL) >) = opDeclError(QIL) .

  op parseDecl : Term Module Module OpDeclSet -> ParseDeclResult .

*** changed 03/27/02
*** In the case of importation declarations, since internally only the
*** \texttt{including} mode is handled, all importations are generated in
*** this mode, independently of the keyword used in the input.

  eq parseDecl('inc_.[T], PU, U, VDS)
    = parseDecl('including_.[T], PU, U, VDS) .
  eq parseDecl('ex_.[T], PU, U, VDS)
    = parseDecl('extending_.[T], PU, U, VDS) .
  eq parseDecl('pr_.[T], PU, U, VDS)
    = parseDecl('protecting_.[T], PU, U, VDS) .
  eq parseDecl('including_.[T], PU, U, VDS)
    = < addImports((including parseModExp(T) .), PU) ; U ; VDS > .
  eq parseDecl('extending_.[T], PU, U, VDS)
    = < addImports((extending parseModExp(T) .), PU) ; U ; VDS > .
  eq parseDecl('protecting_.[T], PU, U, VDS)
    = < addImports((protecting parseModExp(T) .), PU) ; U ; VDS > .

  eq parseDecl('sort_.[T], PU, U, VDS) = parseDecl('sorts_.[T], PU, U, VDS) .
  eq parseDecl('sorts_.[T], PU, U, VDS)
    = < addSorts(parseSortSet(T), PU) ; addSorts(parseSortSet(T), U) ; VDS > .

  eq parseDecl('subsort_.[T], PU, U, VDS)
    = parseDecl('subsorts_.[T], PU, U, VDS) .
  eq parseDecl('subsorts_.[T], PU, U, VDS)
    = < addSubsorts(unfoldSubsortRel(parseSubsortRel(T)), PU) ;
        addSubsorts(unfoldSubsortRel(parseSubsortRel(T)), U) ; VDS > .

*** As pointed out in Section~\ref{SyntacticalRequirementsAndCaveats}, the
*** name of operators in operator declaration has to be given as a single
*** token identifier (see Section~\ref{order-sorted}). We assume that when
*** declaring a multitoken operator, its name is given as a single quoted
*** identifier in which each token is preceded by a backquote. Thus, the name
*** of an operator \verb~_(_)~, for example, is given as \verb~_`(_`)~.

  eq parseDecl('op_:`->_.['token[T], T'], PU, U, VDS)
    = < addOps((op downQid(T) : nil -> parseType(T') [none] .), PU) ;
        addOps((op downQid(T) : nil -> parseType(T') [none] .), U) ;
        VDS > .
  eq parseDecl('op_:`->_`[_`].['token[T], T', T''], PU, U, VDS)
    = < addOps(
          (op downQid(T) : nil -> parseType(T') [parsePreAttrs(T'', 0)] .),
          PU) ;
        addOps(
          (op downQid(T) : nil -> parseType(T') [parseAttrs(T'')] .),
          U) ;
        VDS > .
  eq parseDecl('op_:_->_.['token[T], T', T''], PU, U, VDS)
    = < addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'') [none] .),
          PU) ;
        addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'') [none] .),
          U) ;
        VDS > .
  eq parseDecl('op_:_->_`[_`].['token[T], T', T'', T3], PU, U, VDS)
    = < addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'')
               [parsePreAttrs(T3, size(parseTypeList(T')))] .), PU) ;
        addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'')
               [parseAttrs(T3)] .), U) ;
        VDS > .

  ceq parseDecl('op_:`->_.[F[TL], T], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:`->_`[_`].[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:_->_.[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:_->_`[_`].[F[TL], T, T', T''], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .

  eq parseDecl('ops_:`->_.['neTokenList[T], T'], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'), none), PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'), none), U) ;
        VDS > .
  eq parseDecl('ops_:`->_`[_`].['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'),
            parsePreAttrs(T'', 0)),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'),
            parseAttrs(T'')),
          U) ;
        VDS > .
  eq parseDecl('ops_:_->_.['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'),
            parseType(T''), none),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'),
            parseType(T''), none),
          U) ;
        VDS > .
  eq parseDecl('ops_:_->_`[_`].['neTokenList[T], T', T'', T3], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'), parseType(T''),
            parsePreAttrs(T3, size(parseTypeList(T')))), PU) ;
        addOps(
          unfoldOpDecl(downTypes(T),
            parseTypeList(T'), parseType(T''), parseAttrs(T3)), U) ;
        VDS > .

  eq parseDecl('op_:`~>_.['token[T], T'], PU, U, VDS)
    = < addOps((op downQid(T) : nil -> kind(parseType(T')) [none] .), PU) ;
        addOps((op downQid(T) : nil -> kind(parseType(T')) [none] .), U) ;
        VDS > .
  eq parseDecl('op_:`~>_`[_`].['token[T], T', T''], PU, U, VDS)
    = < addOps((op downQid(T) : nil -> kind(parseType(T'))
                    [parsePreAttrs(T'', 0)] .), PU) ;
        addOps((op downQid(T) : nil -> kind(parseType(T'))
                    [parseAttrs(T'')] .), U) ;
        VDS > .
  eq parseDecl('op_:_~>_.['token[T], T', T''], PU, U, VDS)
    = < addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                    [none] .), PU) ;
        addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                    [none] .), U) ;
        VDS > .
  eq parseDecl('op_:_~>_`[_`].['token[T], T', T'', T3], PU, U, VDS)
    = < addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                   [parsePreAttrs(T3, size(parseTypeList(T')))] .), PU) ;
        addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                   [parseAttrs(T3)] .), U) ;
        VDS > .

  ceq parseDecl('op_:`~>_.[F[TL], T], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:`~>_`[_`].[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:_~>_.[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .
  ceq parseDecl('op_:_~>_`[_`].[F[TL], T, T', T''], PU, U, VDS)
    = < PU ; U ; VDS >
    if F =/= 'token .

  eq parseDecl('ops_:`~>_.['neTokenList[T], T'], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')), none),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')), none),
          U) ;
        VDS > .
  eq parseDecl('ops_:`~>_`[_`].['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')),
            parsePreAttrs(T'', 0)),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')),
            parseAttrs(T'')), U) ;
        VDS > .
  eq parseDecl('ops_:_~>_.['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'),
            kind(parseType(T'')), none),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'),
            kind(parseType(T'')), none),
          U) ;
        VDS > .
  eq parseDecl('ops_:_~>_`[_`].['neTokenList[T], T', T'', T3], PU,
       U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'), parseType(T''),
            parsePreAttrs(T3, size(parseTypeList(T')))),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T),
            parseTypeList(T'), parseType(T''), parseAttrs(T3)), U) ;
        VDS > .

  eq parseDecl('var_:_.['neTokenList[T], T'], PU, U, VDS)
    = parseDecl('vars_:_.['neTokenList[T], T'], PU, U, VDS) .
  eq parseDecl('vars_:_.['neTokenList[T], T'], PU, U, VDS)
    = < PU ; U ; VDS parseVars(downQidList(T), parseType(T')) > .

  eq parseDecl('mb_:_.['bubble['__[''`[.Qid, L, ''`].Qid]], T], PU, U, VDS)
    = < addMbs((mb getTerm(breakMb(T, VDS)) : getSort(breakMb(T, VDS))
                  [label(downQid(L)) getAttrSet(breakMb(T, VDS))] .), PU) ; U ; VDS > .
  eq parseDecl('mb_:_.[T, T'], PU, U, VDS)
    = < addMbs((mb T : getSort(breakMb(T', VDS)) [getAttrSet(breakMb(T', VDS))] .), PU) ; U ; VDS >
    [owise] .
  eq parseDecl('cmb_:_if_.[T, T', T''], PU, U, VDS)
    = < addMbs(
          (cmb T : getSort(breakMb(T', VDS))
             if term(pullStmtAttrOut(T'', VDS)) = 'true.Bool
             [attrSet(pullStmtAttrOut(T'', VDS))] .), PU) ; U ; VDS > .
  eq parseDecl('cmb`[_`]:_:_if_.['token[T'''], T, T', T''], PU, U, VDS)
    = < addMbs(
          (cmb T : getSort(breakMb(T', VDS))
             if term(pullStmtAttrOut(T'', VDS)) = 'true.Bool
             [attrSet(pullStmtAttrOut(T'', VDS)) label(downQid(T'''))] .), PU) ; U ; VDS > .

  sort Tuple{Default{Term},Sort,AttrSet} .

  op breakMb : Term OpDeclSet -> [Tuple{Default{Term},Sort,AttrSet}] .
  op breakMbAux : Term TermList AttrSet OpDeclSet -> [Tuple{Default{Term},Sort,AttrSet}] .
  op {_,_,_} : Default{Term} Sort AttrSet -> Tuple{Default{Term},Sort,AttrSet} .
  op getTerm : Tuple{Default{Term},Sort,AttrSet} -> Default{Term} .
  op getSort : Tuple{Default{Term},Sort,AttrSet} -> Sort .
  op getAttrSet : Tuple{Default{Term},Sort,AttrSet} -> AttrSet .
  eq getTerm({DT, S, AtS}) = DT .
  eq getTerm({DT, qidError(QIL), AtS}) = DT .
  eq getSort({DT, S, AtS}) = S .
  eq getSort({DT, qidError(QIL), AtS}) = qidError(QIL) .
  eq getAttrSet({DT, S, AtS}) = AtS .
  eq getAttrSet({DT, qidError(QIL), AtS}) = AtS .

----  eq breakMb('bubble[QI]) = {maybe, downQidList(QI), none} .
----  eq breakMb('bubble['__[QI, QI']])
----    = {maybe, getType(parseTypeMb('bubble['__[QI, QI']])), none} .
----  eq breakMb('bubble['__[QI, QI', QI'']])
----    = {getTerm(parseTypeMb('bubble['__[QI, QI', QI'']])),
----       getType(parseTypeMb('bubble['__[QI, QI', QI'']])),
----       none} .
  eq breakMb('bubble['__[QI, QI', TL, QI'']], VDS)
    = if QI'' =/= ''`].Qid
      then {getTerm(parseTypeMb('bubble['__[QI, QI', TL, QI'']])),
            getType(parseTypeMb('bubble['__[QI, QI', TL, QI'']])),
            none}
      else breakMbAux('bubble['__[QI, QI', TL, QI'']], (QI, QI', TL), none, VDS)
      fi .
  eq breakMb('sortToken[T], VDS) = {null, parseType('sortToken[T]), none} [owise] .
  eq breakMb('_`{_`}[T, T'], VDS) = {null, parseType('_`{_`}[T, T']), none} [owise] .
  eq breakMb(T, VDS) = {null, getType(parseTypeMb(T)), none} [owise] .

  eq breakMbAux(T, (TL, ''`[.Qid), AtS, VDS)
    = if AtS =/= none
      then {null, getType(parseTypeMb('bubble[TL])), AtS}
      else {null, T, none}
      fi .
  eq breakMbAux(T, (TL, QI, QI', ''`[.Qid), AtS, VDS)
    = if AtS =/= none
      then {getTerm(parseTypeMb('bubble['__[TL, QI, QI']])),
            getType(parseTypeMb('bubble['__[TL, QI, QI']])), AtS}
      else {getTerm(parseTypeMb(T)), getType(parseTypeMb(T)), none}
      fi .
  eq breakMbAux(T, (TL, QI, ''nonexec.Qid), AtS, VDS)
    = breakMbAux(T, (TL, QI), AtS nonexec, VDS) .
  eq breakMbAux(T, (TL, QI, ''variant.Qid), AtS, VDS)
    = breakMbAux(T, (TL, QI), AtS variant, VDS) .
  eq breakMbAux(T, (TL, QI, ''owise.Qid), AtS, VDS)
    = breakMbAux(T, (TL, QI), AtS owise, VDS) .
  eq breakMbAux(T, (TL, QI, ''otherwise.Qid), AtS, VDS)
    = breakMbAux(T, (TL, QI), AtS owise, VDS) .
  eq breakMbAux(T, (TL, QI, ''label.Qid, QI'), AtS, VDS)
    = if downQid(QI') :: Qid
      then breakMbAux(T, (TL, QI), AtS label(downQid(QI')), VDS)
      else {null, T, none}
      fi .
  eq breakMbAux(T, (TL, QI, ''metadata.Qid, QI'), AtS, VDS)
    = if downString(downQid(QI')) :: String
      then breakMbAux(T, (TL, QI), AtS metadata(downString(downQid(QI'))), VDS)
      else {null, T, none}
      fi .
  ceq breakMbAux(T, (TL, QI, ''`[.Qid, TL',  ''print.Qid, TL''), AtS, VDS)
    = breakMbAux(T, (TL, QI, ''`[.Qid, TL'), AtS print(printArg(TL'', VDS)), VDS)
    if printArg(TL'', VDS) : QidList .
  eq breakMbAux(T, TL, AtS, VDS)  = {null, T, none} [owise] .

  op parseTypeMb : Term ~> ResultPair .
----  eq parseTypeMb('bubble[T])
----    = parseType(getTerm(metaParse(upModule('EXTENDED-SORTS, false), downQidList(T), '@Sort@))) .
  eq parseTypeMb('bubble[TL])
    = if metaParse(
           addOps(
             op '_:_ : '@Bubble@ '@Sort@ -> '@TermSort@ [none] .,
             addSorts('@TermSort@, GRAMMAR)),
           downQidList(TL), '@TermSort@) :: ResultPair
      then breakTermSort(
             getTerm(
               metaParse(
                 addOps(
                   op '_:_ : '@Bubble@ '@Sort@ -> '@TermSort@ [none] .,
                   addSorts('@TermSort@, GRAMMAR)),
                 downQidList(TL), '@TermSort@)))
      else {null, parseType(getTerm(metaParse(GRAMMAR, downQidList(TL), '@Sort@)))}
      fi .

  op breakTermSort : Term ~> ResultPair .
  eq breakTermSort('_:_[T, T']) = {T, parseType(T')} .

  eq parseDecl('eq_=_.[T, T'], PU, U, VDS)
    = < addEqs((eq T = T' [none] .), PU) ; U ; VDS > .
  eq parseDecl('ceq_=_if_.[T, T', T''], PU, U, VDS)
    = < addEqs((ceq T = T' if T'' = 'true.Bool [none] .), PU) ; U ; VDS > .
  eq parseDecl('cq_=_if_.[T, T', T''], PU, U, VDS)
    = < addEqs((ceq T = T' if T'' = 'true.Bool [none] .), PU) ; U ; VDS > .

  eq parseDecl('rl_=>_.[T, T'], PU, U, VDS)
    = < addRls((rl T => T' [none] .), PU) ; U ; VDS > .
  eq parseDecl('crl_=>_if_.[T, T', T''], PU, U, VDS)
    = < addRls((crl T => T' if T'' = 'true.Bool [none] .), PU) ; U ; VDS > .

  eq parseDecl('class_|`.[T], PU, U, VDS)
    = parseDecl('class_.[T], PU, U, VDS) .
  eq parseDecl('class_.[T], PU, U, VDS)
    = < addClasses((class parseType(T) | none .), PU) ;
        addClasses((class parseType(T) | none .), U) ; VDS > .
  eq parseDecl('class_|_.[T, T'], PU, U, VDS)
    = < addClasses((class parseType(T) | parseAttrDeclList(T') .), PU) ;
        addClasses((class parseType(T) | parseAttrDeclList(T') .), U) ; VDS > .

  eq parseDecl('subclass_.[T], PU, U, VDS)
    = < addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), PU) ;
        addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), U) ; VDS > .
  eq parseDecl('subclasses_.[T], PU, U, VDS)
    = < addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), PU) ;
        addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), U) ; VDS > .

  eq parseDecl('msg_:_->_.['token[T], T', T''], PU, U, VDS)
    = < addMsgs((msg downQid(T) : parseTypeList(T') -> parseType(T'') .), PU)
        ;
        addMsgs((msg downQid(T) : parseTypeList(T') -> parseType(T'') .), U)
        ;
        VDS > .
  eq parseDecl('msg_:`->_.['token[T], T'], PU, U, VDS)
    = < addMsgs((msg downQid(T) : nil -> parseType(T') .), PU) ;
        addMsgs((msg downQid(T) : nil -> parseType(T') .), U) ; VDS > .
  eq parseDecl('msgs_:_->_.['neTokenList[T], T', T''], PU, U, VDS)
    = < addMsgs(unfoldMultipleMsgDecl(downQidList(T), parseTypeList(T'), parseType(T'')), PU) ;
        addMsgs(unfoldMultipleMsgDecl(downQidList(T), parseTypeList(T'), parseType(T'')), U) ;
        VDS > .
  eq parseDecl('msgs_:`->_.['neTokenList[T], T'], PU, U, VDS)
    = < addMsgs(unfoldMultipleMsgDecl(downQidList(T), nil, parseType(T')), PU) ;
        addMsgs(unfoldMultipleMsgDecl(downQidList(T), nil, parseType(T')), U) ; VDS > .

endfm

*******************************************************************************

***
*** 8.1.2 Parsing of View Declarations
***

*** A similar approach is followed for the parsing of declarations in views.

fmod VIEW-DECL-PARSING is
  pr PRE-VIEW .
  pr VIEW .
  pr UNIT .
  pr UNIT-DECL-PARSING .

  vars T T' : Term .
  var  OPDS : OpDeclSet .
  var  MDS : MsgDeclSet .
  var  M : Module .
  vars F F' : Qid .
  vars S S' : Sort .
  vars Ty Ty' : Type .
  vars TyL TyL' : TypeList .
  vars T'' T3 : Term .
  var  PV : PreView .
  var  OPD : OpDecl .
  var  OPDS' : OpDeclSet .
  var  AtS : AttrSet .
  var  MD : MsgDecl .
  var  MDS' : MsgDeclSet .
  var  VDS : OpDeclSet .

*** Operator and message name maps of the form \verb~F to F'~ are substituted
*** by an equivalent set of maps of the form \verb~F : TyL -> S to F'~. One
*** of these maps is added for each family of subsort-overloaded operators in
*** the source theory of the view.

*** The following functions \texttt{genOpMaps} and \texttt{genMsgMaps}
*** take, respectively, an operator and a message map of the form
*** \verb~F to F'~, a set of operator or message declarations, and a term of
*** sort \texttt{Module}, and return, respectively, a set of operator maps and
*** a set of message maps, with each of the members of those sTS having the
*** general form \verb~F : TyL -> S to F'~. One of these maps is generated
*** for each family of subsort-overloaded operators or messages with name
*** \texttt{F} in the module given as argument.

  op genOpMaps : OpMapping OpDeclSet Module -> OpMappingSet .
  op genMsgMaps : OpMapping MsgDeclSet Module -> OpMappingSet .

  op genOpMapsAux : OpDeclSet Qid -> OpMappingSet .
  op genMsgMapsAux : MsgDeclSet Qid -> OpMappingSet .

  op getOpDeclSet : Qid Module -> OpDeclSet .
  op getOpDeclSetAux : Qid OpDeclSet -> OpDeclSet .
  *** getOpDeclSet(F, U) returns the set of declarations of operators with
  *** name F in the unit U
  op getMsgDeclSet : Qid Module -> MsgDeclSet .
  op getMsgDeclSetAux : Qid MsgDeclSet -> MsgDeclSet .
  *** getMsgDeclSet(F, U) returns the set of declarations of messages with
  *** name F in the unit U
  op gTSubsortOverloadedFamilies : OpDeclSet OpDeclSet Module -> OpDeclSet .
  op gTSubsortOverloadedFamilies : MsgDeclSet MsgDeclSet Module -> MsgDeclSet .
  *** gTSubsortOverloadedFamilies returns a declaration of operator or
  *** message for each family of subsort-overloaded operators or messages.
  op selectOpDeclSet : Qid OpDeclSet -> OpDeclSet .
  op selectMsgDeclSet : Qid MsgDeclSet -> MsgDeclSet .
  *** selectOpDeclSet and selectMsgDeclSet returns, respectively, the subset
  *** of those declarations  of ops and msgs which name coincides with the
  *** qid given ar argument.
  op opFamilyIn : OpDecl OpDeclSet Module -> Bool .
  op msgFamilyIn : MsgDecl MsgDeclSet Module -> Bool .
  *** Check whether the family of the subsort-overloaded operator given as
  *** argument has already a  representative in the set of declarations given.

  eq genOpMaps(op F to F' ., OPDS, M)
    = genOpMapsAux(
         gTSubsortOverloadedFamilies(selectOpDeclSet(F, OPDS), none, M),
         F') .

  eq genMsgMaps(msg F to F' ., MDS, M)
    = genMsgMapsAux(
         gTSubsortOverloadedFamilies(selectMsgDeclSet(F, MDS), none, M),
         F') .

  eq selectOpDeclSet(F, ((op F' : TyL -> Ty [AtS] .) OPDS))
    = ((if F == F'
        then (op F' : TyL -> Ty [AtS] .)
        else none
        fi)
       selectOpDeclSet(F, OPDS)) .
  eq selectOpDeclSet(F, none) = none .

  eq selectMsgDeclSet(F, ((msg F' : TyL -> Ty .) MDS))
    = ((if F == F'
        then (msg F' : TyL -> Ty .)
        else none
        fi)
       selectMsgDeclSet(F, MDS)) .
  eq selectMsgDeclSet(F, none) = none .

  eq genOpMapsAux(op F : TyL -> Ty [AtS] . OPDS, F')
    = (op F : TyL -> Ty to F' . genOpMapsAux(OPDS, F')) .
  eq genOpMapsAux(none, F') = none .

  eq genMsgMapsAux(((msg F : TyL -> Ty .) MDS), F')
    = (msg F : TyL -> Ty to F' . genMsgMapsAux(MDS, F')) .
  eq genMsgMapsAux(none, F') = none .

  eq gTSubsortOverloadedFamilies((OPD OPDS), OPDS', M)
    = if opFamilyIn(OPD, OPDS', M)
      then gTSubsortOverloadedFamilies(OPDS, OPDS', M)
      else gTSubsortOverloadedFamilies(OPDS, (OPD OPDS'), M)
      fi .
  eq gTSubsortOverloadedFamilies(none, OPDS, M) = OPDS .

  eq gTSubsortOverloadedFamilies((MD MDS), MDS', M)
    = if msgFamilyIn(MD, MDS', M)
      then gTSubsortOverloadedFamilies(MDS, MDS', M)
      else gTSubsortOverloadedFamilies(MDS, (MD MDS'), M)
      fi .
  eq gTSubsortOverloadedFamilies(none, MDS, M) = MDS .

  eq opFamilyIn(
       (op F : TyL -> Ty [AtS] .), ((op F' : TyL' -> Ty' [AtS] .) OPDS), M)
    = ((F == F') and-then sameKind(M, TyL, TyL')) or-else
      opFamilyIn((op F : TyL -> Ty [AtS] .), OPDS, M) .
  eq opFamilyIn((op F : TyL -> Ty [AtS] .), none, M) = false .

  eq msgFamilyIn((msg F : TyL -> Ty .), ((msg F' : TyL' -> Ty' .) MDS), M)
    = ((F == F') and-then sameKind(M, TyL, TyL'))
      or-else
      msgFamilyIn((msg F : TyL -> Ty .), MDS, M) .
  eq msgFamilyIn((msg F : TyL -> Ty .), none, M) = false .

*** In the case of views, the \texttt{parseDecl} function takes the term
*** representing the corresponding declaration and a preview in which the
*** declarations are introduced. Note that in the case of views, the approach
*** followed in the evaluation is somewhat different. The only predeclarations
*** in a preview correspond to the term premaps of sort \texttt{PreTermMap},
*** for which, in addition to solving the bubbles in them, we have to convert
*** them into term maps of sort \texttt{TermMap} associating to them the set
*** of declarations of variables in the view which are used in them (see
*** Section~\ref{view-processing}).

*** The function \texttt{parseDecl} for declarations in views takes then the
*** term representing such declaration and a preview in which the result of
*** adding the declaration will be returned. To be able to generate the sTS
*** of equivalent operator and message maps as indicated above, the function
*** takes also as parameters the sTS of declarations of operators and messages
*** in the theory part of the source theory of the view in question, and the
*** signature of such theory to make the necessary sort comparisons.

  op parseDecl : Term PreView OpDeclSet MsgDeclSet Module -> PreView .

  eq parseDecl('sort_to_.[T, T'], PV, OPDS, MDS, M)
    = addMaps(sort parseType(T) to parseType(T') ., PV) .

  eq parseDecl('class_to_.[T, T'], PV, OPDS, MDS, M)
    = addMaps(class parseType(T) to parseType(T') ., PV) .

  eq parseDecl('vars_:_.['neTokenList[T], T'], PV, OPDS, MDS, M)
    = addVars(parseVars(downQidList(T), parseType(T')), PV).
  eq parseDecl('var_:_.['neTokenList[T], T'], PV, OPDS, MDS, M)
    = addVars(parseVars(downQidList(T), parseType(T')), PV).

  eq parseDecl('op_to`term_.[T, T'], PV, OPDS, MDS, M)
    = addMaps(op_to`term_.(T, T'), PV) .

  eq parseDecl('op_to_.['token[T], 'token[T']], PV, OPDS, MDS, M)
    = addMaps(genOpMaps(op downQid(T) to downQid(T') ., OPDS, M), PV) .
  eq parseDecl('op_:_->_to_.['token[T], T', T'', 'token[T3]], PV, OPDS, MDS, M)
    = addMaps(op downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3) ., PV) .
  eq parseDecl('op_:`->_to_.['token[T], T', 'token[T'']], PV, OPDS, MDS, M)
    = addMaps(op downQid(T) : nil -> parseType(T') to downQid(T'') ., PV) .

  eq parseDecl('msg_to_.['token[T], 'token[T']], PV, OPDS, MDS, M)
    = addMaps(genMsgMaps(msg downQid(T) to downQid(T') ., MDS, M), PV) .
  eq parseDecl('msg_:_->_to_.['token[T], T', T'', 'token[T3]], PV, OPDS, MDS, M)
    = addMaps(msg downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3) ., PV) .
  eq parseDecl('msg_:`->_to_.['token[T], T', 'token[T'']], PV, OPDS, MDS, M)
    = addMaps(msg downQid(T) : nil -> parseType(T') to downQid(T'') ., PV) .

  eq parseDecl('attr_._to_.[T', 'token[T], 'token[T'']], PV, OPDS, MDS, M)
    = addMaps(attr downQid(T) . parseType(T') to downQid(T'') ., PV) .

  eq parseDecl(T, PV, OPDS, MDS, M) = PV [owise] .
endfm

*******************************************************************************

***
*** 8.2 Meta Pretty Printing
***

*** To be able to show to the user the modules, theories, views, and terms
*** resulting from the different commands, the built-in function
*** \texttt{meta-pretty-print} is extended in the modules in this section to
*** deal with units and views.

***
*** 8.2.1 Meta Pretty Printing of Declarations
***

*** The predefined function \texttt{meta-pretty-print} is extended in the
*** following module \texttt{DECL-META-PRETTY-PRINT} to handle any declaration
*** that can appear in a unit. Note that the following
*** \texttt{meta-pretty-print} functions, as the built-in one, return a list
*** terms---such as equations, rules,* operator declarations with an identity
*** attribute, etc.---they have been defined with a term of operator
*** declarations with an identity attribute, etc.---they have been defined
*** with a term of sort \texttt{Module} as argument. In the other cases the
*** module is not necessary.

fmod DECL-META-PRETTY-PRINT is
  pr EXT-DECL .
  pr O-O-DECL .
  pr UNIT .
  pr CONVERSION .
  pr INT-LIST .
  pr VIEW-EXPR-TO-QID .

  op eMetaPrettyPrint : Sort -> QidList .
  op eMetaPrettyPrint : SortSet -> QidList .
  op eMetaPrettyPrint : TypeList -> QidList .
  op eMetaPrettyPrint : SubsortDeclSet -> QidList .
  op eMetaPrettyPrint : ClassDeclSet -> QidList .
  op eMetaPrettyPrint : SubclassDeclSet -> QidList .
  op eMetaPrettyPrint : Module OpDeclSet -> QidList .
  op eMetaPrettyPrintVars : OpDeclSet -> QidList .
  op eMetaPrettyPrint : MsgDeclSet -> QidList .
  op eMetaPrettyPrint : Module MembAxSet -> QidList .
  op eMetaPrettyPrint : Module EquationSet -> QidList .
  op eMetaPrettyPrint : Module RuleSet -> QidList .
  op eMetaPrettyPrint : Module Condition -> QidList .
  op eMetaPrettyPrint : Module Term -> QidList .

  ---- error handling
---(
  eq metaPrettyPrint(M, T, POS:PrintOptionSet)
    = 'Module getName(M) 'contains 'errors. .
---)

  eq eMetaPrettyPrint(U, T) = metaPrettyPrint(U, T) . ----, mixfix flat format) .
  eq eMetaPrettyPrint(U, qidError(QIL)) = QIL .
  eq eMetaPrettyPrint(qidError(QIL)) = QIL .

  op eMetaPrettyPrint : Module AttrSet -> QidList .
  op eMetaPrettyPrint : IntList -> QidList .
  op eMetaPrettyPrint : AttrDeclSet -> QidList .
  op eMetaPrettyPrint : Module HookList -> QidList .

  vars QI QI' QI'' F V L : Qid .
  var  QIL : QidList .
  var  St : String .
  var  M : Module .
  var  U : Module .
  vars VE VE' : ViewExp .
  vars SS : SortSet .
  vars S S' : Sort .
  var  TyL : TypeList .
  var  Ty : Type .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  AtS : AttrSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  Hk : Hook .
  var  HkL : HookList .
  var  I : Int .
  var  NL : IntList .
  vars T T' T'' T3 : Term .
  var  CDS : ClassDeclSet .
  var  SCDS : SubclassDeclSet .
  var  MDS : MsgDeclSet .
  var  ADS : AttrDeclSet .
  var  Cond : Condition .
  var  K : Kind .

  --- eq eMetaPrettyPrint(Ty) = Ty .

  eq eMetaPrettyPrint(S)
    = if getPars(S) == empty
      then S
      else getName(S) '`{ parameterList2QidList(getPars(S)) '`}
      fi .
  eq eMetaPrettyPrint(K) = '`[ eMetaPrettyPrint(getSort(K)) '`] .

  eq eMetaPrettyPrint((S ; SS))
    = (eMetaPrettyPrint(S) eMetaPrettyPrint(SS))
    [owise] .
  eq eMetaPrettyPrint((none).SortSet) = nil .

  eq eMetaPrettyPrint(Ty TyL)
    = eMetaPrettyPrint(Ty) eMetaPrettyPrint(TyL)
    [owise] .
  eq eMetaPrettyPrint((nil).TypeList) = nil .

  eq eMetaPrettyPrint(((subsort S < S' .) SSDS))
    = ('\s '\s '\b
       'subsort '\o eMetaPrettyPrint(S) '\b
           '< '\o eMetaPrettyPrint(S') '\b '. '\o '\n
       eMetaPrettyPrint(SSDS)) .
  eq eMetaPrettyPrint((none).SubsortDeclSet) = nil .

  eq eMetaPrettyPrint(M, ((op F : TyL -> Ty [none] .) OPDS))
    = ('\s '\s
       '\b 'op '\o F '\b ': '\o eMetaPrettyPrint(TyL)
       '\b '-> '\o eMetaPrettyPrint(Ty) '\b '. '\o '\n
       eMetaPrettyPrint(M, OPDS)) .
  eq eMetaPrettyPrint(M, ((op F : TyL -> Ty [AtS] .) OPDS))
    = ('\s '\s
       '\b 'op '\o F '\b ': '\o eMetaPrettyPrint(TyL)
       '\b '-> '\o eMetaPrettyPrint(Ty) '\n
       '\s '\s '\s '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, OPDS))
    [owise] .
  eq eMetaPrettyPrint(M, (none).OpDeclSet)  = nil .

  eq eMetaPrettyPrintVars((op F : nil -> Ty [none] .) OPDS)
    = ('\s '\s '\b 'var '\o F '\b ': '\o eMetaPrettyPrint(Ty) '\b '. '\o '\n
       eMetaPrettyPrintVars(OPDS)) .
  eq eMetaPrettyPrintVars((none).OpDeclSet)  = nil .

  eq eMetaPrettyPrint(M, (mb T : S [none] .) MAS)
    = ('\s '\s '\b 'mb '\o eMetaPrettyPrint(M, T) '\b ': '\o eMetaPrettyPrint(S) '\b '. '\o '\n
       eMetaPrettyPrint(M, MAS)) .
  eq eMetaPrettyPrint(M, (mb T : S [AtS] .) MAS)
    = ('\s '\s '\b 'mb '\o eMetaPrettyPrint(M, T)
                   '\b ': '\o eMetaPrettyPrint(S)
               '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, MAS))
    [owise] .
  eq eMetaPrettyPrint(M, (cmb T : S if Cond [none] .) MAS)
    = ('\s '\s '\b 'cmb '\o eMetaPrettyPrint(M, T)
                   '\b ': '\o eMetaPrettyPrint(S) '\n
       '\s '\s '\s '\s '\b 'if '\o eMetaPrettyPrint(M, Cond) '\b '. '\o '\n
       eMetaPrettyPrint(M, MAS)) .
  eq eMetaPrettyPrint(M, (cmb T : S if Cond [AtS] .) MAS)
    = ('\s '\s '\b 'cmb '\o eMetaPrettyPrint(M, T)
                   '\b ': '\o eMetaPrettyPrint(S) '\n
       '\s '\s '\s '\s '\b 'if '\o eMetaPrettyPrint(M, Cond)
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, MAS))
    [owise] .
  eq eMetaPrettyPrint(M, (none).MembAxSet) = nil .

  eq eMetaPrettyPrint(M, ((eq T = T' [none] .) EqS))
    = ('\s '\s '\b 'eq '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T') '\b '\s '. '\n
       '\o
       eMetaPrettyPrint(M, EqS)) .
  eq eMetaPrettyPrint(M, ((eq T = T' [AtS] .) EqS))
    = ('\s '\s '\b 'eq '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T')
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, EqS))
    [owise] .
  eq eMetaPrettyPrint(M, ((ceq T = T' if Cond [none] .) EqS))
    = ('\s '\s '\b 'ceq '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T') '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond) '\b '\s '. '\o '\n
       eMetaPrettyPrint(M, EqS)) .
  eq eMetaPrettyPrint(M, ((ceq T = T' if Cond [AtS] .) EqS))
    = ('\s '\s '\b 'ceq '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T') '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond)
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, EqS))
    [owise] .
  eq eMetaPrettyPrint(M, (none).EquationSet) = nil .

  eq eMetaPrettyPrint(M, ((rl T => T' [none] .) RlS))
    = ('\s '\s '\b 'rl '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T') '\b '\s '. '\n '\o
       eMetaPrettyPrint(M, RlS)) .
  eq eMetaPrettyPrint(M, ((rl T => T' [AtS] .) RlS))
    = ('\s '\s '\b 'rl '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T')
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, RlS))
    [owise] .
  eq eMetaPrettyPrint(M, ((crl T => T' if Cond [none] .) RlS))
    = ('\s '\s '\b 'crl '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T') '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond) '\b '\s '. '\o '\n
       eMetaPrettyPrint(M, RlS)) .
  eq eMetaPrettyPrint(M, ((crl T => T' if Cond [AtS] .) RlS))
    = ('\s '\s '\b 'crl '\s '\o eMetaPrettyPrint(M, T) '\n
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T') '\n
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond)
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, RlS))
    [owise] .
  eq eMetaPrettyPrint(M, (none).RuleSet) = nil .

  eq eMetaPrettyPrint(M, T = T' /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b '= '\o eMetaPrettyPrint(M, T') '\b
      '/\ '\o eMetaPrettyPrint(M, Cond))
    [owise] .
  eq eMetaPrettyPrint(M, T : S /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b ': '\o eMetaPrettyPrint(S) '\b
      '/\ '\o eMetaPrettyPrint(M, Cond))
    [owise] .
  eq eMetaPrettyPrint(M, T := T' /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b ':= '\o eMetaPrettyPrint(M, T') '\b
      '/\ '\o eMetaPrettyPrint(M, Cond))
    [owise] .
  eq eMetaPrettyPrint(M, T => T' /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b '=> '\o eMetaPrettyPrint(M, T') '\b
      '/\ '\o eMetaPrettyPrint(M, Cond))
    [owise] .
  eq eMetaPrettyPrint(M, T = T')
    = (eMetaPrettyPrint(M, T) '\b '= '\o eMetaPrettyPrint(M, T')) .
  eq eMetaPrettyPrint(M, T : S)
    = (eMetaPrettyPrint(M, T) '\b ': '\o eMetaPrettyPrint(S)) .
  eq eMetaPrettyPrint(M, T := T')
    = (eMetaPrettyPrint(M, T) '\b ':= '\o eMetaPrettyPrint(M, T')) .
  eq eMetaPrettyPrint(M, T => T')
    = (eMetaPrettyPrint(M, T) '\b '=> '\o eMetaPrettyPrint(M, T')) .
  eq eMetaPrettyPrint(M, (nil).EqCondition) = nil .

  eq eMetaPrettyPrint(M, (assoc AtS))
    = ('\b 'assoc '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (comm AtS))
    = ('\b 'comm '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (memo AtS))
    = ('\b 'memo '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (idem AtS))
    = ('\b 'idem '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (id(T) AtS))
    = ('\b 'id: '\o eMetaPrettyPrint(M, T) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (right-id(T) AtS))
    = ('\b 'right 'id: '\o eMetaPrettyPrint(M, T) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (left-id(T) AtS))
    = ('\b 'left 'id: '\o eMetaPrettyPrint(M, T) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (poly(NL) AtS))
    = ('\b 'poly '`( '\o eMetaPrettyPrint(NL) '\b '`)
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (strat(NL) AtS))
    = ('\b 'strat '`( '\o eMetaPrettyPrint(NL) '\b '`)
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (memo AtS))
    = ('\b 'memo '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (prec(I) AtS))
    = ('\b 'prec '\o eMetaPrettyPrint(I) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (gather(QIL) AtS))
    = ('\b 'gather '\o '`( QIL '`) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (format(QIL) AtS))
    = ('\b 'format '\o '`( QIL '`) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (ctor AtS))
    = ('\b 'ctor '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (frozen(NL) AtS))
    = ('\b 'frozen '`( '\o eMetaPrettyPrint(NL) '\b '`)
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (iter AtS))
    = ('\b 'iter '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (special(HkL) AtS))
    = ('\b 'special '`( '\o eMetaPrettyPrint(M, HkL) '\b '`)
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (config AtS))
    = ('\b 'config '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (object AtS))
    = ('\b 'object '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (msg AtS))
    = ('\b 'msg '\o eMetaPrettyPrint(M, AtS)) .

  eq eMetaPrettyPrint(M, (label(QI) AtS))
    = ('\b 'label '\o QI '\b '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (metadata(St) AtS))
    = ('\b 'metadata '\o qid("\"" + St + "\"") '\b
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (nonexec AtS))
    = ('\b 'nonexec '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (variant AtS))
    = ('\b 'variant '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (owise AtS))
    = ('\b 'owise '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (print(QIL) AtS))
    = ('\b 'print QIL '\o eMetaPrettyPrint(M, AtS)) .

  eq eMetaPrettyPrint(M, (none).AttrSet) = nil .

  ceq eMetaPrettyPrint(M, (Hk HkL))
    = (eMetaPrettyPrint(M, Hk) eMetaPrettyPrint(M, HkL))
    if HkL =/= nil .
  eq eMetaPrettyPrint(M, id-hook(QI, nil)) = ('\b 'id-hook '\o QI) .
  eq eMetaPrettyPrint(M, id-hook(QI, QIL))
    = ('\b 'id-hook '\o QI '\b '`( '\o QIL '\b '`) '\o )
    [owise] .
  eq eMetaPrettyPrint(M, op-hook(QI, QI', nil, QI''))
    = ('\b 'op-hook '\o QI '\b '`( '\o QI' ': '~> QI'' '\b '`) '\o) .
  eq eMetaPrettyPrint(M, op-hook(QI, QI', QIL, QI''))
    = ('\b 'op-hook '\o QI '\b '`( '\o QI' ': QIL '~> QI'' '\b '`) '\o)
    [owise] .
  eq eMetaPrettyPrint(M, term-hook(QI, T))
    = ('\b 'term-hook '\o QI '\b '`( '\o eMetaPrettyPrint(M, T) '\b '`) '\o) .

  eq eMetaPrettyPrint((I NL)) = (qid(string(I, 10)) eMetaPrettyPrint(NL)) .
  eq eMetaPrettyPrint((nil).NatList) = nil .

  eq eMetaPrettyPrint((class S | ADS .) CDS)
    = ((if ADS == none
        then ('\s '\s '\b 'class '\o eMetaPrettyPrint(S) '\b '. '\o '\n)
        else ('\s '\s '\b 'class '\o eMetaPrettyPrint(S) '\b '| '\o eMetaPrettyPrint(ADS) '\b '. '\o '\n)
        fi)
       eMetaPrettyPrint(CDS)) .
  eq eMetaPrettyPrint((none).ClassDeclSet) = nil .

  eq eMetaPrettyPrint((subclass S < S' .) SCDS)
    = ('\s '\s '\b 'subclass '\o eMetaPrettyPrint(S) '\b
           '< '\o eMetaPrettyPrint(S') '\b '. '\o '\n
       eMetaPrettyPrint(SCDS)) .
  eq eMetaPrettyPrint((none).SubclassDeclSet) = nil .

  eq eMetaPrettyPrint((msg F : TyL -> Ty .) MDS)
    = ('\s '\s '\b 'msg '\o F '\b ': '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty) '\b '. '\o '\n
       eMetaPrettyPrint(MDS)) .
  eq eMetaPrettyPrint((none).MsgDeclSet) = nil .

  eq eMetaPrettyPrint(((attr F : S), ADS))
    = (F '\b ': '\o eMetaPrettyPrint(S) '\b '`, '\o '\s eMetaPrettyPrint(ADS))
    [owise] .
  eq eMetaPrettyPrint((attr F : S)) = (F '\b ': '\o eMetaPrettyPrint(S)) .
  eq eMetaPrettyPrint((none).AttrDeclSet) = nil .

endfm

*******************************************************************************

***
*** 8.2.2 Meta Pretty Printing of Modules
***

*** In the following module, the \texttt{meta-pretty-print} function is
*** defined on sort \texttt{Module}.

fmod UNIT-META-PRETTY-PRINT is
  pr UNIT .
  pr RENAMING-EXPR-EVALUATION .
  pr DECL-META-PRETTY-PRINT .

  op eMetaPrettyPrint : Module Module -> QidList .

  op eMetaPrettyPrint : Module Module -> QidList .
  op eMetaPrettyPrint : Header -> QidList .
  op eMetaPrettyPrint : ParameterDeclList -> QidList .
  op eMetaPrettyPrint : ImportList -> QidList .

  var  M : Module .
  vars QI F F' L L' : Qid .
  var  QIL : QidList .
  var  ME : ModuleExpression .
  vars S S' : Sort .
  var  Ty : Type .
  var  TyL : TypeList .
  var  SS : SortSet .
  var  PD : ParameterDecl .
  var  PDL : ParameterDeclList .
  vars IL IL' : ImportList .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  CDS : ClassDeclSet .
  var  SCDS : SubclassDeclSet .
  var  MDS : MsgDeclSet .
  var  U : Module .
  var  AtS : AttrSet .
  var  MN : ModuleName .

  ceq eMetaPrettyPrint(ME)
    = if QI == '`) or QI == '`] or QI == '`}
      then QIL QI '\s
      else QIL QI
      fi
    if QIL QI := header2QidList(ME) .

  eq eMetaPrettyPrint(W:[Module], unitError(QIL)) = QIL .
  eq eMetaPrettyPrint(unitError(QIL), noModule) = QIL .
  eq eMetaPrettyPrint(noModule, noModule) = nil .
  eq eMetaPrettyPrint(M, mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = ('\b
       'mod '\o eMetaPrettyPrint(ME) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)
          eMetaPrettyPrint(SSDS)
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS)
          eMetaPrettyPrint(M, RlS)
       '\b 'endm '\o '\n) .
  eq eMetaPrettyPrint(M, mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = ('\b
       'mod '\o eMetaPrettyPrint(ME) (if PDL == nil
                                      then nil
                                      else '`{ eMetaPrettyPrint(PDL) '`} '\s
                                      fi) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)
          eMetaPrettyPrint(SSDS)
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS)
          eMetaPrettyPrint(M, RlS)
       '\b 'endm '\o '\n) .
  eq eMetaPrettyPrint(M, th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth)
    = ('\b
       'th '\o eMetaPrettyPrint(MN) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)
          eMetaPrettyPrint(SSDS)
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS)
          eMetaPrettyPrint(M, RlS)
       '\b 'endth '\o '\n) .
  eq eMetaPrettyPrint(M, fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = ('\b
       'fmod '\o eMetaPrettyPrint(ME) '\b 'is '\o '\n
           eMetaPrettyPrint(IL)
           (if SS == none
            then nil
            else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
            fi)
           eMetaPrettyPrint(SSDS)
           eMetaPrettyPrint(M, OPDS)
           eMetaPrettyPrint(M, MAS)
           eMetaPrettyPrint(M, EqS)
       '\b 'endfm '\o '\n) .
  eq eMetaPrettyPrint(M, fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = ('\b
       'fmod '\o eMetaPrettyPrint(ME) (if PDL == nil
                                       then nil
                                       else '`{ eMetaPrettyPrint(PDL) '`} '\s
                                       fi) '\b 'is '\o '\n
           eMetaPrettyPrint(IL)
           (if SS == none
            then nil
            else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
            fi)
           eMetaPrettyPrint(SSDS)
           eMetaPrettyPrint(M, OPDS)
           eMetaPrettyPrint(M, MAS)
           eMetaPrettyPrint(M, EqS)
       '\b 'endfm '\o '\n) .
  eq eMetaPrettyPrint(M, fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth)
    = ('\b
       'fth '\o eMetaPrettyPrint(MN) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)
          eMetaPrettyPrint(SSDS)
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS)
       '\b 'endfth '\o '\n) .
  eq eMetaPrettyPrint(M,
       omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = ('\b
       'omod '\o eMetaPrettyPrint(ME) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n )
           fi)
          eMetaPrettyPrint(SSDS) eMetaPrettyPrint(CDS)
          eMetaPrettyPrint(SCDS) eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(MDS) eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS) eMetaPrettyPrint(M, RlS)
       '\b 'endom '\o '\n) .
  eq eMetaPrettyPrint(M, omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = ('\b
       'omod '\o eMetaPrettyPrint(ME) (if PDL == nil
                                       then nil
                                       else ('`{ eMetaPrettyPrint(PDL) '`} '\s)
                                       fi) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n )
           fi)
          eMetaPrettyPrint(SSDS) eMetaPrettyPrint(CDS)
          eMetaPrettyPrint(SCDS) eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(MDS) eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS) eMetaPrettyPrint(M, RlS)
       '\b 'endom '\o '\n) .
  eq eMetaPrettyPrint(M, oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = ('\b
       'oth '\o eMetaPrettyPrint(MN) '\b 'is '\o '\n
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n )
           fi)
          eMetaPrettyPrint(SSDS) eMetaPrettyPrint(CDS)
          eMetaPrettyPrint(SCDS) eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(MDS) eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS) eMetaPrettyPrint(M, RlS) '\n '\b
       'endoth '\o '\n) .

  eq eMetaPrettyPrint((including ME .) IL)
    = ('\s '\s '\b 'including '\o eMetaPrettyPrint(ME) '\b '. '\o '\n
       eMetaPrettyPrint(IL)) .
  eq eMetaPrettyPrint((extending ME .) IL)
    = ('\s '\s '\b 'extending '\o eMetaPrettyPrint(ME) '\b '. '\o '\n
       eMetaPrettyPrint(IL)) .
  eq eMetaPrettyPrint((protecting ME .) IL)
    = ('\s '\s '\b 'protecting '\o eMetaPrettyPrint(ME) '\b '. '\o '\n
       eMetaPrettyPrint(IL)) .
  eq eMetaPrettyPrint((protecting pd(QI :: ME) .) IL)
    = eMetaPrettyPrint(IL) .
  eq eMetaPrettyPrint((nil).ImportList) = nil .

  eq eMetaPrettyPrint((QI :: ME, PDL))
    = (QI '::  eMetaPrettyPrint(ME) '`, eMetaPrettyPrint(PDL))
    [owise] .
  eq eMetaPrettyPrint((QI :: ME)) = (QI '::  eMetaPrettyPrint(ME)) .
  eq eMetaPrettyPrint((nil).ParameterDeclList) = (nil).QidList .

  op eMetaPrettyPrint : ModuleExpression -> QidList .
  eq eMetaPrettyPrint(QI + ME:ModuleExpression)
    = QI '+ eMetaPrettyPrint(ME:ModuleExpression) .
  eq eMetaPrettyPrint(QI * (RnS:RenamingSet))
    = QI '* '\s '`( renamingSet2QidList(RnS:RenamingSet) '`) .
  eq eMetaPrettyPrint(pd(PD)) = eMetaPrettyPrint(PD) .

  op renamingSet2QidList : RenamingSet -> QidList .
  eq renamingSet2QidList(((op F to F' [AtS]), RS:RenamingSet))
    = if AtS == none
      then ('op F 'to F' '`, '\s renamingSet2QidList(RS:RenamingSet))
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`] '`, '\s
            renamingSet2QidList(RS:RenamingSet))
      fi
    [owise] .
  eq renamingSet2QidList((op F to F' [AtS]))
    = if AtS == none
      then ('op F 'to F')
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`])
      fi .
  eq renamingSet2QidList(((op F : TyL -> Ty to F' [AtS]), RS:RenamingSet))
    = if AtS == none
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F' '`,
            '\s renamingSet2QidList(RS:RenamingSet))
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F'
            '`[ attrSet2QidList(AtS) '`] '`,
            '\s renamingSet2QidList(RS:RenamingSet))
      fi
    [owise] .
  eq renamingSet2QidList((op F : TyL -> Ty to F' [AtS]))
    = if AtS == none
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F')
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F'
            '`[ attrSet2QidList(AtS) '`])
      fi .
  eq renamingSet2QidList(((sort S to S'), RS:RenamingSet))
    = ('sort S 'to S' '`, '\s
       renamingSet2QidList(RS:RenamingSet))
    [owise] .
  eq renamingSet2QidList((sort S to S')) = ('sort S 'to S') .

  eq renamingSet2QidList(((label L to L'), RS:RenamingSet))
    = ('label L 'to L' '`, '\s renamingSet2QidList(RS:RenamingSet))
    [owise] .
  eq renamingSet2QidList((label L to L')) = ('label L 'to L') .
endfm

*******************************************************************************

*** The function \texttt{meta-pretty-print} on units is defined recursively,
*** calling the \texttt{meta-pretty-print} functions for the different
*** declarations in the unit defined in module \texttt{DECL-META-PRETTY-PRINT}.

***
*** 8.2.3 Meta Pretty Printing of Maps and Views
***

*** We define in the following module the function \texttt{meta-pretty-print}
*** on maps.

fmod MAP-SET-META-PRETTY-PRINT is
  pr DECL-META-PRETTY-PRINT .
  pr FMAP .
  pr UNIT .

  op eMetaPrettyPrint : RenamingSet -> QidList .

  var  MAP : Renaming .
  var  MAPS : RenamingSet .
  vars QI QI' F F' L L' : Qid .
  var  AtS : AttrSet .
  vars S S' : Sort .
  var  Ty : Type .
  var  TyL : TypeList .

  eq eMetaPrettyPrint((MAP, MAPS))
    = (eMetaPrettyPrint(MAP) '`, '\s '\s eMetaPrettyPrint(MAPS))
    [owise] .
  eq eMetaPrettyPrint((none).RenamingSet) = nil .

  eq eMetaPrettyPrint(op F to F' [AtS])
    = if AtS == none
      then ('\b 'op '\o F '\b 'to '\o F')
      else ('\b 'op F '\b 'to '\o F' '\b
            '`[ '\o eMetaPrettyPrint(noModule, AtS) '\b '`] '\o)
           *** In a map there should not be attributes requiring a module
      fi .
  eq eMetaPrettyPrint(op F : TyL -> Ty to F' [AtS])
    = if AtS == none
      then ('\b 'op '\o F '\b ':
            '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty)
            '\b 'to '\o F')
      else ('\b 'op '\o F '\b ':
            '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty)
            '\b 'to '\o F'
            '\b '`[ '\o eMetaPrettyPrint(noModule, AtS) '\b '`] '\o)
           *** In a map there should not be attributes requiring a module
      fi .
  eq eMetaPrettyPrint(sort S to S')
    = ('\b 'sort '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S')) .
  eq eMetaPrettyPrint(label L to L') = ('\b 'label '\o L '\b 'to '\o L') .
  eq eMetaPrettyPrint(class S to S')
    = ('\b 'class '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S')) .
  eq eMetaPrettyPrint(attr QI . S to QI')
    = ('\b 'attr '\o eMetaPrettyPrint(S) '\b '. '\o QI '\b 'to '\o QI') .
  eq eMetaPrettyPrint(msg F to F') = ('\b 'msg '\o F '\b 'to '\o F') .
  eq eMetaPrettyPrint(msg F : TyL -> Ty to F')
    = ('\b 'msg '\o F '\b ':
       '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty)
       '\b 'to '\o F') .

endfm

*******************************************************************************

*** Finally, in the \texttt{VIEW-META-PRETTY-PRINT} module, the
*** \texttt{meta-pretty-print} function is defined on views.


fmod VIEW-META-PRETTY-PRINT is
  pr DATABASE .
  pr MAP-SET-META-PRETTY-PRINT .
  pr RENAMING-SET-APPL-ON-UNIT .
  pr UNIT-META-PRETTY-PRINT .

  op eMetaPrettyPrint : Database View -> QidList .
  op eMetaPrettyPrint : ViewExp -> QidList .
  op eMetaPrettyPrint : ModuleExpression ModuleExpression Database SortMappingSet SortMappingSet OpMappingSet -> QidList .
  op eMetaPrettyPrint : ModuleExpression ModuleExpression Database OpMappingSet SortMappingSet OpMappingSet -> QidList .
  op eMetaPrettyPrint : SortMapping -> QidList .
  op eMetaPrettyPrint : OpMapping -> QidList .

  vars QI QI' F F' : Qid .
  vars S S' : Sort .
  var  TyL : TypeList .
  var  Ty : Type .
  var  QIL : QidList .
  var  DB : Database .
  vars ME ME' : ModuleExpression .
  var  SM : SortMapping .
  var  OM : OpMapping .
  vars SMS SMS' : SortMappingSet .
  vars OMS OMS' : OpMappingSet .
  vars T T' : Term .
  var  PDL : ParameterDeclList .
  vars VE VE' : ViewExp .
  var  DT : Default{Term} .

  ceq eMetaPrettyPrint(DB, view VE from ME to ME' is SMS OMS endv)
    = ('\b 'view '\o
                 QIL QI
                 if QI == '`) then '\s else nil fi
              '\b 'from '\o eMetaPrettyPrint(ME)
              '\b 'to '\o eMetaPrettyPrint(ME') '\b 'is '\o '\n
       if SMS =/= none then '\s '\s eMetaPrettyPrint(ME, ME', DB, SMS, SMS, OMS) else nil fi
       if OMS =/= none then '\s '\s eMetaPrettyPrint(ME, ME', DB, OMS, SMS, OMS) else nil fi
       '\b 'endv '\o '\n)
    if QIL QI := eMetaPrettyPrint(VE) .
  ceq eMetaPrettyPrint(DB, view VE{PDL} from ME to ME' is SMS OMS endv)
    = ('\b 'view '\o
                 QIL QI
                 (if PDL == nil
                  then if QI == '`) then '\s else nil fi
                  else '`{ eMetaPrettyPrint(PDL) '`} '\s
                  fi)
              '\b 'from '\o eMetaPrettyPrint(ME)
              '\b 'to '\o eMetaPrettyPrint(ME') '\b 'is '\o '\n
       if OMS =/= none then '\s '\s eMetaPrettyPrint(ME, ME', DB, SMS, SMS, OMS) else nil fi
       if OMS =/= none then '\s '\s eMetaPrettyPrint(ME, ME', DB, OMS, SMS, OMS) else nil fi
       '\b 'endv '\o '\n )
    if QIL QI := eMetaPrettyPrint(VE) .
  eq eMetaPrettyPrint(DB, viewError(QIL)) = QIL .

  ceq eMetaPrettyPrint(QI) = QI if not QI :: Type .
  ceq eMetaPrettyPrint(((VE, VE')))
    = eMetaPrettyPrint(VE) '`, '\s eMetaPrettyPrint(VE')
    if VE =/= nil /\ VE' =/= nil .
  eq eMetaPrettyPrint(QI{VE}) = QI '`{ eMetaPrettyPrint(VE) '`} '\s .

 ceq eMetaPrettyPrint(ME, ME', DB, SM SMS, SMS', OMS')
    = (eMetaPrettyPrint(ME, ME', DB, SM, SMS', OMS') '\n
       '\s '\s eMetaPrettyPrint(ME, ME', DB, SMS, SMS', OMS'))
    if SMS =/= none .
 ceq eMetaPrettyPrint(ME, ME', DB, OM OMS, SMS', OMS')
    = (eMetaPrettyPrint(ME, ME', DB, OM, SMS', OMS') '\n
       '\s '\s eMetaPrettyPrint(ME, ME', DB, OMS, SMS', OMS'))
    if OMS =/= none .
  eq eMetaPrettyPrint(ME, ME', DB, (none).SortMappingSet, SMS, OMS) = nil .
  eq eMetaPrettyPrint(ME, ME', DB, (none).OpMappingSet, SMS, OMS) = nil .

  eq eMetaPrettyPrint(ME, ME', DB, op_to`term_.(T, T'), SMS, OMS)
    = ('\b 'op '\o eMetaPrettyPrint(getFlatModule(ME, DB), T) '\b 'to
               'term '\o eMetaPrettyPrint(getFlatModule(ME', DB), T') '\b '. '\o) .

  eq eMetaPrettyPrint(ME, ME', DB, op_to`term_.(T, T'), SMS, OMS)
    = ('op eMetaPrettyPrint(T) '\b 'to 'term '\o eMetaPrettyPrint(T') '. '\n) .
  eq eMetaPrettyPrint(ME, ME', DB, op F to F' ., SMS, OMS)
    = ('\b 'op '\o F '\b 'to '\o F' '. '\n) .
  eq eMetaPrettyPrint(ME, ME', DB, op F : TyL -> Ty to F' ., SMS, OMS)
    = ('\b 'op '\o F '\b ':
       '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty)
       '\b 'to '\o F' '. '\n) .
  eq eMetaPrettyPrint(ME, ME', DB, sort S to S' ., SMS, OMS)
    = ('\b 'sort '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S') '. '\n) .
  eq eMetaPrettyPrint(ME, ME', DB, class S to S' ., SMS, OMS)
    = ('\b 'class '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S') '. '\n) .
  eq eMetaPrettyPrint(ME, ME', DB, attr QI . S to QI' ., SMS, OMS)
    = ('\b 'attr '\o eMetaPrettyPrint(S) '\b '. '\o QI '\b 'to '\o QI' '. '\n) .
  eq eMetaPrettyPrint(ME, ME', DB, msg F to F' ., SMS, OMS)
    = ('\b 'msg '\o F '\b 'to '\o F' '. '\n) .
  eq eMetaPrettyPrint(ME, ME', DB, msg F : TyL -> Ty to F' ., SMS, OMS)
    = ('\b 'msg '\o F '\b ':
       '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty)
       '\b 'to '\o F' '. '\n) .
endfm

*******************************************************************************

***
*** 8.3 Input Processing
***

*** The processing functions presented in the following modules are in charge
*** of taking each term generated by the \texttt{metaParse} function and,
*** after transforming it into an element of the data types \texttt{Module} or
*** \texttt{View}, or generating some output, returning the database resulting
*** from introducing in it such a term. We shall see in
*** Section~\ref{database-handling} how the appropriate function is called
*** after having performed a first analysis of the term, in which it is
*** detected whether the input corresponds to a unit, view, or command. In the
*** cases of units and views the processing is quite similar. After a
*** preprocessing of the term, the function \texttt{parseDecl} is called with
*** each of the subterms representing declarations, resulting in units or
*** views with the parsed declarations in it.

***
*** 8.3.1 Module Processing
***

*** The processing of a term resulting from the parsing of some input
*** corresponding to a unit is accomplished by the \texttt{procModule} function.
*** This function takes as arguments a term of sort \texttt{Term}, which
*** represents some preunit, and a database. The function then enters into the
*** given database the unit obtained from the transformation of such term
*** into a term of sort \texttt{Module}.

fmod UNIT-PROCESSING is
  pr DATABASE .
  pr UNIT-DECL-PARSING .
  pr EVALUATION .
  pr RENAMING-SET-APPL-ON-UNIT .
  pr META-FULL-MAUDE-SIGN .
  pr MOD-EXP-PARSING .

  vars QI F X : Qid .
  var  M : Module .
  vars PU PU' U U' : Module .
  vars DB DB' : Database .
  vars T T' T'' T3 : Term .
  var  TL : TermList .
  vars PL PL' PL'' : ParameterList .
  var  PDL : ParameterDeclList .
  var  IL IL' : ImportList .
  var  ME : ModuleExpression .
  var  S : Sort .
  var  SS : SortSet .
  var  ME' : ModuleExpression .
  var  VMAPS : RenamingSet .
  var  B : Bool .
  var  VDS : OpDeclSet .
  var  QIL : QidList .
  var  PDR : ParseDeclResult .
  var  DT : Default{Term} .

*** The \texttt{parseParList} takes a term representing a list of parameters
*** and returns the corresponding list.

  op parseParList : Term -> ParameterDeclList .
  eq parseParList('_::_['token[T], T']) = downQid(T) :: parseModExp(T') .
  eq parseParList('_`,_[T, T']) = (parseParList(T), parseParList(T')) .

*** All the operators declared as constructors of sort \texttt{PreModule} in
*** the signature of Full Maude, given in Appendix~\ref{signature-full-maude},
*** are declared with two arguments, namely, the name, or name and interface,
*** of the unit, and the list of declarations of such units. The function
*** \texttt{procModule3} is called with the term corresponding to the name, or
*** name and interface, of the module as first argument, the term corresponding
*** to the set of declarations as second argument, and an empty module of the
*** appropriate type, in which the different declarations will be accumulated,
*** as third argument.

*** The task of the function \texttt{procModule4} is then to make a second
*** level parsing of the input, building up, simultaneously, the preunit
*** represented in the term passed as argument, and the unit resulting from the
*** declarations without bubbles. This unit without bubbles will be used by the
*** \texttt{evalPreModule} function to build the signature with which to
*** analyze the bubbles in the preunit (see Section~\ref{evaluation}).

*** The case of parameterized modules requires a special treatment of the
*** parameters. These parameters are evaluated and are added as submodules in
*** the appropriate way.

*** When the last declaration is parsed, the function \texttt{evalPreModule} is
*** called with the preunit (the top module with bubbles) as first argument,
*** the empty copy of it as second argument, the top module without bubbles as
*** third argument, and the database.

*** Note that the \texttt{procModule} function adds a declaration importing the
*** module \texttt{CONFIGURATION+}, presented in
*** Section~\ref{non-built-in-predefined}, to the object-oriented modules, and
*** that \texttt{procModule4} adds a declaration importing the built-in module
*** \texttt{BOOL} to all modules.

  op procModule : Term Database -> Database .
  ***  moved to MOD-EXPR-EVAL to solve dependency
  ***  op procModule : Qid Database -> Database .
  op procModule2 : Term Term Database -> Database .
  op procModule2 : Term Database -> Database .
  op procModule3 : Term Term Term Module Database -> Database .
  op procModule3 : Term Term Module Database -> Database .
  op procModule4 : Term Term Module Module OpDeclSet Database -> Database .
  op procModule4 : Term Module Module OpDeclSet Database -> Database .

  *** When recompiling a module, it's called with a Qid, and it's
  *** not reentered into the database.

  ceq procModule(QI, DB)
    = if DT == null
      then evalModule(U, VDS, DB)
      else procModule2(DT, DB)
      fi
    if < DT ; VDS ; U > := getTermModule(QI, DB) .
  eq procModule(T, DB) = procModule2(T, T, DB) .

  *** procModule2 just calls procModule3 with the name and the declarations of
  *** the module, and an empty unit of the right type.

  eq procModule2(T, 'fmod_is_endfm[T', T''], DB)
    = procModule3(T, T', T'', emptyFModule, DB) .
  eq procModule2(T, 'obj_is_endo[T', T''], DB)
    = procModule3(T, T', T'', emptyFModule, DB) .
  eq procModule2(T, 'obj_is_jbo[T', T''], DB)
    = procModule3(T, T', T'', emptyFModule, DB) .
  eq procModule2(T, 'mod_is_endm[T', T''], DB)
    = procModule3(T, T', T'', emptySModule, DB) .
  eq procModule2(T, 'omod_is_endom[T', T''], DB)
    = procModule3(T, T', T'',
        addImports((including 'CONFIGURATION . including 'CONFIGURATION+ .),
          emptyOModule),
        DB) .
  eq procModule2(T, 'fth_is_endfth[T', T''], DB)
    = procModule3(T, T', T'', emptyFTheory, DB) .
  eq procModule2(T, 'th_is_endth[T', T''], DB)
    = procModule3(T, T', T'', emptySTheory, DB) .
  eq procModule2(T, 'oth_is_endoth[T', T''], DB)
    = procModule3(T, T', T'',
        addImports((including 'CONFIGURATION . including 'CONFIGURATION+ .),
          emptyOTheory),
        DB) .

  eq procModule2('fmod_is_endfm[T, T'], DB)
    = procModule3(T, T', emptyFModule, DB) .
  eq procModule2('obj_is_endo[T, T'], DB)
    = procModule3(T, T', emptyFModule, DB) .
  eq procModule2('obj_is_jbo[T, T'], DB)
    = procModule3(T, T', emptyFModule, DB) .
  eq procModule2('mod_is_endm[T, T'], DB)
    = procModule3(T, T', emptySModule, DB) .
  eq procModule2('omod_is_endom[T, T'], DB)
    = procModule3(T, T',
        addImports((including 'CONFIGURATION+ .),
          emptyOModule),
        DB) .
  eq procModule2('fth_is_endfth[T, T'], DB)
    = procModule3(T, T', emptyFTheory, DB) .
  eq procModule2('th_is_endth[T, T'], DB)
    = procModule3(T, T', emptySTheory, DB) .
  eq procModule2('oth_is_endoth[T, T'], DB)
    = procModule3(T, T',
        addImports((including 'CONFIGURATION+ .),
          emptyOTheory),
        DB) .

  *** procModule3 evaluates the name of the module and calls procModule4
  *** with the declarations, two empty units (one to contain the declarations
  *** with bubbles and another one the declarations without bubbles), and
  *** a set of op decls initialy empty in which to store the variables

  ceq procModule3(T, 'token[T'], T'', U, DB)
    = procModule4(T, T'', setName(U, QI), setName(U, QI), none, DB)
    if QI := downQid(T') .
  ceq procModule3(T, '_`{_`}['token[T'], T''], T3, U, DB)
    = procModule4(T, T3, setPars(setName(U, QI), parseParList(T'')),
        setName(U, QI), none, DB)
    if QI := downQid(T') .

  ceq procModule3('token[T], T', U, DB)
    = procModule4(T', setName(U, QI), setName(U, QI), none, DB)
    if QI := downQid(T) .
  ceq procModule3('_`{_`}['token[T], T'], T'', U, DB)
    = procModule4(T'', setPars(setName(U, QI), parseParList(T')),
        setName(U, QI), none, DB)
    if QI := downQid(T) .

  *** procModule4 parses one by one each of the declarations in the module.
  *** Note that is parseDecl that adds the parsed declaration to the right
  *** place. When it is done, it calls evalPreModule with the resulting
  *** preModule-unit-vars triple.

  ceq procModule4(T, '__[T', T''], PU, U, VDS, DB)
    = procModule4(T, T'', preModule(PDR), unit(PDR), vars(PDR), DB)
    if PDR := parseDecl(T', PU, U, VDS) .
  ceq procModule4(T, F[TL], PU, U, VDS, DB)
    = evalPreModule(preModule(PDR), unit(PDR), vars(PDR),
        insTermModule(getName(U), T, DB))
    if F =/= '__
       /\ PDR := parseDecl(F[TL], PU, U, VDS) .
  eq procModule4(T, T', unitError(QIL), V:[Module], V:[OpDeclSet], DB)
    = warning(DB, QIL) .
  eq procModule4(T, T', V:[Module], unitError(QIL), V:[OpDeclSet], DB)
    = warning(DB, QIL) .
  eq procModule4(T, T', V:[Module], V':[Module], opDeclError(QIL), DB)
    = warning(DB, QIL) .
  eq procModule4(T, F[TL], PU, U, VDS, DB)
    = warning(DB,'Error: 'no 'parse 'for F 'declaration)
    [owise] .

  ceq procModule4('__[T, T'], PU, U, VDS, DB)
    = procModule4(T', preModule(PDR), unit(PDR), vars(PDR), DB)
    if PDR := parseDecl(T, PU, U, VDS) .
  ceq procModule4(F[TL], PU, U, VDS, DB)
    = evalPreModule(preModule(PDR), unit(PDR), vars(PDR), DB)
    if F =/= '__
       /\ PDR := parseDecl(F[TL], PU, U, VDS) .
  eq procModule4(T, unitError(QIL), U, VDS, DB) = warning(DB, QIL) .
  eq procModule4(T, PU, unitError(QIL), VDS, DB) = warning(DB, QIL) .
  eq procModule4(T, PU, U, opDeclError(QIL), DB) = warning(DB, QIL) .
  eq procModule4(F[TL], PU, U, VDS, DB)
    = warning(DB,'Error: 'no 'parse 'for F 'declaration)
    [owise] .

endfm

*******************************************************************************

***
*** 8.3.2 View Processing
***

*** A similar process is followed for views. Note that in case of operator
*** maps going to derived terms we have bubbles, which will have to be treated
*** using the signatures of the appropriate modules.

fmod VIEW-PROCESSING is
  pr UNIT-PROCESSING .
  pr VIEW-DECL-PARSING .
  pr VIEW-BUBBLE-PARSING .

  vars QI X F : Qid .
  var  QIL : QidList .
  vars T T' T'' T3 T4 : Term .
  var  M : Module .
  var  VE : ViewExp .
  var  V : View .
  vars PV PV' : PreView .
  vars ME ME' : ModuleExpression .
  vars DB DB' : Database .
  vars OPDS VDS VDS' VDS'' : OpDeclSet .
  var  MDS : MsgDeclSet .
  var  TL : TermList .
  vars PDL PDL' : ParameterDeclList .
  var  H : Header .
  var  IL : ImportList .
  var  SMS : SortMappingSet .
  var  OMS : OpMappingSet .

*** As the functions \texttt{getThSorts} and \texttt{getThClasses}
*** presented in Section~\ref{instantiation}, the functions
*** \texttt{getThOpDeclSet} and \texttt{getThMsgDeclSet} return, respectively,
*** the set of declarations of operators, and the set of declarations of
*** messages in the theory part of the structure of the module given as
*** argument.

  op getThOpDeclSet : Header Database -> OpDeclSet .
  op getThMsgDeclSet : Header Database -> MsgDeclSet .

  op getThOpDeclSetAux : ImportList Database -> OpDeclSet .
  op getThMsgDeclSetAux : ImportList Database -> MsgDeclSet .

  eq getThOpDeclSet(ME, DB)
    = if theory(getTopModule(ME, DB))
      then (getThOpDeclSetAux(getImports(getTopModule(ME, DB)), DB)
            getOps(getTopModule(ME, DB)))
      else none
      fi .

  eq getThOpDeclSetAux(((including ME .) IL), DB)
    = (getThOpDeclSet(ME, DB) getThOpDeclSetAux(IL, DB)) .
  eq getThOpDeclSetAux(((extending ME .) IL), DB)
    = (getThOpDeclSet(ME, DB) getThOpDeclSetAux(IL, DB)) .
  eq getThOpDeclSetAux(((protecting ME .) IL), DB)
    = (getThOpDeclSet(ME, DB) getThOpDeclSetAux(IL, DB)) .
  eq getThOpDeclSetAux(nil, DB) = none .

  eq getThMsgDeclSet(ME, DB)
    = if theory(getTopModule(ME, DB))
      then (getThMsgDeclSetAux(getImports(getTopModule(ME, DB)), DB)
            getMsgs(getTopModule(ME, DB)))
      else none
      fi .

  eq getThMsgDeclSetAux(((including ME .) IL), DB)
    = (getThMsgDeclSet(ME, DB) getThMsgDeclSetAux(IL, DB)) .
  eq getThMsgDeclSetAux(((extending ME .) IL), DB)
    = (getThMsgDeclSet(ME, DB) getThMsgDeclSetAux(IL, DB)) .
  eq getThMsgDeclSetAux(((protecting ME .) IL), DB)
    = (getThMsgDeclSet(ME, DB) getThMsgDeclSetAux(IL, DB)) .
  eq getThMsgDeclSetAux(nil, DB) = none .

*** The processing of terms representing previews accomplished by the function
*** \texttt{procView} is quite similar to the one accomplished by
*** \texttt{procModule} on terms representing preunits. The algorithms followed
*** are also quite similar. Both proceed recursively on the list of
*** declarations, accumulating them in a preunit or in a preview.

*** The solving of bubbles in views requires the signatures of the source and
*** target units extended, respectively, with the declarations of variables in
*** the view and with the mappings of these declarations. As we shall see in
*** Section~\ref{databaseADT}, the signatures of the built-in modules are not
*** accesible at the metalevel, and thus built-in modules cannot be used
*** directly as arguments of built-in functions. Thus, to be able to use them
*** as targTS of views, a `dummy' module is created importing the
*** corresponding predefined module. The source and target module expressions
*** of the view are evaluated before the view processing itself starts.

*** As we saw in Section~\ref{view-decl-parsing}, parsing of terms representing
*** operator and message maps requires the set of operator and message
*** declarations in the theory part of the source theory.

  op procPars : ParameterDeclList Database -> Database .

  eq procPars((X :: ME, PDL), DB)
    = procPars(PDL, createCopy((X :: ME), database(evalModExp(ME, DB)))) .
  eq procPars((nil).ParameterDeclList, DB) = DB .

  op procView : Term Database -> Database .
  op procView2 : Term Database -> Database .
  op procView : Term PreView Database -> Database .
  op procViewAux : Term PreView OpDeclSet MsgDeclSet Module Database -> Database .

  eq procView(QI, DB)
    = procView2(getTermView(QI, DB), DB) .

  eq procView2('view_from_to_is_endv['token[T], T', T'', T3], DB)
    = procView(T3,
          emptyPreView(downQid(T), parseModExp(T'), parseModExp(T'')),
          DB) .
  eq procView2('view_from_to_is_endv['_`{_`}['token[T], T'], T'', T3, T4], DB)
    = procView(T4,
        setPars(
          emptyPreView(downQid(T), parseModExp(T''), parseModExp(T3)),
          parseParList(T')),
        procPars(parseParList(T'), DB)) .

  eq procView('view_from_to_is_endv['token[T], T', T'', T3], DB)
    = procView(T3,
        emptyPreView(downQid(T), parseModExp(T'), parseModExp(T'')),
          insertTermView(downQid(T),
            'view_from_to_is_endv['token[T], T', T'', T3], DB)) .
  eq procView('view_from_to_is_endv['_`{_`}['token[T], T'], T'', T3, T4], DB)
    = procView(T4,
        setPars(
          emptyPreView(downQid(T), parseModExp(T''), parseModExp(T3)),
          parseParList(T')),
        procPars(parseParList(T'),
          insertTermView(downQid(T),
            'view_from_to_is_endv['_`{_`}['token[T], T'], T'', T3, T4],
            DB))) .

  ceq procView(V, DB)
    = insertView(V, DB')
    if DB' := database(evalModExp(getFrom(V), nil, database(evalModExp(getTo(V), nil, DB)))) .

  ceq procView(T, PV, DB)
    = procViewAux(T, PV,
        getThOpDeclSet(ME, DB'),
        getThMsgDeclSet(ME, DB'),
        getFlatModule(ME, DB'),
        DB')
    if preview_from_to_is___endpv(VE, ME, ME', none, none, none) := PV
    /\ DB' := database(evalModExp(ME', nil, database(evalModExp(ME, nil, DB)))) .
  ceq procView(T, PV, DB)
    = procViewAux(T, PV,
        getThOpDeclSet(ME, DB':[Database]),
        getThMsgDeclSet(ME, DB':[Database]),
        getFlatModule(ME, DB':[Database]),
        DB':[Database])
    if preview_from_to_is___endpv(VE{PDL}, ME, ME', none, none, none) := PV
    /\ DB':[Database] := database(evalModExp(ME', PDL, database(evalModExp(ME, PDL, DB)))) .

  eq procViewAux('none.ViewDeclSet, preview_from_to_is___endpv(VE{PDL}, ME, ME', VDS, SMS, OMS), OPDS, MDS, M, DB)
    = insertView(view VE{PDL} from ME to ME' is none none endv, DB) .
  eq procViewAux('none.ViewDeclSet, preview_from_to_is___endpv(VE, ME, ME', VDS, SMS, OMS), OPDS, MDS, M, DB)
    = insertView(view VE from ME to ME' is none none endv, DB) .
  eq procViewAux('__[T, T'], PV, OPDS, MDS, M, DB)
  *** - OPDS and MDS are, respectively, the set of operation and
  ***   message declarations in the theory part of the source.
  *** - M is the signature of the source theory.
    = procViewAux(T', parseDecl(T, PV, OPDS, MDS, M), OPDS, MDS, M, DB) .
  ceq procViewAux(F[TL], PV, OPDS, MDS, M, DB)
    = insertView(
        view VE{PDL} from ME to ME' is
          SMS
          solveBubbles(
            OMS,
            VDS, VDS',
            addOps(VDS, M),
            addOps(VDS', getFlatModule(ME', DB)))
        endv,
        DB)
    if F =/= '__
       /\ preview_from_to_is___endpv(VE{PDL}, ME, ME', VDS, SMS, OMS) := parseDecl(F[TL], PV, OPDS, MDS, M)
       /\ VDS' := applyMapsToOps(maps2rens(SMS), none, VDS, M) .
  ceq procViewAux(F[TL], PV, OPDS, MDS, M, DB)
    = insertView(
        view VE from ME to ME' is
          SMS
          solveBubbles(
            OMS,
            VDS, VDS',
            addOps(VDS, M),
            addOps(VDS', getFlatModule(ME', DB)))
        endv,
        DB)
    if F =/= '__
       /\ preview_from_to_is___endpv(VE, ME, ME', VDS, SMS, OMS) := parseDecl(F[TL], PV, OPDS, MDS, M)
       /\ VDS' := applyMapsToOps(maps2rens(SMS), none, VDS, M) .
  eq procViewAux(T, PV, OPDS, MDS, unitError(QIL), DB) = warning(DB, QIL) .
endfm

*******************************************************************************

***
*** 8.3.3 Command Processing
***

*** The function \texttt{procCommand} only handles the \texttt{reduce},
*** \texttt{rewrite}, and \texttt{down} commands. The other commands are
*** directly evaluated by the rules for the top-level handling of the
*** database (see Section~\ref{database-handling}). The \texttt{procCommand}
*** function takes a term, which represents one of these commands, the name of
*** the default module, and a database. The result is a list of quoted
*** identifiers representing the result of the evaluation of the command that
*** will be placed in the read-eval-print loop to be printed in the terminal.

*** The \texttt{reduce} and \texttt{rewrite} commands are basically evaluated
*** calling the built-in functions \texttt{metaReduce} and
*** \texttt{metaRewrite}, respectively. These functions are called with the
*** appropriate modules. In the case of commands in which an explicit module
*** is not specified the default module is used.

*** The preparation of the output for these functions becomes more complex
*** when the \texttt{down} command is used. To deal with the \texttt{down}
*** command, an auxiliary function \texttt{procCommand2} is introduced,
*** returning the term resulting from the evaluation of the command.

fmod COMMAND-PROCESSING is
  pr UNIT-PROCESSING .
  pr UNIT-META-PRETTY-PRINT .
  inc (2TUPLE * (op `(_`,_`) to <<_;_>>,
                 op p1_ to getDatabase,
                 op p2_ to getQidList)) {Database, QidList} .
  pr META-FULL-MAUDE-SIGN .
  pr META-NARROWING-SEARCH * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) .

  eq getDatabase(<< DB ; qidError(QIL) >>) = warning(DB, QIL) .
  eq getQidList(<< DB ; qidError(QIL) >>) = QIL .

  op {_,_} : Term Type ~> ResultPair [ctor] .
  op {_,_,_} : Term Type Substitution ~> ResultTriple [ctor] .
  op {_,_,_,_} : Term Type Substitution Context ~> Result4Tuple [ctor] .
  op {_,_} : Substitution Context ~> MatchPair [ctor] .

*** projection functions (from prelude.maude)
  op getTerm : ResultPair ~> Term .
  eq getTerm({T:[Term], T':[Type]}) = T:[Term] .
  op getType : ResultPair ~> Type .
  eq getType({T:[Term], T':[Type]}) = T':[Type] .

  op getTerm : ResultTriple ~> Term .
  eq getTerm({T:[Term], T':[Type], S:[Substitution]}) = T:[Term] .
  op getType : ResultTriple ~> Type .
  eq getType({T:[Term], T':[Type], S:[Substitution]}) = T':[Type] .
  op gTSubstitution : ResultTriple ~> Substitution .
  eq gTSubstitution({T:[Term], T':[Type], S:[Substitution]})
    = S:[Substitution] .

  op getTerm : Result4Tuple ~> Term .
  eq getTerm({T:[Term], T':[Type], S:[Substitution], C:[Context]}) = T:[Term] .
  op getType : Result4Tuple ~> Type .
  eq getType({T:[Term], T':[Type], S:[Substitution], C:[Context]}) = T':[Type] .
  op gTSubstitution : Result4Tuple ~> Substitution .
  eq gTSubstitution({T:[Term], T':[Type], S:[Substitution], C:[Context]})
    = S:[Substitution] .
  op getContext : Result4Tuple ~> Context .
  eq getContext({T:[Term], T':[Type], S:[Substitution], C:[Context]})
    = C:[Context] .

  op gTSubstitution : MatchPair ~> Substitution .
  eq gTSubstitution({S:[Substitution], C:[Context]}) = S:[Substitution] .
  op getContext : MatchPair ~> Context .
  eq getContext({S:[Substitution], C:[Context]}) = C:[Context] .



  vars T T' T'' T''' : Term .
  var  TL : TermList .
  vars DB DB' DB'' : Database .
  var  DB? : [Database] .
  vars M M' : Module .
  var  M? : [Module] .
  vars ME ME' : ModuleExpression .
  vars H H' : Header .
  vars MNS MNS' MNS'' MNS3 MNS4 : Set{ModuleName} .
  var  VE : ViewExp .
  var  VES : Set{ViewExp} .
  vars N I J : Nat .
  var  I? : [Nat] .
  vars D D' : Bound .
  var  D? : [Bound] .
  var  B : Bool .
  var  B? : [Bool] .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars PDS PDS' : Set{ParameterDecl} .
  var  QIL : QidList .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  vars VS VDS OPDS : OpDeclSet .
  var  OPDS? : [OpDeclSet] .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  vars QI QI' F V O : Qid .
  var  Ct : Constant .
  var  IL : ImportList .
  var  TM : [Tuple{Term,Module,Bool,OpDeclSet,Database}] .
  var  TMVB : [Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}] .
  var  TMVBN : [Tuple{Term,Module,OpDeclSet,Bound,Nat}] .
  var  T? : [Term] .
  var  RP : [ResultPair] .
  var  RT : [ResultTriple] .
  var  Sb? : [Substitution] .
  var  MP? : [MatchPair] .
  var  CD : Condition .
  var  Sb : Substitution .
  var  UP? : [UnificationPair] .
  var  UP : UnificationProblem .

----  sorts Tuple{Term,Module,Bool,OpDeclSet,Database}
----        Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}
----        Tuple{Term,Module,OpDeclSet,Bound,Nat} .
----  op `{_`,_`,_`,_`,_`} : Term Module Bool OpDeclSet Database
----       -> Tuple{Term,Module,Bool,OpDeclSet,Database} .
----  op `{_`,_`,_`,_`,_`,_`} : Term Module Bool OpDeclSet Bound Database
----       -> Tuple{Term,Module,Bool,OpDeclSet,Bound,Database} .
----  op `{_`,_`,_`,_`,_`} : Term Module OpDeclSet Bound Nat
----       -> Tuple{Term,Module,OpDeclSet,Bound,Nat} .
  op tupleTMBODerror : QidList -> [Tuple{Term,Module,Bool,OpDeclSet,Database}] .
  op tupleTMBOBDerror : QidList -> [Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}] .
  op tupleTMOBNerror : QidList -> [Tuple{Term,Module,OpDeclSet,Bound,Nat}] .

  pr 5TUPLE{Term,Module,Bool,OpDeclSet,Database}
       * (op ((_,_,_,_,_)) to `{_`,_`,_`,_`,_`},
          op p1_ to getTerm,
          op p2_ to getModule,
          op p3_ to getBool,
          op p4_ to getVars,
          op p5_ to getDatabase) .
  pr 6TUPLE{Term,Module,Bool,OpDeclSet,Bound,Database}
       * (op ((_,_,_,_,_,_)) to `{_`,_`,_`,_`,_`,_`},
          op p1_ to getTerm,
          op p2_ to getModule,
          op p3_ to getBool,
          op p4_ to getVars,
          op p5_ to getBound,
          op p6_ to getDatabase) .
  pr 5TUPLE{Term,Module,OpDeclSet,Bound,Nat}
       * (op ((_,_,_,_,_)) to `{_`,_`,_`,_`,_`},
          op p1_ to getTerm,
          op p2_ to getModule,
          op p3_ to getVars,
          op p4_ to getBound,
          op p5_ to getNat) .

  op boundError  : QidList -> [Bound] .
----  op getTerm     : Tuple{Term,Module,Bool,OpDeclSet,Database} ~> Term .
----  op getModule   : Tuple{Term,Module,Bool,OpDeclSet,Database} ~> Module .
----  op getVars     : Tuple{Term,Module,Bool,OpDeclSet,Database} ~> OpDeclSet .
----  op getBool     : Tuple{Term,Module,Bool,OpDeclSet,Database} ~> Bool .
----  op getDatabase : Tuple{Term,Module,Bool,OpDeclSet,Database} ~> Database .

----  op getTerm     : Tuple{Term,Module,Bool,OpDeclSet,Bound,Database} ~> Term .
----  op getModule   : Tuple{Term,Module,Bool,OpDeclSet,Bound,Database} ~> Module .
----  op getVars     : Tuple{Term,Module,Bool,OpDeclSet,Bound,Database} ~> OpDeclSet .
----  op getBound    : Tuple{Term,Module,Bool,OpDeclSet,Bound,Database} ~> Bound .
----  op getBool     : Tuple{Term,Module,Bool,OpDeclSet,Bound,Database} ~> Bool .
----  op getDatabase : Tuple{Term,Module,Bool,OpDeclSet,Bound,Database} ~> Database .

----  op getTerm     : Tuple{Term,Module,OpDeclSet,Bound,Nat} ~> Term .
----  op getModule   : Tuple{Term,Module,OpDeclSet,Bound,Nat} ~> Module .
----  op getVars     : Tuple{Term,Module,OpDeclSet,Bound,Nat} ~> OpDeclSet .
----  op getBound    : Tuple{Term,Module,OpDeclSet,Bound,Nat} ~> Bound .
----  op getNat      : Tuple{Term,Module,OpDeclSet,Bound,Nat} ~> Nat .

----  eq {qidError(QIL), M?, B?, OPDS?, DB?} = tupleTMBODerror(QIL) .
----  eq {qidError(QIL), M?, B?, OPDS?, D?, DB?} = tupleTMBOBDerror(QIL) .
----  eq {qidError(QIL), M?, OPDS?, D?, I?} = tupleTMOBNerror(QIL) .

  eq getTerm({T, M, B, VDS, DB}) = T .
  eq getTerm(tupleTMBODerror(QIL)) = qidError(QIL) .
  eq getModule({T, M, B, VDS, DB}) = M .
  eq getModule(tupleTMBODerror(QIL)) = unitError(QIL) .
  eq getVars({T, M, B, VDS, DB}) = VDS .
  eq getVars(tupleTMBODerror(QIL)) = opDeclError(QIL) .
  eq getBool({T, M, B, VDS, DB}) = B .
  eq getBool(tupleTMBODerror(QIL)) = false .
  eq getDatabase({T, M, B, VDS, DB}) = DB .
  eq getDatabase(tupleTMBODerror(QIL)) = emptyDatabase .

  eq getTerm({T, M, B, VDS, D, DB}) = T .
----  eq getTerm(error(QIL)) = qidError(QIL) .
  eq getModule({T, M, B, VDS, D, DB}) = M .
----  eq getModule(error(QIL)) = unitError(QIL) .
  eq getVars({T, M, B, VDS, D, DB}) = VDS .
----  eq getVars(error(QIL)) = opDeclError(QIL) .
  eq getBound({T, M, B, VDS, D, DB}) = D .
----  eq getBound(error(QIL)) = boundError(QIL) .
  eq getBool({T, M, B, VDS, D, DB}) = B .
----  eq getBool(error(QIL)) = false .
  eq getDatabase({T, M, B, VDS, D, DB}) = DB .
----  eq getDatabase(error(QIL)) = emptyDatabase .

  eq getTerm({T, M, VDS, D, I}) = T .
----  eq getTerm(error(QIL)) = qidError(QIL) .
  eq getModule({T, M, VDS, D, I}) = M .
----  eq getModule(error(QIL)) = unitError(QIL) .
  eq getVars({T, M, VDS, D, I}) = VDS .
----  eq getVars(error(QIL)) = opDeclError(QIL) .
  eq getBound({T, M, VDS, D, I}) = D .
----  eq getBound(error(QIL)) = boundError(QIL) .
  eq getNat({T, M, VDS, D, I}) = I .
----  eq getNat(error(QIL)) = numberError(QIL) .

  ---- procLoad

  op procLoad : Term ModuleExpression Database -> Tuple{Database,QidList} .
  op procLoad : Term ModuleExpression Module OpDeclSet Database -> Tuple{Database,QidList} .

  eq procLoad(T, ME, DB)
   = if compiledModule(ME, DB)
     then procLoad(T, ME, getFlatModule(ME, DB), getVars(ME, DB), DB)
     else procLoad(T, modExp(evalModExp(ME, DB)),
               getFlatModule(modExp(evalModExp(ME, DB)),
                 database(evalModExp(ME, DB))),
               getVars(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB))),
               database(evalModExp(ME, DB)))
     fi .

  ceq procLoad(T, ME, M, VDS, DB)
    = if downTerm(T:[Term], emptyFModule) =/= emptyFModule
      then << evalModule(downModule(T:[Term]), none, DB) ;
              'Introduced 'module header2Qid(getName(downModule(T:[Term]))) '\n >>
      else << DB ; '\r 'Error: '\o 'Incorrect 'metamodule. '\n >>
      fi
    if T:[Term] := getTerm(metaReduce(M, solveBubbles(T, M, true, VDS, DB))) .

  ---- procCommand

  op procCommand : Term ModuleExpression Database -> Tuple{Database,QidList} .
  op procCommand : Term ModuleExpression Module OpDeclSet Database -> QidList .
  op procDownCommand : Term ModuleExpression Database -> Tuple{Database,QidList} .

  op procParse : ModuleExpression Module Term OpDeclSet Database -> QidList .

  op procRed : ModuleExpression Module Term OpDeclSet Database -> QidList .
  op solveBubblesRed : Term Module Bool OpDeclSet Database
       -> [Tuple{Term,Module,Bool,OpDeclSet,Database}] .
  op solveBubblesRed2 : Term Database -> [Tuple{Term,Module,Bool,OpDeclSet,Database}] .
  op solveBubblesRed3 : Term Module ModuleExpression OpDeclSet Database -> [Tuple{Term,Module,Bool,OpDeclSet,Database}] .

  op procRew : ModuleExpression Module Term OpDeclSet Database -> QidList .
  op solveBubblesRew : Term Module Bool Bound OpDeclSet Database -> [Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}] .
  op solveBubblesRew2 : Term Module Bool OpDeclSet Database -> [Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}] .

  op procFrew : ModuleExpression Module Term Bound Nat OpDeclSet Database -> QidList .
  op solveBubblesFrew : Term Module Bool Bound Nat OpDeclSet Database -> [Tuple{Term,Module,OpDeclSet,Bound,Nat}] .
  op solveBubblesFrew2 : Term Module Bool Nat OpDeclSet Database -> [Tuple{Term,Module,OpDeclSet,Bound,Nat}] .

  op procSearch : ModuleExpression Module Term Term Qid Bound Bound OpDeclSet Database -> QidList .
  op solveBubblesSearchL : Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesSearchL1 : Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesSearchR : Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesSearchR1 : Module Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesSearchR2 : Module Term Term Qid Bound Bound OpDeclSet -> QidList .
  op procSearch2 : Module Term Term Condition Qid Bound Bound -> QidList .
  op procSearch3 : Module Term Term Condition Qid Bound Nat Bound -> QidList .

  op procNarrowSearch : ModuleExpression Module Term Term Qid Bound Bound OpDeclSet Database -> QidList .
  op solveBubblesNarrowSearchL : Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesNarrowSearchL1 : Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesNarrowSearchR : Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesNarrowSearchR1 : Module Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesNarrowSearchR2 : Module Term Term Qid Bound Bound OpDeclSet -> QidList .
  op procNarrowSearch2 : Module Term Term Condition Qid Bound Bound -> QidList .
  op procNarrowSearch3 : Module Nat TermList ResultTripleSet -> QidList .

  op procMatch : ModuleExpression Module Term Term Qid Bound OpDeclSet Database -> QidList .
  op procMatch2 : Module Term Term Condition Qid Bound -> QidList .
  op procMatch3 : Module Term Term Condition Qid Bound Nat -> QidList .
  op solveBubblesMatch : Module Module Term Term Qid Bound Bool OpDeclSet Database ~> QidList .
  op solveBubblesMatch2 : Module Term Term Qid Bound OpDeclSet ~> QidList .

  op procUnify : ModuleExpression Module Term Bound OpDeclSet Database -> QidList .
  op procUnify2 : ModuleExpression Module Term Bound OpDeclSet Database -> QidList .
  op addInfoUnify : Module -> [Module] .
  op parseUnify : Term OpDeclSet -> UnificationProblem .
  op procUnify2 : Module UnificationProblem Bound -> QidList .
  op eMetaPrettyPrint : Module UnificationProblem -> QidList .
  op procUnify3 : Module UnificationProblem Bound Nat -> QidList .
  op procUnify3Aux : Module UnificationPair Nat -> QidList .
  op unificationProblemError : QidList -> [UnificationProblem] .

  op procIdUnify : ModuleExpression Module Term Bound OpDeclSet Database -> QidList .
  op procIdUnify2 : Module UnificationProblem Bound -> QidList .
  op procIdUnify3 : Module UnificationProblem Nat SubstitutionSet -> QidList .

  op procVariantUnify : ModuleExpression Module Term Bound OpDeclSet Database -> QidList .
  op procVariantUnify2 : Module UnificationProblem Bound -> QidList .
  op procVariantUnify3 : Module UnificationProblem Nat SubstitutionSet -> QidList .

  op procAsymmetricVariantUnify : ModuleExpression Module Term Bound OpDeclSet Database -> QidList .
  op procAsymmetricVariantUnify2 : Module UnificationProblem Bound -> QidList .
  op procAsymmetricVariantUnify3 : Module UnificationProblem Nat SubstitutionSet -> QidList .

  op procGetVariants : ModuleExpression Module Term Bound OpDeclSet Database -> QidList .
  op parseGetVariants : Term OpDeclSet -> Term .
  op procGetVariants2 : Module Term Bound -> QidList .
  op procGetVariants3 : Module Term Nat VariantFourSet -> QidList .

  op solveBubblesUnify : Module Term OpDeclSet ~> UnificationProblem .
  op solveBubblesRedUnify : Term Module Bool OpDeclSet Database
       -> [Tuple{Term,Module,Bool,OpDeclSet,Database}] .
  op solveBubblesRedUnify2 : Term Database -> [Tuple{Term,Module,Bool,OpDeclSet,Database}] .
  op solveBubblesRedUnify3 : Term Module ModuleExpression OpDeclSet Database
       -> [Tuple{Term,Module,Bool,OpDeclSet,Database}] .
  op procRewUnify : ModuleExpression Module Term OpDeclSet Database -> QidList .
  op solveBubblesRewUnify : Term Module Bool Bound OpDeclSet Database
       -> [Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}] .
  op solveBubblesRewUnify2 : Term Module Bool OpDeclSet Database
       -> [Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}] .

  op eMetaPrettyPrint : Module Substitution -> QidList .

  eq eMetaPrettyPrint(M, V <- T ; Sb:Substitution)
    = V '--> '\s eMetaPrettyPrint(M, T)
      if eMetaPrettyPrint(M, Sb:Substitution) == nil
      then nil
      else '; eMetaPrettyPrint(M, Sb:Substitution)
      fi .
  eq eMetaPrettyPrint(M, (none).Substitution) = nil .

  op procCommandUp : ModuleExpression Module Term OpDeclSet Database -> Term .
  op procRedUp : ModuleExpression Module Term OpDeclSet Database -> Term .
  op procRewUp : ModuleExpression Module Term Bound OpDeclSet Database -> Term .
  op procFrewUp : ModuleExpression Module Term Bound Nat OpDeclSet Database -> Term .

*** Processing of commands.

  ceq procDownCommand('down_:_[T, T'], ME, DB)
    = if T'':[Term] :: Term
      then << DB'' ;
              ('\b 'result '\o
               '\s eMetaPrettyPrint(leastSort(M, T'':[Term]))
               '\s '\b ': '\o '\n '\s '\s
               eMetaPrettyPrint(M, T'':[Term]) '\n) >>
      else << DB ; ('\r 'Error: '\o 'Incorrect 'input. '\n) >>
      fi
    if DB' := database(evalModExp(ME, DB))
    /\ < DB'' ; ME' > := evalModExp(parseModExp(T), DB')
    /\ M := getFlatModule(ME', DB'')
    /\ T'':[Term] := procCommandUp(ME, getFlatModule(ME, DB''), T', getVars(ME, DB''), DB'').

  eq procCommand(T, ME, DB)
   = if compiledModule(ME, DB)
     then << DB ; procCommand(T, ME, getFlatModule(ME, DB), getVars(ME, DB), DB) >>
     else << database(evalModExp(ME, DB)) ;
             procCommand(T, modExp(evalModExp(ME, DB)),
               getFlatModule(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB))),
               getVars(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB))),
               database(evalModExp(ME, DB))) >>
     fi
     [owise] .

----  eq procCommand(T, ME, unitError(QIL), VS, DB) = qidError(QIL) .
  eq procCommand(T, ME, unitError(QIL), VS, DB) = QIL .

  eq procCommand('parse_.['bubble[T]], ME, M, VS, DB)
   = procParse(ME, M, 'bubble[T], VS, DB) .

  eq procCommand('reduce_.['bubble[T]], ME, M, VS, DB)
    = procCommand('red_.['bubble[T]], ME, M, VS, DB) .
  eq procCommand('red_.['bubble[T]], ME, M, VS, DB)
    = procRed(ME, M, 'bubble[T], VS, DB) .

  eq procCommand('rewrite_.['bubble[T]], ME, M, VS, DB)
    = procCommand('rew_.['bubble[T]], ME, M, VS, DB) .
  eq procCommand('rew_.['bubble[T]], ME, M, VS, DB)
    = procRew(ME, M, 'bubble[T], VS, DB) .

  eq procCommand('frewrite_.['bubble[T]], ME, M, VS, DB)
    = procCommand('frew_.['bubble[T]], ME, M, VS, DB) .
  eq procCommand('frew_.['bubble[T]], ME, M, VS, DB)
    = procFrew(ME, M, 'bubble[T], unbounded, 1, VS, DB) .

  eq procCommand('search_=>1_.['bubble[T], 'bubble[T']], ME, M, VS, DB)
    = procSearch(ME, M, 'bubble[T], 'bubble[T'], '+, unbounded, 1, VS, DB) .
  eq procCommand('search_=>*_.['bubble[T], 'bubble[T']], ME, M, VS, DB)
    = procSearch(ME, M, 'bubble[T], 'bubble[T'], '*, unbounded, unbounded, VS, DB) .
  eq procCommand('search_=>+_.['bubble[T], 'bubble[T']], ME, M, VS, DB)
    = procSearch(ME, M, 'bubble[T], 'bubble[T'], '+, unbounded, unbounded, VS, DB) .
  eq procCommand('search_=>!_.['bubble[T], 'bubble[T']], ME, M, VS, DB)
    = procSearch(ME, M, 'bubble[T], 'bubble[T'], '!, unbounded, unbounded, VS, DB) .

  eq procCommand('search_~>1_.['bubble[T], 'bubble[T']], ME, M, VS, DB)
    = procNarrowSearch(ME, M, 'bubble[T], 'bubble[T'], '+, unbounded, 1, VS, DB) .
  eq procCommand('search_~>*_.['bubble[T], 'bubble[T']], ME, M, VS, DB)
    = procNarrowSearch(ME, M, 'bubble[T], 'bubble[T'], '*, unbounded, unbounded, VS, DB) .
  eq procCommand('search_~>+_.['bubble[T], 'bubble[T']], ME, M, VS, DB)
    = procNarrowSearch(ME, M, 'bubble[T], 'bubble[T'], '+, unbounded, unbounded, VS, DB) .
  eq procCommand('search_~>!_.['bubble[T], 'bubble[T']], ME, M, VS, DB)
    = procNarrowSearch(ME, M, 'bubble[T], 'bubble[T'], '!, unbounded, unbounded, VS, DB) .

  eq procCommand('match_<=?_.['bubble[T], 'bubble[T']], ME, M, VS, DB)
    = procMatch(ME, M, 'bubble[T], 'bubble[T'], 'match, 0, VS, DB) .
  eq procCommand('xmatch_<=?_.['bubble[T], 'bubble[T']], ME, M, VS, DB)
    = procMatch(ME, M, 'bubble[T], 'bubble[T'], 'xmatch, 0, VS, DB) .

  eq procCommand('unify_.['bubble[T]], ME, M, VS, DB)
    = procUnify(ME, M, 'bubble[T], unbounded, VS, DB) .

  eq procCommand('id-unify_.['bubble[T]], ME, M, VS, DB)
    = procIdUnify(ME, M, 'bubble[T], unbounded, VS, DB) .

  eq procCommand('variant`unify_.['bubble[T]], ME, M, VS, DB)
    = procVariantUnify(ME, M, 'bubble[T], unbounded, VS, DB) .

  eq procCommand('asymmetric`variant`unify_.['bubble[T]], ME, M, VS, DB)
    = procAsymmetricVariantUnify(ME, M, 'bubble[T], unbounded, VS, DB) .

  eq procCommand('get`variants_.['bubble[T]], ME, M, VS, DB)
    = procGetVariants(ME, M, 'bubble[T], unbounded, VS, DB) .

  eq procCommandUp(ME, M, 'down_:_[T, T'], VDS, DB)
    = downTerm(procCommandUp(ME, M, T', VDS, DB)) .
  eq procCommandUp(ME, M, 'red_.['bubble[T]], VDS, DB)
    = downTerm(procRedUp(ME, M, 'bubble[T], VDS, DB)) .
  eq procCommandUp(ME, M, 'reduce_.['bubble[T]], VDS, DB)
    = downTerm(procRedUp(ME, M, 'bubble[T], VDS, DB)) .
  eq procCommandUp(ME, M, 'rew_.['bubble[T]], VDS, DB)
    = downTerm(procRewUp(ME, M, 'bubble[T], unbounded, VDS, DB)) .
  eq procCommandUp(ME, M, 'rewrite_.['bubble[T]], VDS, DB)
    = downTerm(procRewUp(ME, M, 'bubble[T], unbounded, VDS, DB)) .
  eq procCommandUp(ME, M, 'frew_.['bubble[T]], VDS, DB)
    = downTerm(procFrewUp(ME, M, 'bubble[T], unbounded, 0, VDS, DB)) .
  eq procCommandUp(ME, M, 'frewrite_.['bubble[T]], VDS, DB)
    = downTerm(procFrewUp(ME, M, 'bubble[T], unbounded, 0, VDS, DB)) .

  ceq procRedUp(ME, M, T, VDS, DB)
    = if metaReduce(getModule(TM), getTerm(TM)) :: ResultPair
      then getTerm(metaReduce(getModule(TM), getTerm(TM)))
      else qidError('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi
    if TM := solveBubblesRed(T, M,
               included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
               VDS, DB) .

  ceq procRewUp(ME, M, T, D, VDS, DB)
    = if metaRewrite(getModule(TMVB), getTerm(TMVB), getBound(TMVB))
           :: ResultPair
      then getTerm(metaRewrite(getModule(TMVB), getTerm(TMVB), getBound(TMVB)))
      else qidError('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi
    if TMVB := solveBubblesRew(T, M,
                included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
                D, VDS, DB) .

  ceq procFrewUp(ME, M, T, D, I, VDS, DB)
    = if metaFrewrite(
           getModule(TMVBN), getTerm(TMVBN), getBound(TMVBN), getNat(TMVBN))
         :: ResultPair
      then getTerm(
             metaFrewrite(getModule(TMVBN), getTerm(TMVBN),
               getBound(TMVBN), getNat(TMVBN)))
      else qidError('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi
    if TMVBN := solveBubblesFrew(T, M,
                 included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
                 D, I, VDS, DB) .

  ceq procParse(ME, M, T, VDS, DB)
    = if leastSort(getModule(TM), getTerm(TM)) :: Type
      then (eMetaPrettyPrint(leastSort(getModule(TM), getTerm(TM)))
            '\s '\b ': '\o '\n '\s '\s
            eMetaPrettyPrint(getModule(TM), getTerm(TM)) '\n)
      else getMsg(getTerm(TM))
      fi
    if TM := solveBubblesRed(T, M,
               included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
               VDS, DB) .
  eq procParse(ME, unitError(QIL), T, VDS, DB) = QIL .
  eq procParse(ME, noModule, T, VDS, DB) = getMsg(DB) .

  ceq procRed(ME, M, T, VDS, DB)
    = if metaReduce(getModule(TM), getTerm(TM)) :: ResultPair
      then ('\b 'reduce 'in
            '\o eMetaPrettyPrint(getName(getModule(TM))) '\b ': '\o '\n '\s '\s
            eMetaPrettyPrint(getModule(TM), getTerm(TM)) '\n
            '\b 'result '\o '\s
            eMetaPrettyPrint(getType(metaReduce(getModule(TM), getTerm(TM))))
            '\s '\b ': '\o '\n '\s '\s
            eMetaPrettyPrint(getModule(TM),
              getTerm(metaReduce(getModule(TM), getTerm(TM))))
            '\n)
      else getMsg(getTerm(metaReduce(getModule(TM), getTerm(TM))))
      fi
    if TM := solveBubblesRed(T, M,
               included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
               VDS, DB) .
  eq procRed(ME, unitError(QIL), T, VDS, DB) = QIL .
  eq procRed(ME, noModule, T, VDS, DB) = getMsg(DB) .

  eq metaReduce(unitError(QIL), T) = {qidError(QIL), '`[Term`]} .
  eq metaReduce(U:[Module], qidError(QIL)) = {qidError(QIL), '`[Term`]} .

  ceq solveBubblesRed('bubble[QI], M, B, VDS, DB)
    = if T? :: Term
      then {T?, M, B, VDS, DB}
      else tupleTMBODerror('\r 'Error: '\o 'no 'parse 'for downQidList(QI) '\n)
      fi
    if T? := solveBubbles('bubble[QI], M, B, VDS, DB) .
  ceq solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)
    = if T? :: Term
      then {T?, M, B, VDS, DB}
      else if metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]), '@RedInPart@) :: ResultPair
           then solveBubblesRed2(
                  getTerm(metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]), '@RedInPart@)),
                  DB)
           else tupleTMBODerror(
                  '\r 'Warning: '\o
                    printSyntaxError(
                      metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]),
                       '@RedInPart@), downQidList('__[TL, ''..Qid])) '\n
                    '\r 'Error: '\o
                    'no 'parse 'for downQidList('__[TL, ''..Qid]) '\n)
           fi
      fi
    if T? := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .
  *** There is some problem parsing 'in_:_ in solveBubblesRed, but it
  *** seems to work with the additional '.

  ceq solveBubblesRed2('in_:_.[T, T'], DB)
    = if unitInDb(ME, DB')
      then solveBubblesRed3(T', getFlatModule(ME, DB'), ME, getVars(ME, DB'), DB')
      else tupleTMBODerror('\r 'Error: '\o 'It 'is 'not 'possible 'to 'compile eMetaPrettyPrint(ME) '. '\n)
      fi
    if < DB' ; ME > := evalModExp(parseModExp(T), DB) .
  eq solveBubblesRed2('in_:_.[T, T'], DB)
    = tupleTMBODerror('\r 'Error: '\o 'It 'isn't 'possible 'to 'compile eMetaPrettyPrint(parseModExp(T)) '. '\n)
    [owise] .

  eq solveBubblesRed3(T, M, ME, VDS, DB)
    = {solveBubbles(T, M,
         included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
         VDS, DB),
       M,
       included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
       VDS,
       DB} .

  op GRAMMAR-RED : -> FModule [memo] .
  eq GRAMMAR-RED
    = addImports((including 'MOD-EXPRS .),
        addSorts('@RedInPart@,
          addOps((op 'in_:_. : '@ModExp@ '@Bubble@ -> '@RedInPart@ [none] .),
            BUBBLES))) .

  ceq procRew(ME, M, T, VDS, DB)
    = if RP :: ResultPair
      then ('\b 'rewrite 'in '\o eMetaPrettyPrint(getName(getModule(TMVB)))
            '\b ': '\o '\n '\s '\s
            eMetaPrettyPrint(getModule(TMVB), getTerm(TMVB)) '\n
            '\b 'result '\o '\s
            eMetaPrettyPrint(getType(RP))
            '\s '\b ': '\o '\n '\s '\s
            eMetaPrettyPrint(getModule(TMVB), getTerm(RP))
            '\n)
      else getMsg(getTerm(TMVB))
      fi
    if TMVB := solveBubblesRew(T, M,
                included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
                unbounded, VDS, DB)
       /\ RP  := metaRewrite(getModule(TMVB), getTerm(TMVB), getBound(TMVB)) .
  eq procRew(ME, unitError(QIL), T, VDS, DB) = qidError(QIL) .

  eq solveBubblesRew('bubble[QI], M, B, D, VDS, DB)
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble[QI], M, B, VDS, DB), M, B, VDS, unbounded, DB}
      else tupleTMBOBDerror(
             '\r 'Error: '\o 'no 'parsing 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble['__[TL]], M, B, VDS, DB), M, B, VDS, unbounded, DB}
      else if metaParse(GRAMMAR-REW, downQidList('__[TL, ''..Qid]), '@RewNuPart@)
                :: ResultPair
           then solveBubblesRew2(
                  getTerm(
                    metaParse(GRAMMAR-REW, downQidList('__[TL, ''..Qid]),
                      '@RewNuPart@)),
                  M, B, VDS, DB)
           else {getTerm(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 getModule(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 getBool(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 getVars(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 unbounded,
                 getDatabase(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB))}
           fi
      fi .

  eq solveBubblesRew2('`[_`]_.['token[T], T'], M, B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRed(T', M, B, VDS, DB)
                    :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then {getTerm(solveBubblesRed(T', M, B, VDS, DB)),
            getModule(solveBubblesRed(T', M, B, VDS, DB)),
            getBool(solveBubblesRed(T', M, B, VDS, DB)),
            getVars(solveBubblesRed(T', M, B, VDS, DB)),
            downNat(downMetaNat(T)),
            getDatabase(solveBubblesRed(T', M, B, VDS, DB))}
      else tupleTMBOBDerror(
             '\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  op GRAMMAR-REW : -> FModule [memo] .
  eq GRAMMAR-REW
    = addSorts('@RewNuPart@ ; '@Token@ ; '@SortToken@ ; '@ViewToken@ ; '@NeTokenList@ ; '@Bubble@,
        addOps((op '`[_`]_. : '@Token@ '@Bubble@ -> '@RewNuPart@ [none] .),
          BUBBLES)) .

----  eq metaRewrite(fmod QI is IL sorts SS . SSDS OPDS MAS EqS endfm, T, D)
----    = metaReduce(fmod QI is IL sorts SS . SSDS OPDS MAS EqS endfm, T) .
----  eq metaRewrite(M, T, 0) = {T, leastSort(M, T)} .

  *** FREW

  ceq procFrew(ME, M, T, D, I, VDS, DB)
    = if RP :: ResultPair
      then ('\b 'frewrite 'in '\o eMetaPrettyPrint(getName(getModule(TMVBN)))
            '\b ': '\o  '\n '\s '\s
            eMetaPrettyPrint(getModule(TMVBN), getTerm(TMVBN)) '\n
            '\b 'result '\o '\s eMetaPrettyPrint(getType(RP))
            '\s '\b ': '\o '\n '\s '\s
            eMetaPrettyPrint(getModule(TMVBN), getTerm(RP)) '\n)
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi
    if TMVBN := solveBubblesFrew(T, M,
                 included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
                 D, I, VDS, DB)
       /\ RP   := metaFrewrite(getModule(TMVBN), getTerm(TMVBN),
                               getBound(TMVBN),  getNat(TMVBN)) .
  eq procFrew(ME, unitError(QIL), T, D, I, VDS, DB) = qidError(QIL) .

  eq solveBubblesFrew('bubble[QI], M, B, D, I, VDS, DB)
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble[QI], M, B, VDS, DB), M, VDS, unbounded, I}
      else tupleTMOBNerror(
             '\r 'Error: '\o 'no 'parse 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesFrew('bubble['__[TL]], M, B, D, I, VDS, DB)
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble['__[TL]], M, B, VDS, DB),
              M, VDS, unbounded, I}
      else if metaParse(GRAMMAR-FREW, downQidList('__[TL, ''..Qid]),
                '@FrewNuPart@)
                :: ResultPair
           then solveBubblesFrew2(
                  getTerm(
                    metaParse(GRAMMAR-FREW, downQidList('__[TL, ''..Qid]),
                      '@FrewNuPart@)),
                  M, B, I, VDS, DB)
           else {getTerm(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 getModule(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 getVars(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 unbounded, I}
           fi
      fi .
  *** There is some problem parsing _ in solveBubblesRed, but it
  *** seems to work with the additional '.

  eq solveBubblesFrew2('`[_`]_.['token[T], T'], M, B, I, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRed(T', M, B, VDS, DB)
                    :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then {getTerm(solveBubblesRed(T', M, B, VDS, DB)),
            getModule(solveBubblesRed(T', M, B, VDS, DB)),
            getVars(solveBubblesRed(T', M, B, VDS, DB)),
            downNat(downMetaNat(T)),
            I}
      else tupleTMOBNerror(
             '\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .
  eq solveBubblesFrew2('`[_`,_`]_.['token[T], 'token[T'], T''],
       M, B, I, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then downNat(downMetaNat(T')) :: Nat
         and-then solveBubblesRed(T'', M, B, VDS, DB)
                    :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then {getTerm(solveBubblesRed(T'', M, B, VDS, DB)),
            getModule(solveBubblesRed(T'', M, B, VDS, DB)),
            getVars(solveBubblesRed(T'', M, B, VDS, DB)),
            downNat(downMetaNat(T)),
            downNat(downMetaNat(T'))}
      else tupleTMOBNerror('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  op GRAMMAR-FREW : -> FModule [memo] .
  eq GRAMMAR-FREW
    = addSorts('@FrewNuPart@ ; '@Token@ ; '@SortToken@ ; '@ViewToken@ ; '@NeTokenList@ ; '@Bubble@,
        addOps(
          (op '`[_`]_. : '@Token@ '@Bubble@ -> '@FrewNuPart@ [none] .
           op '`[_`,_`]_. : '@Token@ '@Token@ '@Bubble@ -> '@FrewNuPart@ [none] .),
          BUBBLES)) .

  eq metaFrewrite(fmod QI is IL sorts SS . SSDS OPDS MAS EqS endfm, T, D, I)
    = metaReduce(fmod QI is IL sorts SS . SSDS OPDS MAS EqS endfm, T) .
  eq metaFrewrite(M, T, 0, I) = {T, leastSort(M, T)} .
  eq metaFrewrite(M, T, D, 0) = {T, leastSort(M, T)} .

  *** SEARCH

  op GRAMMAR-SEARCH : -> FModule [memo] .
  eq GRAMMAR-SEARCH
    = addSorts('@SearchNuPart@ ; '@Token@ ; '@SortToken@ ; '@ViewToken@ ; '@NeTokenList@ ; '@Bubble@,
        addOps((op '`[_`,_`]_. : '@Token@ '@Token@ '@Bubble@ -> '@SearchNuPart@ [none] .)
               (op '`[`,_`]_. : '@Token@ '@Bubble@ -> '@SearchNuPart@ [none] .),
          BUBBLES)) .

  ceq procSearch(ME, M, T, T', QI, D, D', VDS, DB)
    *** D is a bound on the number of solutions, and D' is a bound on the depth of the search
    = if solveBubblesRl(T, T', M, B, VDS, DB) :: Term
      then procSearch2(addOps(VDS, M),
             lhs(solveBubblesRl(T, T', M, B, VDS, DB)),
             rhs(solveBubblesRl(T, T', M, B, VDS, DB)), nil, QI, D, D')
      else solveBubblesSearchL(M, T, T', QI, D, D', B, VDS, DB)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  eq solveBubblesSearchL(M, 'bubble[QI], T, QI', D, D', B, VDS, DB)
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then solveBubblesSearchR(M, solveBubbles('bubble[QI], M, B, VDS, DB), T, QI', D, D', B, VDS, DB)
      else ('\r 'Error: '\o 'no 'parsing 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesSearchL(M, 'bubble['__[TL]], T, QI, D, D', B, VDS, DB)
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then solveBubblesSearchR(M, solveBubbles('bubble['__[TL]], M, B, VDS, DB), T, QI, D, D', B, VDS, DB)
      else if metaParse(GRAMMAR-SEARCH, downQidList('__[TL, ''..Qid]), '@SearchNuPart@) :: ResultPair
           then solveBubblesSearchL1(
                  M,
                  getTerm(metaParse(GRAMMAR-SEARCH, downQidList('__[TL, ''..Qid]), '@SearchNuPart@)),
                  T, QI, D, D', B, VDS, DB)
           else solveBubblesSearchR(
                  getModule(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getTerm(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  T,
                  QI,
                  getBound(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  D',
                  getBool(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getVars(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getDatabase(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)))
           fi
      fi .

  eq solveBubblesSearchL1(M, '`[`,_`]_.['token[T], T'], T'', QI, D, D', B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRed(T', M, B, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then solveBubblesSearchR(
             getModule(solveBubblesRed(T', M, B, VDS, DB)),
             getTerm(solveBubblesRed(T', M, B, VDS, DB)),
             T'', QI, D,
             downNat(downMetaNat(T)),
             B,
             getVars(solveBubblesRed(T', M, B, VDS, DB)),
             DB)
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .
  eq solveBubblesSearchL1(M, '`[_`,_`]_.['token[T], 'token[T'], T''], T''', QI, D, D', B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then downNat(downMetaNat(T')) :: Nat
         and-then solveBubblesRed(T'', M, B, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then solveBubblesSearchR(
             getModule(solveBubblesRed(T'', M, B, VDS, DB)),
             getTerm(solveBubblesRed(T'', M, B, VDS, DB)),
             T''', QI,
             downNat(downMetaNat(T)),
             downNat(downMetaNat(T')),
             B,
             getVars(solveBubblesRed(T'', M, B, VDS, DB)),
             DB)
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  eq solveBubblesSearchR(M, T, T', QI, D, D', B, VDS, DB)
    = solveBubblesSearchR1(
        M,
        addOps(
          op '_s.t._. : leastSort(M, T) '@Condition@ -> 'PatternCondition [none] .
          op '_such`that_. : leastSort(M, T) '@Condition@ -> 'PatternCondition [none] .,
          addSorts('PatternCondition, addInfoConds(M))),
        T,
        T',
        QI,
        D,
        D',
        B,
        VDS,
        DB) .
  eq solveBubblesSearchR(M:[Module], T:[Term], T':[Term], QI:[Qid], D:[Bound], D':[Bound], B:[Bool], VDS:[OpDeclSet], DB:[Database])
    = ('\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n) .

  ceq solveBubblesSearchR1(M, M', T, 'bubble[QI], QI', D, D', B, VDS, DB)
    = if T?:[Term] :: Term
      then procSearch2(M, T, T?:[Term], nil, QI', D, D')
      else ('\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n)
      fi
    if T?:[Term] := solveBubbles('bubble[QI], M, B, VDS, DB) .
  ceq solveBubblesSearchR1(M, M', T, 'bubble['__[TL]], QI, D, D', B, VDS, DB)
    = if T?:[Term] :: Term
      then procSearch2(M, T, T?:[Term], nil, QI, D, D')
      else if metaParse(M', downQidList('__[TL, ''..Qid]), 'PatternCondition)
                :: ResultPair
           then solveBubblesSearchR2(M, T,
                  getTerm(
                    metaParse(M', downQidList('__[TL, ''..Qid]),
                      'PatternCondition)),
                  QI, D, D', VDS)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n
           fi
      fi
    if T?:[Term] := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .

  eq solveBubblesSearchR2(M, T, QI, QI', D, D', VDS)
    = procSearch2(M, T, constsToVars(QI, VDS), nil, QI', D, D') .
  eq solveBubblesSearchR2(M, T, F[T], QI, D, D', VDS)
    = procSearch2(M, T, constsToVars(F[T], VDS), nil, QI, D, D') .
  eq solveBubblesSearchR2(M, T, F[T', T''], QI, D, D', VDS)
    = if F == '_s.t._. or F == '_such`that_.
      then procSearch2(M, T, T', parseCond(T'', VDS), QI, D, D')
      else procSearch2(M, T, constsToVars(F[T', T''], VDS), nil, QI, D, D')
      fi .
  eq solveBubblesSearchR2(M, T, F[T', T'', TL], QI, D, D', VDS)
    = procSearch2(M, T, constsToVars(F[T', T'', TL], VDS), nil, QI, D, D') .

  ceq procSearch2(M, T, T', CD, QI, D, D')
    = if RT :: ResultTriple
      then ('search
            if D == unbounded and D' == unbounded
            then nil
            else '\s '`[
                 if D == unbounded
                 then nil
                 else qid(string(D, 10))
                 fi
                 if D' == unbounded
                 then nil
                 else '`, qid(string(D', 10))
                 fi
                 '`] '\s
            fi
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T) '\s qid("=>" + string(QI)) '\s
            eMetaPrettyPrint(M, T'') '. '\n '\n
            'Solution '1 '\n
            if gTSubstitution(RT) == none
            then 'empty 'substitution '\n '\n
            else eMetaPrettyPrint(M, gTSubstitution(RT)) '\n '\n
            fi
            procSearch3(M, T, T'', CD, QI, D, 1, D'))
      else if RT == failure
           then ('search
           if D == unbounded and D' == unbounded
            then nil
            else '\s '`[
                 if D == unbounded
                 then nil
                 else qid(string(D, 10))
                 fi
                 if D' == unbounded
                 then nil
                 else '`, qid(string(D', 10))
                 fi
                 '`] '\s
            fi
            'in eMetaPrettyPrint(getName(M)) ':
                 eMetaPrettyPrint(M, T)
                 '\s qid("=>" + string(QI)) '\s
                 eMetaPrettyPrint(M, T'') '. '\n '\n
                'No 'solution. '\n)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n
           fi
      fi
    if T'' := prepSearchPattern(T')
       /\ RT := metaSearch(M, T, T'', CD, QI, D', 0) .


  eq procSearch3(M, T, T', CD, QI, D, I, D')
    = if D == unbounded or-else (D == 0 or-else I < D)
      then if metaSearch(M, T, T', CD, QI, D', I) :: ResultTriple
           then ('Solution qid(string(I + 1, 10)) '\n
                 if gTSubstitution(metaSearch(M, T, T', CD, QI, D', I)) == none
                 then 'empty 'substitution '\n '\n
                 else eMetaPrettyPrint(M,
                            gTSubstitution(
                              metaSearch(M, T, T', CD, QI, D', I))) '\n '\n
                 fi
                 procSearch3(M, T, T', CD, QI, D, I + 1, D'))
           else ('No 'more 'solutions. '\n)
           fi
      else nil
      fi .

-------------------
*** Equal to procSearch except replacing metaSearch by metaNarrowSearch

  ceq procNarrowSearch(ME, M, T, T', QI, D, D', VDS, DB)
    *** D is a bound on the number of solutions, and D' is a bound on the depth of the search
    = if solveBubblesRl(T, T', M, B, VDS, DB) :: Term
      then procNarrowSearch2(addOps(VDS, M),
             lhs(solveBubblesRl(T, T', M, B, VDS, DB)),
             rhs(solveBubblesRl(T, T', M, B, VDS, DB)), nil, QI, D, D')
      else solveBubblesNarrowSearchL(M, T, T', QI, D, D', B, VDS, DB)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  eq solveBubblesNarrowSearchL(M, 'bubble[QI], T, QI, D, D', B, VDS, DB)
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then solveBubblesNarrowSearchR(M, solveBubbles('bubble[QI], M, B, VDS, DB), T, QI, D, D', B, VDS, DB)
      else ('\r 'Error: '\o 'no 'parsing 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesNarrowSearchL(M, 'bubble['__[TL]], T, QI, D, D', B, VDS, DB)
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then solveBubblesNarrowSearchR(M, solveBubbles('bubble['__[TL]], M, B, VDS, DB), T, QI, D, D', B, VDS, DB)
      else if metaParse(GRAMMAR-SEARCH, downQidList('__[TL, ''..Qid]), '@SearchNuPart@) :: ResultPair
           then solveBubblesNarrowSearchL1(
                  M,
                  getTerm(
                    metaParse(GRAMMAR-SEARCH, downQidList('__[TL, ''..Qid]),
                      '@SearchNuPart@)),
                  T, QI, D, D', B, VDS, DB)
           else solveBubblesNarrowSearchR(
                  getModule(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getTerm(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  T,
                  QI,
                  getBound(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  D',
                  getBool(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getVars(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getDatabase(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)))
           fi
      fi .

  eq solveBubblesNarrowSearchL1(M, '`[`,_`]_.['token[T], T'], T'', QI, D, D', B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRed(T', M, B, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then solveBubblesNarrowSearchR(
             getModule(solveBubblesRed(T', M, B, VDS, DB)),
             getTerm(solveBubblesRed(T', M, B, VDS, DB)),
             T'', QI, D,
             downNat(downMetaNat(T)),
             B,
             getVars(solveBubblesRed(T', M, B, VDS, DB)),
             DB)
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .
  eq solveBubblesNarrowSearchL1(M, '`[_`,_`]_.['token[T], 'token[T'], T''], T''', QI, D, D', B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then downNat(downMetaNat(T')) :: Nat
         and-then solveBubblesRed(T'', M, B, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then solveBubblesNarrowSearchR(
             getModule(solveBubblesRed(T'', M, B, VDS, DB)),
             getTerm(solveBubblesRed(T'', M, B, VDS, DB)),
             T''', QI,
             downNat(downMetaNat(T)),
             downNat(downMetaNat(T')),
             B,
             getVars(solveBubblesRed(T'', M, B, VDS, DB)),
             DB)
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  eq solveBubblesNarrowSearchR(M, T, T', QI, D, D', B, VDS, DB)
    = solveBubblesNarrowSearchR1(
        M,
        addOps(
          op '_s.t._. : leastSort(M, T) '@Condition@ -> 'PatternCondition [none] .
          op '_such`that_. : leastSort(M, T) '@Condition@ -> 'PatternCondition [none] .,
          addSorts('PatternCondition, addInfoConds(M))),
        T,
        T',
        QI,
        D,
        D',
        B,
        VDS,
        DB) .
  eq solveBubblesNarrowSearchR(M:[Module], T:[Term], T':[Term], QI:[Qid], D:[Bound], D':[Bound], B:[Bool], VDS:[OpDeclSet], DB:[Database])
    = qidError('\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n) .

  ceq solveBubblesNarrowSearchR1(M, M', T, 'bubble[QI], QI', D, D', B, VDS, DB)
    = if T?:[Term] :: Term
      then procNarrowSearch2(M, T, T?:[Term], nil, QI', D, D')
      else ('\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n)
      fi
    if T?:[Term] := solveBubbles('bubble[QI], M, B, VDS, DB) .
  ceq solveBubblesNarrowSearchR1(M, M', T, 'bubble['__[TL]], QI, D, D', B, VDS, DB)
    = if T?:[Term] :: Term
      then procNarrowSearch2(M, T, T?:[Term], nil, QI, D, D')
      else if metaParse(M', downQidList('__[TL, ''..Qid]), 'PatternCondition)
                :: ResultPair
           then solveBubblesNarrowSearchR2(M, T,
                  getTerm(
                    metaParse(M', downQidList('__[TL, ''..Qid]),
                      'PatternCondition)),
                  QI, D, D', VDS)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n
           fi
      fi
    if T?:[Term] := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .

  eq solveBubblesNarrowSearchR2(M, T, QI, QI', D, I, VDS)
    = procNarrowSearch2(M, T, constsToVars(QI, VDS), nil, QI', D, I) .
  eq solveBubblesNarrowSearchR2(M, T, F[T], QI, D, I, VDS)
    = procNarrowSearch2(M, T, constsToVars(F[T], VDS), nil, QI, D, I) .
  eq solveBubblesNarrowSearchR2(M, T, F[T', T''], QI, D, I, VDS)
    = if F == '_s.t._. or F == '_such`that_.
      then procNarrowSearch2(M, T, T', parseCond(T'', VDS), QI, D, I)
      else procNarrowSearch2(M, T, constsToVars(F[T', T''], VDS), nil, QI, D, I)
      fi .
  eq solveBubblesNarrowSearchR2(M, T, F[T', T'', TL], QI, D, I, VDS)
    = procNarrowSearch2(M, T, constsToVars(F[T', T'', TL], VDS), nil, QI, D, I) .

  op axCohComplete : SModule -> SModule .       ---- Defined later in module AX-COHERENCE-COMPLETION

  sort IdsToRemove .                             ---- moved from VARIANTS
  ops all non-handled : -> IdsToRemove .         ---- moved from VARIANTS
  op removeIds : Module IdsToRemove ~> Module .  ---- moved from VARIANTS

  ceq procNarrowSearch2(M, T, T', CD, QI, D, D')
    = if RTS:[ResultTripleSet] :: ResultTripleSet
      then ('search
            if D == unbounded and D' == unbounded
            then nil
            else '\s '`[
                 if D == unbounded
                 then nil
                 else qid(string(D, 10))
                 fi
                 if D' == unbounded
                 then nil
                 else '`, qid(string(D', 10))
                 fi
                 '`] '\s
            fi
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T) '\s qid("~>" + string(QI)) '\s
            eMetaPrettyPrint(M, T'') '.
            procNarrowSearch3(M, 0, Vars((T,T')), RTS:[ResultTripleSet])
            if D =/= unbounded and-then D' == unbounded and-then | RTS:[ResultTripleSet] | < D
            then procNarrowSearch2RT(M, T, T', CD, QI, D, D',RTS:[ResultTripleSet],1)
            else nil
            fi
            ('\n '\n 'No 'more 'solutions. '\n))
      else if RTS:[ResultTripleSet] == empty
           then ('search
           if D == unbounded and D' == unbounded
            then nil
            else '\s '`[
                 if D == unbounded
                 then nil
                 else qid(string(D, 10))
                 fi
                 if D' == unbounded
                 then nil
                 else '`, qid(string(D', 10))
                 fi
                 '`] '\s
            fi
            'in eMetaPrettyPrint(getName(M)) ':
                 eMetaPrettyPrint(M, T)
                 '\s qid("~>" + string(QI)) '\s
                 eMetaPrettyPrint(M, T'') '. '\n '\n
                 'No 'solution. '\n)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n
           fi
      fi
    if T'' := prepSearchPattern(T')
       /\ RTS:[ResultTripleSet]
          := upDown(M,
              metaNarrowSearchGen(
                 removeIds(axCohComplete(M), non-handled),
                 T,
                 T'',
                 none,
                 typeOfRelation(QI),
                 D',
                 D,
                 unbounded,
                 full E-ACU-unify noStrategy E-normalize-terms)
              |> (T,T'')
             ) .

  var RTS' : ResultTripleSet .

  op procNarrowSearch2RT : Module Term Term Condition Qid Bound Bound ResultTripleSet Nat -> QidList .
  ceq procNarrowSearch2RT(M, T, T', CD, QI, D, D',RTS',J)
    = nil
   if | RTS' | == D .
  ceq procNarrowSearch2RT(M, T, T', CD, QI, D, D',RTS',J)
    = if RTS:[ResultTripleSet] :: ResultTripleSet
      then (procNarrowSearch3(M, | RTS' |, Vars((T,T')), RTS:[ResultTripleSet])
            procNarrowSearch2RT(M, T, T', CD, QI, D, D',RTS' | RTS:[ResultTripleSet],J + 1) )
      else nil
      fi
    if | RTS' | < D
       /\ T'' := prepSearchPattern(T')
       /\ (RTS' | RTS:[ResultTripleSet])
          := upDown(M,
              metaNarrowSearchGen(
                 removeIds(axCohComplete(M), non-handled),
                 T,
                 T'',
                 none,
                 typeOfRelation(QI),
                 D',
                 D + J,
                 unbounded,
                 full E-ACU-unify noStrategy E-normalize-terms)
              |> (T,T'')
             ) .

  eq procNarrowSearch3(M, I, TL:TermList, empty)
   = nil .
  eq procNarrowSearch3(M, I, TL:TermList, {T:Term,TP:Type,S:Substitution} | RTS:ResultTripleSet)
    = ('\n '\n 'Solution qid(string(I + 1, 10))
       if (S:Substitution |> TL:TermList) == none
       then '\n 'empty 'substitution
       else '\n eMetaPrettyPrint(M, S:Substitution |> TL:TermList)
       fi
       procNarrowSearch3(M, I + 1, TL:TermList, RTS:ResultTripleSet)) .

-------------------

  sort Tuple{TermList, Nat} .
  op <_;_> : Term Nat -> Tuple{TermList, Nat} .
  op term : Tuple{TermList, Nat} -> TermList .
  op index : Tuple{TermList, Nat} -> Nat .
  eq term(< TL:[TermList] ; I:[Nat] >) = TL:[TermList] .
  eq index(< TL:[TermList] ; I:[Nat] >) = I:[Nat] .

  op prepSearchPattern : Term -> Term .
  op prepSearchPattern : TermList Nat -> Tuple{TermList, Nat} .

  eq prepSearchPattern(T) = term(prepSearchPattern(T, 0)) .

  eq prepSearchPattern('<_:_|_>[O, Ct, T], I)
    = < '<_:_|_>[O, qid("V#" + string(I, 10) + ":" + string(getName(Ct))),
           '_`,_[term(prepSearchPattern(T, s s I)),
                 qid("V#" + string(s I, 10) + ":AttributeSet")]] ;
        index(prepSearchPattern(T, s s I)) > .
  eq prepSearchPattern('<_:_|`>[O, Ct], I)
    = < '<_:_|_>[O, qid("V#" + string(I, 10) + ":" + string(getName(Ct))),
           qid("V#" + string(s I, 10) + ".AttributeSet")] ;
        s I > .
  eq prepSearchPattern(F[TL], I)
    = < F[term(prepSearchPattern(TL, I))] ;
        index(prepSearchPattern(TL, I)) >
    [owise] .

  eq prepSearchPattern(F, I) = < F ; I > .
  eq prepSearchPattern(Ct, I) = < Ct ; I > .

  ceq prepSearchPattern((T, TL), I)
    = < (term(prepSearchPattern(T, I)),
         term(prepSearchPattern(TL, index(prepSearchPattern(T, I))))) ;
        index(prepSearchPattern(TL, index(prepSearchPattern(T, I)))) >
    if TL =/= empty .

  *** MATCH

  ceq procMatch(ME, M, T, T', QI, I, VDS, DB)
    *** the number I in search is not a bound, but the number of solutions
    = if solveBubblesRl(T, T', M, B, VDS, DB) :: Term
      then procMatch2(addOps(VDS, M),
             lhs(solveBubblesRl(T, T', M, B, VDS, DB)),
             rhs(solveBubblesRl(T, T', M, B, VDS, DB)), nil, QI, I)
      else if solveBubblesRew(T, M, B, I, VDS, DB)
                :: Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}
           then solveBubblesMatch(
                  getModule(solveBubblesRew(T, M, B, I, VDS, DB)),
                  addOps(
                    op '_s.t._. :
                       leastSort(
                         getModule(solveBubblesRew(T, M, B, I, VDS, DB)),
                         getTerm(solveBubblesRew(T, M, B, I, VDS, DB)))
                       '@Condition@ -> 'PatternCondition [none] .
                    op '_such`that_. :
                       leastSort(
                         getModule(solveBubblesRew(T, M, B, I, VDS, DB)),
                         getTerm(solveBubblesRew(T, M, B, I, VDS, DB)))
                       '@Condition@ -> 'PatternCondition [none] .,
                    addSorts('PatternCondition,
                      addInfoConds(
                        getModule(solveBubblesRew(T, M, B, I, VDS, DB))))),
                  getTerm(solveBubblesRew(T, M, B, I, VDS, DB)),
                  T',
                  QI,
                  (if getBound(solveBubblesRew(T, M, B, I, VDS, DB))
                         == unbounded
                   then 0
                   else getBound(solveBubblesRew(T, M, B, I, VDS, DB))
                   fi),
                  B,
                  getVars(solveBubblesRew(T, M, B, I, VDS, DB)),
                  DB)
           else getMsg(getTerm(solveBubblesRew(T, M, B, I, VDS, DB)))
                ----('\r 'Error: '\o 'Incorrect 'match 'command. '\n)
           fi
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  ceq solveBubblesMatch(M, M', T, 'bubble[QI], QI', I, B, VDS, DB)
    = if T?:[Term] :: Term
      then procMatch2(M, T, T?:[Term], nil, QI', I)
      else ('\r 'Error: '\o 'Incorrect 'use 'of 'the 'match 'command. '\n)
      fi
    if T?:[Term] := solveBubbles('bubble[QI], M, B, VDS, DB) .
  ceq solveBubblesMatch(M, M', T, 'bubble['__[TL]], QI, I, B, VDS, DB)
    = if T?:[Term] :: Term
      then procMatch2(M, T, T?:[Term], nil, QI, I)
      else if metaParse(M', downQidList('__[TL, ''..Qid]), 'PatternCondition)
                :: ResultPair
           then solveBubblesMatch2(M, T,
                  getTerm(
                    metaParse(M', downQidList('__[TL, ''..Qid]),
                      'PatternCondition)),
                  QI, I, VDS)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'match 'command. '\n
           fi
      fi
    if T?:[Term] := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .

  eq solveBubblesMatch2(M, T, QI, QI', I, VDS)
    = procMatch2(M, T, constsToVars(QI, VDS), nil, QI', I) .
  eq solveBubblesMatch2(M, T, F[T], QI, I, VDS)
    = procMatch2(M, T, constsToVars(F[T], VDS), nil, QI, I) .
  eq solveBubblesMatch2(M, T, F[T', T''], QI, I, VDS)
    = if F == '_s.t._. or F == '_such`that_.
      then procMatch2(M, T, T', parseCond(T'', VDS), QI, I)
      else procMatch2(M, T, constsToVars(F[T', T''], VDS), nil, QI, I)
      fi .
  eq solveBubblesMatch2(M, T, F[T', T'', TL], QI, I, VDS)
    = procMatch2(M, T, constsToVars(F[T', T'', TL], VDS), nil, QI, I) .

  ceq procMatch2(M, T, T', CD, 'match, I)
    = if Sb? :: Substitution
      then ('match
            if I == 0 then nil else '\s '`[ qid(string(I, 10)) '`] '\s fi
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T) '\s '<=? '\s eMetaPrettyPrint(M, T') '. '\n '\n
            'Solution '1 '\n
            if Sb? == none
            then 'empty 'substitution
            else eMetaPrettyPrint(M, Sb?)
            fi
            procMatch3(M, T, T', CD, 'match, I, 1))
      else if Sb? == noMatch
           then ('match
                 if I == 0
                 then nil
                 else '\s '`[ qid(string(I, 10)) '`] '\s
                 fi
                 'in eMetaPrettyPrint(getName(M)) ':
                       eMetaPrettyPrint(M, T) '\s '<=? '\s
                       eMetaPrettyPrint(M, T') '. '\n '\n
                       'No 'solution. '\n)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'match 'command. '\n
           fi
      fi
    if Sb? := metaMatch(M, T, T', CD, 0) .
  ceq procMatch2(M, T, T', CD, 'xmatch, I)
    = if MP? :: MatchPair
      then ('xmatch
            if I == 0 then nil else '\s '`[ qid(string(I, 10)) '`] '\s fi
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T) '\s '<=? '\s eMetaPrettyPrint(M, T') '. '\n '\n
            'Solution '1 '\n
            if gTSubstitution(MP?) == none
            then 'empty 'substitution
            else eMetaPrettyPrint(M, gTSubstitution(MP?))
            fi '\n '\n
            procMatch3(M, T, T', CD, 'xmatch, I, 1))
      else if MP? == noMatch
           then ('xmatch
                 if I == 0
                 then nil
                 else '\s '`[ qid(string(I, 10)) '`] '\s
                 fi
                 'in eMetaPrettyPrint(getName(M)) ':
                      eMetaPrettyPrint(M, T) '\s '<=? '\s
                      eMetaPrettyPrint(M, T') '. '\n '\n
                      'No 'solution. '\n)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'xmatch 'command. '\n
           fi
      fi
    if MP? := metaXmatch(M, T, T', CD, 0, unbounded, 0) .

  eq procMatch3(M, T, T', CD, 'match, I, J)
    = if I == 0 or J < I
      then if metaMatch(M, T, T', CD, J) :: Substitution
           then ('Solution qid(string(J + 1, 10)) '\n
                 if metaMatch(M, T, T', CD, J) == none
                 then 'empty 'substitution
                 else eMetaPrettyPrint(M, metaMatch(M, T, T', CD, J))
                 fi '\n '\n
                 procMatch3(M, T, T', CD, 'match, I, J + 1))
           else ('No 'more 'solutions. '\n)
           fi
      else nil
      fi .
  eq procMatch3(M, T, T', CD, 'xmatch, I, J)
    = if I == 0 or J < I
      then if metaXmatch(M, T, T', CD, 0, unbounded, J) :: MatchPair
           then ('Solution qid(string(J + 1, 10)) '\n
                 if gTSubstitution(metaXmatch(M, T, T', CD, 0, unbounded, J))
                      == none
                 then 'empty 'substitution
                 else eMetaPrettyPrint(M,
                            gTSubstitution(
                               metaXmatch(M, T, T', CD, 0, unbounded, J)))
                 fi '\n '\n
                 procMatch3(M, T, T', CD, 'xmatch, I, J + 1))
           else ('No 'more 'solutions. '\n)
           fi
      else nil
      fi .

  *** UNIFY

  ceq procUnify(ME, M, T, D, VDS, DB)
    *** D is a bound on the number of solutions
    = if solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)
           :: Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}
      then procUnify2(
             getModule(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
             parseUnify(
               getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
               getVars(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))),
             getBound(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
      else getMsg(getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
                ----('\r 'Error: '\o 'Incorrect 'match 'command. '\n)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  eq addInfoUnify(M)
    = addOps(op '_/\_ : '@UnificationProblem@ '@UnificationProblem@ -> '@UnificationProblem@
                               [ctor assoc prec(73)] .
             op '_=?_  : 'Universal 'Universal -> '@UnificationProblem@
                               [ctor poly(1 2) prec(71)] .,
        addSorts('@UnificationProblem@, M)) .

  eq parseUnify('_/\_[T, T'], VDS) = parseUnify(T, VDS) /\ parseUnify(T', VDS) .
  eq parseUnify('_=?_[T, T'], VDS) = constsToVars(T, VDS) =? constsToVars(T', VDS) .

  ceq procUnify2(M, UP, D)
    = if UP? :: UnificationPair?
      then ('unify
            if D == unbounded then nil else '\s '`[ qid(string(D, 10)) '`] '\s fi
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, UP) '\n '\n
            if UP? == noUnifier
            then 'No 'unifier
            else procUnify3Aux(M, UP?, 0) '\n '\n
                 procUnify3(M, UP, D, 1)
            fi)
      else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'unify 'command. '\n
      fi
    if UP? := metaUnify(M, UP, 0, 0) .
  eq procUnify2(M?, UP??:[UnificationProblem], D?) = getMsg(M?) [owise] .

  eq eMetaPrettyPrint(M, T =? T')
    = eMetaPrettyPrint(M, T) '\s '=? '\s eMetaPrettyPrint(M, T') '. .
  eq eMetaPrettyPrint(M, T =? T' /\ UP)
    = eMetaPrettyPrint(M, T =? T') '\s '/\ '\s eMetaPrettyPrint(M, UP) '. .

  eq procUnify3Aux(M, {Sb, N}, I)
    = 'Solution qid(string(I + 1, 10)) '\n
      if Sb == none
      then 'empty 'substitution '\n '\n
      else eMetaPrettyPrint(M, Sb) '\n '\n
      fi .

  eq procUnify3(M, UP, D, I)
    = if D == unbounded or-else I < D
      then if metaUnify(M, UP, 0, I) :: UnificationPair
           then (procUnify3Aux(M, metaUnify(M, UP, 0, I), I)
                 procUnify3(M, UP, D, I + 1))
           else ('No 'more 'solutions. '\n)
           fi
      else nil
      fi .

  ceq solveBubblesUnify(M, 'bubble[T], VDS)
    = if metaParse(M, QIL, '@UnificationProblem@) :: ResultPair
      then parseUnify(getTerm(metaParse(M, QIL, '@UnificationProblem@)), VDS)
      else unificationProblemError('\r 'Warning: '\o
             printSyntaxError(metaParse(M, QIL, '@UnificationProblem@), QIL) '\n)
      fi
    if QIL := downQidList(T) .

  eq solveBubblesRewUnify('bubble[QI], M, B, D, VDS, DB)
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble[QI], M, B, VDS, DB), M, B, VDS, unbounded, DB}
      else tupleTMBOBDerror(
             '\r 'Error: '\o 'no 'parsing 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesRewUnify('bubble['__[TL]], M, B, D, VDS, DB)
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble['__[TL]], M, B, VDS, DB), M, B, VDS, unbounded, DB}
      else if metaParse(GRAMMAR-REW, downQidList('__[TL, ''..Qid]), '@RewNuPart@)
                :: ResultPair
           then solveBubblesRewUnify2(
                  getTerm(
                    metaParse(GRAMMAR-REW, downQidList('__[TL, ''..Qid]),
                      '@RewNuPart@)),
                  M, B, VDS, DB)
           else {getTerm(solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB)),
                 getModule(solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB)),
                 getBool(solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB)),
                 getVars(solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB)),
                 unbounded,
                 getDatabase(solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB))}
           fi
      fi .

  eq solveBubblesRewUnify2('`[_`]_.['token[T], T'], M, B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRedUnify(T', M, B, VDS, DB)
                    :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then {getTerm(solveBubblesRedUnify(T', M, B, VDS, DB)),
            getModule(solveBubblesRedUnify(T', M, B, VDS, DB)),
            getBool(solveBubblesRedUnify(T', M, B, VDS, DB)),
            getVars(solveBubblesRedUnify(T', M, B, VDS, DB)),
            downNat(downMetaNat(T)),
            getDatabase(solveBubblesRedUnify(T', M, B, VDS, DB))}
      else tupleTMBOBDerror('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  ceq solveBubblesRedUnify('bubble[QI], M, B, VDS, DB)
    = if T? :: Term
      then {T?, M, B, VDS, DB}
      else tupleTMBODerror('\r 'Error: '\o 'no 'parse 'for downQidList(QI) '\n)
      fi
    if T? := solveBubbles('bubble[QI], M, B, VDS, DB) .
  ceq solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB)
    = if T? :: Term
      then {T?, M, B, VDS, DB}
      else if metaParse(GRAMMAR-RED,
                downQidList('__[TL, ''..Qid]), '@RedInPart@)
                :: ResultPair
           then solveBubblesRedUnify2(
                  getTerm(
                    metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]), '@RedInPart@)),
                  DB)
           else tupleTMBODerror('\r 'Warning: '\o
                      printSyntaxError(
                        metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]),
                        '@RedInPart@), downQidList('__[TL, ''..Qid])) '\n
                      '\r 'Error: '\o
                      'no 'parse 'for downQidList('__[TL, ''..Qid]) '\n)
           fi
      fi
    if T? := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .
  *** There is some problem parsing 'in_:_ in solveBubblesRed, but it
  *** seems to work with the additional '.

  ceq solveBubblesRedUnify2('in_:_.[T, T'], DB)
    = if unitInDb(ME, DB')
      then solveBubblesRed3(T', addInfoUnify(getFlatModule(ME, DB')), ME, getVars(ME, DB'), DB')
      else tupleTMBODerror('\r 'Error: '\o 'The 'module eMetaPrettyPrint(ME) 'is 'not 'in 'the 'database '. '\n)
      fi
    if < DB' ; ME > := evalModExp(parseModExp(T), DB) .
  eq solveBubblesRedUnify2('in_:_.[T, T'], DB)
    = tupleTMBODerror('\r 'Error: '\o 'It 'isn't 'possible 'to 'compile eMetaPrettyPrint(parseModExp(T)) '. '\n)
    [owise] .

  *** ID-UNIFY

  ceq procIdUnify(ME, M, T, D, VDS, DB)
    *** D is a bound on the number of solutions
    = if solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}
      then procIdUnify2(
             getModule(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
             parseUnify(
               getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
               getVars(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))),
             getBound(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
      else getMsg(getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
                ----('\r 'Error: '\o 'Incorrect 'id-unify 'command. '\n)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  ceq procIdUnify2(M, T =? T', D)
    = if X:[SubstitutionSet] :: SubstitutionSet
      then ('id-unify
            if D == unbounded then nil else '\s '`[ qid(string(D, 10)) '`] '\s fi
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T =? T')
            if X:[SubstitutionSet] == empty
            then '\n 'No 'unifier
            else procIdUnify3(M, T =? T', 0, X:[SubstitutionSet])
            fi)
      else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'id-unify 'command. '\n
      fi
    if X:[SubstitutionSet] := metaACUUnify(M, T, T') .
  eq procIdUnify2(M?, UP??:[UnificationProblem], D?) = getMsg(M?) [owise] .

  eq procIdUnify3(M, UP, I, empty)
   = ('\n '\n 'No 'more 'solutions. '\n) .
  eq procIdUnify3(M, UP, I, S:Substitution | SS:SubstitutionSet)
   = '\n '\n 'Solution qid(string(I + 1, 10))
      if S:Substitution == none
      then '\n 'empty 'substitution
      else '\n eMetaPrettyPrint(M, S:Substitution)
      fi
     procIdUnify3(M, UP, I + 1, SS:SubstitutionSet) .

  *** VARIANT-UNIFY

  ceq procVariantUnify(ME, M, T, D, VDS, DB)
    *** D is a bound on the number of solutions
    = if solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}
      then procVariantUnify2(
             getModule(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
             parseUnify(
               getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
               getVars(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))),
             getBound(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
      else getMsg(getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
                ----('\r 'Error: '\o 'Incorrect 'variant 'unify 'command. '\n)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  ceq procVariantUnify2(M, T =? T', D)
    = if X:[SubstitutionSet] :: SubstitutionSet
      then ('variant 'unify
            if D == unbounded then nil else '\s '`[ qid(string(D, 10)) '`] '\s fi
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T =? T')
            if X:[SubstitutionSet] == empty
            then '\n 'No 'variant 'unifier
            else procVariantUnify3(M, T =? T', 0, X:[SubstitutionSet])
            fi)
      else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'variant 'unify 'command. '\n
      fi
    if X:[SubstitutionSet]
       := toSubstitution(
            metaVariantUnify(
               removeIds(axCohComplete(M), non-handled),
               T,
               T',
               highestVar((T,T')) + 1,
               minimal-unifiers reducible
            )
          ) .
  eq procVariantUnify2(M?, UP??:[UnificationProblem], D?) = getMsg(M?) [owise] .

  eq procVariantUnify3(M, UP, I, empty)
   = ('\n '\n 'No 'more 'solutions. '\n) .
  eq procVariantUnify3(M, UP, I, S:Substitution | SS:SubstitutionSet)
   = '\n '\n 'Solution qid(string(I + 1, 10))
      if S:Substitution == none
      then '\n 'empty 'substitution
      else '\n eMetaPrettyPrint(M, S:Substitution)
      fi
     procVariantUnify3(M, UP, I + 1, SS:SubstitutionSet) .

  *** ASYMMETRIC-VARIANT-UNIFY

  ceq procAsymmetricVariantUnify(ME, M, T, D, VDS, DB)
    *** D is a bound on the number of solutions
    = if solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}
      then procAsymmetricVariantUnify2(
             getModule(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
             parseUnify(
               getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
               getVars(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))),
             getBound(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
      else getMsg(getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
                ----('\r 'Error: '\o 'Incorrect 'asymmetric 'variant 'unify 'command. '\n)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  ---op axCohComplete : SModule -> SModule . --- Defined later in module AX-COHERENCE-COMPLETION
  ---op removeIds : Module ~> Module . ---Defined later in module VARIANTS

  ceq procAsymmetricVariantUnify2(M, T =? T', D)
    = if X:[SubstitutionSet] :: SubstitutionSet
      then ('variant 'unify
            if D == unbounded then nil else '\s '`[ qid(string(D, 10)) '`] '\s fi
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T =? T')
            if X:[SubstitutionSet] == empty
            then '\n 'No 'asymmetric 'unifier
            else procAsymmetricVariantUnify3(M, T =? T', 0, X:[SubstitutionSet])
            fi)
      else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'asymmetric 'variant 'unify 'command. '\n
      fi
    if X:[SubstitutionSet]
       := toSubstitution(
            metaVariantUnify(
               removeIds(axCohComplete(M), non-handled),
               T,
               T',
               highestVar((T,T')) + 1,
               minimal-unifiers irreducible
            )
          ) .
  eq procAsymmetricVariantUnify2(M?, UP??:[UnificationProblem], D?) = getMsg(M?) [owise] .

  eq procAsymmetricVariantUnify3(M, UP, I, empty)
   = ('\n '\n 'No 'more 'solutions. '\n) .
  eq procAsymmetricVariantUnify3(M, UP, I, S:Substitution | SS:SubstitutionSet)
   = '\n '\n 'Solution qid(string(I + 1, 10))
      if S:Substitution == none
      then '\n 'empty 'substitution
      else '\n eMetaPrettyPrint(M, S:Substitution)
      fi
     procAsymmetricVariantUnify3(M, UP, I + 1, SS:SubstitutionSet) .

  *** GET-VARIANTS

  ceq procGetVariants(ME, M, T, D, VDS, DB)
    *** D is a bound on the number of solutions
    = if solveBubblesRewUnify(T, M, B, D, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}
      then procGetVariants2(
             getModule(solveBubblesRewUnify(T, M, B, D, VDS, DB)),
             parseGetVariants(
               getTerm(solveBubblesRewUnify(T, M, B, D, VDS, DB)),
               getVars(solveBubblesRewUnify(T, M, B, D, VDS, DB))),
             getBound(solveBubblesRewUnify(T, M, B, D, VDS, DB)))
      else getMsg(getTerm(solveBubblesRewUnify(T, M, B, D, VDS, DB)))
                ----('\r 'Error: '\o 'Incorrect 'get 'variants 'command. '\n)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  eq parseGetVariants(T, VDS) = constsToVars(T, VDS) .

  ceq procGetVariants2(M, T, D)
    = if X:[VariantFourSet] :: VariantFourSet
      then ('get 'variants
            if D == unbounded then nil else '\s '`[ qid(string(D, 10)) '`] '\s fi
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T)
            if X:[VariantFourSet] == empty
            then '\n 'No 'variant
            else procGetVariants3(M, T, 0, X:[VariantFourSet])
            fi)
      else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'get 'variants 'command. '\n
      fi
    if X:[VariantFourSet]
         := getVariants(
              removeIds(axCohComplete(M), non-handled),
              T,
              highestVar(T) + 1,
              ACUUnify irreducible minimal-unifiers
            ) .
  eq procGetVariants2(M?, UP??:[Term], D?) = getMsg(M?) [owise] .

  eq procGetVariants3(M, T, I, (empty).VariantFourSet)
   = ('\n '\n 'No 'more 'variants. '\n) .
  eq procGetVariants3(M, T, I, {T1:Term,S:Substitution,S*:Substitution,NextVar:Nat} | VS:VariantFourSet)
   = '\n '\n 'Variant qid(string(I + 1, 10))
      '\n
      '`{
      eMetaPrettyPrint(M, T1:Term) '`,
      if S:Substitution == none
      then 'empty 'substitution
      else eMetaPrettyPrint(M, S:Substitution)
      fi
      '`}
     procGetVariants3(M, T, I + 1, VS:VariantFourSet) .
endfm

----load check-input-module.maude

---- Input modules are assumed not to have:
---- - idem
---- - assoc without comm
---- - variable alone in lhs
---- - owise
---- - iter
---- - built-ins
---- - something else?

fmod CHECK-INPUT-MODULE is
  inc EXT-TERM .
  inc MODULE-HANDLING  * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) .

  op checkModule : Module -> Bool .
  op attr : OpDeclSet Attr -> Bool .
  ops assocWithoutComm specialAttr : OpDeclSet -> Bool .
  op nonValidAttrs : OpDeclSet AttrSet -> Bool .
  op singleVbleInLHSs : RuleSet -> Bool .
  op singleVbleInLHSs : EquationSet -> Bool .

  var  M : Module .
  var  F : Qid .
  var  TpL : TypeList .
  vars Tp Tp' Tp'' Tp''' : Type .
  var  TpS : TypeSet .
  var  At : Attr .
  vars AtS AtS' : AttrSet .
  vars ODS ODS' : OpDeclSet .
  var  V : Variable .
  var  VS : QidSet .
  var  RlS : RuleSet .
  var  EqS : EquationSet .
  vars T LHS RHS : Term .
  var  Cond : Condition .

  eq attr(op F : TpL -> Tp [owise AtS] . ODS, At AtS) = true .
  eq attr(op F : TpL -> Tp [idem AtS] . ODS, idem) = true .
  eq attr(op F : TpL -> Tp [iter AtS] . ODS, iter) = true .
  eq attr(ODS, At) = false [owise] .

  eq nonValidAttrs(op F : TpL -> Tp [At AtS] . ODS, At AtS') = true .
  eq nonValidAttrs(ODS, AtS) = false [owise] .

  ---- special attributes only allowed for constants
  eq specialAttr(op F : TpL -> Tp [special(NEHL:NeHookList) AtS] . ODS) = TpL =/= nil .
  eq specialAttr(ODS) = false [owise] .

  eq assocWithoutComm(op F : TpL -> Tp [assoc AtS] . ODS)
    = (not comm in AtS) or-else assocWithoutComm(ODS) .
  eq assocWithoutComm(ODS) = false [owise] .

  eq singleVbleInLHSs(rl V => RHS [AtS] . RlS) = true .
  eq singleVbleInLHSs(crl V => RHS if Cond [AtS] . RlS) = true .
  eq singleVbleInLHSs(RlS) = false [owise] .

  eq singleVbleInLHSs(eq V = RHS [AtS] . EqS) = true .
  eq singleVbleInLHSs(ceq V = RHS if Cond [AtS] . EqS) = true .
  eq singleVbleInLHSs(EqS) = false [owise] .

  op isRegular : EquationSet -> Bool .
  op isRegular : RuleSet -> Bool .
  eq isRegular(eq LHS = RHS [AtS] . EqS) = (vars(LHS) == vars(RHS)) and isRegular(EqS) .
  eq isRegular(ceq LHS = RHS if Cond [AtS] . EqS) = (vars(LHS) == vars(RHS)) and isRegular(EqS) .
  eq isRegular(rl LHS => RHS [AtS] . RlS) = (vars(LHS) == vars(RHS)) and isRegular(RlS) .
  eq isRegular(crl LHS => RHS if Cond [AtS] . RlS) = (vars(LHS) == vars(RHS)) and isRegular(RlS) .

  ---- We say that a term l is linear iff all its variables appear only once in it.

  op linear : Term -> Bool .
  eq linear(T) = | vars(T) | == size(varlist(T)) .

  ---- We say that a term l is C-nonlinear iff all its variables are c-nonlinear.
  ---- A variable x : s in vars(l) is c-nonlinear if it is nonlinear in l and
  ---- there is a \Sigma-subterm t with ls[t]_B <= s with a position p such that
  ---- t|_p = f(u,v) with B_f = {C_f}.

  op c-nonlinear : Qid Term Module -> Bool . ---- the variable (1st arg.) is c-linear in the term (2nd arg.)
  op c-nonlinear : Term Module -> Bool . ---- no repeated variables and all such varaibles are c-linear
  op c-nonlinearAux : QidSet Module -> Bool .
  op c-nonlinearAux : Type Module -> Bool .
  op c-nonlinearAux : Type TypeSet OpDeclSet OpDeclSet Module -> Bool .
  op c-nonlinearAux2 : TypeList TypeSet OpDeclSet Module -> Bool .

  eq c-nonlinear(V, T, M) = occurrences(V, T) > 1 and-then c-nonlinearAux(V, M) .

  eq c-nonlinear(T, M) = not linear(T) and-then c-nonlinearAux(vars(T), M) .

  eq c-nonlinearAux(V ; VS, M) = c-nonlinearAux(getType(V), M) or-else c-nonlinearAux(VS, M) .
  eq c-nonlinearAux(none, M) = false .

  eq c-nonlinearAux(Tp, M) = c-nonlinearAux(Tp, Tp, getOps(M), getOps(M), M) .

  ceq c-nonlinearAux(Tp, TpS, op F : Tp' Tp'' -> Tp''' [comm AtS] . ODS, ODS', M)
    = true
    if sortLeq(M, Tp''', Tp) .
  eq c-nonlinearAux(Tp, TpS, op F : TpL -> Tp' [AtS] . ODS, ODS', M)
    = if not comm in AtS and-then (not Tp in TpS and-then sortLeq(M, Tp', Tp))
      then c-nonlinearAux2(TpL, TpS, ODS', M) ---- all the sorts in that declarations have already been checked
      else c-nonlinearAux(Tp, TpS, ODS, ODS', M)
      fi
    [owise] .
  eq c-nonlinearAux(Tp, TpS, none, ODS, M)
    = false .

  eq c-nonlinearAux2(Tp TpL, TpS, ODS, M)
    = if Tp in TpS
      then false
      else c-nonlinearAux(Tp, Tp ; TpS, ODS, ODS, M)
      fi
      or-else c-nonlinearAux2(TpL, TpS, ODS, M) .
  eq c-nonlinearAux2(nil, TpS, ODS, M) = false .

---(
  eq c-permute(C, M) = C .
  eq c-permute(V, M) = V .
  ceq c-permute(F[T, T'], M)
    = c-combine(F, c-permute((T, T'), M)) # c-combine(F, c-permute((T', T), M))
    if isCommutative(M, F, getTypes(M, (T, T'))) .
  eq c-permute(F[TL], M)
    = c-combine(F, c-permute(TL, M))
    [owise] .

  eq c-permute((T, T'), M)
    = c-permute(T, M) .
---)
endfm

--------------------------------------------------------------------------------

view SubstitutionSet from TRIV to SUBSTITUTIONSET is
  sort Elt to SubstitutionSet .
endv

fmod MODULE-VARIANTS is
  inc CHECK-INPUT-MODULE .
  inc META-NARROWING-SEARCH * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) .
  inc UNIT .
  pr 2TUPLE{SubstitutionSet, Nat}
      * (op `(_`,_`) : SubstitutionSet Nat -> Tuple{SubstitutionSet, Nat} to <_;_>,
         op p1_ : Tuple{SubstitutionSet, Nat} -> SubstitutionSet to getSubst,
         op p2_ : Tuple{SubstitutionSet, Nat} -> Nat to getIndex) .
  pr CONVERSION .
  pr EXT-TERM .
  pr EXT-DECL .
  pr 2TUPLE{Module,Module}
      * (op `(_`,_`) : Module Module -> Tuple{Module, Module} to <_;_>) .

  vars V W : Variable .
  var  C : Constant .
  vars M M' M'' : Module .
  var  N : Nat .
  vars T T' T'' LHS RHS : Term .
  var  F : Qid .
  var  TL : TermList .
  var  AtS : AttrSet .
  var  VFS : VariantFourSet .
  var  VtS : VariantTripleSet .
  vars Tp Tp' Tp'' : Type .
  var  TpL : TypeList .
  var  Rl : Rule .
  var  RlS : RuleSet .
  var  Eq : Equation .
  var  EqS : EquationSet .
  var  ODS : OpDeclSet .
  var  Cond : Condition .
  var  S : Sort .
  var  VS : QidSet .
  vars Subst Subst' : Substitution .
  vars SubstS SubstS' : SubstitutionSet .
  var  H : Header .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  vars OPDS OPDS' : OpDeclSet .
  var  MAS : MembAxSet .
  var  IL : ImportList .

  ------------------------------------------------------------------------------
  ---- Given a module \mathcal{R} = (\Sigma, E, R)
  ---- removeIds(\mathcal{R}) = removeIds((\widehat{\Sigma}, B, \widetilde{U}), R)
  ---- where
  ---- - \widehat{\Sigma} is obtained by
  ----   - adding to $\Sigma$ a fresh new sort [Tuple] and
  ----   - a tupling operator <_,...,_> : [s] [s_1] ... [s_n] -> [Tuple]
  ----     for each rule l -> r if u_1 -> v_1 /\ ... /\ u_n -> v_n in R,
  ----     where l has sort s and v_i has sort s_i, 1 <= i <= n,
  ---- - B_f = E_f \cap {A_f, C_f}
  ---- - U_f = E_f \cap {LU_f, RU_f},
  ----   with LU_f and RU_f rewrite rules f(e,x) -> x and f(x,e) -> x, and
  ----   where \widetilde{U} is the B-coherence completion of U,
  ----   which is described as \widetilde{U} = \bigcup_{f:[s_1]...[s_n] -> [s] \in \Sigma} \widetilde{U}_f.
  ----   If A_f \not \in B_f, or A_f, C_f \in B_f, then \widetilde{U}_f = U_f.
  ----   Otherwise, if A_f \in B_f, but C_f \not \in B_f, then,
  ----     if LU_f \in U_f, then we add the rule f(x,f(e,y)) -> f(x,y) and
  ----     if RU_f \in U_f, then we add the rule f(f(x,e'),y) -> f(x,y).
  ---- makeIdsModule computes (\widehat{\Sigma}, B, \widetilde{U})
  ------------------------------------------------------------------------------

  sort VariantProcedure .
  ops narrowing ad-hoc built-in : -> VariantProcedure .
  var VP : VariantProcedure .
  sort IdsToRemove .                             ---- moved to COMMAND-PROCESSING
  ops all non-handled : -> IdsToRemove .         ---- moved to COMMAND-PROCESSING
  var Which : IdsToRemove .

  op removeIds : Module IdsToRemove ~> Module .  ---- moved to COMMAND-PROCESSING
  ---- given a module returns an equivalent module without ids but with variants of eqs and rls
  ---- the second argument may be either all (all id attributes are removed) or non-handled (only those not directly handled by Maude's unification are removed)
  op removeIds : Module IdsToRemove VariantProcedure ~> Module .
  ---- given a module returns an equivalent module without ids but with variants
  ---- of eqs and rls using the specified procedure for calculating variants
  op getVariants : Module Module RuleSet VariantProcedure -> RuleSet .
  ---- given a (\widehat{\Sigma}, B, \widetilde{U}) returns the variants of the given set of rules
  ---- It takes the modules without and with ids. The module with id attributes is used to normalize.
  op getVariants : Module Module EquationSet VariantProcedure -> EquationSet .
  ---- given a (\widehat{\Sigma}, B, \widetilde{U}) returns the variants of the given set of equations
  ---- It takes the modules without and with ids. The module with id attributes is used to normalize.
  op getVariants# : Module Module Term VariantProcedure -> VariantTripleSet .
  ---- given a (\widehat{\Sigma}, B, \widetilde{U}) returns the variants of a term (a tuple)
  op getRlVariants : Module VariantTripleSet Term Condition AttrSet -> RuleSet .
  ---- given the variants of a tuple < LHS, target terms in condition >, a RHS, a condition, and an attribute set,
  ---- it constructs the corresponding variant rules
  op getEqVariants : Module VariantTripleSet Term Condition AttrSet -> EquationSet .
  ---- given the variants of a tuple < LHS, target terms in condition >, a RHS, a condition, and an attribute set,
  ---- it constructs the corresponding variant equations

  eq removeIds(M, Which) ---- Which may be either all or non-handled
    = if nonValidAttrs(getOps(M), owise idem iter)
      then unitError('The 'module 'uses 'non-supported 'attributes '`(owise`, 'idem`, 'or 'iter '`). '\n)
      else if singleVbleInLHSs(getRls(M))
           then unitError('The 'module 'contains 'rules 'with 'single 'variables 'in 'their 'left-hand 'sides. '\n)
           else if singleVbleInLHSs(getEqs(M))
                then unitError('The 'module 'contains 'equations 'with 'single 'variables 'in 'their 'left-hand 'sides. '\n)
                else if assocWithoutComm(getOps(M))
                     then moreGeneralEqs(moreGeneralRls(removeIds(M, Which, ad-hoc)))
                     else moreGeneralEqs(moreGeneralRls(removeIds(M, Which, narrowing))) ---- built-in
                     fi
                fi
           fi
      fi .

  eq removeIds(M, Which, VP)
    ---- the narrowing based getVariant function requires a module with id attributes turned into eqs
    ---- and sort Tuple and tuple operators in; the ad-hoc getVariant (FroCos th 2) only needs the
    ---- tuple declarations.
    = setRls(
        addEqs(
          getVariants(makeIdsTuplingModule(M, Which), addTupling(M, M), getEqs(M), VP),
          makeIdsModule(M, Which)),
        getVariants(makeIdsTuplingModule(M, Which), addTupling(M, M), getRls(M), VP)) .

  eq getVariants(M, M', Rl RlS, VP)
    = getRlVariants(M', getVariants#(M, M', makeTuple(lhs(Rl), cond(Rl)), VP), rhs(Rl), cond(Rl), atts(Rl))
      getVariants(M, M', RlS, VP) .
  eq getVariants(M, M', (none).RuleSet, VP) = none .

  eq getVariants(M, M', Eq EqS, VP)
    = getEqVariants(M', getVariants#(M, M', makeTuple(lhs(Eq), cond(Eq)), VP), rhs(Eq), cond(Eq), atts(Eq))
      getVariants(M, M', EqS, VP) .
  eq getVariants(M, M', (none).EquationSet, VP) = none .

  eq getVariants#(M, M', T, narrowing) = makeVariantSet(getVariants(M, T, 1, irreducible ACUUnify minimal-unifiers)) .

  op makeVariantSet : VariantFourSet -> VariantTripleSet .
  eq makeVariantSet({T, Subst, Subst', N} | VFS) = {T, Subst, N} | makeVariantSet(VFS) .
  eq makeVariantSet(empty) = empty .

---- PD: pre alpha96
----  eq getVariants#(M, M', T, built-in) = getVariants#(M, T, 0) .
----
----  op getVariants# : Module Term Nat -> VariantTripleSet .
----  eq getVariants#(M, T, N)
----    = if metaGenerateVariant(M, T, 0, N) == noVariant
----      then empty
----      else metaGenerateVariant(M, T, 0, N), getVariants#(M, T, s N)
----      fi .

  eq getRlVariants(M, ({'@<@_@>@[T], Subst, N} | VtS), T', nil, AtS)
    = (rl getTerm(metaNormalize(M, T)) => getTerm(metaNormalize(M, _<<_(T', Subst))) [AtS] .)
      getRlVariants(M, VtS, T', nil, AtS) .
  eq getRlVariants(M, ({F[T, TL], Subst,N} | VtS), T', Cond, AtS)
    = (crl getTerm(metaNormalize(M, T)) => getTerm(metaNormalize(M, _<<_(T', Subst))) if makeCond(TL, Cond, Subst) [AtS] .)
      getRlVariants(M, VtS, T', Cond, AtS) .
  eq getRlVariants(M, empty, T', Cond, AtS) = none .

  eq getEqVariants(M, ({'@<@_@>@[T], Subst, N} | VtS), T', nil, AtS)
    = (eq getTerm(metaNormalize(M, T)) = getTerm(metaNormalize(M, _<<_(T', Subst))) [AtS] .)
      getEqVariants(M, VtS, T', nil, AtS) .
  eq getEqVariants(M, ({F[T, TL], Subst, N} | VtS), T', Cond, AtS)
    = (ceq getTerm(metaNormalize(M, T)) = getTerm(metaNormalize(M, _<<_(T', Subst))) if makeCond(TL, Cond, Subst) [AtS] .)
      getEqVariants(M, VtS, T', Cond, AtS) .
  eq getEqVariants(M, empty, T', Cond, AtS) = none .

  ------------------------------------------------------------------------------

  op makeTuple : Term Condition -> Term .
  op tupleTermList : Condition -> TermList .
  eq makeTuple(T, Cond)
    = if Cond == nil
      then qid("@<@_@>@")[T]
      else qid("@<@_" + tupleId(Cond) + "@>@")[T, tupleTermList(Cond)]
      fi .
  eq tupleTermList(T' => T'' /\ Cond) = (T'', tupleTermList(Cond)) .
  eq tupleTermList(T' = T'' /\ Cond) = tupleTermList(Cond) .
  eq tupleTermList(T' : S /\ Cond) = tupleTermList(Cond) .
  eq tupleTermList(T' := T'' /\ Cond) = (T', tupleTermList(Cond)) .
  eq tupleTermList(nil) = empty .

  op makeCond : TermList Condition Substitution -> Condition .
  eq makeCond((T, TL), T' => T'' /\ Cond, Subst)
    = (T' << Subst) => T /\ makeCond(TL, Cond, Subst) .
  eq makeCond((T, TL), T' := T'' /\ Cond, Subst)
    = T := (T'' << Subst) /\ makeCond(TL, Cond, Subst) .
  eq makeCond(TL, T' = T'' /\ Cond, Subst)
    = (T' << Subst) = (T'' << Subst) /\ makeCond(TL, Cond, Subst) .
  eq makeCond(TL, T' : S /\ Cond, Subst)
    = (T' << Subst) : S /\ makeCond(TL, Cond, Subst) .
  eq makeCond(empty, nil, Subst) = nil .

  ------------------------------------------------------------------------------
  ---- makeIdsTuplingModule((\Sigma, E, R)) computes (\widehat{\Sigma}, B, \widetilde{U})
  ------------------------------------------------------------------------------
  op makeIdsTuplingModule : Module IdsToRemove -> Module .
  op makeIdsModule : Module IdsToRemove -> Module .
  op addTupling : Module Module -> Module .
  ---- addTupling is called after makeIdsModule, which removes the eqs in it
  ---- the first module is the oiginal one, with the original eqs and rls

  eq makeIdsTuplingModule(M, Which) = addTupling(M, makeIdsModule(M, Which)) .

  eq makeIdsModule(M, Which)
    = setEqs(
        setOps(
          setRls(M, none),
          removeIds(getOps(M), Which)),
        idEqs(M, getOps(M), Which)) .

  eq addTupling(M, M')
    = addOps(
        tuplingOps(M, getEqs(M), getRls(M)),
        addSorts('Tuple, M')) .

  op idEqs : Module OpDeclSet IdsToRemove -> EquationSet .
  ---- the 3rd arguments indicates whether all the id attributes are to be removed (all), or only those not handled by the Maude unification algorithm (non-handled)
  eq idEqs(M, op F : Tp Tp' -> Tp'' [left-id(T) AtS] . ODS, Which)
    = (eq F[T, qid("X:" + string(type2qid(getKind(M, Tp))))] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('lIdEq1)
      if assoc in AtS and not comm in AtS
      then (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), F[T, qid("Y:" + string(type2qid(getKind(M, Tp))))]]
              = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))]
              [variant] .) ---- label('lIdEq2)
      else none
      fi
      idEqs(M, ODS, Which) .
  eq idEqs(M, op F : Tp Tp' -> Tp'' [right-id(T) AtS] . ODS, Which)
    = (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), T] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('rIdEq1)
      if assoc in AtS and not comm in AtS
      then (eq F[F[qid("X:" + string(type2qid(getKind(M, Tp)))), T], qid("Y:" + string(type2qid(getKind(M, Tp))))]
              = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))]
              [variant] .) ---- label('rIdEq2)
      else none
      fi
      idEqs(M, ODS, Which) .
  eq idEqs(M, op F : Tp Tp' -> Tp'' [id(T) AtS] . ODS, all)
    = if comm in AtS
      then (eq F[T, qid("X:" + string(type2qid(getKind(M, Tp))))] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq1)
      else (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), T] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq2)
           (eq F[T, qid("X:" + string(type2qid(getKind(M, Tp))))] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq3)
      fi
      if assoc in AtS and not comm in AtS
      then (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), F[T, qid("Y:" + string(type2qid(getKind(M, Tp))))]]
              = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))]
              [variant] .)
           (eq F[F[qid("X:" + string(type2qid(getKind(M, Tp)))), T], qid("Y:" + string(type2qid(getKind(M, Tp))))]
              = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))]
              [variant] .)
      else none
      fi
      idEqs(M, ODS, all) .
  eq idEqs(M, op F : Tp Tp' -> Tp'' [id(T) AtS] . ODS, non-handled)
    ---- modified on Jan 13th, 2011
    ---- The ACU case is now handled, the id attributes are left if also AC
    = if assoc in AtS and comm in AtS
      then none
      else if comm in AtS
           then (eq F[T, qid("X:" + string(type2qid(getKind(M, Tp))))] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq1)
           else (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), T] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq2)
                (eq F[T, qid("X:" + string(type2qid(getKind(M, Tp))))] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq3)
           fi
           if assoc in AtS and not comm in AtS
           then (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), F[T, qid("Y:" + string(type2qid(getKind(M, Tp))))]]
                   = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))]
                   [variant] .)
                (eq F[F[qid("X:" + string(type2qid(getKind(M, Tp)))), T], qid("Y:" + string(type2qid(getKind(M, Tp))))]
                   = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))]
                   [variant] .)
           else none
           fi
      fi
      idEqs(M, ODS, non-handled) .
  eq idEqs(M, ODS, Which) = none [owise] .

  op removeIds : OpDeclSet IdsToRemove -> OpDeclSet .
  eq removeIds(op F : TpL -> Tp [id(T) AtS] . ODS, all)
    = removeIds(op F : TpL -> Tp [AtS] . ODS, all) .
 ceq removeIds(op F : TpL -> Tp [id(T) AtS] . ODS, non-handled)
    = removeIds(op F : TpL -> Tp [AtS] . ODS, non-handled)
    if not (assoc in AtS and comm in AtS) .
  eq removeIds(op F : TpL -> Tp [left-id(T) AtS] . ODS, Which)
    = removeIds(op F : TpL -> Tp [AtS] . ODS, Which) .
  eq removeIds(op F : TpL -> Tp [right-id(T) AtS] . ODS, Which)
    = removeIds(op F : TpL -> Tp [AtS] . ODS, Which) .
  eq removeIds(ODS, Which) = ODS [owise] .

  op tuplingOps : Module EquationSet RuleSet -> OpDeclSet .
  op tuplingOps : Module EquationSet -> OpDeclSet .
  op tuplingOps : Module RuleSet -> OpDeclSet .
  eq tuplingOps(M, EqS, RlS) = tuplingOps(M, EqS) tuplingOps(M, RlS) .
  eq tuplingOps(M, eq LHS = RHS [AtS] . EqS)
    = (op qid("@<@_@>@") : getKind(M, leastSort(M, LHS)) -> '`[Tuple`] [none] .)
      tuplingOps(M, EqS) .
  eq tuplingOps(M, ceq LHS = RHS if Cond [AtS] . EqS)
    = (op qid("@<@_" + tupleId(Cond) + "@>@") : getKind(M, leastSort(M, LHS)) arityCond(M, Cond) -> '`[Tuple`] [none] .)
      tuplingOps(M, EqS) .
  eq tuplingOps(M, (none).EquationSet) = none .
  eq tuplingOps(M, rl LHS => RHS [AtS] . RlS)
    = (op qid("@<@_@>@") : getKind(M, leastSort(M, LHS)) -> '`[Tuple`] [none] .)
      tuplingOps(M, RlS) .
  eq tuplingOps(M, crl LHS => RHS if Cond [AtS] . RlS)
    = (op qid("@<@_" + tupleId(Cond) + "@>@") : getKind(M, leastSort(M, LHS)) arityCond(M, Cond) -> '`[Tuple`] [none] .)
      tuplingOps(M, RlS) .
  eq tuplingOps(M, (none).RuleSet) = none .

  op arityCond : Module Condition -> TypeList .
  eq arityCond(M, T => T' /\ Cond) = getKind(M, leastSort(M, T')) arityCond(M, Cond) .
  eq arityCond(M, T := T' /\ Cond) = getKind(M, leastSort(M, T)) arityCond(M, Cond) .
  eq arityCond(M, T = T' /\ Cond) = arityCond(M, Cond) .
  eq arityCond(M, T : S /\ Cond) = arityCond(M, Cond) .
  eq arityCond(M, nil) = nil .

  op tupleId : Condition -> String .
  eq tupleId(T => T' /\ Cond) = ",_" + tupleId(Cond) .
  eq tupleId(T := T' /\ Cond) = ",_" + tupleId(Cond) .
  eq tupleId(T = T' /\ Cond) = tupleId(Cond) .
  eq tupleId(T : S /\ Cond) = tupleId(Cond) .
  eq tupleId(Cond) = "" .

  ------------------------------------------------------------------------------
  ---- See Th. 2, FroCos'09
  ---- TO DO: it doesn't give the minimal set of variants

  op getVariants : Module Term SubstitutionSet -> VariantTripleSet .
  op getSubstitutions : Module QidSet OpDeclSet Nat -> Tuple{SubstitutionSet,Nat} .
  op getSubstitutions1 : Module Variable OpDeclSet Nat -> Tuple{SubstitutionSet,Nat} .
  op combineSubsts : SubstitutionSet SubstitutionSet -> SubstitutionSet .

  eq getVariants#(M, M', T, ad-hoc)
    = getVariants(M', T, getSubst(getSubstitutions(M', vars(T), getOps(M'), 0))) .

  eq getVariants(M, T, Subst | SubstS)
    = {getTerm(metaNormalize(M, T << Subst)), Subst, 0} | getVariants(M, T, SubstS) .
  eq getVariants(M, T, empty) = {T, none, 0} .

  eq getSubstitutions(M, V ; VS, ODS, N)
    = < combineSubsts(
          getSubst(getSubstitutions1(M, V, ODS, N)),
          getSubst(getSubstitutions(M, VS, ODS, getIndex(getSubstitutions1(M, V, ODS, N))))) ;
        getIndex(getSubstitutions(M, VS, ODS, getIndex(getSubstitutions1(M, V, ODS, N)))) > .
  eq getSubstitutions(M, none, ODS, N) = < empty ; N > .

  eq combineSubsts(Subst | SubstS, Subst' | SubstS')
    = (Subst ; Subst') | combineSubsts(SubstS, Subst' | SubstS') | combineSubsts(Subst, SubstS') .
  eq combineSubsts(SubstS, empty) = SubstS .
  eq combineSubsts(empty, SubstS) = SubstS .

  ceq getSubstitutions1(M, V, op F : TpL -> Tp [id(T) AtS] . ODS, N)
    = < (V <- T) |
        if (assoc in AtS and-then not comm in AtS)
           and-then sortLeq(M, leastSort(M, F[qid("X@" + string(N, 10) + ":" + string(Tp)), T]), getType(V))
        then (V <- (F[qid("X@" + string(N, 10) + ":" + string(Tp)), T]))
           | (V <- (F[T, qid("X@" + string(s N, 10) + ":" + string(Tp))]))
        else empty
        fi |
        getSubst(getSubstitutions1(M, V, ODS, s s N)) ;
        getIndex(getSubstitutions1(M, V, ODS, s s N)) >
    if sortLeq(M, leastSort(M, T), getType(V)) . ----  ls[e] <= s ls[f(y,e)] <= s
  ceq getSubstitutions1(M, V, op F : TpL -> Tp [right-id(T) AtS] . ODS, N)
    = < (V <- T) |
        if (assoc in AtS and-then not comm in AtS)
           and-then sortLeq(M, leastSort(M, F[qid("X@" + string(N, 10) + ":" + string(Tp)), T]), getType(V))
        then (V <- F[T, qid("X@" + string(N, 10) + ":" + string(Tp))])
        else empty
        fi |
        getSubst(getSubstitutions1(M, V, ODS, s s N)) ;
        getIndex(getSubstitutions1(M, V, ODS, s s N)) >
    if sortLeq(M, leastSort(M, T), getType(V)) . ----  ls[e] <= s ls[f(y,e)] <= s
  ceq getSubstitutions1(M, V, op F : TpL -> Tp [left-id(T) AtS] . ODS, N)
    = < (V <- T) |
        if (assoc in AtS and-then not comm in AtS)
           and-then sortLeq(M, leastSort(M, F[qid("X@" + string(N, 10) + ":" + string(Tp)), T]), getType(V))
        then (V <- F[qid("X@" + string(s N, 10) + ":" + string(Tp)), T])
        else empty
        fi |
        getSubst(getSubstitutions1(M, V, ODS, s s N)) ;
        getIndex(getSubstitutions1(M, V, ODS, s s N)) >
    if sortLeq(M, leastSort(M, T), getType(V)) . ----  ls[e] <= s ls[f(y,e)] <= s
  eq getSubstitutions1(M, V, ODS, N) = < empty ; N > [owise] .

  ------------------------------------------------------------------------------
  ---- Given a module with axioms B where for each f we have B_f \in {A_f,C_f},
  ---- we now define a rewrite theory (\Sigma, B', A), where for each f we have
  ---- B'_f = B_f if B_f =/= {A_f}, and B'_f = \emptyset if B_f == {A_f}, and
  ---- where A consists of rules of either the form
  ----  f(f(x, y), z) -> f(x, f(y, z))
  ---- or the form
  ----  f(x, f(y, z)) -> f(f(x, y), z)
  ---- for each f such that B_f == {A_f}. That is, for any such f we "choose" a
  ---- rule asociating f to the right or to the left (but only "one" of these possibilities).

  ---- TO DO: I cannot set a timeout. If the first one doesn't work it hangs up!
  ---- TO DO: All terms are in their flatten form, when removing the assoc atributes I get error messages.

  op removeLonelyAssocs : Module -> Module .
  ---- removes all assoc with no comm, returning an equivalent module
  op $removeLonelyAssocs : OpDeclSet -> OpDeclSet .
  ---- removes those assoc attributes that are not with the comm one
  op $removeLonelyAssocs : Module OpDeclSet OpDeclSet EquationSet ~> Module .
  ---- arg. 1 (Module): the module with assoc attribute removed
  ---- arg. 2 (OpDeclSet): initially all op. decls.; they are evaluated one by one,
  ----   adding the corresponding equation to the 4th arg. in the recursive call
  ---- arg. 3 (OpDeclSet): initially empty; evaluated op. decls. are added to this set
  ---- arg. 4 (EquationSet): assoc. eq. to be added to the module
  op $checkAEq : Module Equation -> Bool .
  ---- checks whether the assoc. eq. given as argument unifies with any lhs in the module
  ---- arg. 1 (Module): the module with assoc attribute removed
  ---- arg. 2 (Equation): tentative assoc. eq. to evaluate
  op $checkAEqAux : Module EquationSet -> Bool .
  ---- tries to narrow with the assoc. eq. (as a rule) on each lhs in the module.
  ---- arg. 1 (Module): module with assoc attribute removed, with the assoc. eq.
  ----   turned into a rule as single rule (no eqs.)
  ---- arg. 2 (EquationSet): eqs. in the original module
  op $anyLonelyAssoc : OpDeclSet -> Bool .
  ---- checks whether the module contains an operator with assoc and no comm

  eq removeLonelyAssocs(M)
    = if $anyLonelyAssoc(getOps(M))
      then if nonValidAttrs(getOps(M), owise idem iter)
           then unitError('The 'module 'uses 'non-supported 'attributes '`(owise`, 'idem`, 'or 'iter '`). '`))
           else if singleVbleInLHSs(getRls(M))
                then unitError('The 'module 'contains 'rules 'with 'single 'variables 'in 'their 'left-hand 'sides. '`))
                else if singleVbleInLHSs(getEqs(M))
                     then unitError('The 'module 'contains 'equations 'with 'single 'variables 'in 'their 'left-hand 'sides. '`))
                     else $removeLonelyAssocs(setOps(M, $removeLonelyAssocs(getOps(M))), getOps(M), none, none)
                     fi
                fi
           fi
      else M
      fi .

  ceq $removeLonelyAssocs(op F : Tp Tp -> Tp [assoc AtS] . OPDS)
    = op F : Tp Tp -> Tp [AtS] . $removeLonelyAssocs(OPDS)
    if not comm in AtS .
  eq $removeLonelyAssocs(OPDS) = OPDS [owise] .

  ceq $removeLonelyAssocs(M, op F : TpL -> Tp [AtS] . OPDS, OPDS', EqS)
    = $removeLonelyAssocs(M, OPDS, op F : TpL -> Tp [AtS] . OPDS', EqS)
    if size(TpL) =/= 2 or not assoc in AtS or comm in AtS .
  ceq $removeLonelyAssocs(M, op F : Tp Tp -> Tp [assoc AtS] . OPDS, OPDS', EqS)
    = $removeLonelyAssocs(M, OPDS, op F : Tp Tp -> Tp [AtS] . OPDS', Eq EqS)
    if not comm in AtS
    /\ Str:String := string(type2qid(getKind(M, Tp)))
    /\ Eq := (eq F[F[qid("X:" + Str:String), qid("Y:" + Str:String)], qid("Z:" + Str:String)]
                = F[qid("X:" + Str:String), F[qid("Y:" + Str:String), qid("Z:" + Str:String)]] [label('assocEq)] .)
    /\ $checkAEq(M, Eq) .
  ceq $removeLonelyAssocs(M, op F : Tp Tp -> Tp [assoc AtS] . OPDS, OPDS', EqS)
    = $removeLonelyAssocs(M, OPDS, op F : Tp Tp -> Tp [AtS] . OPDS', Eq EqS)
    if not comm in AtS
    /\ Str:String := string(type2qid(getKind(M, Tp)))
    /\ Eq := (eq F[qid("X:" + Str:String), F[qid("Y:" + Str:String), qid("Z:" + Str:String)]]
                = F[F[qid("X:" + Str:String), qid("Y:" + Str:String)], qid("Z:" + Str:String)] [label('assocEq)] .)
    /\ $checkAEq(M, Eq) .
  eq $removeLonelyAssocs(M, none, OPDS', EqS) = addEqs(EqS, M) .
  eq $removeLonelyAssocs(M, op F : TpL -> Tp [AtS] . OPDS, OPDS', EqS) = unitError('assoc 'attributes 'cannot 'be 'removed 'for F) [owise] .

  eq $checkAEq(M, Eq) = $checkAEqAux(setRls(setEqs(M, none), rulify(Eq)), getEqs(M)) .

  ceq $checkAEqAux(M, Eq EqS)
    = T:Term == lhs(Eq) ---- the assoc eq doesn't unify with the equation's lhs
      and
      Subst:Substitution == none
      and-then
      $checkAEqAux(M, EqS)
    if {T:Term, Tp:Type, Subst:Substitution} := metaNarrow(M, lhs(Eq), 1) .
  eq $checkAEqAux(M, none) = true .

  ceq $anyLonelyAssoc(op F : Tp Tp -> Tp [assoc AtS] . OPDS)
    = true
    if not comm in AtS .
  eq $anyLonelyAssoc(OPDS) = false [owise] .
endfm

-------------------------------------------------------------------------------

fmod AX-COHERENCE-COMPLETION is
  inc UNIT .
  inc MODULE-HANDLING * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) .

  vars V W : Variable .
  var  C : Constant .
  var  FM : FModule .
  var  SM : SModule .
  var  M : Module .
  var  N : Nat .
  vars T T' T'' LHS RHS : Term .
  vars Subst Subst' : Substitution .
  var  F : Qid .
  var  TL : TermList .
  vars AtS AtS' : AttrSet .
----  var  VFS : VariantFourSet .
  vars Tp Tp' Tp'' : Type .
  var  TpL : TypeList .
  var  Rl : Rule .
  var  RlS : RuleSet .
  var  Eq : Equation .
  var  EqS : EquationSet .
  var  ODS : OpDeclSet .
  var  Cond : Condition .
  var  QIL : QidList .

  ------------------------------------------------------------------------------
  ---- coherence completion
  ------------------------------------------------------------------------------

  op axCohComplete : SModule -> SModule .
  op axCohComplete : SModule OpDeclSet RuleSet -> RuleSet .
  op axCohComplete : SModule Type AttrSet Rule -> RuleSet .
  op axCohComplete : SModule OpDeclSet EquationSet -> EquationSet .
  op axCohComplete : SModule Type AttrSet Equation -> EquationSet .

  eq axCohComplete(FM)
    = moreGeneralEqs(setEqs(FM, axCohComplete(FM, getOps(FM), getEqs(FM)))) .
  eq axCohComplete(SM)
    = moreGeneralEqs(
        moreGeneralRls(
          setRls(
            setEqs(SM,
              axCohComplete(SM, getOps(SM), getEqs(SM))),
            axCohComplete(SM, getOps(SM), getRls(SM)))))
    [owise] .
  eq axCohComplete(unitError(QIL)) = unitError(QIL) .

  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, rl F[TL] => RHS [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc AtS, rl F[TL] => RHS [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, RlS)
    if sameKind(M, Tp, Tp')
    /\ sameKind(M, Tp', Tp'')
    /\ sameKindAll(M, Tp, eLeastSort(M, TL)) .
  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, crl F[TL] => RHS if Cond [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc AtS, crl F[TL] => RHS if Cond [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, RlS)
    if sameKind(M, Tp, Tp')
    /\ sameKind(M, Tp', Tp'')
    /\ sameKindAll(M, Tp, eLeastSort(M, TL)) .
  eq axCohComplete(M, ODS, rl LHS => RHS [AtS] . RlS)
    = rl LHS => RHS [AtS] . axCohComplete(M, ODS, RlS)
    [owise] .
  eq axCohComplete(M, ODS, crl LHS => RHS if Cond [AtS] . RlS)
    = crl LHS => RHS if Cond [AtS] . axCohComplete(M, ODS, RlS)
    [owise] .
  eq axCohComplete(M, ODS, (none).RuleSet) = none .

  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, eq F[TL] = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc AtS, eq F[TL] = RHS [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, EqS)
    if sameKind(M, Tp, Tp')
    /\ sameKind(M, Tp', Tp'')
    /\ sameKindAll(M, Tp, eLeastSort(M, TL)) .
  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, ceq F[TL] = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc AtS, ceq F[TL] = RHS if Cond [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, EqS)
    if sameKind(M, Tp, Tp')
    /\ sameKind(M, Tp', Tp'')
    /\ sameKindAll(M, Tp, eLeastSort(M, TL)) .
  eq axCohComplete(M, ODS, eq LHS = RHS [AtS] . EqS)
    = eq LHS = RHS [AtS] . axCohComplete(M, ODS, EqS)
    [owise] .
  eq axCohComplete(M, ODS, ceq LHS = RHS if Cond [AtS] . EqS)
    = ceq LHS = RHS if Cond [AtS] . axCohComplete(M, ODS, EqS)
    [owise] .
  eq axCohComplete(M, ODS, (none).EquationSet) = none .

  ---- Given f(t1,...,tn) -> r if C
  ---- if f AC add f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[TL] => RHS [AtS'] .)
      (rl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => F[RHS, qid("X@@@:" + string(getKind(M, Tp)))] [AtS'] .)
    [owise] .
  eq axCohComplete(M, Tp, assoc comm AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[TL] => RHS if Cond [AtS'] .)
      (crl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => F[RHS, qid("X@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .)
    [owise] .
  ---- if f ACU replace by f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => F[RHS, qid("X@@@:" + string(getKind(M, Tp)))] [AtS'] .) .
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => F[RHS, qid("X@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .) .
  ---- if f AU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] [AtS'] .)
    if not comm in AtS .
  ceq axCohComplete(M, Tp, assoc id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .)
    if not comm in AtS .
  ---- if f ALU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] [AtS'] .)
      (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         => F[qid("X@@@:" + string(getKind(M, Tp))), RHS] [AtS'] .)  .
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .)
      (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         => F[qid("X@@@:" + string(getKind(M, Tp))), RHS] if Cond [AtS'] .)  .
  ---- if f ARU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] [AtS'] .)
      (rl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))] [AtS'] .) .
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .)
      (crl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .) .
  ---- if f A add f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----            f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  ----            f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[TL] => RHS [AtS'] .)
      (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] [AtS'] .)
      (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         => F[qid("X@@@:" + string(getKind(M, Tp))), RHS] [AtS'] .)
      (rl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))] [AtS'] .)
    if not comm in AtS
    [owise] .
  ceq axCohComplete(M, Tp, assoc AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[TL] => RHS if Cond [AtS'] .)
      (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .)
      (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         => F[qid("X@@@:" + string(getKind(M, Tp))), RHS] if Cond [AtS'] .)
      (crl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .)
    if not comm in AtS
    [owise] .

  ---- Given f(t1,...,tn) -> r if C
  ---- if f AC add f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[TL] = RHS [AtS'] .)
      (eq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = F[RHS, qid("X@@@:" + string(getKind(M, Tp)))] [AtS'] .)
    [owise] .
  eq axCohComplete(M, Tp, assoc comm AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[TL] = RHS if Cond [AtS'] .)
      (ceq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = F[RHS, qid("X@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .)
    [owise] .
  ---- if f ACU replace by f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = F[RHS, qid("X@@@:" + string(getKind(M, Tp)))] [AtS'] .) .
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = F[RHS, qid("X@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .) .
  ---- if f AU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] [AtS'] .)
    if not comm in AtS .
  ceq axCohComplete(M, Tp, assoc id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .)
    if not comm in AtS .
  ---- if f ALU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] [AtS'] .)
      (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         = F[qid("X@@@:" + string(getKind(M, Tp))), RHS] [AtS'] .)  .
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .)
      (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         = F[qid("X@@@:" + string(getKind(M, Tp))), RHS] if Cond [AtS'] .)  .
  ---- if f ARU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] [AtS'] .)
      (eq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))] [AtS'] .) .
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .)
      (ceq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .) .
  ---- if f A add f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----            f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  ----            f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[TL] = RHS [AtS'] .)
      (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] [AtS'] .)
      (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         = F[qid("X@@@:" + string(getKind(M, Tp))), RHS] [AtS'] .)
      (eq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))] [AtS'] .)
    if not comm in AtS
    [owise] .
  ceq axCohComplete(M, Tp, assoc AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[TL] = RHS if Cond [AtS'] .)
      (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .)
      (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         = F[qid("X@@@:" + string(getKind(M, Tp))), RHS] if Cond [AtS'] .)
      (ceq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))] if Cond [AtS'] .)
    if not comm in AtS
    [owise] .
endfm

*******************************************************************************

***
*** Interaction with the Persistent Database
***

*** In the case of Full Maude, the persistent state of the system is given by
*** a single object which maintains the database of the system. This object
*** has an attribute \texttt{db}, to keep the actual database in which all the
*** modules being entered are stored, an attribute \texttt{default}, to keep
*** the identifier of the current module by default, and attributes
*** \texttt{input} and \texttt{output} to simplify the communication of the
*** read-eval-print loop given by the \texttt{LOOP-MODE} module with the
*** database. Using the notation for classes in object-oriented modules (see
*** Section~\ref{object-oriented-modules}) we can declare the class
*** \texttt{database} as follows:
***
***   class database | db : Database, input : TermList,
***                    output : QidList, default : ModId .
***
*** Since we assume that \texttt{database} is the only object class that has
*** been defined---so that the only objects of sort \texttt{Object} will
*** belong to the \texttt{database} class---to specify the admissible states
*** in the persistent state of \texttt{LOOP-MODE} for Full Maude, it is enough
*** to give the subsort declaration
***
***   subsort Object < State .

***
*** \subsection{The \texttt{CONFIGURATION+} Module}
***

*** change (2/20/2002): CONFIGURATION is now part of the prelude
***
*** fmod CONFIGURATION is
***   sort Oid Cid Attribute AttributeSet Configuration Object Msg .
***
***   subsort Attribute < AttributeSet .
***   subsorts Object Msg < Configuration .
***
***   op none : -> AttributeSet .
***   op _,_ : AttributeSet AttributeSet -> AttributeSet
***       [assoc comm id: none] .
***   op none : -> Configuration .
***   op __ : Configuration Configuration -> Configuration
***       [assoc comm id: none] .
***   op <_:_|_> : Oid Cid AttributeSet -> Object .
***   op <_:_| > : Oid Cid -> Object .
***
***   var O : Oid .
***   var C : Cid .
***
***   eq < O : C | > = < O : C | none > .
*** endfm

*******************************************************************************

***
*** Top Level Handling of the Persistent Database
***

*** Note that, since the Full Maude specification is given as a system module
***Core Maude, object-oriented declarations cannot be given directly.
*** Instead, the equivalent declarations desugaring the desired
*** object-oriented declarations have to be specified. We use also the same
*** conventions discussed in Section~\ref{omod2mod} regarding the use of
*** variables instead of class names in the objects and in the addition of
*** variables of sort \texttt{AttributeSet} to range over the additional
*** attributes. As we shall see in Chapter~\ref{crc}, this convention will
*** allow us to extend the Full Maude system in a very simple and clean way.

*** To allow the use of the object-oriented notation the predefined module
*** \texttt{CONFIGURATION}, presented in Section~\ref{omod2mod}, is included
*** in the following module \texttt{DATABASE-HANDLING}.


mod DATABASE-HANDLING is
---  inc META-LEVEL + PRE-VARIANT .
  inc META-LEVEL .
  inc CONFIGURATION .
  pr VIEW-META-PRETTY-PRINT .
  pr VIEW-PROCESSING .
  pr COMMAND-PROCESSING .
  pr PREDEF-UNITS .
  pr MODULE-VARIANTS .
  pr AX-COHERENCE-COMPLETION .
  pr HELP .

  var  F : Qid .
  var  QIL : QidList .
  var  NQIL NQIL' NQIL'' : NeQidList .
  vars T T' T'' T3 : Term .
  var  TL : TermList .
  var  DB DB' : Database .
  vars ME ME' ME'' : ModuleExpression .
  vars QIL' QIL'' : QidList .
  vars MNS MNS' MNS'' MNS3 MNS4 : Set{ModuleName} .
  var  VE : ViewExp .
  var  VES : Set{ViewExp} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars PDS PDS' : Set{ParameterDecl} .
  var  B : Bool .
  var  I : Import .
  var  IL : ImportList .
  var  MN : ModuleName .

  op initialDatabase : -> Database .
  eq initialDatabase
    = insTermModule('META-MODULE,
        addOps(getOps(#UP#),
          addSorts(getSorts(#UP#),
            addImports(getImports(#UP#), upModule('META-MODULE, false)))),
        emptyDatabase) .
---(
  eq initialDatabase
    = insTermModule('META-MODULE,
        addOps(getOps(#UP#),
          addSorts(getSorts(#UP#),
            addImports(getImports(#UP#), upModule('META-MODULE, false)))),
      insertTermView('TRIV,
        ('view_from_to_is_endv['token[''TRIV.Qid],'token[''TRIV.Qid],'token[
         ''TRIV.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Elt.Qid]]]),
      insertTermView('Bool,
        ('view_from_to_is_endv['token[''Bool.Qid],'token[''TRIV.Qid],'token[
         ''BOOL.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Bool.Qid]]]),
      insertTermView('Nat,
        ('view_from_to_is_endv['token[''Nat.Qid],'token[''TRIV.Qid],'token[
         ''NAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Nat.Qid]]]),
      insertTermView('Int,
        ('view_from_to_is_endv['token[''Int.Qid],'token[''TRIV.Qid],'token[
         ''INT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Int.Qid]]]),
      insertTermView('Rat,
        ('view_from_to_is_endv['token[''Rat.Qid],'token[''TRIV.Qid],'token[
         ''RAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Rat.Qid]]]),
      insertTermView('Float,
        ('view_from_to_is_endv['token[''Float.Qid],'token[''TRIV.Qid],'token[
         ''FLOAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Float.Qid]]]),
      insertTermView('String,
        ('view_from_to_is_endv['token[''String.Qid],'token[''TRIV.Qid],'token[
         ''STRING.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''String.Qid]]]),
      insertTermView('Qid,
        ('view_from_to_is_endv['token[''Qid.Qid],'token[''TRIV.Qid],'token[
         ''QID.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Qid.Qid]]]),
      insertTermView('STRICT-WEAK-ORDER,
        ('view_from_to_is_endv['token[''STRICT-WEAK-ORDER.Qid],'token[''TRIV.Qid],
         'token[''STRICT-WEAK-ORDER.Qid],'sort_to_.['sortToken[''Elt.Qid],
         'sortToken[''Elt.Qid]]]),
      insertTermView('STRICT-TOTAL-ORDER,
        ('view_from_to_is_endv['token[''STRICT-TOTAL-ORDER.Qid],
         'token[''STRICT-WEAK-ORDER.Qid],'token[''STRICT-TOTAL-ORDER.Qid],
         'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Elt.Qid]]]),
      insertTermView('Nat<,
        ('view_from_to_is_endv['token[''Nat<.Qid],'token[''STRICT-TOTAL-ORDER.Qid],
         'token[''NAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Nat.Qid]]]),
      insertTermView('Int<,
        ('view_from_to_is_endv['token[''Int<.Qid],'token[''STRICT-TOTAL-ORDER.Qid],
         'token[''INT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Int.Qid]]]),
      insertTermView('Rat<,
        ('view_from_to_is_endv['token[''Rat<.Qid],'token[''STRICT-TOTAL-ORDER.Qid],'token[
         ''RAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Rat.Qid]]]),
      insertTermView('Float<,
        ('view_from_to_is_endv['token[''Float<.Qid],'token[''STRICT-TOTAL-ORDER.Qid],
         'token[''FLOAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Float.Qid]]]),
      insertTermView('String<,
        ('view_from_to_is_endv['token[''String<.Qid],'token[''STRICT-TOTAL-ORDER.Qid],
         'token[''STRING.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''String.Qid]]]),
      insertTermView('TOTAL-PREORDER,
        ('view_from_to_is_endv['token[''TOTAL-PREORDER.Qid],'token[''TRIV.Qid],'token[
         ''TOTAL-PREORDER.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Elt.Qid]]]),
      insertTermView('TOTAL-ORDER,
        ('view_from_to_is_endv['token[''TOTAL-ORDER.Qid],'token[''TOTAL-PREORDER.Qid],
         'token[''TOTAL-ORDER.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Elt.Qid]]]),
      insertTermView('Nat<=,
        ('view_from_to_is_endv['token[''Nat<=.Qid],'token[''TOTAL-ORDER.Qid],
         'token[''NAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Nat.Qid]]]),
      insertTermView('Int<=,
        ('view_from_to_is_endv['token[''Int<=.Qid],'token[''TOTAL-ORDER.Qid],
         'token[''INT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Int.Qid]]]),
      insertTermView('Rat<=,
        ('view_from_to_is_endv['token[''Rat<=.Qid],'token[''TOTAL-ORDER.Qid],'token[
         ''RAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Rat.Qid]]]),
      insertTermView('Float<=,
        ('view_from_to_is_endv['token[''Float<=.Qid],'token[''TOTAL-ORDER.Qid],
         'token[''FLOAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Float.Qid]]]),
      insertTermView('String<=,
        ('view_from_to_is_endv['token[''String<=.Qid],'token[''TOTAL-ORDER.Qid],
         'token[''STRING.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''String.Qid]]]),
      insertTermView('DEFAULT,
        ('view_from_to_is_endv['token[''DEFAULT.Qid],'token[''TRIV.Qid],'token[
         ''DEFAULT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Elt.Qid]]]),
      insertTermView('Nat0,
        ('view_from_to_is_endv['token[''Nat0.Qid],'token[''DEFAULT.Qid],'token[
         ''NAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Nat.Qid]]]),
      insertTermView('Int0,
        ('view_from_to_is_endv['token[''Int0.Qid],'token[''DEFAULT.Qid],'token[
         ''INT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Int.Qid]]]),
      insertTermView('Rat0,
        ('view_from_to_is_endv['token[''Rat0.Qid],'token[''DEFAULT.Qid],'token[
         ''RAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Rat.Qid]]]),
      insertTermView('Float0,
        ('view_from_to_is_endv['token[''Float0.Qid],'token[''DEFAULT.Qid],
         'token[''FLOAT.Qid],'__['sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Float.Qid]], 'op_to`term_.['bubble[''0.Qid],'bubble[''0.0.Qid]]]]),
      insertTermView('String0,
        ('view_from_to_is_endv['token[''String0.Qid],'token[''DEFAULT.Qid],
         'token[''STRING.Qid],'__['sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''String.Qid]],'op_to`term_.['bubble[''0.Qid],'bubble[''"".Qid]]]]),
      insertTermView('Qid0,
        ('view_from_to_is_endv['token[''Qid0.Qid],'token[''DEFAULT.Qid],'token[
         ''QID.Qid],'__['sort_to_.['sortToken[''Elt.Qid],'sortToken[''Qid.Qid]],
         'op_to`term_.['bubble[''0.Qid],'bubble['''.Qid]]]]),
      emptyDatabase)))))))))))))))))))))))))))))) .
---)

*** We start by introducing a subsort \texttt{DatabaseClass} of sort
*** \texttt{Cid}, the operator declarations necessary for representing objects
*** in class \texttt{DatabaseClass} as defined above, and variables to range
*** over subclasses of class \texttt{DatabaseClass} and over attributes.

  sort DatabaseClass .
  subsort DatabaseClass < Cid .
  op Database : -> DatabaseClass .
  op db :_ : Database -> Attribute .
  op input :_ : TermList -> Attribute .
  op output :_ : QidList -> Attribute .
  op default :_ : Header -> Attribute .

  var Atts : AttributeSet .
  var X@DatabaseClass : DatabaseClass .
  var O : Oid .

*** Next, we introduce an auxiliary function \texttt{parseHeader} to parse
*** names of user-defined modules, and a constant \texttt{nilTermList} of sort
*** \texttt{TermList}. Note that the name of a user-defined module must be a
*** single identifier (a token) or, for parameterized modules, its name---a
*** single identifier---and its interface.

  op parseHeader : Term -> Qid .
  eq parseHeader('token[T]) = downQid(T) .
  ----eq parseHeader('_`(_`)['token[T], T']) = downQid(T) .
  eq parseHeader('_`{_`}['token[T], T']) = downQid(T) .

  op nilTermList : -> TermList .

*** Finally, we present the rules processing the inputs of the database. These
*** rules define the behavior of the system for the different commands,
*** modules, theories, and views entered into the system. For example, the
*** first rule processes the different types of modules entered to the system.
*** Note that the operators declared as constructors of sort \texttt{PreModule}
*** in the signature of Full Maude, given in
*** Appendix~\ref{signature-full-maude}, are declared with two arguments,
*** namely the name of the unit, or its name + its interface, and the list
*** of declarations of such a unit.

  crl [module] :
     < O : X@DatabaseClass | db : DB, input : (F[T, T']), output : nil, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : procModule(F[T, T'], DB), input : nilTermList,
           output : ('Introduced 'module header2Qid(parseHeader(T)) '\n),
           default : parseHeader(T), Atts >
     if  (F == 'fmod_is_endfm) or-else
        ((F == 'obj_is_endo)   or-else
        ((F == 'obj_is_jbo)    or-else
        ((F == 'mod_is_endm)   or-else
         (F == 'omod_is_endom)))) .

*** Notice the message placed in the output channel, and the change in the
*** current module by default, which is now the new module just processed.
*** Since the name of the module \texttt{T} can be complex---a parameterized
*** module---some extra parsing has to be performed by the auxiliary function
*** \texttt{parseHeader}. Similar rules are given for the processing of
*** theories and views.

  crl [theory] :
     < O : X@DatabaseClass | db : DB, input : (F[T, T']), output : nil, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : procModule(F[T, T'], DB), input : nilTermList,
           output : ('Introduced 'theory header2Qid(parseHeader(T)) '\n),
           default : parseHeader(T), Atts >
     if  (F == 'fth_is_endfth) or-else
        ((F == 'th_is_endth)   or-else
         (F == 'oth_is_endoth)) .

  rl [view] :
     < O : X@DatabaseClass | db : DB,
        input : ('view_from_to_is`endv[T, T', T'']),
        output : nil, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : procView('view_from_to_is_endv[T, T', T'', 'none.ViewDeclSet], DB),
           input : nilTermList,
           output : ('Introduced 'view header2Qid(parseHeader(T)) '\n),
           default : ME, Atts > .
  rl [view] :
     < O : X@DatabaseClass | db : DB,
        input : ('view_from_to_is_endv[T, T', T'', T3]),
        output : nil, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : procView('view_from_to_is_endv[T, T', T'', T3], DB),
           input : nilTermList,
           output : ('Introduced 'view header2Qid(parseHeader(T)) '\n),
           default : ME, Atts > .

*** Commands are handled by rules as well. For example, the \texttt{down},
*** \texttt{reduce}, and \texttt{rewrite} commands are handled by the
*** following rules.

  rl [down] :
     < O : X@DatabaseClass | db : DB, input : ('down_:_[T, T']), output : nil, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : getDatabase(procDownCommand('down_:_[T, T'], ME, DB)),
           input : nilTermList,
           output : getQidList(procDownCommand('down_:_[T, T'], ME, DB)),
           default : ME, Atts > .

  crl [red/rew/frew] :
     < O : X@DatabaseClass | db : DB, input : (F[T]), output : QIL, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : getDatabase(procCommand(F[T], ME, DB)),
           input : nilTermList,
           output : getQidList(procCommand(F[T], ME, DB)),
           default : ME, Atts >
     if  (F == 'parse_.)    or-else
        ((F == 'red_.)      or-else
        ((F == 'reduce_.)   or-else
        ((F == 'rew_.)      or-else
        ((F == 'rewrite_.)  or-else
        ((F == 'frew_.)     or-else
        ((F == 'frewrite_.) or-else
        ((F == 'unify_.) or-else
         (F == 'id-unify_.) or-else
         (F == 'variant`unify_.) or-else
         (F == 'asymmetric`variant`unify_.) or-else
         (F == 'get`variants_.)
         ))))))) .

  crl [search] :
     < O : X@DatabaseClass | db : DB, input : (F[T, T']), output : QIL, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : getDatabase(procCommand(F[T, T'], ME, DB)),
           input : nilTermList,
           output : getQidList(procCommand(F[T, T'], ME, DB)),
           default : ME, Atts >
     if  (F == 'search_=>_.)  or-else
        ((F == 'search_=>1_.) or-else
        ((F == 'search_=>*_.) or-else
        ((F == 'search_=>+_.) or-else
        ((F == 'search_=>!_.) or-else
        ((F == 'search_~>_.)  or-else
        ((F == 'search_~>1_.) or-else
        ((F == 'search_~>*_.) or-else
        ((F == 'search_~>+_.) or-else
        ((F == 'search_~>!_.) or-else
        ((F == 'match_<=?_.)  or-else
         (F == 'xmatch_<=?_.))))))))))) .

  rl [select] :
     < O : X@DatabaseClass | db : DB, input : ('select_.[T]), output : QIL, default : ME, Atts >
     => < O : X@DatabaseClass | db : DB, input : nilTermList, output : (QIL 'The eMetaPrettyPrint(parseModExp(T)) 'has 'been 'set 'as 'current 'module. '\n), default : parseModExp(T), Atts > .

  rl [show-modules] :
     < O : X@DatabaseClass | db : DB,
        input : ('show`modules`..@Command@),
        output : nil, default : ME, Atts >
     => < O : X@DatabaseClass | db : DB, input : nilTermList,
           output : showModules(DB), default : ME, Atts > .
  rl [show-views] :
     < O : X@DatabaseClass | db : DB,
        input : ('show`views`..@Command@),
        output : nil, default : ME, Atts >
     => < O : X@DatabaseClass | db : DB, input : nilTermList,
           output : showViews(DB), default : ME, Atts >  .

*** The \texttt{show module} command, which prints the specified module, or
*** the current one if no module name is specified, is handled by the
*** following rules.

  crl [show-module] :
    < O : X@DatabaseClass | db : DB,
       input : ('show`module`..@Command@),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getTopModule(ME', DB')),
          default : ME', Atts >
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [show-module] :
    < O : X@DatabaseClass | db : DB, input : ('show`module_.[T]), output : nil, default : ME,   Atts >
    => < O : X@DatabaseClass |
          db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME'', DB'), getTopModule(ME'', DB')),
          default : ME, Atts >
    if < DB' ; ME'' > := evalModExp(parseModExp(T), DB) .
  crl [show-module] :
    < O : X@DatabaseClass | db : DB, input : ('show`module_.[T]), output : nil, Atts >
    => < O : X@DatabaseClass | db : DB, input : nil,
          output : ('Error 'evaluating 'the 'given 'module 'expression.), Atts >
    if evalModExp(ME:[ModuleExpression], DB':[Database]) := evalModExp(parseModExp(T), DB) .

  crl [show-all] :
    < O : X@DatabaseClass | db : DB, input : ('show`all`..@Command@),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getFlatModule(ME', DB')),
          default : ME', Atts >
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [show-all] :
    < O : X@DatabaseClass | db : DB, input : ('show`all_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getFlatModule(ME', DB')),
          default : ME, Atts >
    if ME'' := parseModExp(T)
    /\ < DB' ; ME' > := evalModExp(ME'', DB) .

  crl [show-vars] :
    < O : X@DatabaseClass | db : DB, input : ('show`vars`..@Command@),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrintVars(getVars(ME', DB')),
          default : ME', Atts >
    if DB' := database(evalModExp(ME, DB))
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-vars] :
    < O : X@DatabaseClass | db : DB, input : ('show`vars_.[T]),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrintVars(getVars(ME', DB')),
          default : ME, Atts >
    if ME'' := parseModExp(T)
       /\ DB' := database(evalModExp(ME'', DB))
       /\ ME' := modExp(evalModExp(ME'', DB)) .

  crl [show-sorts] :
    < O : X@DatabaseClass | db : DB, input : ('show`sorts`..@Command@), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getSorts(getFlatModule(ME', DB'))),
          default : ME', Atts >
    if DB' := database(evalModExp(ME, DB))
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-sorts] :
    < O : X@DatabaseClass | db : DB, input : ('show`sorts_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getSorts(getFlatModule(ME', DB'))),
          default : ME, Atts >
    if ME'' := parseModExp(T)
       /\ DB' := database(evalModExp(ME'', DB))
       /\ ME' := modExp(evalModExp(ME'', DB)) .

  crl [show-ops] :
    < O : X@DatabaseClass | db : DB, input : ('show`ops`..@Command@), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getOps(getFlatModule(ME', DB'))),
          default : ME', Atts >
    if DB' := database(evalModExp(ME, DB))
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-ops] :
    < O : X@DatabaseClass | db : DB, input : ('show`ops_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getOps(getFlatModule(ME', DB'))),
          default : ME, Atts >
    if ME'' := parseModExp(T)
       /\ DB' := database(evalModExp(ME'', DB))
       /\ ME' := modExp(evalModExp(ME'', DB)) .

  crl [show-mbs] :
    < O : X@DatabaseClass | db : DB, input : ('show`mbs`..@Command@), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getMbs(getFlatModule(ME', DB'))),
          default : ME', Atts >
    if DB' := database(evalModExp(ME, DB))
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-mbs] :
    < O : X@DatabaseClass | db : DB, input : ('show`mbs_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getMbs(getFlatModule(ME', DB'))),
          default : ME, Atts >
    if ME := parseModExp(T)
       /\ DB' := database(evalModExp(ME, DB))
       /\ ME' := modExp(evalModExp(ME, DB)) .

  crl [show-eqns] :
    < O : X@DatabaseClass | db : DB, input : ('show`eqs`..@Command@), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass |
          db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getEqs(getFlatModule(ME', DB'))),
         default : ME', Atts >
    if DB' := database(evalModExp(ME, DB))
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-eqns] :
    < O : X@DatabaseClass | db : DB, input : ('show`eqs_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass |
          db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getEqs(getFlatModule(ME', DB'))),
          default : ME, Atts >
    if ME'' := parseModExp(T)
       /\ DB' := database(evalModExp(ME'', DB))
       /\ ME' := modExp(evalModExp(ME'', DB)) .

  crl [show-rls] :
    < O : X@DatabaseClass | db : DB, input : ('show`rls`..@Command@), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getRls(getFlatModule(ME', DB'))),
          default : ME', Atts >
    if DB' := database(evalModExp(ME, DB))
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-rls] :
    < O : X@DatabaseClass | db : DB, input : ('show`rls_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getRls(getFlatModule(ME', DB'))),
          default : ME, Atts >
    if ME'' := parseModExp(T)
       /\ DB' := database(evalModExp(ME'', DB))
       /\ ME' := modExp(evalModExp(ME'', DB)) .

  crl [show-view] :
     < O : X@DatabaseClass | db : DB, input : ('show`view_.[T]), output : nil, default : ME, Atts >
     => < O : X@DatabaseClass | db : DB', input : nilTermList,
           output : eMetaPrettyPrint(DB', getView(parseViewExp(T), DB')),
           default : ME, Atts >
     if DB' := evalViewExp(parseViewExp(T), nil, DB) .

  crl [set`protect_on] :
     < O : X@DatabaseClass |
           db : DB,
           input : ('set`protect_on`.[T]),
           output : QIL',
           default : ME, Atts >
     => < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES,
                   MNS' ME', MNS'', MNS3, QIL),
           input : nilTermList,
           output : (QIL' 'set 'protect header2QidList(ME') 'on '\n),
           default : ME, Atts >
     if ME' := parseModExp(T)
        /\ unitInDb(ME', DB)
        /\ db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL) := DB .
  crl [set`protect_off] :
     < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL),
           input : ('set`protect_off`.[T]),
           output : QIL',
           default : ME, Atts >
     => < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES, remove(MNS', ME'), MNS'', MNS3, QIL),
           input : nilTermList,
           output : (QIL' 'set 'protect header2QidList(ME') 'off '\n),
           default : ME, Atts >
     if ME' := parseModExp(T) .

  crl [set`extend_on] :
     < O : X@DatabaseClass |
           db : DB,
           input : ('set`extend_on`.[T]),
           output : QIL',
           default : ME, Atts >
     => < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES,
                   MNS', MNS'' ME', MNS3, QIL),
           input : nilTermList,
           output : (QIL' 'set 'extend header2QidList(ME') 'on '\n),
           default : ME, Atts >
     if ME' := parseModExp(T)
        /\ unitInDb(ME', DB)
        /\ db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL) := DB .
  crl [set`extend_off] :
     < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL),
           input : ('set`extend_off`.[T]),
           output : QIL',
           default : ME, Atts >
     => < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES, MNS', remove(MNS'', ME'), MNS3, QIL),
           input : nilTermList,
           output : (QIL' 'set 'extend header2QidList(ME') 'off '\n),
           default : ME, Atts >
     if ME' := parseModExp(T) .

  crl [set`include_on] :
     < O : X@DatabaseClass |
           db : DB,
           input : ('set`include_on`.[T]),
           output : QIL',
           default : ME, Atts >
     => < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES,
                   MNS', MNS'', MNS3 . ME', QIL),
           input : nilTermList,
           output : (QIL' 'set 'include header2QidList(ME') 'on '\n),
           default : ME, Atts >
     if ME' := parseModExp(T)
        ----/\ unitInDb(ME', DB)
        /\ db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL) := DB .
  crl [set`include_off] :
     < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL),
           input : ('set`include_off`.[T]),
           output : QIL',
           default : ME, Atts >
     => < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES, MNS', MNS'', remove(MNS3, ME'), QIL),
           input : nilTermList,
           output : (QIL' 'set 'include header2QidList(ME') 'off '\n),
           default : ME, Atts >
     if ME' := parseModExp(T) .

  crl [load] :
     < O : X@DatabaseClass |
           db : DB,
           input : ('load_.[T]),
           output : QIL',
           default : ME, Atts >
     => < O : X@DatabaseClass |
           db : getDatabase(procLoad(T, ME, DB)),
           input : nilTermList,
           output : getQidList(procLoad(T, ME, DB)),
           default : ME, Atts >
     if ME' := parseModExp(T) .

  eq 'rm`ids`..@Command@ = 'remove`identity`attributes`..@Command@ .
  eq 'rm`ids_.[T] = 'remove`identity`attributes_.[T] .

  crl [remove-id-attributes] :
    < O : X@DatabaseClass | db : DB,
       input : ('remove`identity`attributes`..@Command@),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME', DB'), removeIds(getFlatModule(ME', DB'), all))),
          default : ME', Atts >
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [remove-id-attributes] :
    < O : X@DatabaseClass | db : DB, input : ('remove`identity`attributes_.[T]), output : nil, default : ME,   Atts >
    => < O : X@DatabaseClass |
          db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME'', DB'), removeIds(axCohComplete(getFlatModule(ME'', DB')), all))),
          default : ME, Atts >
    if < DB' ; ME'' > := evalModExp(parseModExp(T), DB) .

  eq 'rm`nh`ids`..@Command@ = 'remove`non-handled`identity`attributes`..@Command@ .
  eq 'rm`nh`ids_.[T] = 'remove`non-handled`identity`attributes_.[T] .

  crl [remove-id-attributes] :
    < O : X@DatabaseClass | db : DB,
       input : ('remove`non-handled`identity`attributes`..@Command@),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME', DB'), removeIds(getFlatModule(ME', DB'), non-handled))),
          default : ME', Atts >
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [remove-id-attributes] :
    < O : X@DatabaseClass | db : DB, input : ('remove`non-handled`identity`attributes_.[T]), output : nil, default : ME,   Atts >
    => < O : X@DatabaseClass |
          db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME'', DB'), removeIds(getFlatModule(ME'', DB'), non-handled))),
          default : ME, Atts >
    if < DB' ; ME'' > := evalModExp(parseModExp(T), DB) .

  crl [remove-assoc-attributes] :
    < O : X@DatabaseClass | db : DB,
       input : ('remove`assoc`attributes`..@Command@),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME', DB'), removeLonelyAssocs(getFlatModule(ME', DB')))),
          default : ME', Atts >
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [remove-assoc-attributes] :
    < O : X@DatabaseClass | db : DB, input : ('remove`assoc`attributes_.[T]), output : nil, default : ME,   Atts >
    => < O : X@DatabaseClass |
          db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME'', DB'), removeLonelyAssocs(getFlatModule(ME'', DB')))),
          default : ME, Atts >
    if < DB' ; ME'' > := evalModExp(parseModExp(T), DB) .

  crl [acu-coherence-completion] :
    < O : X@DatabaseClass | db : DB,
       input : ('ax`coherence`completion`..@Command@),
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME', DB'), axCohComplete(getFlatModule(ME', DB')))),
          default : ME', Atts >
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [acu-coherence-completion] :
    < O : X@DatabaseClass | db : DB, input : ('ax`coherence`completion_.[T]), output : nil, default : ME,   Atts >
    => < O : X@DatabaseClass |
          db : DB', input : nilTermList,
          output : (eMetaPrettyPrint(getFlatModule(ME'', DB'), axCohComplete(getFlatModule(ME'', DB')))),
          default : ME, Atts >
    if < DB' ; ME'' > := evalModExp(parseModExp(T), DB) .

  rl [error] :
     < O : X@DatabaseClass |
        db : db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, NQIL),
        input : TL, output : nil, default : ME, Atts >
     => < O : X@DatabaseClass |
           db : db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, nil),
           input : TL, output : NQIL, default : ME, Atts > .

  *** Auxiliary Functions

  op showViews : Database -> QidList .
  op showModules : Database -> QidList .

  eq showViews(db(MIS, MNS, VIS, (VE # VES), MNS', MNS'', MNS3, QIL))
    = (eMetaPrettyPrint(VE) '\n
       showViews(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))) .
  eq showViews(
       db(MIS, MNS, VIS, emptyViewExpSet, MNS', MNS'', MNS3, QIL))
    = nil .

  eq showModules(
       db(MIS, (MN . MNS), VIS, VES, MNS', MNS'', MNS3, QIL))
    = (eMetaPrettyPrint(MN) '\n
       showModules(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))) .
  eq showModules(
    db(MIS, emptyModuleNameSet, VIS, VES, MNS', MNS'', MNS3, QIL))
    = nil .

  rl [help] :
     < O : X@DatabaseClass | input : ('help`..@Command@), output : QIL, Atts >
     => < O : X@DatabaseClass | input : nilTermList, output : fm-help, Atts > .
endm

*******************************************************************************
fmod TEXT-STYLE is
--- pr META-LEVEL + PRE-VARIANT .
 pr META-LEVEL .

 var QL : QidList .

 op green : QidList -> QidList .
 eq green(QL) = '\g QL '\o .

 op yellow : QidList -> QidList .
 eq yellow(QL) = '\y QL '\o .

 op red : QidList -> QidList .
 eq red(QL) = '\r QL '\o .

 op bold : QidList -> QidList .
 eq bold(QL) = '\! QL '\o .
endfm

*******************************************************************************

***
*** The Full Maude Module
***

*** We now give the rules to initialize the loop, and to specify the
*** communication between the loop---the input/output of the system---and the
*** database.  Depending on the kind of input that the database receives, its
*** state will be changed, or some output will be generated.

mod FULL-MAUDE is
  pr META-FULL-MAUDE-SIGN .
  pr DATABASE-HANDLING .
  inc LOOP-MODE .
  pr BANNER .

*** The state of the persistent system, which is supported by the built-in
*** module \texttt{LOOP-MODE}, described in Section~\ref{loop}, is represented
*** as a single object.

  subsort Object < State .

  op o : -> Oid .
  op init : -> System .

  var  Atts : AttributeSet .
  var  X@DatabaseClass : DatabaseClass .
  var  O : Oid .
  var  DB : Database .
  var  ME : Header .
  var  QI : Qid .
  vars QIL QIL' QIL'' : QidList .
  var  TL : TermList .
  var  N : Nat .
  vars RP RP' : ResultPair .

  rl [init] :
     init
     => [nil,
         < o : Database |
            db : initialDatabase,
            input : nilTermList, output : nil,
            default : 'CONVERSION >,
         ('\n '\t '\s '\s '\s '\s string2qidList(banner) '\n)] .

*** When some text has been introduced in the loop, the first argument of the
*** operator \verb~[_,_,_,]~ is different from \texttt{nil}, and we can use
*** this fact to activate the following rule, that enters an input such as a
*** module or a command from the user into the database.  The constant
*** \texttt{GRAMMAR} names the module containing the signature defining the
*** top level syntax of Full Maude (see Section~\ref{sec:signature} and
*** Appendix~\ref{signature-full-maude}). This signature is used by the
*** \texttt{metaParse} function to parse the input. PD the input is
*** syntactically valid\footnote{Of course, the input may be syntactically
*** valid, but not semantically valid, since further processing---for example,
*** of bubbles---may reveal a semantic inconsistency.}, the parsed input is
*** placed in the \texttt{input} attribute of the database object; otherwise,
*** an error message is placed in the output channel of the loop.

  rl [in] :
    [QI QIL,
     < O : X@DatabaseClass |
         db : DB, input : nilTermList, output : nil, default : ME, Atts >,
     QIL']
    => if metaParse(GRAMMAR, QI QIL, '@Input@) :: ResultPair
       then [nil,
             < O : X@DatabaseClass | db : DB,
                 input : getTerm(metaParse(GRAMMAR, QI QIL, '@Input@)),
                 output : nil, default : ME, Atts >,
              QIL']
       else [nil,
             < O : X@DatabaseClass | db : DB, input : nilTermList,
                 output : ('\r 'Warning:
                           printSyntaxError(metaParse(GRAMMAR, QI QIL, '@Input@),
                             QI QIL)
                           '\n
                           '\r 'Error: '\o 'No 'parse 'for 'input. '\n),
                 default : ME, Atts >,
             QIL']
       fi .

*** When the \texttt{output} attribute of the persistent object contains a
*** nonempty list of quoted identifiers, the \texttt{out} rule moves it to the
*** third argument of the loop. Then the Core Maude system displays it in the
*** terminal.

  rl [out] :
    [QIL,
     < O : X@DatabaseClass |
         db : DB, input : TL, output : (QI QIL'), default : ME, Atts >,
     QIL'']
    => [QIL,
        < O : X@DatabaseClass |
            db : DB, input : TL, output : nil, default : ME, Atts >,
        (QI QIL' QIL'')] .
endm

*******************************************************************************

load ../cafeOBJ2maude.maude

--- loop init .

trace exclude FULL-MAUDE .

---- set show loop stats on .
---- set show loop timing on .
---- set show advisories on .


***(%

{\codesize
\begin{comment}
%)

fmod MAYBE{X :: TRIV} is
  sort Maybe{X} .
  subsort X$Elt < Maybe{X} .
  op maybe : -> Maybe{X} .
endfm

***(%
\end{comment}
}

We show here how the ideas described in the previous sections
are implemented. This implementation is done in Maude itself by means
of its reflective capabilities, that allow us to use Maude terms and
modules as data \cite[Chapter 14]{maude-book}. Sections \ref{subsec:ptd} to
\ref{subsec:dbt}
describe the tree construction stage, where the abbreviated proof trees
are constructed.
The tree navigation is explained in Section \ref{subsec:dbt}, and
the interaction with the user is explained in Section \ref{subsec:io}.

\subsection{Debugging trees definition}\label{subsec:ptd}

In this section we show how to represent in Maude the debugging trees. First,
we implement parametric general trees with
generic data in each node. Then, we instantiate them by defining the concrete
data for building our debugging trees.

The parameterized module that describes the behavior of the tree
receives the theory \texttt{TRIV} (that simply requires a sort \texttt{Elt})
as parameter.
We use lists of natural numbers to identify (the position of) each node:

{\codesize
\begin{verbatim}
%)

 fmod TREE{X :: TRIV} is
  pr NAT-LIST .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  var  T : Tree .
  vars F F' F'' : Forest .
  vars N N' : Nat .
  var  C : X$Elt .
  var  NL : NatList .

***(%
\end{verbatim}
}

\end{comment}

General trees are defined by means of the constructor \texttt{tree},
composed of some contents (received from
the theory), the size of the tree, and a \texttt{Forest},
which in turn is a list of trees:

{\codesize
\begin{verbatim}
%)

  sorts Tree Forest .
  subsort Tree < Forest .

  op tree(_,_,_) : X$Elt Nat Forest -> Tree [ctor format (ngi o d d d d ++i n--i d)] .

  op mtForest : -> Forest [ctor format (ni d)] .
  op __ : Forest Forest -> Forest [ctor assoc id: mtForest] .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  *** Repeated computations
  eq T F T = T F .

***(%
\end{verbatim}
}

\end{comment}

We define now some operations over trees.
The function \texttt{find} extracts the $n$th tree from a forest.
Notice the use of \verb"~>"
%\texttt{\raisebox{-.5ex}{\~{}}>}
in the operator declaration,
stating that the function is partial, that is, if the number
received as argument is bigger than the size of the forest, the
function is not defined:

{\codesize
\begin{verbatim}
%)

  op find : Forest Nat ~> Tree .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  eq find(T F, 0) = T .
  eq find(T F, s(N)) = find(F, N) .

***(%
\end{verbatim}
}

\end{comment}

The function \texttt{size} calculates the length of a forest:

{\codesize
\begin{verbatim}
%)

  op size : Forest -> Nat .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  eq size(mtForest) = 0 .
  eq size(T F) = s(size(F)) .

***(%
\end{verbatim}
}

\end{comment}

Given a tree and a list identifying a node, the function
\texttt{getContents} extracts the contents of the node described by the list,
\texttt{getForest} extracts its forest, \texttt{getSubTree} returns the whole
subtree, and \texttt{hasOffspring?} checks whether the forest of the node is not empty:

{\codesize
\begin{verbatim}
%)

  op getContents : Tree NatList ~> X$Elt .
  op getForest : Tree NatList ~> Forest .
  op getSubTree : Tree NatList ~> Tree .
  op hasOffspring? : Tree NatList ~> Bool .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  eq getContents(tree(C, N, F), N' NL) = getContents(find(F, N'), NL) .
  eq getContents(tree(C, N, F), nil) = C .

  eq getForest(tree(C, N, F), N' NL) = getForest(find(F, N'), NL) .
  eq getForest(tree(C, N, F), nil) = F .

  eq getSubTree(tree(C, N, F), N' NL) = getSubTree(find(F, N'), NL) .
  eq getSubTree(T, nil) = T .

  eq hasOffspring?(tree(C, N, F), N' NL) = hasOffspring?(find(F, N'), NL) .
  eq hasOffspring?(tree(C, N, F), nil) = F =/= mtForest .

***(%
\end{verbatim}
}

\end{comment}

{\codesize
\begin{verbatim}
  ...
%)

 endfm

***(%
\end{verbatim}
}

We use the sort \texttt{Judgment} to define the values kept in the
debugging trees.
When keeping reductions and memberships, we want to know the
name of the statement associated with the node and
the lefthand and righthand sides
of the computation, or the term and sort of a membership, respectively:

{\codesize
\begin{verbatim}
%)

 fmod DEBUGGING-TREE-NODE is
  pr MAYBE{Term} .
  pr META-LEVEL .

  sort Judgment .

  op _:_->_ : Qid Term Term -> Judgment [ctor format (b o d b o d)] .
  op _:_:_ : Qid Term Type -> Judgment [ctor format (b o d b o d)] .

***(%
\end{verbatim}
}

If the inferred type is the least sort, we use the special notation below:

{\codesize
\begin{verbatim}
%)

  op _:ls_ : Term Type -> Judgment [ctor format (d b o d)] .

***(%
\end{verbatim}
}

In the case of rewrites, we distinguish between nodes in the one-step tree
and nodes in the many-steps tree:

{\codesize
\begin{verbatim}
%)

  op _:_=>1_ : Qid Term Term -> Judgment [ctor format (b o d b o d)] .
  op _=>+_ : Term Term -> Judgment [ctor format (d b o d)] .

***(%
\end{verbatim}
}

Since the many-steps tree is computed on demand, its leaves
corresponding to one-step rewrites are
kept as ``frozen,'' and will be evaluated only if needed:

{\codesize
\begin{verbatim}
%)

  op _=>f_ : Term Term -> Judgment [ctor format (d b o d)] .

***(%
\end{verbatim}
}

The nodes for debugging missing answers in system modules keep the
initial term and the list of possible results. We distinguish between:

\begin{itemize}

\item The set of reachable terms in one step:

{\codesize
\begin{verbatim}
%)

  op _=>1{_} : Term TermList -> Judgment [ctor format (d b o d d d)] .

***(%
\end{verbatim}
}

\item The set of reachable terms by applying one rule:

{\codesize
\begin{verbatim}
%)

  op _=>q[_]{_} : Term Qid TermList -> Judgment [ctor format (d b o d d d d d d)] .

***(%
\end{verbatim}
}

\item The set of reachable terms when many rewrite steps are used.
In this case we also keep the bound, the pattern, the condition and
a Boolean value indicating whether this search corresponds to the initial
one, and thus these terms are the reachable \emph{solutions} from the initial
one, or corresponds to a search due to a rewrite condition:

{\codesize
\begin{verbatim}
%)

  op _~>[_]{_}s.t._&_[_] : Term Bound TermList Term Condition Bool
                           -> Judgment [ctor format (d b o d d d d d d d d d d d d d)] .

***(%
\end{verbatim}
}

\end{itemize}

We use the operator \texttt{sol} to indicate (the Boolean value in the fourth
argument) whether a term (the first argument) matches the pattern given as
second argument and fulfills the condition given as third argument.
When the questions about solutions are prioritized these nodes are frozen and
are expanded on demand, so it has a Boolean value (the fifth argument)
indicating whether the node has been already expanded. Finally, the last
Boolean value indicates whether this term is a solution of the initial search
condition or it is a solution of a rewrite condition:

{\codesize
\begin{verbatim}
%)

  op sol : Term Term Condition Bool Bool Bool -> Judgment [ctor format (b o)] .

***(%
\end{verbatim}
}

The operator \verb"normal" indicates that a term is in normal form with respect
to the equational theory:

{\codesize
\begin{verbatim}
%)

  op normal : Term -> Judgment [ctor format (r o)] .

***(%
\end{verbatim}
}

The operator \verb"semantics" is used for declarative debugging using the
semantics of programming languages:

{\codesize
\begin{verbatim}
%)

  op semantics : Qid Term Term -> Judgment [ctor format (r o)] .

  op semantics : Qid Term Term Maybe{Term} -> Judgment [ctor format (r o)] .

***(%
\end{verbatim}
}

Finally, we define a constant \verb"unknown", that will be used when the user
answers \verb"don't know" to any question:

{\codesize
\begin{verbatim}
%)

  op unknown : -> Judgment [ctor] .
 endfm

***(%
\end{verbatim}
}

We use this module to create a view from the \texttt{TRIV} theory and
we obtain our debugging trees by instantiating the module
\texttt{TREE} above with this view:

{\codesize
\begin{verbatim}
%)

 view DebuggingTreeNode from TRIV to DEBUGGING-TREE-NODE is
  sort Elt to Judgment .
 endv

 fmod PROOF-TREE is
  pr TREE{DebuggingTreeNode} .

***(%
\end{verbatim}
}

This module
defines functions to obtain the different components from the root:
\texttt{getLabel} extracts the statement identifier,
\texttt{getFirstTerm} returns the first term from the judgment,
\texttt{getSecondTerm} extracts the second term in case the judgment
is related to an equation or a rule, and \texttt{getOffspring} returns
the number of nodes in the tree:

\begin{comment}

{\codesize
\begin{verbatim}
%)

  vars F F' : Forest .
  var  Q : Qid .
  vars T T' T2 T3 PAT : Term .
  var  TL : TermList .
  var  J : Judgment .
  vars N N' N'' : Nat .
  var  NL : NatList .
  var  NNL : NeNatList .
  vars A A' : Tree .
  var  S : Type .
  var  B : Bound .
  var  C : Condition .
  var  FST : Bool .

  op getLabel : Tree NatList ~> Qid .
  eq getLabel(A, NL) = getLabel(getSubTree(A, NL)) .

***(%
\end{verbatim}
}

\end{comment}

{\codesize
\begin{verbatim}
%)

  op getLabel : Tree ~> Qid .
  op getFirstTerm : Tree ~> Term .
  op getSecondTerm : Tree ~> Term .
  op getOffspring : Tree -> Nat .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  eq getLabel(tree(Q : T -> T', N, F)) = Q .
  eq getLabel(tree(Q : T : S, N, F)) = Q .
  eq getLabel(tree(Q : T =>1 T', N, F)) = Q .
  eq getLabel(tree(T =>q[Q] {TL}, N, F)) = Q .

  eq getFirstTerm(tree(Q : T -> T', N, F)) = T .
  eq getFirstTerm(tree(Q : T : S, N, F)) = T .
  eq getFirstTerm(tree(Q : T =>1 T', N, F)) = T .
  eq getFirstTerm(tree(T =>f T', N, F)) = T .
  eq getFirstTerm(tree(T =>+ T', N, F)) = T .
  eq getFirstTerm(tree(T =>1 {TL}, N, F)) = T .
  eq getFirstTerm(tree(T =>q[Q] {TL}, N, F)) = T .
  eq getFirstTerm(tree(T ~>[B] {TL} s.t. PAT & C [FST], N, F)) = T .

  eq getSecondTerm(tree(Q : T -> T', N, F)) = T' .
  eq getSecondTerm(tree(Q : T =>1 T', N, F)) = T' .
  eq getSecondTerm(tree(T =>f T', N, F)) = T' .
  eq getSecondTerm(tree(T =>+ T', N, F)) = T' .

  eq getOffspring(mtForest) = 0 .
  eq getOffspring(tree(J, N, F)) = N .

  op getOffspring : Tree NatList ~> Nat .
  eq getOffspring(A, NL) = getOffspring(getSubTree(A, NL)) .

  op getOffspring* : Forest -> Nat .
  eq getOffspring*(mtForest) = 0 .
  eq getOffspring*(A F) = getOffspring(A) + getOffspring*(F) .

  op setForest : Tree Forest -> Tree .
  eq setForest(tree(J, N, F), F') = tree(J, getOffspring*(F') + 1, F') .

***(%
\end{verbatim}
}

\end{comment}

Finally, the function \texttt{deleteSubTree} removes a subtree
from the tree:

{\codesize
\begin{verbatim}
%)

  op deleteSubTree : Tree NatList ~> Tree .

***(%
  ...
 endfm
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  eq deleteSubTree(A, NL) = forest(deleteSubTree2(A, NL)) .

  sort DeletionPair .
  op [_,_] : Forest Nat -> DeletionPair .
  op forest : DeletionPair -> Forest .
  eq forest([F, N]) = F .

  op deleteSubTree2 : Tree NatList ~> DeletionPair .
  op deleteSubTree2* : Forest NatList ~> DeletionPair .

  ceq deleteSubTree2(tree(J, N, F), NNL) = [tree(J, sd(N, N'), F'), N']
   if [F', N'] := deleteSubTree2*(F, NNL) .
  eq deleteSubTree2(tree(J, N, F), nil) = [mtForest, N] .

  ceq deleteSubTree2*(A F, s(N) NL) = [A F', N']
   if [F', N'] := deleteSubTree2*(F, N NL) .
  ceq deleteSubTree2*(A F, 0 NL) = [F' F, N']
   if [F', N'] := deleteSubTree2(A, NL) .
  eq deleteSubTree2*(A, nil) = [mtForest, 0] .

***(%
\end{verbatim}
}

{\codesize
\begin{verbatim}
%)

  op setUnknown : Tree NatList ~> Tree .
  op setUnknown* : Forest NatList ~> Forest .

  eq setUnknown(tree(J, s(N), F), nil) = tree(unknown, N, F) .
  eq setUnknown(tree(J, s(N), F), NNL) = tree(J, N, setUnknown*(F, NNL)) .

  eq setUnknown*(A F, s(N) NL) = A setUnknown*(F, N NL) .
  eq setUnknown*(A F, 0 NL) = setUnknown(A, NL) F .
 endfm

***(%
\end{verbatim}
}

\end{comment}
%)
***(%

\subsection{Auxiliary modules}\label{subsec:aux-mod}

In this section we describe the main auxiliary modules used
by the tool.

\begin{comment}
%)

fmod GEN-MODE is
 sort GenMode .
  ops complete random narrowing : -> GenMode [ctor] .
endfm

fmod SEMANTICS-TYPE is
 sort SemanticsType .
 *** Big-step and small-step semantics
 ops bs ss : -> SemanticsType [ctor] .
endfm

fmod BOUND-WITH-MINUS is
 pr META-LEVEL .

 vars N N' : Nat .

 op _minus_ : Bound Nat -> Bound .
 eq unbounded minus N = unbounded .
 eq s(N) minus s(N') = N minus N' .
 eq 0 minus N = 0 .
 eq N minus 0 = N .
endfm

fmod NAT-SET is
 pr NAT .

 vars NS NS' : NatSet .
 vars N N' : Nat .

 sort NatSet .
 subsort Nat < NatSet .

 op mtNS : -> NatSet [ctor] .
 op _._ : NatSet NatSet -> NatSet [ctor assoc comm id: mtNS] .

 op _\_ : NatSet NatSet -> NatSet .
 eq (N . NS) \ (N . NS') = NS \ NS' .
 eq NS \ NS' = NS [owise] .

 op genNatSetUpTo : Nat -> NatSet .
 eq genNatSetUpTo(N) = genNatSetUpTo(N, 0) .

 op genNatSetUpTo : Nat Nat -> NatSet .
 eq genNatSetUpTo(N, N') = if N' < N
                           then N' . genNatSetUpTo(N, s(N'))
                           else mtNS
                           fi .
endfm

fmod RULE-STMNT-REL is
 pr META-LEVEL .

 sorts RuleStmntRel RuleStmntRelSet .
 subsort RuleStmntRel < RuleStmntRelSet .

 op _~>_ : Qid TermList -> RuleStmntRel [ctor] .
 op mtRSR : -> RuleStmntRelSet [ctor] .
 op __ : RuleStmntRelSet RuleStmntRelSet -> RuleStmntRelSet [ctor assoc comm id: mtRSR] .

 var  M : Module .
 var  R : Rule .
 var  RS : RuleSet .
 vars T T' : Term .
 vars TL TL' : TermList .
 var  Q : Qid .
 var  AtS : AttrSet .
 var  V : Variable .
 var  C : Constant .
 var  COND : Condition .
 var  RSRS : RuleStmntRelSet .

 op computeRSR : Module -> RuleStmntRelSet .
 eq computeRSR(M) = computeRSR*(getRls(M)) .

 op computeRSR* : RuleSet -> RuleStmntRelSet .
 eq computeRSR*(none) = mtRSR .
 eq computeRSR*(R RS) = computeRSR(R) computeRSR*(RS) .

 op computeRSR : Rule ~> RuleStmntRelSet .
 ceq computeRSR(rl T => T' [label(Q) AtS] .) =
                    if TL == empty
                    then mtRSR
                    else Q ~> TL
                    fi
  if TL := getFirstIndex(T) .
 ceq computeRSR(crl T => T' if COND [label(Q) AtS] .) =
                    if TL == empty
                    then mtRSR
                    else Q ~> TL
                    fi
  if TL := getFirstIndex(T) .
 eq computeRSR(R) = mtRSR [owise] .

 op getFirstIndex : Term -> TermList .
 eq getFirstIndex(V) = empty .
 eq getFirstIndex(C) = empty .
 eq getFirstIndex('stmntIndx[T, T']) = T' .
 eq getFirstIndex(Q[TL]) = getFirstIndex*(TL) [owise] .

 op getFirstIndex* : TermList -> TermList .
 eq getFirstIndex*(empty) = empty .
 ceq getFirstIndex*((T, TL)) = if TL' == empty
                               then getFirstIndex*(TL)
                               else TL'
                               fi
  if TL' := getFirstIndex(T) .

  op updateRSRS : RuleStmntRelSet Qid TermList -> RuleStmntRelSet .
  eq updateRSRS((Q ~> TL) RSRS, Q, TL') = (Q ~> TL') RSRS .
  eq updateRSRS(RSRS, Q, TL) = RSRS [owise] .
endfm

fmod TEST-CASE is
 pr META-LEVEL .

 *** CM stands for correct module
 sort TestStatus .
 ops ok notNormal notEqualCM greatSortCM lessSortCM greatSortOp wrongSign noInfo
     userBigger noPropFinal noPropZeroOrMore noPropOneOrMore okProp sysCov errConformance
     failureProp fulfillProp uncheckedProp failurePropMC fulfillPropMC okConformance :
     -> TestStatus [ctor] .

 sort TestCase .
 op <_,_,_> : Term Term TestStatus -> TestCase [ctor] .
 op <_,_,_> : Term Sort TestStatus -> TestCase [ctor] .
 *** failureConformance(T1, sigma, T2, T3, Q)
 *** The term *T1* after applying the rules in *sigma* produces the term *T2* in the
 *** module under test and *T3* in the specification. Moreover, accepted by one of the
 *** modules but not by the other one.
 op failureConformance : Term QidList Term Term -> TestCase [ctor] .
 *** failureConformance(T, sigma, Q)
 *** Starting from T we can apply sigma to both the specification and the implementation
 *** but we fail when trying to apply Q to the implementation, even though it can be
 *** applied to the specification.
 op failureConformance : Term QidList Qid -> TestCase [ctor] .
 ***
 op okConformance : -> TestCase [ctor] .

 var T : Term .
 var TC : TestCase .

 op fulfill? : TestCase -> Bool .
 eq fulfill?(< T, T, fulfillProp >) = true .
 eq fulfill?(TC) = false [owise] .
endfm

view TestCase from TRIV to TEST-CASE is
 sort Elt to TestCase .
endv

fmod CALL is
 pr META-LEVEL .

 sort Call .
 op [_,_,_] : Equation Term EquationSet -> Call [ctor] .
endfm

view Call from TRIV to CALL is
 sort Elt to Call .
endv

fmod RULE-COVERED-INFO is
 pr META-TERM .

 sort RuleCoveredInfo .
 op applied : Qid Term Term -> RuleCoveredInfo [ctor] .
 op fail : Qid Term -> RuleCoveredInfo [ctor] .

 sort AllRulesInfo .
 subsort RuleCoveredInfo < AllRulesInfo .

 op noInfo : -> AllRulesInfo [ctor] .
 op __ : AllRulesInfo AllRulesInfo -> AllRulesInfo [ctor assoc comm id: noInfo] .
endfm

view AllRulesInfo from TRIV to RULE-COVERED-INFO is
 sort Elt to AllRulesInfo .
endv

fmod DEB-REL is
  pr QID .

  sorts DebRel DebRel? .
  subsort DebRel < DebRel? .

  op errorDR : -> DebRel? [ctor] .
  op mtDR : -> DebRel [ctor] .
  op _debugs_ : Qid Qid -> DebRel [ctor] .
  op _;_ : DebRel DebRel -> DebRel [ctor assoc comm id: mtDR] .
endfm

fmod COMPUTED-COVERAGE is
 pr MAP{Term,AllRulesInfo} * (sort Map{Term,AllRulesInfo} to SysInfo) .
 pr TERMSET .
 pr LIST{TestCase} .
 pr SET{Call} .
 --- The sort obtained when computing a coverage.
 --- Each coverage defines its own constructors.
 sort TestGenerationResult CoverageInfo .

 op noCoverageInfo : -> CoverageInfo [ctor] .
 op testGenError : -> TestGenerationResult [ctor] .
 op <_,_> : List{TestCase} CoverageInfo -> TestGenerationResult [ctor] .
 op <_,_> : TermSet CoverageInfo -> TestGenerationResult [ctor] .

 op globalCoverage : QidList -> CoverageInfo [ctor] .
 op callCoverage : Set{Call} -> CoverageInfo [ctor] .
 op mbCoverage : QidList QidList -> CoverageInfo [ctor] .
 op sysCoverage : QidSet QidSet SysInfo -> CoverageInfo [ctor] .
endfm

view Term from TRIV to META-TERM is
 sort Elt to Term .
endv

***(%

The module \texttt{SDD} is in charge of defining the data structures required for
declarative debugging using semantics:

%)

fmod SDD is
 pr MAYBE{Term} .
 pr META-TERM .

 sort SDDInfo SDDInfoSet .
 subsort SDDInfo < SDDInfoSet .

***(%

The first argument in the \verb"SDDInfo" pair indicates the name of the rule
in the intended semantics, while the second one points out the responsible for
the error.

%)

 op sdd : Qid Maybe{Term} -> SDDInfo [ctor] .
 op mtSDDIS : -> SDDInfoSet [ctor] .
 op __ : SDDInfoSet SDDInfoSet -> SDDInfoSet [ctor comm assoc id: mtSDDIS] .
endfm

fmod PRINT is
  pr DECL-META-PRETTY-PRINT .
  pr COMPUTED-COVERAGE .
  pr LIST{TestCase} .
  pr RULE-STMNT-REL .
  pr CONVERSION .
  pr PROOF-TREE .
  pr META-LEVEL .
  pr EXT-DECL .
  pr MOD-NAME .
  pr SDD .

  vars Q Q' : Qid .
  vars QIL QIL' QIL1 QIL2 QIL3 : QidList .
  vars QS QS' : QidSet .
  vars N N' : Nat .
  var  AttS : AttrSet .
  var  NL : NatList .
  vars T T' T1 T2 T3 PAT LHS T? : Term .
  var  MT : Maybe{Term} .
  var  V : Variable .
  var  TL : TermList .
  var  M : Module .
  var  A : Tree .
  vars F F' : Forest .
  var  S : Type .
  vars C C' COND : Condition .
  var  PL : ParameterList .
  var  RN : Renaming .
  var  RS : RenamingSet .
  vars Ty Ty' : Type .
  var  TyL : TypeList .
  vars AttrS AtS : AttrSet .
  var  At : Attr .
  vars ME ME' : ModuleExpression .
  vars B EXP : Bool .
  var  J : Judgment .
  var  BND : Bound .
  var  Ct : Constant .
  var  LTC : List{TestCase} .
  var  TC : TestCase .
  var  TCS : TestStatus .
  var  CI : CoverageInfo .
  var  SC : Set{Call} .
  var  Eq : Equation .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  R : Rule .
  var  SI : SysInfo .
  var  ARI : AllRulesInfo .
  var  RCI : RuleCoveredInfo .
  var  SS : SortSet .
  var  RSRS : RuleStmntRelSet .
  var  RSR : RuleStmntRel .
  var  SDD : SDDInfoSet .
  var  SB : Substitution .

  op printOptions : -> PrintOptionSet .
  eq printOptions = mixfix number rat format .

  -----------------------------------------------------------------------------------------
  ---------------------------------------- PRINT ------------------------------------------
  -----------------------------------------------------------------------------------------

  op indent : Nat -> QidList .
  eq indent(0) = nil .
  eq indent(s(N)) = '\t indent(N) .

  op lazy : Module Term -> Term .
  op lazy2 : Module Term -> Term .
  op lazy2* : Module TermList -> Term .

  eq lazy(M, Q[TL]) = Q[lazy2*(M, TL)] .
  eq lazy(M, T) = T [owise] .

  ceq lazy2(M, T) = if T == T' then lazy(M, T)
                    else lazyVar(S)
                    fi
   if {T', S} := metaReduce(M, T) .

  eq lazy2*(M, empty) = empty .
  eq lazy2*(M, (T, TL)) = lazy2(M, T), lazy2*(M, TL) .

  op lazyVar : Sort -> Variable .
  eq lazyVar(S) = qid("?:" + string(S)) .

  op eMetaPrettyLatex : Nat Forest Module Bool -> QidList .
  eq eMetaPrettyLatex(N, mtForest, M, B) = '\n indent(N) '`{ '`} .
  ceq eMetaPrettyLatex(N, A F, M, B) = indent(N) eMetaPrettyLatex(N, A, M, B)
                                     indent(N) eMetaPrettyLatex(N, F, M, false) if F =/= mtForest .
  eq eMetaPrettyLatex(N, tree(Q : T -> T', N', F), M, B) =
       '\n
       indent(N) if B then nil else '& fi '\g '\infer '\o '`[ '\lab '`{ '\! Q '\o '`} '`] '`{
               '\texttt '`{ add-spaceR(eMetaPrettyPrint(M, T)) '`} '\rightarrow '\texttt '`{ eMetaPrettyPrint(M, T')  '`} '`} '`{
            eMetaPrettyLatex(N + 1, F, M, true) '\n
       indent(N) ' '`} .
  eq eMetaPrettyLatex(N, tree(Q : T : S, N', F), M, B) =
       '\n
       indent(N) if B then nil else '& fi '\g '\infer '\o '`[ '\lab '`{ '\! Q '\o '`} '`] '`{
               '\texttt '`{ add-spaceR(eMetaPrettyPrint(M, T)) '`} ': '\texttt '`{ S '`} '`} '`{
            eMetaPrettyLatex(N + 1, F, M, true) '\n
       indent(N) ' '`} .
  eq eMetaPrettyLatex(N, tree(Q : T =>1 T', N', F), M, B) =
       '\n
       indent(N) if B then nil else '& fi '\g '\infer '\o '`[ '\lab '`{ '\! Q '\o '`} '`] '`{
               '\texttt '`{ add-spaceR(eMetaPrettyPrint(M, T)) '`} '\Rightarrow_1 '\texttt '`{ eMetaPrettyPrint(M, T')  '`} '`} '`{
            eMetaPrettyLatex(N + 1, F, M, true) '\n
       indent(N) ' '`} .
  eq eMetaPrettyLatex(N, tree(T =>f T', N', F), M, B) =
       '\n
       indent(N) if B then nil else '& fi '\g '\infer '\o '`[ 'frozen '`] '`{
               '\texttt '`{ add-spaceR(eMetaPrettyPrint(M, T)) '`} '\Rightarrow_f '\texttt '`{ eMetaPrettyPrint(M, T')  '`} '`} '`{
            eMetaPrettyLatex(N + 1, F, M, true) '\n
       indent(N) ' '`} .
  eq eMetaPrettyLatex(N, tree(T =>+ T', N', F), M, B) =
       '\n
       indent(N) if B then nil else '& fi '\g '\infer '\o '`[ '\lab '`{ '\! 'Tr '\o '`} '`] '`{
               '\texttt '`{ add-spaceR(eMetaPrettyPrint(M, T)) '`} '\Rightarrow^+ '\texttt '`{ eMetaPrettyPrint(M, T')  '`} '`} '`{
            eMetaPrettyLatex(N + 1, F, M, true) '\n
       indent(N) ' '`} .
  eq eMetaPrettyLatex(N, tree(T :ls S, N', F), M, B) =
       '\n
       indent(N) if B then nil else '& fi '\g '\infer '\o '`[ '\lab '`{ '\! 'ls '\o '`} '`] '`{
               '\texttt '`{ add-spaceR(eMetaPrettyPrint(M, T)) '`} ':ls S  '`} '`} '`{
            eMetaPrettyLatex(N + 1, F, M, true) '\n
       indent(N) ' '`} .


  op eMetaPrettyPrint : Nat Forest Module -> QidList .
  eq eMetaPrettyPrint(N, mtForest, M) = '\n indent(N) 'mt .
  ceq eMetaPrettyPrint(N, A F, M) = indent(N) eMetaPrettyPrint(N, A, M)
                                       indent(N) eMetaPrettyPrint(N, F, M)
   if F =/= mtForest .
  eq eMetaPrettyPrint(N, tree(Q : T -> T', N', F), M) =
       '\n
       indent(N) '\g 'tree '\o '`( '\! Q '\o ': add-spaceR(eMetaPrettyPrint(M, T)) '-> add-spaceL(eMetaPrettyPrint(M, T'))  '`,
            eMetaPrettyPrint(N + 1, F, M) '\n
       indent(N) ' '`) .
  eq eMetaPrettyPrint(N, tree(Q : T : S, N', F), M) =
       '\n
       indent(N) '\g 'tree '\o '`( '\! Q '\o ': add-spaceR(eMetaPrettyPrint(M, T)) ': S  '`,
            eMetaPrettyPrint(N + 1, F, M) '\n
       indent(N) ' '`) .
  eq eMetaPrettyPrint(N, tree(Q : T =>1 T', N', F), M) =
       '\n
       indent(N) '\g 'tree '\o '`( '\! Q '\o ': add-spaceR(eMetaPrettyPrint(M, T)) '=>1 add-spaceL(eMetaPrettyPrint(M, T'))  '`,
            eMetaPrettyPrint(N + 1, F, M) '\n
       indent(N) ' '`) .
  eq eMetaPrettyPrint(N, tree(T =>f T', N', F), M) =
       '\n
       indent(N) '\g 'tree '\o '`( add-spaceR(eMetaPrettyPrint(M, T)) '=>f add-spaceL(eMetaPrettyPrint(M, T'))  '`,
            eMetaPrettyPrint(N + 1, F, M) '\n
       indent(N) ' '`) .
  eq eMetaPrettyPrint(N, tree(T =>+ T', N', F), M) =
       '\n
       indent(N) '\g 'tree '\o '`( add-spaceR(eMetaPrettyPrint(M, T)) '=>+ add-spaceL(eMetaPrettyPrint(M, T'))  '`,
            eMetaPrettyPrint(N + 1, F, M) '\n
       indent(N) ' '`) .

  op printRoot : Tree Module SDDInfoSet -> QidList .
  eq printRoot(tree('root@#$% : T -> T', N, F), M, SDD) = noInformation2 .
  eq printRoot(tree('root@#$% : T : S, N, F), M, SDD) = noInformation2 .
  *** The user has answered "don't know" to all the nodes
  eq printRoot(tree(J, 1, A F), M, SDD) = noInformation3 .
  eq printRoot(tree(Q : T -> T', N, F), M, SDD) = buggy
                          add-space(metaPrettyPrint(M, lazy(M, T), printOptions)) '\! '-> '\o
                          add-space(metaPrettyPrint(M, lazy(M, T'), printOptions)) '\n
                          '\b 'with 'the 'associated 'equation: '\o Q '\n [owise] .
  eq printRoot(tree(Q : T : S, N, F), M, SDD) = buggy
                          add-space(metaPrettyPrint(M, lazy(M, T), printOptions)) '\! ': '\o S '\n
                          '\b 'with 'the 'associated 'membership: '\o Q '\n [owise] .
  eq printRoot(tree(Q : T =>1 T', N, F), M, SDD) = buggy
                          add-space(metaPrettyPrint(M, T, printOptions)) '\! '=>1 '\o
                          add-space(metaPrettyPrint(M, T', printOptions)) '\n
                          '\b 'with 'the 'associated 'rule: '\o Q '\n [owise] .
  eq printRoot(tree(T =>1 {empty}, N, F), M, SDD) = buggy '\b 'The 'term '\o
                                               add-space(metaPrettyPrint(M, lazy(M, T), printOptions))
                                               '\b 'is 'final. '\n
                                'Either 'the 'operator '\o getWrongOp(M, T) '\b 'needs
                                'more 'rules 'or 'the 'conditions 'of 'the 'current
                                'rules 'are 'not 'written 'in 'the 'intended 'way. [owise] .
  eq printRoot(tree(T =>1 {(T', TL)}, N, F), M, SDD) = buggy add-space(metaPrettyPrint(M, lazy(M, T), printOptions))
                                            '\! '=>1 ' '\! '`{ '\o printList(M, (T', TL)) '\! '`} '\o '\n
                                '\b 'Either 'the 'operator '\o getWrongOp(M, T) '\b 'needs
                                'more 'rules 'or 'the 'conditions 'of 'the 'current
                                'rules 'are 'not 'written 'in 'the 'intended 'way. [owise] .
  eq printRoot(tree(T =>q[Q] {empty}, N, F), M, SDD) =
                                buggy '\b 'The 'rule '\o Q '\b 'cannot 'be
                                'applied 'to '\o
                                add-space(metaPrettyPrint(M, lazy(M, T), printOptions))
                                '\o '\n '\n '\b 'The 'rule '\o Q '\b 'is 'buggy.
                                '\o '\n [owise] .
  eq printRoot(tree(T =>q[Q] {(T', TL)}, N, F), M, SDD) =
                                buggy '\b 'One 'application 'of 'the 'rule '\o Q '\b
                                'to 'the 'term '\o
                                add-space(metaPrettyPrint(M, lazy(M, T), printOptions))
                                '\b 'leads 'to '\o ' '\! '`{ '\o printList(M, (T', TL)) '\! '`}
                                '\o '\n '\n '\b 'The 'rule '\o Q '\b 'is 'incompletely
                                'defined. '\o '\n .
  eq printRoot(tree(T :ls Ty, N, F), M, SDD) = buggy '\b 'The 'least 'sort 'of '\o
                                add-space(metaPrettyPrint(M, lazy(M, T), printOptions))
                                '\b 'is '\o Ty
                                '\n '\b 'Either 'the 'operator '\o getWrongOp(M, T) '\b
                                'needs 'more 'membership 'axioms 'or 'the 'conditions
                                'of 'the 'current 'axioms 'are 'not 'written 'in 'the
                                'intended 'way. .
  eq printRoot(tree(normal(T), N, F), M, SDD) = buggy
                                add-space(metaPrettyPrint(M, lazy(M, T), printOptions))
                                '\b 'is 'in 'normal 'form. '\n
                                'Either 'the 'operator '\o getWrongOp(M, T) '\b 'needs
                                'more 'equations 'or 'the 'conditions 'of 'the 'current
                                'equations 'are 'not 'written 'in 'the 'intended 'way. .
  eq printRoot(tree(semantics(Q, T, T'), N, F), M, SDD) = buggy
                     'The 'term add-space(metaPrettyPrint(M, T, printOptions))
                     '\b 'has 'been 'evaluated 'to '\o
                     add-space(metaPrettyPrint(M, T', printOptions))
                     relateSemantics(M, Q, T, SDD) .
  eq printRoot(tree(semantics(Q, T, T', maybe), N, F), M, SDD) = buggy
                     'The 'term add-space(metaPrettyPrint(M, T, printOptions))
                     '\b 'has 'been 'evaluated 'to '\o
                     add-space(metaPrettyPrint(M, T', printOptions))
                     relateSemantics(M, Q, T, SDD) .
  eq printRoot(tree(semantics(Q, T, T', T1), N, F), M, SDD) = buggy
                     'The 'term add-space(metaPrettyPrint(M, T, printOptions))
                     '\b 'has 'been 'evaluated 'to '\o
                     add-space(metaPrettyPrint(M, T', printOptions))
                     '\n '\b 'The 'code 'responsible 'for 'the 'error
                     'is '\o '\! add-space(metaPrettyPrint(M, T1, printOptions))
                     '\o '\n .
  eq printRoot(tree(T =>f T', N, F), M, SDD) = noInformation2 [owise] .
  eq printRoot(tree(T =>+ T', N, F), M, SDD) = noInformation2 [owise] .
  eq printRoot(tree(T ~>[BND] {TL} s.t. PAT & C [B], N, F), M, SDD) = noInformation2 [owise] .
  eq printRoot(tree(sol(T, T', C, B, true, true), N, F), M, SDD) =
                     buggy 'The 'term add-space(metaPrettyPrint(M, lazy(M, T), printOptions))
                     'is solution?(B) 'a 'solution. '\n
                     '\n '\b 'Either 'the 'condition 'or 'the 'pattern
                     'of 'the 'search 'is 'wrong. '\o '\n
                     'Pattern: add-space(metaPrettyPrint(M, lazy(M, T'), printOptions)) '\n
                     condition?(M, C) [owise] .

  op relateSemantics : Module Qid Term SDDInfoSet -> QidList .
  eq relateSemantics(M, Q, T, sdd(Q, T') SDD) = relateSemantics(M, getLHS(getRule(M, Q)), T, T') .
  eq relateSemantics(M, Q, T, SDD) = nil [owise] .

  op relateSemantics : Module Term Term Term -> QidList .
  ceq relateSemantics(M, LHS, T, T') =  '\n '\b 'The 'code 'responsible 'for 'the 'error
              'is '\o '\! add-space(metaPrettyPrint(M, T2, printOptions)) '\o '\n
   if (T' <- T2 ; SB) := metaMatch(M, LHS, T, nil, 0) .
  eq relateSemantics(M, LHS, T, T') = nil [owise] .

  op solution? : Bool -> QidList .
  eq solution?(B) = if B then nil else 'not fi .

  op condition? : Module Condition -> QidList .
  eq condition?(M, nil) = nil .
  eq condition?(M, C) = 'Condition: metaPrettyPrint*(M, C) '\n [owise] .

  op printNode : Tree NatList Module -> QidList .
  ceq printNode(A, NL, M) = '\n trans-correct?(Q) '\n
                            add-spaceR(metaPrettyPrint(M, lazy(M, T), printOptions)) '\! '-> '\o
                            add-spaceL(metaPrettyPrint(M, lazy(M, T'), printOptions)) '\n
   if Q : T -> T' := getContents(A, NL) .
  ceq printNode(A, NL, M) = '\n mb-correct?(Q) '\n
                            add-spaceR(metaPrettyPrint(M, lazy(M, T), printOptions)) '\! ': '\o S '\n
   if Q : T : S := getContents(A, NL) .
  ceq printNode(A, NL, M) = '\n rew-correct?(Q) '\n
                               add-spaceR(metaPrettyPrint(M, T, printOptions)) '\! '=>1 '\o
                               add-spaceL(metaPrettyPrint(M, T', printOptions)) '\n
   if Q : T =>1 T' := getContents(A, NL) .
  ceq printNode(A, NL, M) = add-spaceR(metaPrettyPrint(M, T, printOptions)) '\! '=>1 '\o
                            add-spaceL(metaPrettyPrint(M, T', printOptions)) '\n
   if T =>f T' := getContents(A, NL) .
  ceq printNode(A, NL, M) = '\n trans-rew-correct? '\n
                            add-spaceR(metaPrettyPrint(M, T, printOptions)) '\! '=>+ '\o
                            add-spaceL(metaPrettyPrint(M, T', printOptions)) '\n
   if T =>+ T' := getContents(A, NL) .
  ceq printNode(A, NL, M) = '\n '\b 'Are 'the 'following 'terms 'all 'the 'reachable 'terms
                            'from '\o add-space(metaPrettyPrint(M, T, printOptions))
                            '\b 'in 'one 'step? '\o '\n
                            printList(M, TL, 1) '\n
   if T =>1 {TL} := getContents(A, NL) /\
      TL =/= empty .
  ceq printNode(A, NL, M) = '\n '\b 'Did 'you 'expect '\o
                            add-space(metaPrettyPrint(M, T, printOptions))
                            '\b 'to 'be 'final? '\o '\n
   if T =>1 {empty} := getContents(A, NL) .
  ceq printNode(A, NL, M) = '\n '\b 'Are 'the 'following 'terms 'all 'the 'reachable 'terms
                            'from '\o add-space(metaPrettyPrint(M, T, printOptions))
                            '\b 'with 'one 'application 'of 'the 'rule '\o Q '\b '? '\o '\n
                            printList(M, TL, 1) '\n
   if T =>q[Q] {TL} := getContents(A, NL) /\
      TL =/= empty .
  ceq printNode(A, NL, M) = '\n '\b 'Did 'you 'expect 'that 'no 'terms 'can 'be 'obtained
                            'from '\o add-space(metaPrettyPrint(M, T, printOptions))
                            '\b 'by 'applying 'the 'rule '\o Q '\b '? '\o '\n
   if T =>q[Q] {empty} := getContents(A, NL) .
  ceq printNode(A, NL, M) = '\n '\b 'Are 'the 'following 'terms 'all 'the 'reachable 'solutions
                            'from '\o add-space(metaPrettyPrint(M, T, printOptions))
                            '\b 'in 'at 'most '\o  qid(string(N, 10)) '\b 'steps? '\o '\n
                            printList(M, TL, 1) '\n
   if T ~>[N] {TL} s.t. PAT & C [true] := getContents(A, NL) /\
      TL =/= empty .
  ceq printNode(A, NL, M) = '\n '\b 'Are 'the 'following 'terms 'all 'the 'reachable 'terms
                            'from '\o add-space(metaPrettyPrint(M, T, printOptions))
                            '\b 'in 'at 'most '\o  qid(string(N, 10)) '\b 'steps 'that
                            'match 'the 'pattern '\o
                            add-space(metaPrettyPrint(M, PAT, printOptions)) '\b '? '\o '\n
                            printList(M, TL, 1) '\n
   if T ~>[N] {TL} s.t. PAT & C [false] := getContents(A, NL) /\
      TL =/= empty .
  ceq printNode(A, NL, M) = '\n '\b 'Are 'the 'following 'terms 'all 'the 'reachable
                            'solutions 'from '\o
                            add-space(metaPrettyPrint(M, T, printOptions)) '\b '? '\o '\n
                             printList(M, TL, 1) '\n
   if T ~>[unbounded] {TL} s.t. PAT & C [true] := getContents(A, NL) /\
      TL =/= empty .
  ceq printNode(A, NL, M) = '\n '\b 'Are 'the 'following 'terms 'all 'the 'reachable 'terms
                            'from '\o add-space(metaPrettyPrint(M, T, printOptions)) '\b
                            'that 'match 'the 'pattern '\o
                            add-space(metaPrettyPrint(M, PAT, printOptions)) '\b '? '\o '\n
                            printList(M, TL, 1) '\n
   if T ~>[unbounded] {TL} s.t. PAT & C [false] := getContents(A, NL) /\
      TL =/= empty .
  ceq printNode(A, NL, M) = '\n '\b 'Did 'you 'expect 'that 'no 'solutions 'can 'be 'obtained
                            'from '\o add-space(metaPrettyPrint(M, T, printOptions)) '\b
                            'in '\o qid(string(N, 10)) '\b 'steps? '\o '\n
   if T ~>[N] {empty} s.t. PAT & C [true] := getContents(A, NL) .
  ceq printNode(A, NL, M) = '\n '\b 'Did 'you 'expect 'that 'no 'terms 'matching 'the
                            'pattern '\o add-space(metaPrettyPrint(M, PAT, printOptions))
                            '\b 'can 'be 'obtained
                            'from '\o add-space(metaPrettyPrint(M, T, printOptions)) '\b
                            'in '\o qid(string(N, 10)) '\b 'steps? '\o '\n
   if T ~>[N] {empty} s.t. PAT & C [false] := getContents(A, NL) .
  ceq printNode(A, NL, M) = '\n '\b 'Did 'you 'expect 'that 'no 'solutions 'can 'be 'obtained
                            'from '\o add-space(metaPrettyPrint(M, T, printOptions)) '\b '? '\o '\n
   if T ~>[unbounded] {empty} s.t. PAT & C [true] := getContents(A, NL) .
  ceq printNode(A, NL, M) = '\n '\b 'Did 'you 'expect 'that 'no 'terms 'matching 'the
                            'pattern '\o add-space(metaPrettyPrint(M, PAT, printOptions))
                            '\b 'can 'be 'obtained
                            'from '\o add-space(metaPrettyPrint(M, T, printOptions)) '\b '? '\o '\n
   if T ~>[unbounded] {empty} s.t. PAT & C [false] := getContents(A, NL) .
  ceq printNode(A, NL, M) = '\n '\b 'Did 'you 'expect '\o
                            add-space(metaPrettyPrint(M, T, printOptions))
                            '\b 'to 'be 'a 'solution? '\o '\n
   if sol(T, T', C, true, EXP, true) := getContents(A, NL) .
  ceq printNode(A, NL, M) = '\n '\b 'Did 'you 'expect '\o
                            add-space(metaPrettyPrint(M, T, printOptions))
                            '\b 'not 'to 'be 'a 'solution? '\o '\n
   if sol(T, T', C, false, EXP, true) := getContents(A, NL) .
  ceq printNode(A, NL, M) = '\n '\b 'Is '\o Ty '\b 'the 'least
                            'sort 'of '\o add-space(metaPrettyPrint(M, T, printOptions))
                            '\b '? '\o '\n
   if T :ls Ty := getContents(A, NL) .
  ceq printNode(A, NL, M) = '\n '\b 'Is '\o add-space(metaPrettyPrint(M, T, printOptions))
                            '\b 'in 'normal 'form? '\o '\n
   if normal(T) := getContents(A, NL) .
  ceq printNode(A, NL, M) = '\n '\b 'Is '\o add-space(metaPrettyPrint(M, T, printOptions))
                            '\b 'evaluated 'to '\o
                            add-space(metaPrettyPrint(M, T', printOptions)) '\n
   if semantics(Q, T, T') := getContents(A, NL) .
  ceq printNode(A, NL, M) = '\n '\b 'Is '\o add-space(metaPrettyPrint(M, T, printOptions))
                            '\b 'evaluated 'to '\o
                            add-space(metaPrettyPrint(M, T', printOptions)) '\n
   if semantics(Q, T, T', MT) := getContents(A, NL) .


  op printOffspring : Tree Module ~> QidList .
  op printOffspring* : Forest Module Nat -> QidList .
  eq printOffspring(tree(J, N, F), M) = '\n printOffspring*(removeUnknown*(F), M, 1) .
  eq printOffspring*(mtForest, M, N) = nil .
  eq printOffspring*(A F, M, N) = '\b '\! 'Question qid(string(N, 10)) '\o ':
        printNode(A, nil, M) '\n
        printOffspring*(F, M, s(N)) .

  op printFirstPreorder : Tree Module -> QidList .
  eq printFirstPreorder(tree(J, N, mtForest), M) = printNode(tree(J, N, mtForest), nil, M) .
  eq printFirstPreorder(tree(J, N, F), M) = printFirstPreorder*(F, M) .

  op printFirstPreorder* : Forest Module ~> QidList .
  eq printFirstPreorder*(A F, M) = printFirstPreorder(A, M) .

  op getWrongOp : Module Term -> Qid .
  eq getWrongOp(M, Q[TL]) = Q .
  eq getWrongOp(M, Ct) = getName(Ct) .

  op add-spaceR : QidList -> QidList .
  eq add-spaceR(QIL '`)) = QIL '`) ' .
  eq add-spaceR(QIL '`]) = QIL '`] ' .
  eq add-spaceR(QIL '`}) = QIL '`} ' .
  eq add-spaceR(QIL) = QIL [owise] .

  op add-spaceL : QidList -> QidList .
  eq add-spaceL('`( QIL) = ' '`( QIL .
  eq add-spaceL('`[ QIL) = ' '`[ QIL .
  eq add-spaceL('`{ QIL) = ' '`{ QIL .
  eq add-spaceL(QIL) = QIL [owise] .

  op add-space : QidList -> QidList .
  eq add-space(QIL) = add-spaceL(add-spaceR(QIL)) .

  op trans-correct? : Qid -> QidList .
  eq trans-correct?(Q) = '\b 'Is 'this 'reduction ' '`( 'associated 'with 'the 'equation '\o Q '\b '`) '
                         'correct? '\o '\n .

  op rew-correct? : Qid -> QidList .
  eq rew-correct?(Q) = '\b 'Is 'this 'rewrite ' '`( 'associated 'with 'the 'rule '\o Q '\b '`) '
                       'correct? '\o '\n .

  op trans-rew-correct? : -> QidList .
  eq trans-rew-correct? = '\b 'Is 'this 'rewrite 'correct? '\o '\n .

  op mb-correct? : Qid -> QidList .
  eq mb-correct?(Q) = '\b 'Is 'this 'membership ' '`( 'associated 'with 'the 'membership '\o Q
                      '\b '`) ' 'correct? '\o '\n .

  op buggy : -> QidList .
  eq buggy = '\n '\b 'The '\! 'buggy '\o '\b 'node 'is: '\o '\n .

  op deb-started : -> QidList .
  eq deb-started = '\b 'The 'debugging 'process 'has 'already 'started. '\o '\n .

  op dd-banner : -> QidList .
  eq dd-banner = '\n '\t 'Declarative 'debugging 'and 'test-case 'generation 'for 'Maude
           '\n '\t ' ' ' '\t '\t '`( 'February '5th '`, '\s '2013 '`) '\n .


  ops noInformation noInformation2 noInformation3 noInformation4 : -> QidList .
  eq noInformation = '\n '\r 'Error: '\o 'With 'the 'given 'information ' '`( 'labeling 'and
                     'correct 'module '`) ' 'it 'is 'impossible 'to 'debug. '\n .
  eq noInformation2 = '\n '\r 'Error: '\o 'With 'the 'given 'information ' '`( 'labeling '`, '
                      'correct 'module '`, ' 'and 'answers '`) ' 'it 'is 'impossible 'to 'debug. '\n .
  eq noInformation3 = '\n '\r 'Error: '\o 'With 'the 'given 'information 'it 'is 'impossible 'to
                      'debug 'the 'computation. '\n .
  eq noInformation4 = '\n '\r 'Error: '\o 'Not 'enough 'information 'available. '\n .

   op advisory-select : Bool -> QidList .
   eq advisory-select(B) = if not B
                           then '\n '\g 'Advisory: '\o 'Debug 'select 'is 'off. '\n
                           else nil
                           fi .

   op advisory-final : Bool -> QidList .
   eq advisory-final(B) = if not B
                          then '\n '\g 'Advisory: '\o 'Final 'select 'is 'off. '\n
                          else nil
                          fi .

   op advisory-test-select : Bool -> QidList .
   eq advisory-test-select(B) = if not B
                                then '\n '\g 'Advisory: '\o 'Test 'select 'is 'off. '\n
                                else nil
                                fi .

   op printME : ModuleExpression -> QidList .
   eq printME(Q) = Q .
   eq printME(ME{PL}) = printME(ME) '`{ printPL(PL) '`} .
   eq printME(ME * (RS)) = printME(ME) '* '`( printRS(RS) '`) .
   eq printME(ME + ME') = printME(ME) '+ printME(ME') .
   eq printME(TUPLE[N]) = 'TUPLE`[ qid(string(N, 10)) '`] .
   eq printME(POWER[N]) = 'POWER`[ qid(string(N, 10)) '`] .

   op printPL : ParameterList -> QidList .
   eq printPL(ME) = printME(ME) .
   eq printPL((ME, PL)) = printME(ME) '`, printPL(PL) [owise] .

   op printRS : RenamingSet -> QidList .
   eq printRS((RN, RS)) = printRS(RN) '\n printRS(RS) .
   eq printRS(sort Ty to Ty') = 'sort Ty 'to Ty' .
   eq printRS(label Q to Q') = 'label Q 'to Q' .
   eq printRS(class Ty to Ty') = 'class Ty 'to Ty' .
   eq printRS(attr Q . Ty to Q') = 'attr Q '. Ty 'to Q' .
   eq printRS(msg Q to Q') = 'msg Q 'to Q' .
   eq printRS(msg Q : TyL -> Ty to Q') = 'msg Q ': TyL '-> Ty 'to Q' .
   eq printRS(msg Q : nil -> Ty to Q') = 'msg Q ': '-> Ty 'to Q' .
   eq printRS(op Q to Q' [AttrS]) = 'op Q 'to Q' '`[ printAtS(AttrS) '`] .
   eq printRS(op Q : TyL -> Ty to Q' [AttrS]) = 'op Q ': TyL '-> Ty 'to Q' '`[ printAtS(AttrS) '`] .
   eq printRS(op Q : nil -> Ty to Q' [AttrS]) = 'op Q ': '-> Ty 'to Q' '`[ printAtS(AttrS) '`] .

   op printAtS : AttrSet -> QidList .
   eq printAtS(At AttrS) = printAtS(At) printAtS(AttrS) .
   eq printAtS(none) = nil .

   eq printAtS(assoc) = 'assoc .
   eq printAtS(comm) = 'comm .
   eq printAtS(idem) = 'idem .
   eq printAtS(ctor) = 'ctor .
   eq printAtS(iter) = 'iter .
   eq printAtS(msg) = 'msg .
   eq printAtS(ditto) = 'ditto .
   eq printAtS(gather(QIL)) = 'gather`( QIL '`) .
   eq printAtS(config) = 'config .
   eq printAtS(object) = 'object .
   eq printAtS(prec(N)) = 'prec`( qid(string(N,10)) '`) .

   op metaPrettyPrint : Module Rule -> QidList .
   eq metaPrettyPrint(M, rl T1 => T2 [AttrS] .) = '\n 'rl add-space(metaPrettyPrint(M, T1, printOptions) '\n)
                                                 '=> add-space(metaPrettyPrint(M, T2, printOptions)) ' '. '\n .
   eq metaPrettyPrint(M, crl T1 => T2 if C [AttrS] .) = '\n 'crl add-space(metaPrettyPrint(M, T1, printOptions)) '\n
                                                 '=> add-space(metaPrettyPrint(M, T2, printOptions)) '\n
                                                 '\n '\t 'if metaPrettyPrint(M, C) '. '\n .

   op metaPrettyPrint : Module Condition -> QidList .
   eq metaPrettyPrint(M, T = T') = add-space(metaPrettyPrint(M, T, printOptions)) '=
                                   add-space(metaPrettyPrint(M, T', printOptions)) .
   eq metaPrettyPrint(M, T := T') = add-space(metaPrettyPrint(M, T, printOptions)) ':=
                                    add-space(metaPrettyPrint(M, T', printOptions)) .
   eq metaPrettyPrint(M, T => T') = add-space(metaPrettyPrint(M, T, printOptions)) '=>
                                    add-space(metaPrettyPrint(M, T', printOptions)) .
   eq metaPrettyPrint(M, T : Ty) = add-space(metaPrettyPrint(M, T, printOptions)) ': Ty .
   ceq metaPrettyPrint(M, C /\ C') = metaPrettyPrint(M, C) '/\ '\n ' ' ' '
                                     metaPrettyPrint(M, C')
    if C =/= nil /\ C' =/= nil .

   op printList : Module TermList Nat -> QidList .
   eq printList(M, empty, N) = nil .
   eq printList(M, (T, TL), N) = '\n '\! qid(string(N, 10)) '\o ' metaPrettyPrint(M, T, printOptions)
                                  printList(M, TL, s(N)) .

   op printList : Module TermList -> QidList .
   eq printList(M, empty) = nil .
   eq printList(M, T) = metaPrettyPrint(M, T, printOptions) .
   eq printList(M, (T, T', TL)) = metaPrettyPrint(M, T, printOptions) '\! '`, '\o ' ' printList(M, (T', TL)) .

   op printCondition : Module Term Condition -> QidList .
   eq printCondition(M, PAT, C) = '\b 'given 'the 'pattern '\o add-space(
                                  metaPrettyPrint(M, PAT, printOptions)) '\o
                                  if C =/= nil
                                  then '\b 'and 'the 'condition '\o
                                       add-space(metaPrettyPrint*(M, C))
                                  else nil
                                  fi .

   op printBiggerSortsFinal : SortSet QidList -> QidList .
   eq printBiggerSortsFinal(none, QIL) = nil .
   ceq printBiggerSortsFinal(SS, QIL) =
        '\b 'The 'following 'subsorts 'were 'also 'added 'as 'no 'final: '\o QIL2 '\b '. '\o '\n
    if QIL1 := sortset2qidlist(SS) /\
       QIL2 := quit QIL to QIL1 [owise] .

   op printLesserSortsFinal : SortSet QidList -> QidList .
   eq printLesserSortsFinal(none, QIL) = nil .
   ceq printLesserSortsFinal(SS, QIL) =
        '\b 'The 'following 'subsorts 'were 'also 'added 'as 'final: '\o QIL2 '\b '. '\o '\n
    if QIL1 := sortset2qidlist(SS) /\
       QIL2 := quit QIL to QIL1 [owise] .

   op quit_to_ : QidList QidList -> QidList .
   eq quit nil to QIL = QIL .
   eq quit Q QIL1 to QIL2 = quit QIL1 to quit(Q, QIL2) .

   op quit : Qid QidList -> QidList .
   eq quit(Q, nil) = nil .
   eq quit(Q, Q QIL) = quit(Q, QIL) .
   eq quit(Q, Q' QIL) = Q' quit(Q, QIL) [owise] .

   op sortset2qidlist : SortSet -> QidList .
   eq sortset2qidlist(none) = nil .
   eq sortset2qidlist(S ; SS) = S sortset2qidlist(SS) .

   *** MetaPrettyPrint of conditions without '\n
   op metaPrettyPrint* : Module Condition -> QidList .
   ceq metaPrettyPrint*(M, C /\ C') = metaPrettyPrint*(M, C) '/\
                                      metaPrettyPrint*(M, C')
    if C =/= nil /\ C' =/= nil .
   eq metaPrettyPrint*(M, C) = metaPrettyPrint(M, C) [owise] .

   op metaPrettyPrintEq : Module Equation -> QidList .
   eq metaPrettyPrintEq(M, eq T1 = T2 [label(Q) AttrS] .) =
               'eq '`[ Q '`] ': add-space(metaPrettyPrint(M, T1, printOptions) '\n)
               '= add-space(metaPrettyPrint(M, T2, printOptions)) ' '. '\n .
   eq metaPrettyPrintEq(M, ceq T1 = T2 if C [label(Q) AttrS] .) =
             'ceq '`[ Q '`] ': add-space(metaPrettyPrint(M, T1, printOptions)) '\n
             '= add-space(metaPrettyPrint(M, T2, printOptions)) '\n
             '\n '\t 'if metaPrettyPrint(M, C) '. '\n .
   eq metaPrettyPrintEq(M, eq T1 = T2 [AttrS] .) = 'eq add-space(metaPrettyPrint(M, T1, printOptions) '\n)
                                                 '= add-space(metaPrettyPrint(M, T2, printOptions)) ' '. '\n [owise] .
   eq metaPrettyPrintEq(M, ceq T1 = T2 if C [AttrS] .) = 'ceq add-space(metaPrettyPrint(M, T1, printOptions)) '\n
                                                 '= add-space(metaPrettyPrint(M, T2, printOptions)) '\n
                                                 '\n '\t 'if metaPrettyPrint(M, C) '. '\n [owise] .

   op removeUnknownChildren : Tree -> Forest .
   ceq removeUnknownChildren(tree(J, N, F)) = tree(J, s(N'), F')
    if F' := removeUnknown*(F) /\
       N' := getOffspring*(F') .

   op removeUnknown* : Forest -> Forest .
   eq removeUnknown*(mtForest) = mtForest .
   eq removeUnknown*(tree(unknown, N, F) F') = removeUnknown*(F') .
   eq removeUnknown*(A F) = A removeUnknown*(F) [owise] .

   vars QIL4 QIL5 QIL6 QIL7 QIL8 QIL9 QIL10 QIL11 QIL12 QIL13 QIL14 : QidList .
   vars N1 N2 N3 N4 N5 N6 N7 N8 N9 N10 N11 N12 N13 : Nat .

   op printNumTests : Module List{TestCase} CoverageInfo -> QidList .
   ceq printNumTests(M, LTC, CI) = QIL1 QIL2 QIL3 QIL4 QIL5 QIL6 QIL7 QIL8
                                   QIL9 QIL10 QIL11 QIL12 QIL13
    if N1 := testListSize(LTC) /\
       N2 := numStatus(LTC, ok) /\
       N3 := numStatus(LTC, notEqualCM) /\
       N4 := numStatus(LTC, greatSortCM) /\
       N5 := numStatus(LTC, lessSortCM) /\
       N6 := numStatus(LTC, notNormal) /\
       N7 := numStatus(LTC, wrongSign) /\
       N8 := numStatus(LTC, noInfo) /\
       N9 := numStatusSort(LTC) /\
       N10 := numStatus(LTC, sysCov) /\
       N11 := (numStatus(LTC, failureProp) + numStatus(LTC, fulfillProp)) /\
       N12 := (numStatus(LTC, failurePropMC) + numStatus(LTC, fulfillPropMC)) /\
       N13 := numStatusConformance(LTC) /\
       QIL1 := if (N9 > 0) or-else (N10 > 0) or-else (N11 > 0) or-else (N12 > 0)
               then '\n '\b qid(string(N1, 10)) 'test 'cases 'were 'selected 'by 'the
                    'coverage 'strategy. '\o '\n
               else if narrowing?(LTC)
                    then nil
                    else '\n '\b qid(string(N1, 10)) 'test 'cases 'were 'generated. '\o '\n
                    fi
               fi /\
       QIL2 := if N2 > 0 then
               '\n '\b qid(string(N2, 10)) 'test 'cases 'are 'correct 'with 'respect 'to 'the
               'correct 'module. '\o '\n
               else nil
               fi /\
       QIL3 := if N3 > 0 then
               '\n '\b qid(string(N3, 10)) 'test 'cases 'are 'incorrect 'with 'respect 'to
               'the 'correct 'module. '\o '\n
               else nil
               fi /\
       QIL4 := if N4 > 0 then
               '\n '\b qid(string(N4, 10)) 'test 'cases 'have 'as 'result 'sort 'a 'sort
               'bigger 'than 'the 'expected 'in 'the 'correct 'module. '\o '\n
               else nil
               fi /\
       QIL5 := if N5 > 0 then
               '\n '\b qid(string(N5, 10)) 'test 'cases 'have 'as 'result 'sort 'a 'sort
               'smaller 'than 'the 'expected 'in 'the 'correct 'module. '\o '\n
               else nil
               fi /\
       QIL6 := if N6 > 0 then
               '\n '\b qid(string(N6, 10)) 'test 'cases 'were 'not 'reduced 'to
               'normal 'form. '\o '\n
               else nil
               fi /\
       QIL7 := if N7 > 0 then
               '\n '\b qid(string(N7, 10)) 'test 'cases 'could 'not 'be 'checked 'againt
               'the 'correct 'module. '\o '\n
               else nil
               fi /\
       QIL8 := if N8 > 0 then
               '\n '\b qid(string(N8, 10)) 'test 'cases 'have 'to 'be 'checked 'by
               'the 'user: '\o '\n printUserTests(M, LTC)
               coverageInfoMsg(M, CI)
               else nil
               fi /\
       QIL9 := if N9 > 0 then
               '\n '\b qid(string(N9, 10)) 'test 'cases 'have 'to 'be 'checked 'by
               'the 'user: '\o '\n printUserTests(M, LTC)
               coverageInfoMsg(M, CI)
               else nil
               fi /\
       QIL10 := if N10 > 0 then
                '\n '\b qid(string(N10, 10)) 'test 'cases 'have 'to 'be 'checked 'by
                'the 'user: '\o '\n printUserTests(M, LTC)
                coverageInfoMsg(M, CI)
                else nil
                fi /\
       QIL11 := if N11 > 0 then
                '\n '\b qid(string(N11, 10)) 'test 'cases 'have 'been 'checked: '\o '\n
                printUserTests(M, LTC)
                coverageInfoMsg(M, CI)
                else nil
                fi /\
       QIL12 := if N12 > 0 then
                '\n '\b qid(string(N12, 10)) 'test 'cases 'have 'been 'checked: '\o '\n
                printUserTests(M, LTC)
                coverageInfoMsg(M, CI)
                else nil
                fi /\
       QIL13 := if N13 > 0 then
                if narrowing?(LTC)
                then nil
                else
                '\n '\b qid(string(N13, 10)) 'test 'cases 'have 'been 'checked: '\o '\n
                fi
                printUserTests(M, LTC)
                coverageInfoMsg(M, CI)
                else nil
                fi .

   op coverageInfoMsg : Module CoverageInfo -> QidList .
   eq coverageInfoMsg(M, noCoverageInfo) = nil .
   eq coverageInfoMsg(M, globalCoverage(nil)) = '\n '\b 'All 'the 'statements 'were
                                                'covered. '\o '\n .
   eq coverageInfoMsg(M, globalCoverage(QIL)) = printLabelsNoUsed(QIL) [owise] .
   eq coverageInfoMsg(M, callCoverage(empty)) = '\n '\b 'All 'calls 'were 'covered. '\o '\n .
   eq coverageInfoMsg(M, callCoverage(SC)) = printEqsNotCovered(M, SC) [owise] .
   eq coverageInfoMsg(M, mbCoverage(nil, QIL')) = '\n '\b 'All 'the 'positive 'information
                                                  'was 'covered. '\o '\n '\n
                                                  printLabelsNoFail(QIL') .
   eq coverageInfoMsg(M, mbCoverage(QIL, nil)) = printLabelsNoUsed(QIL)
                                                 '\n '\n '\b 'All 'the 'negative 'information
                                                 'was 'covered. '\o '\n .
   eq coverageInfoMsg(M, mbCoverage(QIL, QIL')) = printLabelsNoUsed(QIL)
                                                  printLabelsNoFail(QIL') [owise] .
   eq coverageInfoMsg(M, sysCoverage(QS, QS', SI)) = printLabelsNoUsed(qidset2qidlist(QS))
                                                     printLabelsNoFail(qidset2qidlist(QS')) '\n
                                                     *** La siguiente linea sobra
                                                     '\n printSysInfo(M, SI) .

   op qidset2qidlist : QidSet -> QidList .
   eq qidset2qidlist(none) = nil .
   eq qidset2qidlist(Q ; QS) = Q qidset2qidlist(QS) .

   op printSysInfo : Module SysInfo -> QidList .
   eq printSysInfo(M, empty) = nil .
   eq printSysInfo(M, (T |-> ARI, SI)) = printSysInfoAux(M, T, ARI) '\n printSysInfo(M, SI) .

   op printSysInfoAux : Module Term AllRulesInfo -> QidList .
   eq printSysInfoAux(M, T, ARI) = '\b 'Starting 'from 'the 'term '\o
                                   add-space(metaPrettyPrint(M, T, printOptions)) '\b 'the
                                   'following 'coverage 'has 'been 'computed: '\o '\n
                                   printSuccess(M, ARI) '\n printFail(M, ARI) .

   op printSuccess : Module AllRulesInfo -> QidList .
   eq printSuccess(M, noInfo) = nil .
   eq printSuccess(M, applied(Q, T, T') ARI) = '\t '\b 'The 'rule '\o Q '\b 'was 'applied 'to
                                               '\o add-space(metaPrettyPrint(M, T, printOptions))
                                               '\b 'to 'obtain '\o
                                               add-space(metaPrettyPrint(M, T', printOptions))
                                               '\n printSuccess(M, ARI) .
   eq printSuccess(M, RCI ARI) = printSuccess(M, ARI) [owise] .

   op printFail : Module AllRulesInfo -> QidList .
   eq printFail(M, noInfo) = nil .
   eq printFail(M, fail(Q, T) ARI) = '\t '\b 'The 'rule '\o Q '\b 'could 'not 'be 'applied 'to
                                     '\o add-space(metaPrettyPrint(M, T, printOptions))
                                     '\n printFail(M, ARI) .
   eq printFail(M, RCI ARI) = printFail(M, ARI) [owise] .

   op printEqsNotCovered : Module Set{Call} -> QidList .
   eq printEqsNotCovered(M, empty) = nil .
   eq printEqsNotCovered(M, ([Eq, T, EqS], SC)) = '\n '\b 'The 'term '\o
                                               add-space(metaPrettyPrint(M, T, printOptions))
                                               '\b 'from 'the 'equation '\o '\n
                                               metaPrettyPrintEq(M, Eq)
                                               '\n '\b 'did 'not 'cover 'the 'equations '\o '\n
                                               printEqs(EqS) '\n
                                               printEqsNotCovered(M, SC) .

   op printEqs : EquationSet -> QidList .
   eq printEqs(eq T = T' [label(Q) AttrS] . EqS) = Q printEqs(EqS) .
   eq printEqs(ceq T = T' if C [label(Q) AttrS] . EqS) = Q printEqs(EqS) .
   eq printEqs(EqS) = nil [owise] .

   op printTests : Module List{TestCase} -> QidList .
   eq printTests(M, LTC) = printTests(M, LTC, 1) .

   op printTests : Module List{TestCase} Nat -> QidList .
   eq printTests(M, nil, N) = nil .
   ceq printTests(M, < T, Ty, TCS > LTC, N) = QIL printTests(M, LTC, s(N))
    if QIL := termMb(M, T, Ty, N) .
   ceq printTests(M, < T, T', TCS > LTC, N) = QIL printTests(M, LTC, s(N))
    if QIL := termReduction(M, T, T', N) [owise] .

   op printTests : Module List{TestCase} Nat -> QidList .
   eq printTests(M, LTC, N) = printTests(M, LTC, 1, N) .

   op printTests : Module List{TestCase} Nat Nat -> QidList .
   eq printTests(M, nil, N, N') = nil .
   eq printTests(M, LTC, N, 0) = nil .
   ceq printTests(M, < T, Ty, TCS > LTC, N, s(N')) =
                                      QIL printTests(M, LTC, s(N), N')
    if QIL := termMb(M, T, Ty, N) .
   ceq printTests(M, < T, T', TCS > LTC, N, s(N')) =
                                      QIL printTests(M, LTC, s(N), N')
    if QIL := termReduction(M, T, T', N) [owise] .

   op skip : List{TestCase} Nat -> List{TestCase} .
   eq skip(nil, N) = nil .
   eq skip(LTC, 0) = LTC .
   eq skip(TC LTC, s(N)) = skip(LTC, N) .

   op printUserTests : Module List{TestCase} -> QidList .
   eq printUserTests(M, LTC) = printUserTests(M, LTC, 1) .

   op printUserTests : Module List{TestCase} Nat -> QidList .
   eq printUserTests(M, nil, N) = nil .
   ceq printUserTests(M, < T, Ty, noInfo > LTC, N) = QIL printUserTests(M, LTC, s(N))
    if QIL := termMb(M, T, Ty, N) .
   ceq printUserTests(M, < T, Ty, userBigger > LTC, N) = QIL printUserTests(M, LTC, s(N))
    if QIL := termMb(M, T, Ty, N) .
   ceq printUserTests(M, < T, T', noInfo > LTC, N) = QIL printUserTests(M, LTC, s(N))
    if QIL := termReduction(M, T, T', N) .
   ceq printUserTests(M, < T, T', sysCov > LTC, N) = QIL printUserTests(M, LTC, s(N))
    if QIL := sysCovTerm(M, T, N) .
   ceq printUserTests(M, < T, T', failureProp > LTC, N) = QIL printUserTests(M, LTC, s(N))
    if QIL := termFailsInv(M, T, T', N) .
   ceq printUserTests(M, < T, T', fulfillProp > LTC, N) = QIL printUserTests(M, LTC, s(N))
    if QIL := termFulfillInv(M, T, N) .
   ceq printUserTests(M, < T, T', uncheckedProp > LTC, N) = QIL printUserTests(M, LTC, s(N))
    if QIL := termUncheckedInv(M, T, N) .
   ceq printUserTests(M, < T, T', fulfillPropMC > LTC, N) = QIL printUserTests(M, LTC, s(N))
    if QIL := termFulfillMC(M, T, N) .
   ceq printUserTests(M, < T, T', failurePropMC > LTC, N) = QIL printUserTests(M, LTC, s(N))
    if QIL := termFailureMC(M, T, T', N) .
   ceq printUserTests(M, < T, T', okConformance > LTC, N) = QIL printUserTests(M, LTC, s(N))
    if QIL := okConformance(M, T, N) .
   ceq printUserTests(M, okConformance LTC, N) = QIL printUserTests(M, LTC, s(N))
    if QIL := okConformance .
   ceq printUserTests(M, failureConformance(T1, QIL, T2, T3) LTC, N) = QIL' printUserTests(M, LTC, s(N))
    if QIL' := failureConformance(M, T1, QIL, T2, T3, N) .
   ceq printUserTests(M, failureConformance(T1, QIL, Q) LTC, N) = QIL' printUserTests(M, LTC, s(N))
    if QIL' := failureConformance(M, T1, QIL, Q, N) .
   eq printUserTests(M, TC LTC, N) = printUserTests(M, LTC, N) [owise] .

   op termReduction : Module Term Term Nat -> QidList .
   eq termReduction(M, T, T', N) = '\n '\t '\b '\! qid(string(N, 10) + ".") '\o '\b 'The 'term '\o
              add-space(metaPrettyPrint(M, T, printOptions)) '\b 'has 'been 'reduced 'to
              '\o add-space(metaPrettyPrint(M, T', printOptions)) '\n .

   op sysCovTerm : Module Term Nat -> QidList .
   eq sysCovTerm(M, T, N) = '\n '\t '\b '\! qid(string(N, 10) + ".") '\o '\b
                            add-space(metaPrettyPrint(M, T, printOptions)) '\n .

   op termMb : Module Term Term Nat -> QidList .
   eq termMb(M, T, Ty, N) = '\n '\t '\b '\! qid(string(N, 10) + ".") '\o '\b 'The 'term '\o
              add-space(metaPrettyPrint(M, T, printOptions)) '\b 'has 'sort
              '\o Ty '\n .

   op termReduction : Module Term Term -> QidList .
   eq termReduction(M, T, T') = '\n '\t '\b 'The 'term '\o
              add-space(metaPrettyPrint(M, T, printOptions)) '\b 'has 'been 'reduced 'to
              '\o add-space(metaPrettyPrint(M, T', printOptions)) '\n .

   op termFulfillInv : Module Term Nat -> QidList .
   eq termFulfillInv(M, T, N) =  '\n '\t '\b '\! qid(string(N, 10) + ".") '\o '\b 'The 'term '\o
              add-space(metaPrettyPrint(M, T, printOptions)) '\b 'fulfills 'the 'invariant. '\o '\n .

   op termUncheckedInv : Module Term Nat -> QidList .
   eq termUncheckedInv(M, T, N) =  '\n '\t '\b '\! qid(string(N, 10) + ".") '\o '\b 'The 'term '\o
              add-space(metaPrettyPrint(M, T, printOptions)) '\b 'was 'not 'checked. '\o '\n .

   op termFailsInv : Module Term Term Nat -> QidList .
   eq termFailsInv(M, T, T', N) =  '\n '\t '\b '\! qid(string(N, 10) + ".") '\o '\b 'The 'term '\o
              add-space(metaPrettyPrint(M, T, printOptions)) '\b 'reaches 'the 'state '\o
              add-space(metaPrettyPrint(M, T', printOptions)) '\b '`, ' 'which 'does 'not
              'fulfill 'the 'invariant. '\o '\n .

   op termFulfillMC : Module Term Nat -> QidList .
   eq termFulfillMC(M, T, N) =  '\n '\t '\b '\! qid(string(N, 10) + ".") '\o '\b 'The 'term '\o
              add-space(metaPrettyPrint(M, T, printOptions)) '\b 'fulfills 'the 'formula. '\o '\n .

   op termFailureMC : Module Term Term Nat -> QidList .
   eq termFailureMC(M, T, T', N) =  '\n '\t '\b '\! qid(string(N, 10) + ".") '\o '\b 'The 'term '\o
              add-space(metaPrettyPrint(M, T, printOptions)) '\b 'does 'not 'fulfills 'the 'formula. '\o '\n
              printCounterexample(M, T') .

   op printCounterexample : Module Term -> QidList .
   eq printCounterexample(M, Q[TL]) = '\n '\n '\! 'Counterexample: '\n '\o printCounterexample*(M, TL) '\n .

   op printCounterexample* : Module TermList -> QidList .
   eq printCounterexample*(M, empty) = nil .
   eq printCounterexample*(M, ('`{_`,_`}[T, T'], TL)) = '\b 'The 'rule '\!
          downTerm(T', 'error) '\o '\b 'is 'applied 'to '\o
          add-space(metaPrettyPrint(M, T, printOptions)) '\n
          printCounterexample*(M, TL) .

   op okConformance : Module Term Nat -> QidList .
   eq okConformance(M, T, N) =  '\n '\t '\b '\! qid(string(N, 10) + ".") '\o '\b 'Starting 'from
             'the 'term '\o add-space(metaPrettyPrint(M, T, printOptions)) '`, '
             '\b 'the 'implementation 'conforms 'the 'specification. '\o '\n .

   op okConformance : -> QidList .
   eq okConformance = '\n '\b 'The 'implementation 'conforms 'the 'specification. '\o '\n .

   op failureConformance : Module Term QidList Term Term Nat -> QidList .
   eq failureConformance(M, T1, QIL Q, T2, T3, N) =
           '\n '\t '\b '\! qid(string(N, 10) + ".") '\o '\b 'Starting 'from 'the 'term
           '\o add-space(metaPrettyPrint(M, T1, printOptions)) '\b
           'the 'rules '\o QIL '\b 'have 'produced '\n '\t '\t
           'the 'term '\o add-space(metaPrettyPrint(M, T2, printOptions)) '\b 'in 'the 'module 'under
           'test 'and '\n '\t '\t
           'the 'term '\o add-space(metaPrettyPrint(M, T3, printOptions)) '\b 'in 'the 'specification.
           '\n '\t '\t 'The 'rule '\o Q '\b 'could 'not 'be 'applied 'to 'the 'former. '\o '\n .

   op failureConformance : Module Term QidList Qid Nat -> QidList .
   eq failureConformance(M, T1, QIL, Q, N) =
       if QIL =/= nil then
           '\n '\t '\b 'Starting 'from 'the 'term
           '\o add-space(metaPrettyPrint(M, T1, printOptions)) '\b
           'the 'rules '\o QIL '\b 'have 'been 'applied 'in 'both 'the 'specification 'and 'the
           'implementation.
           '\n '\t '\t 'The 'rule '\o Q '\b 'could 'not 'be 'applied 'to 'the 'latter. '\o '\n
       else
           '\n '\t '\b 'Starting 'from 'the 'term
           '\o add-space(metaPrettyPrint(M, T1, printOptions)) '\b
           'the 'rule '\o Q '\b 'could 'not 'be 'applied 'to 'the 'implementation. '\o '\n
       fi .

   op intro : QidList QidList -> QidList .
   eq intro(QIL, QIL') = if QIL' == nil then nil
                                        else QIL QIL'
                         fi .

   op printLabelsNoUsed : QidList -> QidList .
   eq printLabelsNoUsed(nil) = '\n '\b 'All 'the 'statements 'were 'checked. '\o .
   ceq printLabelsNoUsed(QIL) = intro(QIL', QIL)
    if QIL' := '\n '\b 'The 'following 'statements 'were 'not 'checked 'with 'the 'given 'test
               'cases: '\o '\n [owise] .

   op printLabelsNoFail : QidList -> QidList .
   eq printLabelsNoFail(nil) = '\n '\b 'All 'the 'negative 'information 'was 'checked. '\o .
   ceq printLabelsNoFail(QIL) = intro(QIL', QIL)
    if QIL' := '\n '\b 'The 'test 'cases 'do 'not 'provide 'negative 'information 'for 'the
               'following 'statements: '\o '\n [owise] .

   op testListSize : List{TestCase} -> Nat .
   eq testListSize(nil) = 0 .
   eq testListSize(TC LTC) = s(testListSize(LTC)) .

   op numStatus : List{TestCase} TestStatus -> Nat .
   eq numStatus(nil, TCS) = 0 .
   eq numStatus(< T, T', TCS > LTC, TCS) = s(numStatus(LTC, TCS)) .
   eq numStatus(TC LTC, TCS) = numStatus(LTC, TCS) [owise] .

   op numStatusConformance : List{TestCase} -> Nat .
   eq numStatusConformance(nil) = 0 .
   eq numStatusConformance(< T, T', okConformance > LTC) = s(numStatusConformance(LTC)) .
   eq numStatusConformance(okConformance LTC) = s(numStatusConformance(LTC)) .
   eq numStatusConformance(failureConformance(T1, QIL, T2, T3) LTC) = s(numStatusConformance(LTC)) .
   eq numStatusConformance(failureConformance(T1, QIL, Q) LTC) = s(numStatusConformance(LTC)) .
   eq numStatusConformance(TC LTC) = numStatusConformance(LTC) [owise] .

   op numStatusSort : List{TestCase} -> Nat .
   eq numStatusSort(nil) = 0 .
   eq numStatusSort(< T, Ty, TCS > LTC) = s(numStatusSort(LTC)) .
   eq numStatusSort(TC LTC) = numStatusSort(LTC) [owise] .

   ops correctMsg incorrectMsg notNormMsg : -> QidList .
   eq correctMsg = '\n '\b 'The 'following 'test 'cases 'are 'correct 'with
                   'respect 'to 'the 'correct 'module: '\n .
   eq incorrectMsg = '\n '\b 'The 'following 'test 'cases 'are 'incorrect 'with
                   'respect 'to 'the 'correct 'module: '\n .
   eq notNormMsg = '\n '\b 'The 'following 'test 'cases 'are 'not 'in 'normal 'form: '\o '\n .

   op narrowing? : List{TestCase} -> Bool .
   eq narrowing?(nil) = false .
   eq narrowing?(okConformance LTC) = true .
   eq narrowing?(failureConformance(T, QIL, Q) LTC) = true .
   eq narrowing?(TC LTC) = narrowing?(LTC) [owise] .

   op printRuleStmntRelSet : Module RuleStmntRelSet -> QidList .
   eq printRuleStmntRelSet(M, mtRSR) = nil .
   eq printRuleStmntRelSet(M, RSR RSRS) = printRuleStmntRel(M, RSR) printRuleStmntRelSet(M, RSRS) .

   op printRuleStmntRel : Module RuleStmntRel -> QidList .
   eq printRuleStmntRel(M, Q ~> empty) = nil .
   ceq printRuleStmntRel(M, Q ~> V) = '\n '\b 'The 'rule '\o Q ':
                                      metaPrettyPrint(M, R)
                                      '\b 'applies 'the 'statement '\o '\n
                                      metaPrettyPrint(M, T) '\b
                                      'identified 'by 'the 'variable '\o getName(V) '\n
    if R := getRule(M, Q) /\
       T := getStmnt(R, V) .

   op getRule : Module Qid ~> Rule .
   eq getRule(M, Q) = getRule(getRls(M), Q) .

   op getLHS : Rule -> Term .
   eq getLHS(rl T => T' [AtS] .) = T .
   eq getLHS(crl T => T' if COND [AtS] .) = T .

   op getRule : RuleSet Qid ~> Rule .
   eq getRule(rl T => T' [label(Q) AtS] . RlS, Q) = rl T => T' [label(Q) AtS] . .
   eq getRule(crl T => T' if COND [label(Q) AtS] . RlS, Q) = crl T => T' if COND [label(Q) AtS] . .

   op getStmnt : Rule Variable ~> Term .
   eq getStmnt(rl T => T' [AtS] ., V) = getStmnt(T, V) .
   eq getStmnt(crl T => T' if COND [AtS] ., V) = getStmnt(T, V) .

   op getStmnt : Term Variable ~> Term .
   eq getStmnt('stmntIndx[T, V], V) = T .
   eq getStmnt('stmntIndx[T, T'], V) = getStmnt(T, V) .
   eq getStmnt(Q[TL], V) = getStmnt*(TL, V) [owise] .

   op getStmnt* : TermList Variable ~> Term .
   ceq getStmnt*((T, TL), V) = if T? :: Term
                               then T?
                               else getStmnt*(TL, V)
                               fi
    if T? := getStmnt(T, V) .

  op printSemanticsRules : Module -> QidList .
  eq printSemanticsRules(M) = printSemanticsRules(M, getRls(M)) .

  op printSemanticsRules : Module RuleSet -> QidList .
  eq printSemanticsRules(M, none) = nil .
  eq printSemanticsRules(M, R RlS) = printSemanticsRule(M, R) printSemanticsRules(M, RlS) .

  op printSemanticsRule : Module Rule -> QidList .
  eq printSemanticsRule(M, R) = if semanticsRule?(R)
                                then '\n '\b 'Rule '\o ruleLabel(R) ':
                                     metaPrettyPrint(M, R)
                                else nil
                                fi .

  op semanticsRule? : Rule -> Bool .
  eq semanticsRule?(rl T => T' [AtS] .) = univOp?(T) .
  eq semanticsRule?(crl T => T' if COND [AtS] .) = univOp?(T) .

  op univOp? : Term -> Bool .
  eq univOp?(V) = false .
  eq univOp?(Ct) = false .
  eq univOp?('stmntIndx[TL]) = true .
  eq univOp?(Q[TL]) = univOp?*(TL) [owise] .

  op univOp?* : TermList -> Bool .
  eq univOp?*(empty) = false .
  eq univOp?*((T, TL)) = univOp?(T) or-else univOp?*(TL) .

  op ruleLabel : Rule ~> Qid .
  eq ruleLabel(rl T => T' [AtS label(Q)] .) = Q .
  eq ruleLabel(crl T => T' if C [AtS label(Q)] .) = Q .
endfm

***(%
\end{comment}

The \texttt{PAIR} module defines pairs of elements, that satisfy the
theory \texttt{TRIV}, and the corresponding projection functions:

{\codesize
\begin{verbatim}
%)

 fmod PAIR{X :: TRIV, Y :: TRIV} is
  sort Pair{X, Y} .
  op <_,_> : X$Elt Y$Elt -> Pair{X, Y} [ctor] .

  var X : X$Elt .
  var Y : Y$Elt .

  op first : Pair{X, Y} -> X$Elt .
  op second : Pair{X, Y} -> Y$Elt .

  eq first(< X, Y >) = X .
  eq second(< X, Y >) = Y .
 endfm

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

 view Substitution from TRIV to META-TERM is
  sort Elt to Substitution .
 endv

 view Context from TRIV to META-TERM is
  sort Elt to Context .
 endv

 view NeCTermList from TRIV to META-TERM is
  sort Elt to NeCTermList .
 endv

 view NatList from TRIV to NAT-LIST is
  sort Elt to NatList .
 endv

 view Forest from TRIV to PROOF-TREE is
  sort Elt to Forest .
 endv

 view MaybeForest from TRIV to MAYBE{Forest} is
  sort Elt to Maybe{Forest} .
 endv

 view Tree from TRIV to PROOF-TREE is
  sort Elt to Tree .
 endv

 view Type from TRIV to META-TERM is
  sort Elt to Type .
 endv

 view Sort from TRIV to META-TERM is
  sort Elt to Sort .
 endv

 view Equation from TRIV to META-MODULE is
  sort Elt to Equation .
 endv

 view CallSet from TRIV to SET{Call} is
  sort Elt to Set{Call} .
 endv

***(%
\end{verbatim}
}

\end{comment}

When navigating the debugging tree, the user can decide to trust the
statement associated to the current question. In this case, the tree
will be pruned, deleting all the nodes associated with this statement:

{\codesize
\begin{verbatim}
%)

 fmod TREE-PRUNING is
  pr PROOF-TREE .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  var  A : Tree .
  vars T T' : Term .
  var  TL : TermList .
  vars Q Q' : Qid .
  vars N N' N'' : Nat .
  vars F F' F'' : Forest .
  var  S : Type .
  var  C : Context .
  var  J : Judgment .

***(%
\end{verbatim}
}

\end{comment}

{\codesize
\begin{verbatim}
%)

  op prune : Tree Qid -> Tree .

***(%
  ...
 endfm
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  ceq prune(tree(J, N, F), Q) = tree(J, sd(N, N'), F')
   if [F', N'] := prune2*(F, Q) .

***(%
\end{verbatim}
}

{\codesize
\begin{verbatim}
%)

  op prune2 : Tree Qid -> DeletionPair .
  op prune2* : Forest Qid -> DeletionPair .

  ceq prune2(tree(Q : T -> T', N, F), Q) = [F', N' + 1]
   if [F', N'] := prune2*(F, Q) .
  ceq prune2(tree(Q : T =>1 T', N, F), Q) = [F', N' + 1]
   if [F', N'] := prune2*(F, Q) .
  ceq prune2(tree(Q : T : S, N, F), Q) = [F', N' + 1]
   if [F', N'] := prune2*(F, Q) .
  ceq prune2(tree(T =>q[Q] {TL}, N, F), Q) = [F', N' + 1]
   if [F', N'] := prune2*(F, Q) .
  ceq prune2(tree(J, N, F), Q) = [tree(J, sd(N, N'), F'), N']
   if [F', N'] := prune2*(F, Q) [owise] .

  eq prune2*(mtForest, Q) = [mtForest, 0] .
  ceq prune2*(A F, Q) = [F' F'', N' + N'']
   if [F', N'] := prune2(A, Q) /\
      [F'', N''] := prune2*(F, Q) .
 endfm

***(%
\end{verbatim}
}

\end{comment}

The module \texttt{STRAT} defines the different navigation strategies
available. The constant \texttt{td} stands for top-down, \texttt{dq}
for divide and query, and \verb"ss" for \verb"single-stepping":

{\codesize
\begin{verbatim}
%)

 fmod STRAT is
  sort Strat .
  ops td dq ss : -> Strat .
 endfm

***(%
\end{verbatim}
}

The different types of tree that can be built
are specified in the module \texttt{TREE-TYPE} below. The
constant \texttt{os} identifies the one-step tree, while
\texttt{ms} refers to the many-steps tree:

{\codesize
\begin{verbatim}
%)

 fmod TREE-TYPE is
  sort TreeType .
  ops os ms : -> TreeType .
 endfm

***(%
\end{verbatim}
}

The module \texttt{DDSTATE} keeps the information needed to
restore the state when the command \texttt{undo} is used: the
current node, the debugging tree, and the navigation strategy:

{\codesize
\begin{verbatim}
%)

 fmod DDSTATE is
  pr NAT-LIST .
  pr PROOF-TREE .
  pr STRAT .

  sort DDState .

  op <_,_,_> : NatList Tree Strat -> DDState .
 endfm

***(%
\end{verbatim}
}

The view \texttt{DDState} will be used to define a list of the
previous states:

{\codesize
\begin{verbatim}
%)

 view DDState from TRIV to DDSTATE is
  sort Elt to DDState .
 endv

***(%
\end{verbatim}
}

\begin{comment}

In order to avoid to make the same question twice, the
answers given by the user are kept. The module
\texttt{ANSWER} defines the structure of the answers:

{\codesize
\begin{verbatim}
%)

 fmod ANSWER is
  pr META-TERM .

  sorts Answer Result .

  ops right wrong unknown : -> Result .

  op <_,_,_> : Term TermList Result -> Answer .
  op <_,_,_> : Term Sort Result -> Answer .
 endfm

***(%
\end{verbatim}
}

We define a view \texttt{Answer} to instantiate lists
of answers:

{\codesize
\begin{verbatim}
%)

 view Answer from TRIV to ANSWER is
  sort Elt to Answer .
 endv

***(%
\end{verbatim}
}


\end{comment}

The module \texttt{SEARCH-TYPE} defines the different
kinds of searches, where the constant \texttt{zeroOrMore} designates
searches in zero or more steps, \texttt{oneOrMore} searches in one
or more steps, and \texttt{final} searches for final terms
(corresponding to the arrows \verb"=>*", \verb"=>+", and \verb"=>!",
respectively):

{\codesize
\begin{verbatim}
%)

 fmod SEARCH-TYPE is
  sort SearchType .
  ops final zeroOrMore oneOrMore : -> SearchType .
 endfm

***(%
\end{verbatim}
}

The \texttt{MODULES} module deals with the operations defined over modules.
It defines the following functions:

{\codesize
\begin{verbatim}
%)

 fmod MODULES is
  pr META-LEVEL .
  pr MAYBE{Module} * (op maybe to undefMod) .
  pr CONVERSION .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  vars Q Q' : Qid .
  vars QS QS' : QidSet .
  var  Eq : Equation .
  vars EqS EqS' : EquationSet .
  vars IL : ImportList .
  vars SS SS' : SortSet .
  vars S' S'' : Sort .
  vars SSD : SubsortDecl .
  vars SSDS SSDS' : SubsortDeclSet .
  vars OD : OpDecl .
  vars ODS ODS' : OpDeclSet .
  var  MA : MembAx .
  vars MAS MAS' : MembAxSet .
  var  C : Condition .
  var  M M1 M2 : Module .
  var  M' : [Module] .
  var  AtS : AttrSet .
  vars T T' : Term .
  var  TL : TermList .
  var  N : Nat .
  vars S Ty : Type .
  var  TyL : TypeList .
  var  R : Rule .
  vars RlS RlS' : RuleSet .
  var  FM : FModule .
  var  SM : SModule .
  var  NNL : NeNatList .

***(%
\end{verbatim}
}

\end{comment}

\begin{itemize}

\item \texttt{functional2system}, that transforms a functional
module into a system module by adding the empty set of rules:

{\codesize
\begin{verbatim}
%)

  op functional2system : Module -> SModule .
  eq functional2system(fmod Q is IL sorts SS . SSDS ODS MAS EqS endfm) =
     mod Q is IL sorts SS . SSDS ODS MAS EqS none endm .
  eq functional2system(SM) = SM .

***(%
\end{verbatim}
}

\item \texttt{quitDefs}, that deletes all the membership axioms, equations, and rules:

{\codesize
\begin{verbatim}
%)

  op quitDefs : Module -> Module [memo] .
  eq quitDefs(fmod Q is IL sorts SS . SSDS ODS MAS EqS endfm) =
           fmod Q is IL sorts SS . SSDS ODS none none endfm .
  eq quitDefs(mod Q is IL sorts SS . SSDS ODS MAS EqS RlS endm) =
           mod Q is IL sorts SS . SSDS ODS none none none endm .

***(%
\end{verbatim}
}

\item \texttt{deleteSuspicious}, that given a module and a set of suspicious
labels, transforms the module by deleting these statements:

{\codesize
\begin{verbatim}
%)

  op deleteSuspicious : Module QidSet -> Module .
  eq deleteSuspicious(FM, QS) = deleteSuspicious(functional2system(FM), QS) .
  eq deleteSuspicious(mod Q is IL sorts SS . SSDS ODS MAS EqS RlS endm, QS) =
   mod Q is
    IL
    sorts SS .
    SSDS
    ODS
    delete(MAS, QS)
    delete(EqS, QS)
    delete(RlS, QS)
   endm .

  op delete : MembAxSet QidSet -> MembAxSet .
  op delete : EquationSet QidSet -> EquationSet .
  op delete : RuleSet QidSet -> RuleSet .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  eq delete(mb T : S [label(Q) AtS] . MAS, Q ; QS) = delete(MAS, QS) .
  eq delete(cmb T : S if C [label(Q) AtS] . MAS, Q ; QS) = delete(MAS, QS) .
  eq delete(MAS, QS) = MAS [owise] .

  eq delete(eq T = T' [label(Q) AtS] . EqS, Q ; QS) = delete(EqS, QS) .
  eq delete(ceq T = T' if C [label(Q) AtS] . EqS, Q ; QS) = delete(EqS, QS) .
  *** We also remove the equations with the ``owise'' attribute, in order to prevent
  *** the trusted module to infer erroneous results.
  eq delete(eq T = T' [owise AtS] . EqS, QS) = delete(EqS, QS) .
  eq delete(ceq T = T' if C [owise AtS] . EqS, QS) = delete(EqS, QS) .
  *** Ditto for _==_ and _=/=_
  ceq delete(eq T = T' [AtS] . EqS, QS) = delete(EqS, QS)
   if containsEquality(T') .
  ceq delete(ceq T = T' if C [AtS] . EqS, QS) = delete(EqS, QS)
   if containsEqualityCond(C) or containsEquality(T') .
  eq delete(EqS, QS) = EqS [owise] .

  op containsEquality : Term -> Bool .
  eq containsEquality(Q[TL]) = (Q == '_==_) or (Q == '_=/=_) or containsEquality*(TL) .
  eq containsEquality(T) = false [owise] .

  op containsEquality* : TermList -> Bool .
  eq containsEquality*(empty) = false .
  eq containsEquality*((T, TL)) = containsEquality(T) or containsEquality*(TL) .

  op containsEqualityCond : Condition -> Bool .
  eq containsEqualityCond(nil) = false .
  eq containsEqualityCond(T = T' /\ C) = containsEquality(T) or containsEquality(T') or
                                         containsEqualityCond(C) .
  eq containsEqualityCond(T := T' /\ C) = containsEquality(T') or
                                          containsEqualityCond(C) .
  eq containsEqualityCond(T : Ty /\ C) = containsEquality(T) or
                                         containsEqualityCond(C) .
  eq containsEqualityCond(T => T' /\ C) = containsEquality(T) or
                                          containsEqualityCond(C) .

  eq delete(rl T => T' [label(Q) AtS] . RlS, Q ; QS) = delete(RlS, QS) .
  eq delete(crl T => T' if C [label(Q) AtS] . RlS, Q ; QS) = delete(RlS, QS) .
  eq delete(RlS, QS) = RlS [owise] .

***(%
\end{verbatim}
}

\item The funciton \texttt{greaterSorts} computes the sorts greater than the given one:

{\codesize
\begin{verbatim}
%)

  op greaterSorts : Module Sort -> SortSet .
  op greaterSorts : Module Sort SortSet SortSet -> SortSet .

  eq greaterSorts(M, S') = greaterSorts(M, S', getSorts(M), none) .
  eq greaterSorts(M, S', none, SS) = SS .
  eq greaterSorts(M, S', S'' ; SS, SS') = if sortLeq(M, S', S'') and-then S' =/= S''
                                        then greaterSorts(M, S', SS, S'' ; SS')
                                        else greaterSorts(M, S', SS, SS')
                                        fi .

***(%
\end{verbatim}
}

\item The funciton \texttt{labeling} labels the unlabeled rules:

{\codesize
\begin{verbatim}
%)

  op labeling : Module -> Module .
  eq labeling(FM) = labeling(functional2system(FM)) .
  eq labeling(mod Q is IL sorts SS . SSDS ODS MAS EqS RlS endm) =
   mod Q is
    IL
    sorts SS .
    SSDS
    ODS
    MAS
    EqS
    labeling(RlS, 0)
   endm .

  op labeling : RuleSet Nat -> RuleSet .
  ceq labeling(R RlS, N) = R labeling(RlS, N)
   if label?(R) .
  eq labeling(R RlS, N) = putLabel(R, N) labeling(RlS, s(N)) .
  eq labeling(none, N) = none .

  op putLabel : Rule Nat -> Rule .
  eq putLabel(rl T => T' [AtS] ., N) = rl T => T' [createLabel(N) AtS] . .
  eq putLabel(crl T => T' if C [AtS] ., N) = crl T => T' if C [createLabel(N) AtS] . .

  op createLabel : Nat -> Attr .
  eq createLabel(N) = label(qid("$@label(" + string(N, 10) + ")@$")) .

  op label? : Rule -> Bool .
  eq label?(rl T => T' [label(Q) AtS] .) = true .
  eq label?(crl T => T' if C [label(Q) AtS] .) = true .
  eq label?(R) = false [owise] .

***(%
\end{verbatim}
}

\end{comment}

\item \texttt{extractLabels}, that extracts all the labels in
a module. We use this function to know which statements
must be treated if the user decides to debug without selecting specific
labels:

{\codesize
\begin{verbatim}
%)

  op extractLabels : Module -> QidSet .
  op extractLabels : MembAxSet -> QidSet .
  op extractLabels : EquationSet -> QidSet .
  op extractLabels : RuleSet -> QidSet [memo] .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  eq extractLabels(FM) = extractLabels(functional2system(FM)) .
  eq extractLabels(SM) = extractLabels(getEqs(SM)) ; extractLabels(getMbs(SM)) ;
                         extractLabels(getRls(SM)) .
  eq extractLabels(M') = none .

  eq extractLabels(mb T : S [label(Q) AtS] . MAS) = Q ; extractLabels(MAS) .
  eq extractLabels(cmb T : S if C [label(Q) AtS] . MAS) = Q ; extractLabels(MAS) .
  eq extractLabels(MAS) = none [owise] .

  eq extractLabels(eq T = T' [label(Q) AtS] . EqS) = Q ; extractLabels(EqS) .
  eq extractLabels(ceq T = T' if C [label(Q) AtS] . EqS) = Q ; extractLabels(EqS) .
  eq extractLabels(EqS) = none [owise] .

  eq extractLabels(rl T => T' [label(Q) AtS] . RlS) = Q ; extractLabels(RlS) .
  eq extractLabels(crl T => T' if C [label(Q) AtS] . RlS) = Q ; extractLabels(RlS) .
  eq extractLabels(RlS) = none [owise] .

***(%
\end{verbatim}
}

\item The function \verb"extractLabelsSort" returns the set of labels associated to
the given sort, while \verb"extractLabelsSort*" returns the labels of all the sorts.

{\codesize
\begin{verbatim}
%)

  op extractLabelsSort : Sort Module -> QidSet .
  eq extractLabelsSort(S, FM) = none .
  eq extractLabelsSort(S, SM) = extractLabelsSort(SM, S, getRls(SM)) .

  op extractLabelsSort : Module Sort RuleSet -> QidSet .
  ceq extractLabelsSort(M, S, rl T => T' [label(Q) AtS] . RlS) = Q ; extractLabelsSort(M, S, RlS)
   if sameKind(M, S, type(M, T)) .
  ceq extractLabelsSort(M, S, crl T => T' if C [label(Q) AtS] . RlS) =
                                                                 Q ; extractLabelsSort(M, S, RlS)
   if sameKind(M, S, type(M, T)) .
  eq extractLabelsSort(M, S, RlS) = none [owise] .

  op extractLabelsSort* : SortSet Module -> QidSet .
  eq extractLabelsSort*(none, M) = none .
  eq extractLabelsSort*(S ; SS, M) = extractLabelsSort(S, M) ; extractLabelsSort*(SS, M) .

***(%
\end{verbatim}
}

\end{comment}

\item the functions \texttt{generalEq} and \texttt{generalMb}, that return the given
equation or membership as a conditional one:

{\codesize
\begin{verbatim}
%)

  op generalEq : Equation -> Equation .
  op generalMb : MembAx -> MembAx .
  op generalRl : Rule -> Rule .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  eq generalEq(eq T = T' [AtS] .) = ceq T = T' if nil [AtS] . .
  eq generalEq(Eq) = Eq [owise] .

  eq generalMb(mb T : S [AtS] .) = cmb T : S if nil [AtS] . .
  eq generalMb(MA) = MA [owise] .

  eq generalRl(rl T => T' [AtS] .) = crl T => T' if nil [AtS] . .
  eq generalRl(R) = R [owise] .

***(%
\end{verbatim}
}

\end{comment}

\item the functions \texttt{getLabel}, \texttt{getRighthand},
\texttt{getLefthand}, and \texttt{getCondition} extract the different
parts of a rule:

{\codesize
\begin{verbatim}
%)

  op getLabel : Rule ~> Qid .
  op getRighthand : Rule -> Term .
  op getLefthand : Rule -> Term .
  op getCondition : Rule -> Condition .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  eq getLabel(rl T => T' [AtS label(Q)] .) = Q .
  eq getLabel(crl T => T' if C [AtS label(Q)] .) = Q .

  eq getCondition(rl T => T' [AtS] .) = nil .
  eq getCondition(crl T => T' if C [AtS] .) = C .

  eq getRighthand(rl T => T' [AtS] .) = T' .
  eq getRighthand(crl T => T' if C [AtS] .) = T' .

  eq getLefthand(rl T => T' [AtS] .) = T .
  eq getLefthand(crl T => T' if C [AtS] .) = T .

***(%
\end{verbatim}
}

\item \texttt{owise?}, \texttt{assoc?}, and \texttt{comm?},
that check if an attribute set contains the attributes
\texttt{owise}, \texttt{assoc}, and \texttt{comm}:

{\codesize
\begin{verbatim}
%)

  ops owise? assoc? comm? : AttrSet -> Bool .
  eq owise?(owise AtS) = true .
  eq owise?(AtS) = false [owise] .

  eq assoc?(assoc AtS) = true .
  eq assoc?(AtS) = false [owise] .

  eq comm?(comm AtS) = true .
  eq comm?(AtS) = false [owise] .

***(%
\end{verbatim}
}

\item \texttt{in?}, that checks if an attribute set contains a label
that is also included in a given set:

{\codesize
\begin{verbatim}
%)

  op in? : AttrSet QidSet -> Bool .
  eq in?(label(Q) AtS, Q ; QS) = true .
  eq in?(AtS, QS) = false [owise] .

***(%
\end{verbatim}
}

\item \texttt{label}, that extracts the label from an attribute set:

{\codesize
\begin{verbatim}
%)

  op label : AttrSet ~> Qid .
  eq label(label(Q) AtS) = Q .

***(%
\end{verbatim}
}

\end{comment}

\item the functions \texttt{reduce}, \texttt{normal}, and \texttt{type},
that simply abbreviate the composition of other functions:

{\codesize
\begin{verbatim}
%)

  op reduce : Maybe{Module} Term ~> Term .
  eq reduce(M, T) = getTerm(metaReduce(M, T)) .

  op normal : Maybe{Module} Term ~> Term .
  eq normal(M, T) = getTerm(metaNormalize(M, T)) .

  op type : Maybe{Module} Term ~> Type .
  eq type(M, T) = getType(metaReduce(M, T)) .

  op typeTermWithVars : Maybe{Module} Term ~> Type .
  eq typeTermWithVars(M, T) = getType(metaNormalize(M, T)) .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  op strat? : Module -> Bool .
  op strat? : OpDeclSet -> Bool .

  eq strat?(M) = strat?(getOps(M)) .
  eq strat?(op Q : TyL -> Ty [strat(NNL) AtS] . ODS) = true .
  eq strat?(ODS) = false [owise] .

***(%
\end{verbatim}
}

\end{comment}

\item the function \verb"onlyCtors" removes from the given module the operators that
do not contain the \verb"ctor" attribute. In order to obtain a valid module, it also
removes all the equations, membership axioms, and rules:

{\codesize
\begin{verbatim}
%)

  op onlyCtors : Module -> Module [memo] .
  eq onlyCtors(mod Q is IL sorts SS . SSDS ODS MAS EqS RlS endm) =
        mod Q is IL sorts SS . SSDS onlyCtors(ODS) none none none endm .
  eq onlyCtors(fmod Q is IL sorts SS . SSDS ODS MAS EqS endfm) =
        fmod Q is IL sorts SS . SSDS onlyCtors(ODS) none none endfm .

  op onlyCtors : OpDeclSet -> OpDeclSet [memo] .
  eq onlyCtors(op '<Strings> : nil -> Ty [AtS] . ODS) = op '<Strings> : nil -> Ty [AtS] .
                                                        onlyCtors(ODS) .
  eq onlyCtors(op '<Floats> : nil -> Ty [AtS] . ODS) = op '<Strings> : nil -> Ty [AtS] .
                                                        onlyCtors(ODS) .
  eq onlyCtors(op '<Qids> : nil -> Ty [AtS] . ODS) = op '<Strings> : nil -> Ty [AtS] .
                                                        onlyCtors(ODS) .
  eq onlyCtors(op Q : TyL -> Ty [ctor AtS] . ODS) = op Q : TyL -> Ty [ctor AtS] .
                                                    onlyCtors(ODS) .
  eq onlyCtors(ODS) = none [owise] .

***(%
\end{verbatim}
}

\begin{comment}

\item the function \verb"quitNonexec" removes the equations with the attribute
\verb"nonexec" from the module:

{\codesize
\begin{verbatim}
%)

  op quitNonexec : Module -> Module .
  eq quitNonexec(mod Q is IL sorts SS . SSDS ODS MAS EqS RlS endm) =
            mod Q is IL sorts SS . SSDS ODS MAS quitNonexec(EqS) RlS endm .
  eq quitNonexec(fmod Q is IL sorts SS . SSDS ODS MAS EqS endfm) =
            fmod Q is IL sorts SS . SSDS ODS MAS quitNonexec(EqS) endfm .

  op quitNonexec : EquationSet -> EquationSet .
  eq quitNonexec(none) = none .
  eq quitNonexec(eq T = T' [nonexec AtS] . EqS) = quitNonexec(EqS) .
  eq quitNonexec(ceq T = T' if C [nonexec AtS] . EqS) = quitNonexec(EqS) .
  eq quitNonexec(Eq EqS) = Eq quitNonexec(EqS) [owise] .

***(%
\end{verbatim}
}

\end{comment}

\item the function \verb"normalForm?" checks whether the term is in normal form with
respect to the given module by using the predefined function \verb"wellFormed"
in the module that only contains constructors:

{\codesize
\begin{verbatim}
%)

  op normalForm? : Module Term -> Bool .
  eq normalForm?(M, T) = wellFormed(onlyCtors(M), T) .

***(%
\end{verbatim}
}

{\codesize
\begin{verbatim}
  ...
%)

endfm

***(%
\end{verbatim}
}

\end{itemize}

\end{itemize}

\begin{comment}

The module \texttt{TERMS} manipulates terms

{\codesize
\begin{verbatim}
%)

fmod TERMS is
 pr MODULES .

 var  M : Module .
 var  Ty : Type .
 var  TyL : TypeList .
 var  Q : Qid .
 vars T T' : Term .
 var  TL : TermList .
 var  N : Nat .
 var  S : Sort .
 var  AtS : AttrSet .
 var  ODS : OpDeclSet .

 op createTerm : Module Qid ~> Term .
 eq createTerm(M, Q) = createTerm(M, Q, getTypeList(getOps(M), Q)) .

 op getTypeList : OpDeclSet Qid ~> TypeList .
 eq getTypeList(op Q : TyL -> Ty [AtS] . ODS, Q) = TyL .

 op createTerm : Module Qid TypeList -> Term .
 ceq createTerm(M, Q, nil) = qid(string(Q) + "." + string(getKind(M, Ty)))
  if Ty := getTypeConst(M, Q) .
 ceq createTerm(M, Q, TyL) = T'
  if T := Q[createVars(M, TyL, 0)] /\
     T' := getTerm(metaNormalize(M, T)) [owise] .

 op getTypeConst : Module Qid ~> Type .
 ceq getTypeConst(M, Q) = Ty
  if op Q : nil -> Ty [AtS] . ODS := getOps(M) .

 op createVars : Module TypeList Nat -> TermList .
 eq createVars(M, nil, N) = empty .
 eq createVars(M, Ty TyL, N) = createVar(M, N, Ty), createVars(M, TyL, s(N)) .

 op getTypeList : Module TermList -> TypeList .
 eq getTypeList(M, empty) = nil .
 eq getTypeList(M, (T, TL)) = leastSort(M, T) getTypeList(M, TL) .

 op createVar : Module Nat Sort -> Variable .
 eq createVar(M, N, S) = qid("V$#" + string(N, 10) + ":" + string(getKind(M, S))) .
endfm

***(%
\end{verbatim}
}

\end{comment}

The module \texttt{SUBSTITUTION} is in charge of applying substitutions to
terms:

{\codesize
\begin{verbatim}
%)

 fmod SUBSTITUTION is
  pr MODULES .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  var  SB : Substitution .
  var  TL : TermList .
  vars T T' : Term .
  var  Q : Qid .
  var  S : Sort .
  vars COND COND' : Condition .
  var  M : Module .
  var  C C' : Context .
  var  CTL : NeCTermList .

***(%
\end{verbatim}
}

\end{comment}

The function \texttt{substituteDD} applies a substitution to a term, and then
normalizes it:

{\codesize
\begin{verbatim}
%)

  op substituteDD : Module Term Substitution -> Term .

***(%
  ...
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  op substituteDD : Term Substitution -> Term .
  op substituteDD* : TermList Substitution -> TermList .

  eq substituteDD(M, T, SB) = normal(M, substituteDD(T, SB)) .

  eq substituteDD(Q[TL], SB) = Q[substituteDD*(TL, SB)] .
  eq substituteDD(T, T <- T' ; SB) = T' .
  eq substituteDD(T, SB) = T [owise] .

  eq substituteDD*(empty, SB) = empty .
  eq substituteDD*((T, TL), SB) = substituteDD(T, SB), substituteDD*(TL, SB) .

  op substituteDD : Module Condition Substitution -> Condition .
  ceq substituteDD(M, COND /\ COND', SB) = substituteDD(M, COND, SB) /\
                                         substituteDD(M, COND', SB)
   if COND =/= nil /\ COND' =/= nil .
  eq substituteDD(M, T : S, SB) = substituteDD(M, T, SB) : S .
  eq substituteDD(M, T = T', SB) = substituteDD(M, T, SB) = substituteDD(M, T', SB) .
  eq substituteDD(M, T := T', SB) = substituteDD(M, T, SB) := substituteDD(M, T', SB) .
  eq substituteDD(M, T => T', SB) = substituteDD(M, T, SB) => substituteDD(M, T', SB) .
  eq substituteDD(M, COND, SB) = COND [owise] .

  op substituteDD : Condition Substitution -> Condition .
  ceq substituteDD(COND /\ COND', SB) = substituteDD(COND, SB) /\
                                        substituteDD(COND', SB)
   if COND =/= nil /\ COND' =/= nil .
  eq substituteDD(T : S, SB) = substituteDD(T, SB) : S .
  eq substituteDD(T = T', SB) = substituteDD(T, SB) = substituteDD(T', SB) .
  eq substituteDD(T := T', SB) = substituteDD(T, SB) := substituteDD(T', SB) .
  eq substituteDD(T => T', SB) = substituteDD(T, SB) => substituteDD(T', SB) .
  eq substituteDD(COND, SB) = COND [owise] .

***(%
\end{verbatim}
}

\end{comment}

Finally, the function \texttt{substituteHole} substitutes the hole in a context by a term, and
returns the normal form of the term:

{\codesize
\begin{verbatim}
%)

  op substituteHole : Module Context Term -> Term .

***(%
  ...
 endfm
\end{verbatim}
}

\begin{comment}

The \texttt{substituteHole} auxiliary function distinguishes the different patterns of a context:
if it is a hole, then it is substituted by the term,
otherwise, it recursively substitutes the subterms by using \texttt{substituteHole*}:

{\codesize
\begin{verbatim}
%)

  eq substituteHole(M, C, T) = normal(M, substituteHole(C, T)) .

  op substituteHole : Context Term -> Term .
  eq substituteHole([], T) = T .
  eq substituteHole(Q[CTL], T) = Q[substituteHole*(CTL, T)] .

  op substituteHole* : NeCTermList Term -> TermList .
  eq substituteHole*((T, CTL), T') = T, substituteHole*(CTL, T') .
  eq substituteHole*((C, TL), T) = substituteHole(C, T), TL .
 endfm

***(%
\end{verbatim}
}

\end{comment}
%)


***(%

\subsubsection{Reordering debugging trees}\label{subsubsec:reoder}

In this section we illustrate how to reorder a debugging tree to obtain
another tree where all the terms has been reduced as much as needed in
their computation. To do it we assign colors to each term in the debugging
tree, which allows us to distinguish the different uses of the same
term throughout a tree.
The module \texttt{COLORED-TERM} is in charge of defining these colored terms
as well as some basic functions over them:

{\codesize
\begin{verbatim}
%)

 fmod COLORED-TERM is
  ex META-TERM .
  pr MODULES .
  pr PAIR{TermList,NatList} .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  vars TL TL' : TermList .
  vars T T' T'' : Term .
  var  FST : Bool .
  var  Q : Qid .
  vars CL CL' N N' N'' : Nat .
  var  M : Module .

***(%
\end{verbatim}
}

\end{comment}

Colored terms are created with the operator \verb"[_,_,_]", that receives
as first paramenter a term, as second parameter a natural number representing
its color, and as final parameter a boolean value indicating if this is
the first time the term with this color appears in the tree, that will be
used latter when transforming the tree:

{\codesize
\begin{verbatim}
%)

  op [_,_,_] : Term Nat Bool -> Term .

***(%
\end{verbatim}
}

The function \verb"colored?" checks if a term or any of its subterms
are colored. It uses an auxiliary function \verb"colored?*" that
traverses a list of terms applying \verb"colored?" to each of them:

{\codesize
\begin{verbatim}
%)

  op colored? : Term -> Bool .
  eq colored?([T, CL, FST]) = true .
  eq colored?(Q[TL]) = colored?*(TL) .
  eq colored?(T) = false [owise] .

  op colored?* : TermList -> Bool .
  eq colored?*(empty) = false .
  eq colored?*((T, TL)) = colored?(T) or-else colored?*(TL) .

***(%
\end{verbatim}
}

Colors are removed from a term with \verb"decolor". If the current term
is colored then the color is ``cleaned'' and the function is recursively
applied, while if the term has subterms we use \verb"decolor*" to remove
the color from them:

{\codesize
\begin{verbatim}
%)

  op decolor : Term -> Term .
  eq decolor([T, N, FST]) = decolor(T) .
  eq decolor(Q[TL]) = Q[decolor*(TL)] .
  eq decolor(T) = T [owise] .

  op decolor* : TermList -> TermList .
  eq decolor*((T, TL)) = decolor(T), decolor*(TL) .
  eq decolor*(empty) = empty .

***(%
\end{verbatim}
}

The function \texttt{color} colors a term (including its subterms)
if it is reducible in the module given as first argument, using as
first available color the third parameter:

{\codesize
\begin{verbatim}
%)

  op color : Module Term Nat -> Pair{TermList, NatList} .
  ceq color(M, [T, CL, FST], N) = < [T', CL, false], N' >
   if < T', N' > := colorAux(M, T, N) .
  ceq color(M, T, N) = if reducible?(M, T')
                       then < [T'', N, false], N' >
                       else < T'', N' >
                       fi
   if T' := decolor(T) /\
      < T'', N' > := colorAux(M, T, s(N)) [owise].

***(%
\end{verbatim}
}

\noindent where \verb"reducible?" if a term is reducible by
comparing the terms obtained by reducing and by normalizing it:

{\codesize
\begin{verbatim}
%)

  op reducible? : Module Term -> Bool .
  eq reducible?(M, T) = getTerm(metaReduce(M, decolor(T))) =/=
                        normal(M, decolor(T)) .

***(%
\end{verbatim}
}

\noindent and \texttt{colorAux} is in charge of coloring the
subterms. If the term has arguments it uses \verb"color*" to
color them, while it returns the same term in other case.

{\codesize
\begin{verbatim}
%)

  op colorAux : Module Term Nat -> Pair{TermList, NatList} .
  ceq colorAux(M, Q[TL], N) = < Q[TL'], N' >
   if < TL', N' > := color*(M, TL, N) .
  eq colorAux(M, T, N) = < T, N > [owise] .

  op color* : Module TermList Nat -> Pair{TermList, NatList} .
  eq color*(M, empty, N) = < empty, N > .
  ceq color*(M, (T, TL), N) = < (T', TL'), N'' >
   if < T', N' > := color(M, T, N) /\
      < TL', N'' > := color*(M, TL, N') .

***(%
\end{verbatim}
}

The function \texttt{getColors} returns a list with all the colors
used in a given term:

{\codesize
\begin{verbatim}
%)

  op getColors : Term -> NatList .
  eq getColors([T, CL, FST]) = CL getColors(T) .
  eq getColors(Q[TL]) = getColors*(TL) .
  eq getColors(T) = nil [owise] .

  op getColors* : TermList -> NatList .
  eq getColors*(empty) = nil .
  eq getColors*((T, TL)) = getColors(T) getColors*(TL) .

***(%
\end{verbatim}
}

The function \texttt{putColor} updates the color of a colored term
or colors a normal term:

{\codesize
\begin{verbatim}
%)

  op putColor : Term Nat -> Term .
  eq putColor([T, CL, FST], CL') = [T, CL', false] .
  eq putColor(T, CL) = [T, CL, false] [owise] .
 endfm

***(%
\end{verbatim}
}

The module \texttt{REORDER} is in charge of the transformation from a
colored abbreviated proof tree to debugging tree where all the questions
about reductions have all the subterms in the lefthand side, as well as the
righthand side, in normal form:

{\codesize
\begin{verbatim}
%)

 fmod REORDER is
  pr MAP{Nat,Tree} .
  pr COLORED-TERM .
  pr META-LEVEL .
  pr PAIR{MaybeForest,NatList} * (sort Pair{MaybeForest,NatList} to ForestColor,
                                  op maybe to noProof) .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  var  M : Module .
  vars T T' T1 T2 : Term .
  vars TL TL' : TermList .
  var  Q : Qid .
  vars A A' A'' : Tree .
  vars F F' F1 F2 : Forest .
  var  J : Judgment .
  vars CL N N' : Nat .
  vars NL NL' NL'' EV NDD NDDNEV EVNNDD : NatList .
  var  MNT : Map{Nat,Tree} .
  var  FST : Bool .

***(%
\end{verbatim}
}

\end{comment}

The function \texttt{reorder} is in charge of this transformation. It
first deletes with \texttt{quitResults} the nodes labeled with \verb"'$@#result",
used during the tree construction, as we will se below. Then, it applies
\texttt{setFirstApp} to identify the first occurrence of each colored term
in the tree. The functions \texttt{evolved} and \texttt{needed} compute respectively
the list of colors evolved and needed in the tree. Finally colors not used
in the transformation are decolored with \texttt{decolorNotUsed} and the
transformation follows with \texttt{reorder2}:

{\codesize
\begin{verbatim}
%)

  op reorder : Module Tree -> Tree .
  ceq reorder(M, A) = reorder2(M, A'', NDD)
   if A' := first(setFirstApp(quitResults(A))) /\
      EV := evolved(A') /\
      NDD := needed(A') /\
      *** Needed not evolved
      NDDNEV := removeAll(NDD, EV) /\
      *** Evolved not needed
      EVNNDD := removeAll(EV, NDD) /\
      A'' := decolorNotUsed(A', NDDNEV EVNNDD) .

***(%
\end{verbatim}
}

\texttt{reorder2} uses \verb"getTableSubst" to obtain the substitutions that can be
used in this step of the transformation, and then it applies these substitutions with
\verb"evolveTree". If the tree does not evolve, then we have finished and the current
tree is normalized with \verb"normalTree", while if the tree evolves the function
\texttt{reorder} is used again:

{\codesize
\begin{verbatim}
%)

  op reorder2 : Module Tree NatList -> Tree .
  ceq reorder2(M, A, NDD) = if A == A'
                            then normalTree(M, A)
                            else reorder(M, A')
                            fi
   if MNT := getTableSubst(A, NDD) /\
      A' := evolveTree(A, MNT) .

***(%
\end{verbatim}
}

The function \verb"quitResults" traverses the tree removing the inferences
labeled with \verb"'$@#result":

{\codesize
\begin{verbatim}
%)

  op quitResults : Tree -> Forest .
  ceq quitResults(tree('$@#result : T -> T', N, F)) = F'
   if F' := quitResults*(F) .
  ceq quitResults(tree(J, N, F)) = tree(J, N', F')
   if F' := quitResults*(F) /\
      N' := 1 + getOffspring*(F') [owise] .

  op quitResults* : Forest -> Forest .
  eq quitResults*(mtForest) = mtForest .
  eq quitResults*(A F) = quitResults(A) quitResults*(F) .

***(%
\end{verbatim}
}

\verb"normalTree" is in charge of deleting the nodes labeled with \verb"'$@#trusted",
as well as decoloring and normalizing all the terms:

{\codesize
\begin{verbatim}
%)

  op normalTree : Module Tree -> Forest .
  ceq normalTree(M, tree(Q : T -> T', N, F)) =
      if Q == '$@#trusted
      then F'
      else tree(Q : normal(M, decolor(T)) -> normal(M, decolor(T')), N', F')
      fi
   if F' := normalTree*(M, F) /\
      N' := 1 + getOffspring*(F') .
  ceq normalTree(M, tree(J, N, F)) = tree(J, N', F')
   if F' := normalTree*(M, F) /\
      N' := 1 + getOffspring*(F') [owise] .

  op normalTree* : Module Forest -> Forest .
  eq normalTree*(M, mtForest) = mtForest .
  eq normalTree*(M, A F) = normalTree(M, A) normalTree*(M, F) .

***(%
\end{verbatim}
}

Given a tree, the function \verb"evolved" returns a list of natural numbers
representing the terms that have evolved, that is, the color at the top of terms
in the lefthand side of reductions:

{\codesize
\begin{verbatim}
%)

  op evolved : Tree -> NatList .
  eq evolved(tree(Q : [T, CL, FST] -> T', N, F)) = quitReps(CL evolved*(F)) .
  eq evolved(tree(J, N, F)) = evolved*(F) [owise] .

  op evolved* : Forest -> NatList .
  eq evolved*(mtForest) = nil .
  eq evolved*(A F) = evolved(A) evolved*(F) .

***(%
\end{verbatim}
}

\noindent where \verb"quitReps" removes the repeated elements of the given list:

{\codesize
\begin{verbatim}
%)

  op quitReps : NatList -> NatList .
  eq quitReps(nil) = nil .
  eq quitReps(NL N NL' N NL'') = quitReps(NL N NL' NL'') .
  eq quitReps(NL) = NL [owise] .

***(%
\end{verbatim}
}

The function \verb"needed" skips the root and uses an auxiliary function
\verb"neededAux*" to traverse its forest and
return a list of natural numbers
representing the terms that have appeared at least twice in a righthand side
(extracted with \texttt{neededAux})
or in the subterms of a lefthand side (extracted with \verb"needed"):

{\codesize
\begin{verbatim}
%)

  op needed : Tree -> NatList .
  eq needed(tree(J, N, F)) = quitReps(neededAux*(F)) .

  op neededAux : Tree -> NatList .
  eq neededAux(tree(Q : T -> T', N, F)) = needed(T) neededAux(T') neededAux*(F) .
  eq neededAux(tree(J, N, F)) = neededAux*(F) [owise] .

  op neededAux* : Forest -> NatList .
  eq neededAux*(mtForest) = nil .
  eq neededAux*(A F) = neededAux(A) neededAux*(F) .

***(%
\end{verbatim}
}

As said above, the function \verb"needed" for terms ignores the color at the top
and uses \texttt{neededAux} to compute all the colors in the rest of the term:

{\codesize
\begin{verbatim}
%)

  op needed : Term -> NatList .
  eq needed([T, CL, FST]) = neededAux(T) .
  eq needed(T) = neededAux(T) [owise] .

  op neededAux : Term -> NatList .
  eq neededAux([T, CL, FST]) = CL neededAux(T) .
  eq neededAux(Q[TL]) = neededAux*(TL) .
  eq neededAux(T) = nil [owise] .

  op neededAux* : TermList -> NatList .
  eq neededAux*(empty) = nil .
  eq neededAux*((T, TL)) = neededAux(T) neededAux*(TL) .

***(%
\end{verbatim}
}

\texttt{setFirstApp} traverses a tree setting the third value of each
colored term to \verb"true" if it is the first occurrence of the term
in the tree, that is, it is associated to the statement that created it.
We compute that by returning a pair with the updated tree and a list of
colors that have been already set to true, so we consider that an occurrence
of a term is the first one if it appears in the righthand side of a reduction
but neither in its lefthand side nor in any tree of its forest. The modification
of concrete terms is achieved with the function \texttt{setFirsts}:

{\codesize
\begin{verbatim}
%)

  op setFirstApp : Tree -> ForestColor .
  ceq setFirstApp(tree(Q : T -> T', N, F)) =
        < tree(Q : T -> T1, N, F'), NL'' >
   if NL := getColors(T) /\
      < F', NL' > := setFirstApp*(F) /\
      < T1, NL'' > := setFirsts(T', NL NL') .
  ceq setFirstApp(tree(J, N, F)) = < tree(J, N, F), NL >
   if < F', NL > := setFirstApp*(F) [owise] .

  op setFirstApp* : Forest -> ForestColor .
  eq setFirstApp*(mtForest) = < mtForest, nil > .
  ceq setFirstApp*(A F) = < F1 F2, NL NL' >
   if < F1, NL > := setFirstApp(A) /\
      < F2, NL' > := setFirstApp*(F) .

***(%
\end{verbatim}
}

Given a term and a list of colors, we use \texttt{setFirsts} to update
the first occurrence of colored terms in a given term, returning the new
term and the new list of colors. Each time a colored
term is found it checks if the color is contained in the list with \verb"in?".
If the color is in the list, its third argument is set to \verb"false", while
in other case is set to \texttt{true} and the color is add to the current list:

{\codesize
\begin{verbatim}
%)

  op setFirsts : Term NatList -> Pair{TermList,NatList} .
  ceq setFirsts([T, CL, FST], NL) =
      if in?(CL, NL)
      then < [T', CL, false], NL' >
      else < [T', CL, true], CL NL' >
      fi
   if < T', NL' > := setFirsts(T, NL) .
  ceq setFirsts(Q[TL], NL) = < Q[TL'], NL' >
   if < TL', NL' > := setFirsts*(TL, NL) .
  eq setFirsts(T, NL) = < T, nil > [owise] .

  op setFirsts* : TermList NatList -> Pair{TermList,NatList} .
  eq setFirsts*(empty, NL) = < empty, nil > .
  ceq setFirsts*((T, TL), NL) = < (T', TL'), NL' NL'' >
   if < T', NL' > := setFirsts(T, NL) /\
      < TL', NL'' > := setFirsts*(TL, NL) .

***(%
\end{verbatim}
}

\noindent where \verb"in?" is implemented as follows:

{\codesize
\begin{verbatim}
%)

  op in? : Nat NatList -> Bool .
  eq in?(N, nil) = false .
  eq in?(N, N' NL) = if N == N' then true
                                else in?(N, NL)
                     fi .

***(%
\end{verbatim}
}

The function \texttt{removeAll} deletes from the first list the elements of
the second list:

{\codesize
\begin{verbatim}
%)

  op removeAll : NatList NatList -> NatList .
  eq removeAll(NL, nil) = NL .
  eq removeAll(NL, N NL') = removeAll(remove(NL, N), NL') .

  op remove : NatList Nat -> NatList .
  eq remove(nil, N) = nil .
  eq remove(N NL, N') = if N == N' then NL
                                   else N remove(NL, N')
                       fi .

***(%
\end{verbatim}
}

Given a tree and a list of colors, the function \texttt{decolorNotUsed} traverses
the tree removing the color from the terms indicated by the list by using an
auxiliary function \texttt{decolorNotUsed} applied to terms:

{\codesize
\begin{verbatim}
%)

  op decolorNotUsed : Tree NatList -> Tree .
  eq decolorNotUsed(tree(Q : T -> T', N, F), NL) =
       tree(Q : decolorNotUsed(T, NL) -> decolorNotUsed(T', NL), N,
            decolorNotUsed*(F, NL)) .
  eq decolorNotUsed(tree(J, N, F), NL) = decolorNotUsed*(F, NL) [owise] .

  op decolorNotUsed* : Forest NatList -> Forest .
  eq decolorNotUsed*(mtForest, NL) = mtForest .
  eq decolorNotUsed*(A F, NL) = decolorNotUsed(A, NL) decolorNotUsed*(F, NL) .

***(%
\end{verbatim}
}

The function \texttt{decolorNotUsed} traverses the term and, when it reaches a
colored term, checks if its color is in the given list, removing the color if
it is necessary:

{\codesize
\begin{verbatim}
%)

  op decolorNotUsed : Term NatList -> Term .
  eq decolorNotUsed([T, CL, FST], NL) =
            if in?(CL, NL)
            then decolorNotUsed(T, NL)
            else [decolorNotUsed(T, NL), CL, FST]
            fi .
  eq decolorNotUsed(Q[TL], NL) = Q[decolorNotUsed*(TL, NL)] .
  eq decolorNotUsed(T, NL) = T [owise] .

  op decolorNotUsed* : TermList NatList -> TermList .
  eq decolorNotUsed*(empty, NL) = empty .
  eq decolorNotUsed*((T, TL), NL) = decolorNotUsed(T, NL), decolorNotUsed*(TL, NL) .

***(%
\end{verbatim}
}

We use \texttt{getTableSubst} to obtain a map from colored terms, represented by
their colors, to the terms they are reduced to. The function traverses the tree
and keeps the terms that fulfill the following characteristics:

\begin{itemize}
\item Only the operator at the top of the term is colored, what ensures
that future substitutions do not overwrite any information.
\item The reduced term is not colored, what ensures that it does not need
substitutions itself.
\item The color is included in the list of needed colors, so we only include
required substitutions, which improves the transformation process.
\end{itemize}

{\codesize
\begin{verbatim}
%)

  op getTableSubst : Tree NatList -> Map{Nat,Tree} .
  ceq getTableSubst(A, NDD) = CL |-> A, getTableSubst*(F, NDD)
   if tree(Q : [T, CL, false] -> T', N, F) := A /\
      not colored?(T) /\
      not colored?(T') /\
      in?(CL, NDD) .
  eq getTableSubst(tree(J, N, F), NDD) = getTableSubst*(F, NDD) [owise] .

  op getTableSubst* : Forest NatList -> Map{Nat,Tree} .
  eq getTableSubst*(mtForest, NDD) = empty .
  eq getTableSubst*(A F, NDD) = getTableSubst(A, NDD), getTableSubst*(F, NDD) .

***(%
\end{verbatim}
}

The function \texttt{substituteDD} applies the substitutions defined in the
map computed by \verb"getTableSubst" to a term, checking that only terms
without colors are substituted in order to keep all the relevant information:

{\codesize
\begin{verbatim}
%)

  op substituteDD : Term Map{Nat,Tree} -> Term .
  ceq substituteDD([T, CL, FST], (CL |-> tree(Q : T1 -> T2, N, F), MNT)) = T2
   if not colored?(T) .
  ceq substituteDD([T, CL, FST], (CL |-> tree(Q : T1 -> T2, N, F), MNT)) =
                  [substituteDD(T, (CL |-> tree(Q : T1 -> T2, N, F), MNT)), CL, FST]
   if colored?(T) .
  ceq substituteDD([T, CL, FST], MNT) = [substituteDD(T, MNT), CL, FST]
   if not defined?(CL, MNT) .
  eq substituteDD(Q[TL], MNT) = Q[substituteDD*(TL, MNT)] .
  eq substituteDD(T, MNT) = T [owise] .

  op substituteDD* : TermList Map{Nat,Tree} -> TermList .
  eq substituteDD*(empty, MNT) = empty .
  eq substituteDD*((T, TL), MNT) = substituteDD(T, MNT), substituteDD*(TL, MNT) .

***(%
\end{verbatim}
}
\noindent where \verb"defined?" checks if there is an entry in the map with
the given key:

{\codesize
\begin{verbatim}
%)

  op defined? : Nat Map{Nat,Tree} -> Bool .
  eq defined?(N, (N |-> A, MNT)) = true .
  eq defined?(N, MNT) = false [owise] .

***(%
\end{verbatim}
}

The map of substitutions computed with \texttt{getTableSubst} is applied with
\verb"evolveTree". It computes the list of the colors of the terms that appear
in the tree for the first time with \texttt{getFirstColors}, that is used to
compute with \verb"getTrees" the forest that justifies the substitutions made
with the function \texttt{substituteDD}:

{\codesize
\begin{verbatim}
%)

  op evolveTree : Tree Map{Nat,Tree} -> Forest .
  eq evolveTree(tree(Q : [T, CL, FST] -> T', N, F), (CL |-> A, MNT)) = mtForest .
  ceq evolveTree(tree(Q : T -> T', N, F), MNT) =
             tree(Q : T1 -> T2, 1 + getOffspring*(F1), F1)
   if NDD := getFirstColors(T') /\
      F' := getTrees(NDD, MNT) /\
      T1 := substituteDD(T, MNT) /\
      T2 := substituteDD(T', MNT) /\
      F1 := evolveTree*(F, MNT) F' [owise] .

  op evolveTree* : Forest Map{Nat,Tree} -> Forest .
  eq evolveTree*(mtForest, MNT) = mtForest .
  eq evolveTree*(A F, MNT) = evolveTree(A, MNT) evolveTree*(F, MNT) .

***(%
\end{verbatim}
}

\noindent where \texttt{getFirstColors} traverses a term keeping the
color of the colored terms with their third argument \texttt{true}:

{\codesize
\begin{verbatim}
%)

  op getFirstColors : Term -> NatList .
  eq getFirstColors([T, CL, FST]) =
          if FST then CL
                 else nil
          fi getFirstColors(T) .
  eq getFirstColors(Q[TL]) = quitReps(getFirstColors*(TL)) .
  eq getFirstColors(T) = nil [owise] .

  op getFirstColors* : TermList -> NatList .
  eq getFirstColors*(empty) = nil .
  eq getFirstColors*((T, TL)) = getFirstColors(T) getFirstColors*(TL) .

***(%
\end{verbatim}
}

\noindent and \texttt{getTrees} traverses a list of colors looking for
the trees associated to them in the given map:

{\codesize
\begin{verbatim}
%)

  op getTrees : NatList Map{Nat,Tree} -> Forest .
  eq getTrees(nil, MNT) = mtForest .
  eq getTrees(N NL, (N |-> A, MNT)) = A getTrees(NL, MNT) .
  eq getTrees(N NL, MNT) = getTrees(NL, MNT) [owise] .
 endfm

***(%
\end{verbatim}
}

The module \texttt{STRAT-TREE} is in charge of building the debugging trees
used when debugging modules with operators defined with the attribute
\texttt{strat}:

{\codesize
\begin{verbatim}
%)

 fmod STRAT-TREE is
  pr MAYBE{Forest} * (op maybe to noProof) .
  pr PAIR{TermList,Forest} .
  pr PAIR{Substitution,Substitution} .
  pr SUBSTITUTION .
  pr REORDER .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  vars M OM TM : Module .
  var  CM : Maybe{Module} .
  vars A A' A'' : Tree .
  vars F F' F1 F2 F3 : Forest .
  var  F? : Maybe{Forest} .
  vars TL TL' : TermList .
  vars T T' T'' T1 T2 T3 L R R' CT CT' DT PT : Term .
  var  CONST : Constant .
  vars PC C C' COND : Condition .
  var  TyL : TypeList .
  vars Ty Ty' S : Type .
  vars Q Q' Q'' : Qid .
  var  QS : QidSet .
  vars N N' N'' CL CL' CL'' CL1 CL2 CL3 RCL : Nat .
  vars NL NL' NL'' : NatList .
  var  NNL : NeNatList .
  var  AtS : AttrSet .
  var  ODS : OpDeclSet .
  var  MAS : MembAxSet .
  var  MA : MembAx .
  var  Eq : Equation .
  var  EqS : EquationSet .
  vars ST ST1 ST2 : String .
  vars SB SB' SB'' SB1 SB2 PSB ASB1 ASB2 : Substitution .
  var  J : Judgment .
  vars FST FST' : Bool .
  var  V : Variable .
  var  PSS : Pair{Substitution,Substitution} .

***(%
\end{verbatim}
}

\end{comment}

The function \texttt{createTreeStrat} is in charge of building such trees.
It receives the modules where the wrong reduction took place, a module
only with trusted definitions, a correct module (possibly \texttt{undefMod})
the initial term, the result term, and the set of suspicious labels, and
computes the debugging tree by applying the auxiliary function
\texttt{createForestStrat} to the initial term colored with the function
\texttt{color}. Once the tree is built, it is transformed with the function
\texttt{reorder} above:

{\codesize
\begin{verbatim}
%)

  op createTreeStrat : Module Module Maybe{Module} Term Term QidSet -> Tree .
  ceq createTreeStrat(OM, TM, CM, T, T', QS) =
                 contract(reorder(OM, tree('root@#$% : CT -> T', N, F)))
   if < [CT, RCL, FST], CL' > := color(OM, T, 0) /\
      F := first(createForestStrat(OM, TM, CM, CT, T', QS, CL')) /\
      N := 1 + getOffspring*(F) .

***(%
\end{verbatim}
}

The \texttt{contract} function prunes the root of the tree if it is
duplicated after the computation of the tree:

{\codesize
\begin{verbatim}
%)

  op contract : Tree -> Tree .
  eq contract(tree(J, N, A)) = A .
  eq contract(A) = A [owise] .

***(%
\end{verbatim}
}

The function \texttt{createForestStrat} returns a pair of sort \texttt{ForestColor}
composed by the forest computed
and the next color that can be used.
Since all the transitions can be needed later when transforming the tree, when
a term can be obtained with transitions in the trusted module we generate a
tree labeled with \verb"$@#result", that will be removed once the tree is
transformed. Moreover, we also in order to obtain the final colors obtained
in for the current term.

{\codesize
\begin{verbatim}
%)

  op createForestStrat : Module Module Maybe{Module} Term Term QidSet Nat
                         ~> ForestColor .
  ceq createForestStrat(OM, TM, CM, T, T', QS, CL) =
    if normal(OM, DT) == T' then < tree('$@#result : T -> T, 1, mtForest), CL >
    else if reduce(TM, DT) == T' and not if?(DT)
         then < tree('$@#trusted : T -> T', 1, mtForest)
                tree('$@#result : T' -> T', 1, mtForest), CL >
         else createForestStrat2(OM, TM, CM, T, T', QS, CL)
         fi
    fi
   if DT := decolor(T) .

***(%
\end{verbatim}
}

\noindent where \verb"if?" checks if the operator at the top of the current
term is \verb"if_then_else_fi":

{\codesize
\begin{verbatim}
%)

  op if? : Term -> Bool .
  eq if?('if_then_else_fi[T1, T2, T3]) = true .
  eq if?(T) = false [owise] .

***(%
\end{verbatim}
}

When the term being reduced is of the form \verb"if T1 then T2 else T3 fi"
Maude first evaluates \verb"T1" and then, depending on the result, it evaluates
either \verb"T2" or \verb"T3". The first equation of \verb"createForest2" handles
this special behavior, so that only debugging trees that correspond to evaluated
subterms are really built:

{\codesize
\begin{verbatim}
%)

  op createForestStrat2 : Module Module Maybe{Module} Term Term QidSet Nat ~>
                          ForestColor .
  ceq createForestStrat2(OM, TM, CM, T, T', QS, CL) =
     if reduce(OM, decolor(T1)) == 'true.Bool then
        createTheirForest(OM, TM, CM, (T1, T2), QS, CL, mtForest)
     else
        if reduce(OM, decolor(T1)) == 'false.Bool then
           createTheirForest(OM, TM, CM, (T1, T3), QS, CL, mtForest)
        else
           createTheirForest(OM, TM, CM, (T1, T2, T3), QS, CL, mtForest)
        fi
     fi
   if 'if_then_else_fi[T1, T2, T3] := quitTopColor(T) .

***(%
\end{verbatim}
}

\noindent where \verb"createTheirForest" traverses a list of terms, computing
the forest corresponding to the reduction of each of them and transmiting the
colors used to the next one:

{\codesize
\begin{verbatim}
%)

  op createTheirForest : Module Module Maybe{Module} TermList QidSet Nat Forest
                         ~> ForestColor .
  eq createTheirForest(OM, TM, CM, empty, QS, CL, F) = < F, CL > .
  ceq createTheirForest(OM, TM, CM, (T, TL), QS, CL, F) =
                                 createTheirForest(OM, TM, CM, TL, QS, CL', F F')
   if T' := reduce(OM, decolor(T)) /\
      < F', CL' > := createForestStrat(OM, TM, CM, T, T', QS, CL) .

***(%
\end{verbatim}
}

\noindent and \verb"quitTopColor" removes the color assigned to the operator
at the top of the term:

{\codesize
\begin{verbatim}
%)

  op quitTopColor : Term -> Term .
  eq quitTopColor([T, CL, FST]) = T .
  eq quitTopColor(T) = T [owise] .

***(%
\end{verbatim}
}

In other case, the debugger reduces the subterms in the
appropriate order with the function \texttt{createForestStrat}:

{\codesize
\begin{verbatim}
%)

  ceq createForestStrat2(OM, TM, CM, T, T', QS, CL) =
                         createForestStrat(OM, TM, CM, T, T', QS, CL, NNL)
   if NNL := getStrat(OM, T) [owise] .

***(%
\end{verbatim}
}

The function \texttt{getStrat} is in charge of obtaining the reduction strategy
for a given operator:

{\codesize
\begin{verbatim}
%)

  op getStrat : Module Term -> NatList .
  eq getStrat(M, T) = getStrat(M, getOps(M), decolor(T)) .

***(%
\end{verbatim}
}

If the operator at the top of the current term corresponds with an operator
defined in the module and the types of the arguments correspond with the
operator declaration, we use the auxiliary function \texttt{getStrat} to
the attribute set to obtain the strategy for this operator:

{\codesize
\begin{verbatim}
%)

  op getStrat : Module OpDeclSet Term -> NatList .
  ceq getStrat(M, op Q : TyL -> Ty [AtS] . ODS, Q[TL]) = getStrat(AtS, TL, Q[TL])
   if checkTypes(TL, TyL, M) .

***(%
\end{verbatim}
}

The strat operator for a constant is always \texttt{0}:

{\codesize
\begin{verbatim}
%)

  ceq getStrat(M, op Q : nil -> Ty [AtS] . ODS, CONST) = 0
   if getName(CONST) = Q /\
      getType(CONST) = Ty .

***(%
\end{verbatim}
}

When an operator is defined with the \texttt{iter} attribute we cannot check
directly if the operator at the top of the current is equal to a given operator.
We use the function \texttt{noIter} the generate a new term that no uses the
\texttt{iter} attribute at the top, and then we check for equality:

{\codesize
\begin{verbatim}
%)

  ceq getStrat(M, op Q : Ty -> Ty' [iter AtS] . ODS, Q'[T]) =
                                          getStrat(AtS, Q''[T], Q[Q''[T]])
   if Q[Q''[T]] := noIter(Q'[T]) /\
      sortLeq(M, type(M, Q''[T]), Ty) .

***(%
\end{verbatim}
}

In other case, we use the function \texttt{defStrat} to generate the default
strategy for the term:

{\codesize
\begin{verbatim}
%)

  eq getStrat(M, ODS, T) = defStrat(T) [owise] .

***(%
\end{verbatim}
}

We define now the auxiliary functions used in \texttt{getStrat}:

\begin{itemize}

\item verb"getStrat" extracts the strategy definition from the attribute set
of an operator declaration.
In the case of associative or commutative binary operators, terms
represent equivalence classes
and it might be quite hard to say what is the ﬁrst or the second argument,
thus mentioning either argument in the strategy implies both
\cite[Section 4.4.7]{maude-book}. Therefore, in the presence of this
attribute the real strategy adopted by Maude is computed with
\texttt{newStrat}:

{\codesize
\begin{verbatim}
%)

  op getStrat : AttrSet TermList Term -> NatList .
  eq getStrat(strat(NNL) AtS, TL, T) = if assoc?(AtS) or comm?(AtS)
                                       then newStrat(NNL, TL)
                                       else NNL
                                       fi .
  eq getStrat(AtS, TL, T) = defStrat(T) [owise] .

***(%
\end{verbatim}
}

\item \texttt{newStrat} checks if the strategy contains
any number different of \texttt{0} with \verb"allZeros?". If the
strategy only contains zeros, the unary list \texttt{0}, in other
case a new list is created with \texttt{createStrat}:\footnote{Notice
that just creating the list \texttt{1 2} is not enough, because
associative can be flattened.}

{\codesize
\begin{verbatim}
%)

  op newStrat : NeNatList TermList -> NeNatList .
  eq newStrat(0, TL) = 0 .
  eq newStrat(N NL, TL) = if N > 0 then createStrat(TL, 1) 0
                          else if allZeros?(NL) then 0
                               else 0 createStrat(TL, 1) 0
                               fi
                          fi .

***(%
\end{verbatim}
}

\item The function \verb"allZeros?" traverses a list of natural numbers
checking that all of them are zero:

{\codesize
\begin{verbatim}
%)

  op allZeros? : NatList -> Bool .
  eq allZeros?(nil) = true .
  eq allZeros?(0 NL) = allZeros?(NL) .
  eq allZeros?(N NL) = false [owise] .

***(%
\end{verbatim}
}

\item The function \verb"createStrat", that is initially used with \texttt{1}
in its first argument, introduces a new number in the list for each term in
the list, and inserts a final \texttt{0} (reduction at the top) when it finishes:

{\codesize
\begin{verbatim}
%)

  op createStrat : TermList Nat -> NatList .
  eq createStrat(empty, N) = 0 .
  eq createStrat((T, TL), N) = N createStrat(TL, s(N)) .

***(%
\end{verbatim}
}

\item \texttt{noIter} generates a new term ensuring that the operator
at the top does not use the \texttt{iter} attribute. It first transforms
the initial quoted identifier at the top in a string, then it finds the
character \verb"^" in this string, and tries to transform the string at
the right of this symbol into a natural number, while the string at the
left remains as the operator without \verb"iter". Finally, a new term
is created with \verb"newTerm", that receives the term without the
\verb"iter" attribute, the natural number, and the initial argument:

{\codesize
\begin{verbatim}
%)

  op noIter : Term -> Term .
  ceq noIter(Q[T]) = T'
   if ST := string(Q) /\
      N := rfind(ST, "^", length(ST)) /\
      ST1 := substr(ST, 0, N) /\
      ST2 := substr(ST, N + 1, length(ST)) /\
      Q' := qid(ST1) /\
      N' := rat(ST2, 10) /\
      T' := newTerm(Q', N', T) .
  eq noIter(T) = T [owise] .

***(%
\end{verbatim}
}

\item The function \verb"newTerm" receives a quoted identifier, a natural
number, and a term and creates a new term with the recived quoted identifier
at the top . This operator does not use the \texttt{iter}
attribute at the top, although it uses it at the inner level. If the number
is \verb"2" the function returns the operator enclosed in itself, while if
the number is greater a new quoted identifier is created:

{\codesize
\begin{verbatim}
%)

  op newTerm : Qid Nat Term -> Term .
  eq newTerm(Q, 2, T) = Q[Q[T]] .
  ceq newTerm(Q, N, T) = Q[Q'[T]]
   if N > 2 /\
      ST := string(sd(N, 1), 10) /\
      Q' := qid(string(Q) + "^" + ST) .

***(%
\end{verbatim}
}

\begin{comment}

\item \texttt{size} computes the length of a term list:

{\codesize
\begin{verbatim}
%)

  op size : TermList -> Nat .
  eq size(empty) = 0 .
  eq size((T, TL)) = s(size(TL)) .

***(%
\end{verbatim}
}

\end{comment}

\item The function \verb"defStrat" computes the default strategy for a
given term by using the \texttt{createStrat}:

{\codesize
\begin{verbatim}
%)

  op defStrat : Term -> NatList .
  eq defStrat(Q[TL]) = createStrat(TL, 1) .
  eq defStrat(T) = nil [owise] .

***(%
\end{verbatim}
}

\end{itemize}

The function \texttt{createForestStrat} traverses the list indicating the
strategy and reduces the
corresponding subterms until the operator at the top is reduced or the list is
finished. It reduces the terms until the first zero is found with the function
\texttt{reduceSubtermsStrat} and then tries to reduce the term at the top with
\texttt{applyEqStrat}. If the forest returned by this function is
\texttt{noProof}, then no equations have been applied and the function traverses
the rest of the list; in other case, the forest computed thus far is returned:

{\codesize
\begin{verbatim}
%)

  op createForestStrat : Module Module Maybe{Module} Term Term QidSet Nat NatList
                         -> ForestColor .

  eq createForestStrat(OM, TM, CM, T, T', QS, CL, nil) = < mtForest, CL > .
  ceq createForestStrat(OM, TM, CM, T, T', QS, CL, NNL) =
                       if normal(OM, decolor(T'')) == T' then < F, CL1 >
                       else if F? =/= noProof then < F F?, CL2 >
                            else < F F', CL3 >
                            fi
                       fi
   if < T'', F, CL1 > := reduceSubtermsStrat(OM, TM, CM, T, QS, CL, NNL) /\
      NL := filterUntilFirstZero(NNL) /\
      < F?, CL2 > := applyEqStrat(OM, TM, CM, T'', T', QS, CL1) /\
      < F', CL3 > := if F? == noProof
                     then createForestStrat(OM, TM, CM, T'', T', QS, CL2, NL)
                     else < mtForest, CL2 >
                     fi .

***(%
\end{verbatim}
}

\noindent where \texttt{filterUntilFirstZero} deletes all the numbers
from a list until it finds a zero:

{\codesize
\begin{verbatim}
%)

  op filterUntilFirstZero : NeNatList ~> NatList .
  eq filterUntilFirstZero(0 NL) = NL .
  eq filterUntilFirstZero(N NL) = filterUntilFirstZero(NL) [owise] .

***(%
\end{verbatim}
}

The function \texttt{reduceSubtermsStrat} returns a term of sort \texttt{CongruenceResult},
that consists on a tuple with the updated term, the forest proving the reductions,
and a natural number indicating the next color to be used. It uses an
auxiliary function \texttt{reduceSubtermsStratAux} that updates the subterms
of the given term:

{\codesize
\begin{verbatim}
%)

  sort CongruenceResult .
  op <_,_,_> : TermList Forest Nat -> CongruenceResult .

  op reduceSubtermsStrat : Module Module Maybe{Module} Term QidSet Nat NatList
                           -> CongruenceResult .
  ceq reduceSubtermsStrat(OM, TM, CM, [T, CL, FST], QS, CL', NL) =
         < putColor(T1, CL), F1, CL1 >
   if < T1, F1, CL1 > := reduceSubtermsStrat(OM, TM, CM, T, QS, CL', NL) .
  ceq reduceSubtermsStrat(OM, TM, CM, Q[TL], QS, CL, NL) = < T', F, CL1 >
   if < TL', F, CL' > := reduceSubtermsStratAux(OM, TM, CM, QS, < TL, mtForest, CL >, NL) /\
      < T', CL1 > := color(OM, Q[TL'], CL') .
  eq reduceSubtermsStrat(OM, TM, CM, T, QS, CL, NL) = < T, mtForest, CL > [owise] .

***(%
\end{verbatim}
}

The function \texttt{reduceSubtermsStratAux} traverses the list of
numbers provided by the \texttt{strat} attribute and reduces the
indicated terms, generating the corresponding forest with
\texttt{createForestStrat}:

{\codesize
\begin{verbatim}
%)

  op reduceSubtermsStratAux : Module Module Maybe{Module} QidSet CongruenceResult NatList
                           -> CongruenceResult .
  eq reduceSubtermsStratAux(OM, TM, CM, QS, < TL, F, CL >, 0 NL) = < TL, F, CL > .
  ceq reduceSubtermsStratAux(OM, TM, CM, QS, < TL, F, CL >, N NL) =
       reduceSubtermsStratAux(OM, TM, CM, QS, < TL', F F', CL' >, NL)
   if T := get(TL, N) /\
      T' := reduce(OM, decolor(T)) /\
      < F', CL' > := createForestStrat(OM, TM, CM, T, T', QS, CL) /\
      TL' := set(TL, N, getResult*(OM, T', F')) [owise] .

***(%
\end{verbatim}
}

\noindent where \texttt{get} returns the term specified by the index and
\texttt{set} substitutes the term in the given position by the term given
as parameter:

{\codesize
\begin{verbatim}
%)

  op get : TermList Nat ~> Term .
  eq get((T, TL), 1) = T .
  eq get((T, TL), s(s(N))) = get(TL, s(N)) [owise] .

  op set : TermList Nat Term ~> TermList .
  eq set((T, TL), 1, T') = T', TL .
  eq set((T, TL), s(s(N)), T') = T, set(TL, s(N), T') [owise] .

***(%
\end{verbatim}
}

The function \texttt{applyEqStrat} tries to apply (at the top) one
equation,\footnote{Since the module is assumed to be confluent, we can choose
any equation and the final result should be the same.} by using the
\emph{replacement} rule from Figure \ref{fig:semanticrules}, with the
constraint that we cannot apply equations with the \texttt{otherwise}
attribute if other equations can be applied.
To apply an equation we check if the
term we are trying to reduce matches the lefthand side of the equation
and its conditions are fulfilled. If this happens, we obtain a substitution
(from both the matching with the lefthand side and the matching conditions)
that we can apply to the righthand side of the equation.
First, if the reduction can be obtained with built-in functions, we only
generate a node with the label \verb"$@#trusted":

{\codesize
\begin{verbatim}
%)

  op applyEqStrat : Module Module Maybe{Module} Term Term QidSet Nat -> ForestColor .
  eq applyEqStrat(OM, TM, CM, T, T', QS, CL) =
        if reduce(quitDefs(OM), decolor(T)) == T'
        then < tree('$@#trusted : T -> T', 1, mtForest), CL >
        else applyEqStrat(OM, TM, CM, T, T', QS, CL, getEqs(OM))
        fi .

***(%
\end{verbatim}
}

In other case, we try to apply one of the equations in the specification.
The function performs in this case the following operations:

\begin{itemize}
\item The first condition obtains the general form of the equation with the
function \texttt{generalEq}.
\item The second condition checks that the equation is not defined with the
\texttt{owise} attribute.
\item Since we cannot match the lefthand side of the equation with a colored
term, we use \texttt{prepareMatching} to obtain a term without colors. This
function returns a tuple that contains:

\begin{itemize}
\item The term with its colored subterms replaced by variables of the same
sort.\footnote{This transformation is correct because colored terms can be
reduced, while the lefthand side of the equation is a pattern.}
\item A substitution that assigns to each of this variables the corresponding
colored term.
\item A condition created by matching conditions between the variables and
the corresponding \emph{decolored} terms, that will extend the condition of
the equation.
\end{itemize}

\item The fourth condition obtains the match between the lefthand side of the
equation and the term obtained with \texttt{prepareMatching}, checking that
the condition of the equation, expanded with the condition generated by
\texttt{prepareMatching} as prefix, is fulfulled.
\item In the fifth condition the forest generated by the condition instantiated
with the colored terms is generated.
\item Since the matching conditions have been solved using terms without colors
in the fourth condition, the function \texttt{newSubst} modifies the substitution
in order to bind the variables in the matching conditions with the corresponding
colored terms.
\item The seventh condition generates the new term by applying the substitutions
to the righthand side of the equations. Once the substitutions are applied, the
term is colored.
\item The forest for the reduction to normal form of this new term is obtained
with a new application of \texttt{createForestStrat} in the eighth condition.
\item Because we cannot know a priori the colors of the normal form obtained,
we extract it from the forest generated in the previous condition with the function
\verb"getResult*".
\item Once the conditions have been resolved, the tree is generated. If the result
can be obtained in the trusted or in the correct module, the whole tree is labeled
as trusted with verb"allTrusted*", in other case the tree with the label of the
equation currently used is generated:
\end{itemize}

{\codesize
\begin{verbatim}
%)

  op applyEqStrat : Module Module Maybe{Module} Term Term QidSet Nat
                    EquationSet -> ForestColor .
  ceq applyEqStrat(OM, TM, CM, T, T', QS, CL, Eq EqS) =
          if reduce(TM, decolor(T)) == T' or-else reduce(CM, decolor(T)) == T'
          then < tree('$@#trusted : T -> T1, N, allTrusted*(F F')), CL3 >
          else < tree(putLabel(AtS, QS) : T -> T1, N, F F'), CL3 >
          fi
   if ceq L = R if C [AtS] . := generalEq(Eq) /\
      not owise?(AtS) /\
      < PT, PSB, PC > := prepareMatching(OM, T) /\
      SB := metaMatch(OM, L, PT, PC /\ C, 0) /\
      < F, CL1 > := conditionForest(substituteDD(substituteDD(C, SB), PSB), OM, TM, CM, QS, CL) /\
      < ASB1, ASB2 > := newSubst(OM, SB, PSB, C, F, < none, none >) /\
      < R', CL2 > := color(OM, substituteDD(substituteDD(R, ASB1), ASB2), CL1) /\
      < F', CL3 > := createForestStrat(OM, TM, CM, R', T', QS, CL2) /\
      T1 := getResult*(OM, T', F F') /\
      N := 1 + getOffspring*(F F') .

***(%
\end{verbatim}
}

The auxiliary functions used in this function are defined as follows:

\begin{itemize}

\item The function \texttt{prepareMatching} returns a value of sort
\texttt{ColorMatching}, that is composed by a term of lists, a substitution,
and a condition. The function skips the color in the operator at the top
and uses an auxiliary function \verb"prepareMatchingAux" in the term:

{\codesize
\begin{verbatim}
%)

  sort ColorMatching .
  op <_,_,_> : TermList Substitution Condition -> ColorMatching .

  op prepareMatching : Module Term -> ColorMatching .
  eq prepareMatching(M, [T, CL, FST]) = prepareMatchingAux(M, T) .
  eq prepareMatching(M, T) = prepareMatchingAux(M, T) [owise] .

***(%
\end{verbatim}
}

\item \texttt{prepareMatchingAux} distinguishes between terms with and
without color. In the first case, it replaces the term by a variable
of the same sort, using the color of the term to create different variables.
In the second case, if the term have arguments it applies the function
\texttt{prepareMatchingAux*} to them, while in other case the same term is
returned:

{\codesize
\begin{verbatim}
%)

  op prepareMatchingAux : Module Term -> ColorMatching .
  ceq prepareMatchingAux(M, [T, CL, FST]) = < V, V <- [T, CL, FST], V := T' >
   if T' := decolor(T) /\
      Ty := getType(metaReduce(M, T')) /\
      V := createVar(CL, Ty) .
  ceq prepareMatchingAux(M, Q[TL]) = < Q[TL'], SB, C >
   if < TL', SB, C > := prepareMatchingAux*(M, TL) .
  eq prepareMatchingAux(M, T) = < T, none, nil > [owise] .

***(%
\end{verbatim}
}

\noindent where the function \verb"createVar" creates a new variable
with a natural number and the type of the variable:

{\codesize
\begin{verbatim}
%)

  op createVar : Nat Type -> Variable .
  eq createVar(N, Ty) = qid("V@" + string(N, 10) + ":" + string(Ty)) .

***(%
\end{verbatim}
}

\item The function \texttt{prepareMatchingAux*} traverses a list of terms,
applying \texttt{prepareMatchingAux} to each of them:

{\codesize
\begin{verbatim}
%)

  op prepareMatchingAux* : Module TermList -> ColorMatching .
  eq prepareMatchingAux*(M, empty) = < empty, none, nil > .
  ceq prepareMatchingAux*(M, (T, TL)) = < (T', TL'), SB ; SB', C /\ C' >
   if < T', SB, C > := prepareMatchingAux(M, T) /\
      < TL', SB', C' > := prepareMatchingAux*(M, TL) .

***(%
\end{verbatim}
}

\item The function \texttt{newSubst} traverses the condition given as argument
looking for matching conditions and returns a pair of substitutions, the first
one with the variables bound to terms without colors, and the second one with
variables bound to colored terms.
When a matching condition is reached, the
function instantiates with the given substitutions the lefthand side of the
condition, and searches in the forest for the colored term that corresponds
with it. The substitutions that corresponds to that matching are obtained
by using the functions \texttt{prepareMatching} and \texttt{metaMatch}:

{\codesize
\begin{verbatim}
%)

  op newSubst : Module Substitution Substitution Condition Forest
                Pair{Substitution,Substitution} -> Pair{Substitution,Substitution} .
  eq newSubst(M, SB, PSB, nil, F, < ASB1, ASB2 >) = < removeReps(SB, ASB1), PSB ; ASB2 > .
  eq newSubst(M, SB, PSB, T = T' /\ C, F, PSS) = newSubst(M, SB, PSB, C, F, PSS) .
  eq newSubst(M, SB, PSB, T : S /\ C, F, PSS) = newSubst(M, SB, PSB, C, F, PSS) .
  eq newSubst(M, SB, PSB, T => T' /\ C, F, PSS) = newSubst(M, SB, PSB, C, F, PSS) .
  ceq newSubst(M, SB, PSB, T := T' /\ C, F, < ASB1, ASB2 >) =
           newSubst(M, SB, PSB, C, F, < ASB1 ; SB'', ASB2 ; SB' >)
   if T1 := reduce(M, decolor(substituteDD(substituteDD(T, SB), PSB))) /\
      T2 := getResult*(M, T1, F) /\
      < T3, SB', C' > := prepareMatching(M, T2) /\
      SB'' := metaMatch(M, T, T3, nil, 0) .
  eq newSubst(M, SB, PSB, T := T' /\ C, F, PSS) = newSubst(M, SB, PSB, C, F, PSS) [owise] .

***(%
\end{verbatim}
}

\noindent where \verb"removeReps" removes from the first substitution the
assignments that already appear in the second one:

{\codesize
\begin{verbatim}
%)

  op removeReps : Substitution Substitution -> Substitution .
  eq removeReps(V <- T ; SB, V <- T' ; SB') = V <- T' ; removeReps(SB, SB') .
  eq removeReps(SB, SB') = SB ; SB' [owise] .

***(%
\end{verbatim}
}

\item The function \verb"getResult*" traverses a forest, using
\verb"getResult" in each tree to check if the it contains a colored
term that corresponds with the term given as parameter:

{\codesize
\begin{verbatim}
%)

  op getResult* : Module Term Forest ~> Term .
  ceq getResult*(M, T, F A) = T'
   if T' := getResult(M, T, A) .
  eq getResult*(M, T, F A) = getResult*(M, T, F) [owise] .

***(%
\end{verbatim}
}

\item \verb"getResult" looks in the nodes marked with the label
\verb"$@#result" if the normal form of the lefthand side is equal
to the term given as argument, once both of them are decolored.
In other case, it traverses the forest with \verb"getResult*":

{\codesize
\begin{verbatim}
%)

  op getResult : Module Term Tree ~> Term .
  eq getResult(M, T, tree('$@#result : T1 -> T2, N, F)) =
        if normal(M, decolor(T)) == normal(M, decolor(T1))
        then T1
        else getResult*(M, T, F)
        fi .
  eq getResult(M, T, tree(J, N, F)) = getResult*(M, T, F) .

***(%
\end{verbatim}
}

\item \texttt{putLabel} generates a label, checking if the equation
is suspicious or not, and \texttt{allTrusted} changes the labels of all the nodes
in a tree to trusted, because if a transition is correct in the trusted or the
correct module, then the whole tree can be deleted:

{\codesize
\begin{verbatim}
%)

  op putLabel : AttrSet QidSet -> Qid .
  eq putLabel(AtS, QS) = if in?(AtS, QS) then label(AtS)
                         else '$@#trusted
                         fi .

***(%
\end{verbatim}
}

\item \texttt{allTrusted} changes the label of the current node by \verb"$@#trusted",
and applies \verb"allTrusted*" to its forest to recursively change its labels:

{\codesize
\begin{verbatim}
%)

  op allTrusted : Tree -> Tree .
  eq allTrusted(tree(Q : T -> T', N, F)) = tree('$@#trusted : T -> T', N, allTrusted*(F)) .
  eq allTrusted(tree(Q : T : S, N, F)) = tree('$@#trusted : T : S, N, allTrusted*(F)) .

  op allTrusted* : Forest -> Forest .
  eq allTrusted*(A F) = allTrusted(A) allTrusted*(F) .
  eq allTrusted*(mtForest) = mtForest .

***(%
\end{verbatim}
}

\end{itemize}

If we cannot apply any equation without the \texttt{otherwise} attribute,
we check the rest of equations, applying the same functions tu compute the tree:

{\codesize
\begin{verbatim}
%)

  ceq applyEqStrat(OM, TM, CM, T, T', QS, CL, Eq EqS) =
              if reduce(TM, decolor(T)) == T' or-else reduce(CM, decolor(T)) == T'
              then < tree('$@#trusted : T -> T1, N, allTrusted*(F F')), CL3 >
              else < tree(putLabel(AtS, QS) : T -> T1, N, F F'), CL3 >
              fi
   if ceq L = R if C [AtS] . := generalEq(Eq) /\
      not owise?(AtS) /\
      < PT, PSB, PC > := prepareMatching(OM, T) /\
      SB := metaMatch(OM, L, PT, PC /\ C, 0) /\
      < F, CL1 > := conditionForest(substituteDD(substituteDD(C, SB), PSB), OM, TM, CM, QS, CL) /\
      < ASB1, ASB2 > := newSubst(OM, SB, PSB, C, F, < none, none >) /\
      < R', CL2 > := color(OM, substituteDD(substituteDD(R, ASB1), ASB2), CL1) /\
      < F', CL3 > := createForestStrat(OM, TM, CM, R', T', QS, CL2) /\
      T1 := getResult*(OM, T', F F') /\
      N := 1 + getOffspring*(F F') .

***(%
\end{verbatim}
}

Finally, if no equation is applicable, the function returns \texttt{noProof}:

{\codesize
\begin{verbatim}
%)

  eq applyEqStrat(OM, TM, CM, T, T', QS, CL, EqS) = < noProof, CL > [owise] .

***(%
\end{verbatim}
}

We show now how the proof trees for the conditions in conditional statements
are generated. Since \texttt{conditionForest} is used after having checked that
the condition is fulfilled (by the function \texttt{metaMatch} above),
we do not check it again.

We distinguish between the different types of conditions.
If we have an equation, we add the trees of the reduction of the terms to their
respective normal forms:

{\codesize
\begin{verbatim}
%)

  op conditionForest : Condition Module Module Maybe{Module} QidSet Nat
                       -> ForestColor .
  ceq conditionForest(T = T' /\ COND, OM, TM, CM, QS, CL) = < F1 F2 F3, CL3 >
   if < F1, CL1 > := createForestStrat(OM, TM, CM, T, reduce(OM, decolor(T)), QS, CL) /\
      < F2, CL2 > := createForestStrat(OM, TM, CM, T', reduce(OM, decolor(T')), QS, CL1) /\
      < F3, CL3 > := conditionForest(COND, OM, TM, CM, QS, CL2) .

***(%
\end{verbatim}
}

The case of the matching conditions is very similar. We generate the forest for
the normal form of the righthand side:

{\codesize
\begin{verbatim}
%)

  ceq conditionForest(T := T' /\ COND, OM, TM, CM, QS, CL) = < F1 F2, CL2 >
   if < F1, CL1 > := createForestStrat(OM, TM, CM, T', reduce(OM, decolor(T)), QS, CL) /\
      < F2, CL2 > := conditionForest(COND, OM, TM, CM, QS, CL1) .

***(%
\end{verbatim}
}

In the membership case, we use the version of \texttt{createForest} that
builds a forest for a membership inference where the sort is the least
one assignable to the term in the condition:

{\codesize
\begin{verbatim}
%)

  ceq conditionForest(T : S /\ COND, OM, TM, CM, QS, CL) = < F1 F2, CL2 >
   if < F1, CL1 > := createForestStrat(OM, TM, CM, T, type(OM, decolor(T)), QS, CL) /\
      < F2, CL2 > := conditionForest(COND, OM, TM, CM, QS, CL) .

***(%
\end{verbatim}
}

Finally, the empty condition generates the empty forest:

{\codesize
\begin{verbatim}
%)

  eq conditionForest(nil, OM, TM, CM, QS, CL) = < mtForest, CL > .

***(%
\end{verbatim}
}

To generate the forest for memberships we use the
function \texttt{createForest}, that mimics the \emph{subject reduction}
rule from Figure~\ref{fig:semanticrules} by first
computing the tree for the full reduction of the term
(by means of \texttt{createForest})
and then computing the tree for the membership inference
by using an auxiliary version of \texttt{createForest} that
uses the operator declarations and the membership axioms.
Note that if we can infer the type from the correct
module, there is no need to calculate the forest:

{\codesize
\begin{verbatim}
%)

  op createForest : Module Module Maybe{Module} Term Sort QidSet Nat
                    -> ForestColor .
  op createForest : Module Module Maybe{Module} Term Sort QidSet Nat OpDeclSet
                    MembAxSet -> ForestColor .

  ceq createForest(OM, TM, CM, T, S, QS, CL) = < mtForest, CL >
   if sortLeq(TM, type(TM, T), S) or-else sortLeq(CM, type(CM, T), S) .
  ceq createForest(OM, TM, CM, T, S, QS, CL) = < F1 F2, CL2 >
   if T' := reduce(OM, T) /\
      < F1, CL1 > := createForest(OM, TM, CM, T, T', QS, CL) /\
      < F2, CL2 > := createForest(OM, TM, CM, T', S, QS, CL1, getOps(OM), getMbs(OM)) [owise] .

***(%
\end{verbatim}
}

The auxiliary \texttt{createForest} computes a forest for a membership
inference of the least sort of a term previously fully reduced; this
corresponds to a concrete application of the \emph{membership} inference
rule from Figure~\ref{fig:semanticrules}.
It first checks if the membership has been inferred by using the operator
declarations. If the membership has not been computed by using these
declarations, it checks the memberships:

{\codesize
\begin{verbatim}
%)

  eq createForest(OM, TM, CM, T, S, QS, CL, ODS, MAS) =
     if first(applyOp(OM, TM, CM, T, S, QS, CL, ODS)) =/= noProof then
        applyOp(OM, TM, CM, T, S, QS, CL, ODS)
     else applyMb(OM, TM, CM, T, S, QS, CL, MAS)
     fi .

***(%
\end{verbatim}
}

To check the operators we examine that both the arity and co-arity of
the term and the declaration fit. We recursively calculate the forest
generated by the subterms. Notice that we never generate a new node
for the application of an operator, because we always trust the signature:

{\codesize
\begin{verbatim}
%)

  op applyOp : Module Module Maybe{Module} Term Sort QidSet Nat OpDeclSet
               -> ForestColor .

  ceq applyOp(OM, TM, CM, Q[TL], Ty, QS, CL, op Q : TyL -> Ty [AtS] . ODS) =
      createForest*(OM, TM, CM, TL, QS, CL)
   if checkTypes(TL, TyL, OM) .

  ceq applyOp(OM, TM, CM, CONST, Ty, QS, CL, op Q : nil -> Ty [AtS] . ODS) =
               < mtForest, CL >
   if getName(CONST) = Q /\
      getType(CONST) = Ty .

***(%
\end{verbatim}
}

\noindent where the function \texttt{checkTypes} examines that all the subterms
have the appropriate type in the operator declaration and \texttt{createForest*}
generates the corresponding forest:

{\codesize
\begin{verbatim}
%)

  op checkTypes : TermList TypeList Module -> Bool .
  eq checkTypes(empty, nil, M) = true .
  ceq checkTypes((T, TL), Ty TyL, M) = checkTypes(TL, TyL, M)
   if sortLeq(M, type(M, T), Ty) .
  eq checkTypes(TL, TyL, M) = false [owise] .

  op createForest* : Module Module Maybe{Module} TermList QidSet Nat -> ForestColor .
  eq createForest*(OM, TM, CM, empty, QS, CL) = < mtForest, CL > .
  ceq createForest*(OM, TM, CM, (T, TL), QS, CL) = < F1 F2, CL2 >
   if < F1, CL1 > := createForest(OM, TM, CM, T, type(OM, T), QS, CL) /\
      < F2, CL2 > := createForest*(OM, TM, CM, TL, QS, CL1) .

***(%
\end{verbatim}
}

If the operator at the top is declared with the \texttt{iter} attribute, we
eliminate the iteration with the function \texttt{noIter}:

{\codesize
\begin{verbatim}
%)

  ceq applyOp(OM, TM, CM, Q'[T], Ty', QS, CL, op Q : Ty -> Ty' [iter AtS] . ODS) =
      createForest(OM, TM, CM, Q''[T], type(OM, Q''[T]), QS, CL)
   if Q[Q''[T]] := noIter(Q'[T]) /\
      sortLeq(OM, type(OM, Q''[T]), Ty) .

  eq applyOp(OM, TM, CM, T, S, QS, CL, ODS) = < noProof, CL > [owise] .

***(%
\end{verbatim}
}

We check the membership axioms in a similar fashion to the equation
application, that is, we only generate a new root below the forest
for the conditions if the membership is suspicious.
The unconditional axioms generate leaves of the tree, while
the conditional ones generate nodes with (possibly) non-empty forests:

We use the predefined function \texttt{metaMatch} to check if a membership
axiom can be applied. We only generate a new root below the forest
for the conditions if the membership is suspicious, so
the unconditional axioms generate leaves of the tree, while
the conditional ones generate nodes with (possibly) non-empty forests:

{\codesize
\begin{verbatim}
%)

  op applyMb : Module Module Maybe{Module} Term Sort QidSet Nat MembAxSet -> ForestColor .
  ceq applyMb(OM, TM, CM, T', S, QS, CL, MA MAS) =
      if in?(AtS, QS) then
      < tree(label(AtS) : T' : S, getOffspring*(F) + 1, F), CL1 >
      else < F, CL1 >
      fi
   if cmb T : S if C [AtS] . := generalMb(MA) /\
      SB := metaMatch(OM, T, T', C, 0) /\
      < F, CL1 > := conditionForest(substituteDD(OM, C, SB), OM, TM, CM, QS, CL)  .
  eq applyMb(OM, TM, CM, T, S, QS, CL, MAS) = < mtForest, CL > [owise] .
 endfm

***(%
\end{verbatim}
}

%)

***(%

\subsection{Debugging trees construction}\label{subsec:dtc}

In this section we describe how the different debugging trees are built.
First, we describe the construction of debugging trees for wrong reductions,
memberships, and rewrites and then we use them in the construction of the trees for
erroneous normal forms, least sorts, and sets of reachable terms.
Instead of creating the complete proof trees and then
abbreviating them, we build the abbreviated proof trees directly.

\subsubsection{Debugging trees for wrong reductions and memberships}\label{subsubsec:fm}

The function \texttt{createTree} builds debugging trees for wrong reductions
and memberships. It exploits the fact that the
equations and membership axioms are both \emph{terminating} and \emph{confluent}.
It receives the module where a wrong inference took place, a
correct module (or the constant \texttt{undefMod} when no such module is provided)
to prune the tree, the initial term,
the (erroneous) result obtained, and the set of suspicious statement
labels. It keeps the initial reduction as the root of the tree and uses an
auxiliary function \texttt{createForest} that,
in addition to the arguments received by \texttt{createTree},
receives the module ``cleaned'' of suspicious statements
(by using \texttt{deleteSuspicious}), and generates the forest of
abbreviated trees
corresponding to the reduction between the two terms given as arguments.
The transformed module is used to improve the efficiency of the tree
construction, because we can use it to check whether a term reaches its final
form by using only trusted statements, preventing the debugger from
building a tree that will be finally empty.
%If the module contains operators defined with the \texttt{strat}
%attribute, we cannot delete the nodes corresponding to trusted or correct
%transitions because all the nodes are needed to reorder the tree, which is
%achieved with the function \texttt{reorder}:

{\codesize
\begin{verbatim}
%)

 fmod FUNCTIONAL-TREE-CONSTRUCTION is

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  pr STRAT-TREE .

  vars ST ST1 ST2 : String .
  vars F F' : Forest .
  var  F? : Maybe{Forest} .
  **** OM: Original Module, TM: Trusted Module, CM: Correct Module
  vars OM TM M M' : Module .
  vars T T' T'' T1 T2 T3 L R R' RT : Term .
  vars C C' COND : Condition .
  var  AtS : AttrSet .
  vars Q Q' Q'' : Qid .
  var  QS : QidSet .
  vars TL TL' : TermList .
  vars SB SB' : Substitution .
  vars Ty Ty' S : Type .
  var  TyL : TypeList .
  var  MAS : MembAxSet .
  var  MA : MembAx .
  var  ODS : OpDeclSet .
  var  OD : OpDecl .
  var  CONST : Constant .
  var  CM : Maybe{Module} .
  var  A : Tree .
  var  J : Judgment .
  var  Eq : Equation .
  var  EqS : EquationSet .
  vars N N' : Nat .
  vars NL NL' : NatList .
  var  NNL : NeNatList .
  var  V : Variable .
  var  QIL : QidList .
  var  ST? : Bool .

***(%
\end{verbatim}
}

\end{comment}

{\codesize
\begin{verbatim}
%)

  op createTree : Module Maybe{Module} Term Term QidSet -> Tree .
  ceq createTree(M, CM, T, T', QS) =
     if ST? then createTreeStrat(M, M', CM, T, T', QS)
     else contract(tree('root@#$% : T -> T', getOffspring*(F) + 1, F))
     fi
   if ST? := strat?(M) /\
      M' := deleteSuspicious(M, QS) /\
      F := if not ST?
           then createForest(M, M', CM, T, T', QS)
           else mtForest
           fi .

***(%
\end{verbatim}
}

%TR
\begin{comment}

It is also possible that the inference we are debugging is a membership.
The \texttt{createTree} function is defined in a similar way to the one
above, calculating the least sort possible for the term:

{\codesize
\begin{verbatim}
%)

  op createTree : Module Maybe{Module} Term Sort QidSet -> Tree .
  ceq createTree(M, CM, T, S, QS) =
     if ST? then createTreeStrat(M, M', CM, T, S, QS)
     else contract(tree('root@#$% : T : S, getOffspring*(F) + 1, F))
     fi
   if ST? := strat?(M) /\
      M' := deleteSuspicious(M, QS) /\
      F := if not ST?
           then createForest(M, M', CM, T, type(M, T), QS)
           else mtForest
           fi .

***(%
\end{verbatim}
}

\noindent where \texttt{createForest} computes the normal form of the term
received as argument and then builds the proof tree for the sort inference
(as we will see below).

\end{comment}
%TR

We use the function
\texttt{createForest} to create a forest of abbreviated trees.
It receives as parameters the module where the computation took place,
the transformed module (that only contains trusted statements), a correct
module (possibly \texttt{undefMod}) to check the inferences, two terms
representing the inference whose proof tree we want to generate, and
a set of labels of suspicious equations and memberships.
First, the function checks if the
terms are equal, the result can be reached by using only trusted
statements, or the correct module
can calculate this inference; in such cases, there is no need
to calculate the tree, so the empty forest is returned.
Otherwise, it applies the function \texttt{createForest2}:

{\codesize
\begin{verbatim}
%)

  op createForest : Module Module Maybe{Module} Term Term QidSet ~> Forest .
  eq createForest(OM, TM, CM, T, T', QS) =
   if T == T' or-else (isSafe(OM, TM, CM, T) and-then
                       (reduce(TM, T) == T' or-else reduce(CM, T) == T'))
   then mtForest
   else createForest2(OM, TM, CM, T, T', QS)
   fi .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

 op isSafe : Module Module Module Term -> Bool .
 eq isSafe(OM, TM, CM, CONST) = true .
 eq isSafe(OM, TM, CM, V) = true .
 eq isSafe(OM, TM, CM, '_==_[T1, T2]) =
       if isSafe(OM, TM, CM, T1) and-then isSafe(OM, TM, CM, T2)
       then ((reduce(OM, T1) == T1) and-then (reduce(OM, T2) == T2) or-else
             ((reduce(OM, T1) == reduce(TM, T1)) and-then (reduce(OM, T2) == reduce(TM, T2))) or-else
             ((reduce(OM, T1) == reduce(CM, T1)) and-then (reduce(OM, T2) == reduce(CM, T2))))
       else false
       fi .
 eq isSafe(OM, TM, CM, '_=/=_[T1, T2]) =
       if isSafe(OM, TM, CM, T1) and-then isSafe(OM, TM, CM, T2)
       then ((reduce(OM, T1) == T1) and-then (reduce(OM, T2) == T2) or-else
             ((reduce(OM, T1) == reduce(TM, T1)) and-then (reduce(OM, T2) == reduce(TM, T2))) or-else
             ((reduce(OM, T1) == reduce(CM, T1)) and-then (reduce(OM, T2) == reduce(CM, T2))))
       else false
       fi .
 eq isSafe(OM, TM, CM, Q[TL]) = isSafe*(OM, TM, CM, TL) [owise] .

 op isSafe* : Module Module Module TermList -> Bool .
 eq isSafe*(OM, TM, CM, empty) = true .
 eq isSafe*(OM, TM, CM, (T, TL)) = isSafe(OM, TM, CM, T) and-then isSafe*(OM, TM, CM, TL) .

***(%
\end{verbatim}
}

\end{comment}

The function \verb"createForest2" checks first whether the current term
is of the form \verb"if T1 then T2 else T3 fi". In this case, the debugger
evaluates \verb"T1" and then, depending on the result, it evaluates
either \verb"T2" or \verb"T3" following the same evaluation strategy as Maude:

{\codesize
\begin{verbatim}
%)

  op createForest2 : Module Module Maybe{Module} Term Term QidSet ~> Forest .
  eq createForest2(OM, TM, CM, 'if_then_else_fi[T1, T2, T3], T', QS)  =
     createForest(OM, TM, CM, T1, reduce(OM, T1), QS)
     if reduce(OM, T1) == 'true.Bool then
        createForest(OM, TM, CM, T2, T', QS)
     else
        if reduce(OM, T1) == 'false.Bool then
           createForest(OM, TM, CM, T3, T', QS)
        else
           createForest(OM, TM, CM, T2, reduce(OM, T2), QS)
           createForest(OM, TM, CM, T3, reduce(OM, T3), QS)
        fi
     fi .

***(%
\end{verbatim}
}

Otherwise, the debugger follows the Maude innermost strategy: it first tries
to fully reduce the subterms (by means of the
function \texttt{reduceSubterms}), and once all the
subterms have been reduced, if the result is not the final one, it tries to
reduce at the top (by using the function \texttt{applyEq}), to reach the final
result by \emph{transitivity}:

{\codesize
\begin{verbatim}
%)

  ceq createForest2(OM, TM, CM, T, T', QS) =
                                     if T'' == T' then F
                                     else F applyEq(OM, TM, CM, T'', T', QS)
                                     fi
   if < T'', F > := reduceSubterms(OM, TM, CM, T, QS) [owise] .

***(%
\end{verbatim}
}

The \texttt{reduceSubterms} function returns a pair consisting of the
term with its subterms fully reduced (that is, this function reproduces
a specific behavior of the \emph{congruence} rule shown in Figure
\ref{fig:semanticrules})
and the forest of abbreviated trees generated by these reductions:

{\codesize
\begin{verbatim}
%)

  op reduceSubterms : Module Module Maybe{Module} Term QidSet -> Pair{TermList, Forest} .
  op reduceSubterms : Module Module Maybe{Module} TermList QidSet
                      Pair{TermList, Forest} -> Pair{TermList, Forest} .

  ceq reduceSubterms(OM, TM, CM, Q[TL], QS) = < normal(OM, Q[TL']), F >
   if < TL', F > := reduceSubterms(OM, TM, CM, TL, QS, < empty, mtForest >) .
  eq reduceSubterms(OM, TM, CM, T, QS) = < T, mtForest > [owise] .

  eq reduceSubterms(OM, TM, CM, empty, QS, < TL, F >) = < TL, F > .
  ceq reduceSubterms(OM, TM, CM, (T, TL'), QS, < TL, F >) =
           reduceSubterms(OM, TM, CM, TL', QS,
                           < (TL, T'), F createForest(OM, TM, CM, T, T', QS) >)
   if T' := reduce(OM, T) .

***(%
\end{verbatim}
}

The function \texttt{applyEq} tries to apply (at the top) one
equation,\footnote{Since the module is assumed to be confluent, we can choose
any equation and the final result should be the same.} by using the
\emph{replacement} rule from Figure \ref{fig:semanticrules}, with the
constraint that we cannot apply equations with the \texttt{otherwise}
attribute if other equations can be applied.
To apply an equation we check whether the
term we are trying to reduce matches the lefthand side of the equation
and its conditions are fulfilled. If this happens, we obtain a substitution
(from both the matching with the lefthand side and the conditions)
that we can apply to the righthand side of the equation.
Note that, if we can obtain the transition in the correct module, the forest
is not computed:

{\codesize
\begin{verbatim}
%)

  op applyEq : Module Module Maybe{Module} Term Term QidSet -> Maybe{Forest} .
  op applyEq : Module Module Maybe{Module} Term Term QidSet EquationSet -> Maybe{Forest} .

  eq applyEq(OM, TM, CM, T, T', QS) =
         if (isSafe(OM, TM, CM, T) and-then
             (reduce(TM, T) == T' or-else reduce(CM, T) == T'))
         then mtForest
         else applyEq(OM, TM, CM, T, T', QS, getEqs(OM))
         fi .

***(%
\end{verbatim}
}

First, we try to apply the equations without the \texttt{otherwise}
attribute:

{\codesize
\begin{verbatim}
%)

  ceq applyEq(OM, TM, CM, T, T', QS, Eq EqS) =
              if in?(AtS, QS) then
              tree(label(AtS) : T -> T', getOffspring*(F) + 1, F)
              else F
              fi
   if ceq L = R if C [AtS] . := generalEq(Eq) /\
      not owise?(AtS) /\
      sameKind(OM, typeTermWithVars(OM, L), type(OM, T)) /\
      SB := metaMatch(OM, L, T, C, 0) /\
      R' := substituteDD(OM, R, SB) /\
      F := conditionForest(substituteDD(OM, C, SB), OM, TM, CM, QS)
           createForest(OM, TM, CM, R', T', QS) .

***(%
\end{verbatim}
}

If we cannot apply any equation without the \texttt{otherwise} attribute,
we check the other equations:

{\codesize
\begin{verbatim}
%)

***(
  ceq applyEq(OM, TM, CM, T, T', QS, Eq EqS) =
             if in?(AtS, QS) then
             tree(label(AtS) : T -> T', getOffspring*(F) + 1, F)
             else F
             fi
   if ceq L = R if C [AtS] . := generalEq(Eq) /\
      owise?(AtS) /\
      sameKind(OM, typeTermWithVars(OM, L), type(OM, T)) /\
      SB := metaMatch(OM, L, T, C, 0) /\
      R' := substituteDD(OM, R, SB) /\
      F := conditionForest(substituteDD(OM, C, SB), OM, TM, CM, QS)
           createForest(OM, TM, CM, R', T', QS) .
)

***(%
\end{verbatim}
}

Finally, when no equation is applicable, the function returns \texttt{noProof}:

{\codesize
\begin{verbatim}
%)

  eq applyEq(OM, TM, CM, T, T', QS, EqS) = noProof [owise] .

***(%
\end{verbatim}
}

We show now how the proof trees for the conditions in conditional statements are
generated. Note that, since \texttt{conditionForest} is used after having checked that
the condition is fulfilled (by the function \texttt{metaMatch} above),
we do not check it again.

We distinguish between the different types of conditions.
If we have an equation, we add the trees of the reduction of the terms to their
respective normal forms:

{\codesize
\begin{verbatim}
%)

  op conditionForest : Condition Module Module Maybe{Module} QidSet -> Forest .
  eq conditionForest(T = T' /\ COND, OM, TM, CM, QS) =
                    createForest(OM, TM, CM, T, reduce(OM, T), QS)
                    createForest(OM, TM, CM, T', reduce(OM, T'), QS)
                    conditionForest(COND, OM, TM, CM, QS) .

***(%
\end{verbatim}
}

The case of the matching conditions is very similar. We generate the forest for
the normal form of the righthand side:

{\codesize
\begin{verbatim}
%)

  eq conditionForest(T := T' /\ COND, OM, TM, CM, QS) =
                    createForest(OM, TM, CM, T', reduce(OM, T), QS)
                    conditionForest(COND, OM, TM, CM, QS) .

***(%
\end{verbatim}
}

In the membership case, we use the version of \texttt{createForest} that
builds a forest for a membership inference where the sort is the least
one assignable to the term in the condition:

{\codesize
\begin{verbatim}
%)

  eq conditionForest(T : S /\ COND, OM, TM, CM, QS) =
                    createForest(OM, TM, CM, T, type(OM, T), QS)
                    conditionForest(COND, OM, TM, CM, QS) .

***(%
\end{verbatim}
}

Finally, the empty condition generates the empty forest:

{\codesize
\begin{verbatim}
%)

  eq conditionForest(nil, OM, TM, CM, QS) = mtForest .

***(%
\end{verbatim}
}

%TR
\begin{comment}

To generate the forest for memberships we use the
function \texttt{createForest}, that mimics the \emph{subject reduction}
rule from Figure~\ref{fig:semanticrules} by first
computing the tree for the full reduction of the term
(by means of \texttt{createForest})
and then computing the tree for the membership inference
by using an auxiliary version of \texttt{createForest} that
uses the operator declarations and the membership axioms.
Note that if we can infer the type from the correct
module, there is no need to calculate the forest:

{\codesize
\begin{verbatim}
%)

  op createForest : Module Module Maybe{Module} Term Sort QidSet -> Forest .
  op createForest : Module Module Maybe{Module} Term Sort QidSet OpDeclSet
                    MembAxSet -> Forest .
  ceq createForest(OM, TM, CM, T, S, QS) = mtForest
   if sortLeq(TM, type(TM, T), S) or-else sortLeq(CM, type(CM, T), S) .
  ceq createForest(OM, TM, CM, T, S, QS) =
        createForest(OM, TM, CM, T, T', QS)
        createForest(OM, TM, CM, T', S, QS, getOps(OM), getMbs(OM))
   if T' := reduce(OM, T) [owise] .

***(%
\end{verbatim}
}

The auxiliary \texttt{createForest} computes a forest for a membership
inference of the least sort of a term previously fully reduced; this
corresponds to a concrete application of the \emph{membership} inference
rule from Figure~\ref{fig:semanticrules}.
It first checks if the membership has been inferred by using the operator
declarations. If the membership has not been computed by using these
declarations, it checks the memberships:

{\codesize
\begin{verbatim}
%)

  eq createForest(OM, TM, CM, T, S, QS, ODS, MAS) =
     if applyOp(OM, TM, CM, T, S, QS, ODS) =/= noProof then
        applyOp(OM, TM, CM, T, S, QS, ODS)
     else applyMb(OM, TM, CM, T, S, QS, MAS)
     fi .

***(%
\end{verbatim}
}

To check the operators we examine that both the arity and co-arity of
the term and the declaration fit. We recursively calculate the forest
generated by the subterms. Notice that we never generate a new node
for the application of an operator, because we always trust the signature:

{\codesize
\begin{verbatim}
%)

  op applyOp : Module Module Maybe{Module} Term Sort QidSet OpDeclSet -> Maybe{Forest} .

  ceq applyOp(OM, TM, CM, Q[TL], Ty, QS, op Q : TyL -> Ty [AtS] . ODS) =
      createForest*(OM, TM, CM, TL, QS)
   if checkTypes(TL, TyL, OM) .

  ceq applyOp(OM, TM, CM, CONST, Ty, QS, op Q : nil -> Ty [AtS] . ODS) = mtForest
   if getName(CONST) = Q /\
      getType(CONST) = Ty .

***(%
\end{verbatim}
}

The function \texttt{checkTypes} examines that all the subterms have the
appropriate type in the operator declaration; while \texttt{createForest*}
generates the corresponding forest:

{\codesize
\begin{verbatim}
%)

  op checkTypes : TermList TypeList Module -> Bool .
  eq checkTypes(empty, nil, M) = true .
  ceq checkTypes((T, TL), Ty TyL, M) = checkTypes(TL, TyL, M)
   if sortLeq(M, type(M, T), Ty) .
  eq checkTypes(TL, TyL, M) = false [owise] .

  op createForest* : Module Module Maybe{Module} TermList QidSet -> Forest .
  eq createForest*(OM, TM, CM, empty, QS) = mtForest .
  eq createForest*(OM, TM, CM, (T, TL), QS) = createForest(OM, TM, CM, T, type(OM, T), QS)
                                              createForest*(OM, TM, CM, TL, QS) .

***(%
\end{verbatim}
}

Notice that the operator at top in the term can be different of the operator
declaration if it is declared with the \texttt{iter} operator. We treat this
case by eliminating the iteration from the top with the function \texttt{noIter}:

{\codesize
\begin{verbatim}
%)

  ceq applyOp(OM, TM, CM, Q'[T], Ty', QS, op Q : Ty -> Ty' [iter AtS] . ODS) =
      createForest(OM, TM, CM, Q''[T], type(OM, Q''[T]), QS)
   if Q[Q''[T]] := noIter(Q'[T]) /\
      sortLeq(OM, type(OM, Q''[T]), Ty) .

  eq applyOp(OM, TM, CM, T, S, QS, ODS) = noProof [owise] .

***(%
\end{verbatim}
}

We check the membership axioms in a similar fashion to the equation
application, that is, we only generate a new root below the forest
for the conditions if the membership is suspicious.
The unconditional axioms generate leaves of the tree, while
the conditional ones generate nodes with (possibly) non-empty forests:

{\codesize
\begin{verbatim}
%)

  op applyMb : Module Module Maybe{Module} Term Sort QidSet MembAxSet -> Forest .
  ceq applyMb(OM, TM, CM, T', S, QS, MA MAS) =
      if in?(AtS, QS) then
      tree(label(AtS) : T' : S, getOffspring*(F) + 1, F)
      else F
      fi
   if cmb T : S if C [AtS] . := generalMb(MA) /\
      sameKind(OM, typeTermWithVars(OM, T), type(OM, T')) /\
      SB := metaMatch(OM, T, T', C, 0) /\
      F := conditionForest(substituteDD(OM, C, SB), OM, TM, CM, QS)  .
  eq applyMb(OM, TM, CM, T, S, QS, MAS) = mtForest [owise] .

***(%
\end{verbatim}
}

Finally, we define a function \verb"createForest" with an extra Boolean
argument that distinguishes whether the module contains operators defined
with the \texttt{strat} operator or not. In the first case, the function
\texttt{createForest} specified in this module is used, while in the second
case the colored and reordered tree shown in Section \ref{subsubsec:reoder}
is computed and, if its root does not contain relevant information (i.e.,
it is labeled with \verb"'root@#$%") then it is removed and the forest is
returned:

{\codesize
\begin{verbatim}
%)

  op createForest : Module Module Maybe{Module} Term Term QidSet Bool ~> Forest .
  eq createForest(OM, TM, CM, T, T1, QS, ST?) =
      if ST?
      then quitRoot(createTreeStrat(OM, TM, CM, T, T1, QS))
      else createForest(OM, TM, CM, T, T1, QS)
      fi .

  op quitRoot : Tree -> Forest .
  eq quitRoot(tree(J, N, F)) =
       if getLabel(tree(J, N, F)) == 'root@#$%
       then F
       else tree(J, N, F)
       fi .
 endfm

***(%
\end{verbatim}
}

\end{comment}
%TR

\begin{verbatim}
  ...
 endfm
\end{verbatim}

\subsubsection{Debugging trees for wrong rewrites}

We use a different methodology in the construction of the debugging tree
for incorrect rewrites. Since these modules are not assumed to be
confluent or terminating, we use the predefined breadth-first
search function \texttt{metaSearchPath} to find from the initial term
the wrong term introduced
by the user, and then we use the returned trace to build the
debugging tree. The trace returned by Maude when searching from \texttt{T}
to \texttt{T'} is a list of steps of the form:

{\codesize
\begin{verbatim}
 {T1, Ty1, R1} ... {Tn, Tyn, Rn}
\end{verbatim}
}

\noindent where \verb"Tyi" is the type of \verb"Ti",
\texttt{T1} is the normal form of \texttt{T}, \texttt{Ri}
is the rule applied to (possibly a subterm of) \texttt{Ti} to obtain \texttt{Ti+1}
(which is already in normal form),
and \texttt{T'} is the result of applying \texttt{Rn} to \texttt{Tn}.


The function \texttt{createRewTree}, given
the module where the rewrite took place,
a module with correct statements (possibly \verb"undefMod"),
the rewritten term, the result term, the set of suspicious labels,
the type of tree selected (many-steps or one-step, identified by
constants \texttt{ms} and \texttt{os} in the module \texttt{TREE-TYPE}),
and the bound of the search in the correct and trusted modules, creates the
corresponding debugging tree:

{\codesize
\begin{verbatim}
%)

 fmod SYSTEM-TREE-CONSTRUCTION is
  pr FUNCTIONAL-TREE-CONSTRUCTION .
  pr PAIR{Substitution, Context} .
  pr PAIR{TermList, NeCTermList} .
  pr PAIR{Forest, Forest} .
  pr MAYBE{Tree} * (op maybe to error) .
  pr TREE-TYPE .
  pr EXT-BOOL .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  subsort Maybe{Tree} < Maybe{Forest} .

  vars T T' T'' TN T1 T2 T3 T4 : Term .
  vars TL TL' TL'' : TermList .
  vars R R' : Rule .
  var  S : Sort .
  vars Ty Ty' : Type .
  vars TR TR' : Trace .
  vars TRS TRS' : TraceStep .
  vars M OM TM : Module .
  var  CM : Maybe{Module} .
  var  SB : Substitution .
  var  C : Context .
  vars N N' N1 N2 : Nat .
  vars COND COND' : Condition .
  var  AtS : AttrSet .
  vars CTL CTL' : NeCTermList .
  vars F F' F'' F1 F2 : Forest .
  var  Q : Qid .
  var  QS : QidSet .
  var  NL : NatList .
  vars A A' A2 A3 : Tree .
  var  PFF : Pair{Forest, Forest} .
  var  B : Bound .
  var  TT : TreeType .

***(%
\end{verbatim}
}

\end{comment}

{\codesize
\begin{verbatim}
%)

  op createRewTree : Module Maybe{Module} Term Term QidSet TreeType Bound -> Maybe{Tree} .

  eq createRewTree(OM, CM, T, T', QS, os, B) = oneStepTree(OM, CM, T, T', QS, B) .
  eq createRewTree(OM, CM, T, T', QS, ms, B) = manyStepsTree(OM, CM, T, T', QS, B) .

***(%
\end{verbatim}
}

The function \texttt{oneStepTree} creates a complete debugging tree with only one-step
rewrites in its nodes. It puts as root of the tree the complete inference,
computes the tree for the reduction  from the initial term to normal
form with the function \texttt{createForest}
from Section \ref{subsubsec:fm}, and then computes
the rest of the tree with the function \texttt{oneStepForest}. This corresponds to
a concrete application of the \emph{equivalence class} inference rule from
Figure~\ref{fig:semanticrules}:

{\codesize
\begin{verbatim}
%)

  op oneStepTree : Module Maybe{Module} Term Term QidSet Bound -> Maybe{Tree} .
  ceq oneStepTree(OM, CM, T, T', QS, B) =
             contract(tree(T =>+ T', getOffspring*(F) + 1, F))
   if TM := deleteSuspicious(OM, QS) /\
      T1 := reduce(OM, T) /\
      F := createForest(OM, TM, CM, T, T1, QS, strat?(OM))
           oneStepForest(OM, TM, CM, T1, T', QS, B) .

  eq oneStepTree(OM, CM, T, T', QS, B) = error [owise] .

***(%
\end{verbatim}
}

\texttt{oneStepForest} computes the trace of a rewrite with the predefined function
\texttt{metaSearchPath} and uses it to generate a debugging tree by using
\texttt{trace2forest}:

{\codesize
\begin{verbatim}
%)

  op oneStepForest : Module Module Maybe{Module} Term Term QidSet Bound -> Maybe{Forest} .
  ceq oneStepForest(OM, TM, CM, T, T', QS, B) = F
   if TR := metaSearchPath(OM, T, T', nil, '*, unbounded, 0) /\
      F := trace2forest(OM, TM, CM, TR, T', QS, B) .

  eq oneStepForest(OM, TM, CM, T, T', QS, B) = noProof [owise] .

***(%
\end{verbatim}
}

The function \texttt{trace2forest} generates a forest of one-step rewrites
by extracting each step of the trace and creating its corresponding tree with
the function \texttt{stepForest}:

{\codesize
\begin{verbatim}
%)

  op trace2forest : Module Module Maybe{Module} Trace Term QidSet Bound -> Forest .
  eq trace2forest(OM, TM, CM, nil, T, QS, B) = mtForest .
  eq trace2forest(OM, TM, CM, {T, Ty, R}, T', QS, B) =
     stepForest(OM, TM, CM, T, T', R, QS, B, os) .
  eq trace2forest(OM, TM, CM, {T, Ty, R} {T', Ty', R'} TR, T'', QS, B) =
     stepForest(OM, TM, CM, T, T', R, QS, B, os)
     trace2forest(OM, TM, CM, {T', Ty', R'} TR, T'', QS, B) .

***(%
\end{verbatim}
}

The first equation of \texttt{stepForest} checks whether the value can be obtained
by using trusted statements or the correct module:

{\codesize
\begin{verbatim}
%)

  op stepForest : Module Module Maybe{Module} Term Term Rule QidSet Bound TreeType -> Forest .
  ceq stepForest(OM, TM, CM, T, T', R, QS, B, TT) = mtForest
   if secure?(TM, CM, T, T', B) .

***(%
\end{verbatim}
}

\noindent where \texttt{secure?} searches in the modules with correct statements
whether the rewrite is possible. Note the use of the bound, that can be
selected by the user:

{\codesize
\begin{verbatim}
%)

  op secure? : Module Maybe{Module} Term Term Bound -> Bool .
  eq secure?(TM, CM, T, T', B) = metaSearchPath(TM, T, T', nil, '+, B, 0) :: Trace
                         or-else metaSearchPath(CM, T, T', nil, '+, B, 0) :: Trace .

***(%
\end{verbatim}
}

The second equation of \texttt{stepForest} deals with the other cases.
It uses the function \texttt{getInfo} to obtain the substitution and the context
of the application of the rule, and then applies this substitution in the
lefthand and righthand sides to obtain the rewritten (sub)terms.
The whole rewritten term is obtained by substituting the hole in the context by the
subterm computed before (by using \texttt{substituteHole}). The corresponding
normal forms are computed with the function \texttt{createForest} for
reductions. This equation reproduces the abbreviation of the application of the
\emph{replacement}, \emph{congruence}, and \emph{equivalence class} inference
rules:

{\codesize
\begin{verbatim}
%)

  ceq stepForest(OM, TM, CM, T, T', R, QS, B, TT) = if trusted?(R, QS) then F F'
          else tree(getLabel(R) : T1 =>1 T3, getOffspring*(F) + 1, F) F' fi
   if < SB, C > := getInfo(OM, T, T', getLabel(R), 0) /\
      T1 := substituteDD(OM, getLefthand(R), SB) /\
      T2 := substituteDD(OM, getRighthand(R), SB) /\
      T3 := reduce(OM, T2) /\
      F := conditionForest(substituteDD(OM, getCondition(R), SB), OM, TM, CM, QS, B, TT)
           createForest(OM, TM, CM, T2, T3, QS, strat?(OM)) /\
      F' := createForest(OM, TM, CM, substituteHole(OM, C, T3), T', QS, strat?(OM)) [owise] .

  op getExtendedCondition : Module Term Rule -> Condition .
  ceq getExtendedCondition(M, T, crl T' => T'' if COND [AtS] .) = substituteDD(M, COND, SB)
   if {SB, C} := metaXmatch(M, T', T, COND, 0, unbounded, 0) .
  eq getExtendedCondition(M, T, R) = nil [owise] .

***(%
\end{verbatim}
}

\noindent where \texttt{trusted?} checks whether the rule is not
labeled or it is labeled but the label does not belong to the set of suspicious
statements, and \texttt{getInfo} uses \texttt{metaXapply} to compute the
substitution and the context needed to rewrite a term into
another one:

{\codesize
\begin{verbatim}
%)

  op trusted? : Rule QidSet -> Bool .
  eq trusted?(rl T => T' [label(Q) AtS] ., Q ; QS) = false .
  eq trusted?(crl T => T' if COND [label(Q) AtS] ., Q ; QS) = false .
  eq trusted?(R, QS) = true [owise] .

  op getInfo : Module Term Term Qid Nat ~> Pair{Substitution, Context} .
  ceq getInfo(M, T, T', Q, N) = < SB, C >
   if {T', Ty, SB, C} := metaXapply(M, T, Q, none, 0, unbounded, N) .
  ceq getInfo(M, T, T', Q, N) = getInfo(M, T, T', Q, s(N))
   if {T'', Ty, SB, C} := metaXapply(M, T, Q, none, 0, unbounded, N) /\
      T' =/= T'' .

***(%
\end{verbatim}
}

The new version of the function \texttt{conditionForest} has
as new parameters the bound of the search in
the correct and trusted modules and a value indicating whether the forest
generated by the conditions must be one-step or many-step:

{\codesize
\begin{verbatim}
%)

  op conditionForest : Condition Module Module Maybe{Module} QidSet Bound TreeType -> Forest .

  eq conditionForest(nil, OM, TM, CM, QS, B, TT) = mtForest .
  eq conditionForest(T = T' /\ COND, OM, TM, CM, QS, B, TT) =
                    createForest(OM, TM, CM, T, reduce(OM, T), QS, strat?(OM))
                    createForest(OM, TM, CM, T', reduce(OM, T'), QS, strat?(OM))
                    conditionForest(COND, OM, TM, CM, QS, B, TT) .
  eq conditionForest(T := T' /\ COND, OM, TM, CM, QS, B, TT) =
                    createForest(OM, TM, CM, T', reduce(OM, T), QS, strat?(OM))
                    conditionForest(COND, OM, TM, CM, QS, B, TT) .
  eq conditionForest(T : S /\ COND, OM, TM, CM, QS, B, TT) =
                    createForest(OM, TM, CM, T, type(OM, T), QS, strat?(OM))
                    conditionForest(COND, OM, TM, CM, QS, B, TT) .

***(%
\end{verbatim}
}

Furthermore, it is also defined for the case of rewrite conditions, that
uses the corresponding tree construction function:

{\codesize
\begin{verbatim}
%)

  eq conditionForest(T => T' /\ COND, OM, TM, CM, QS, B, TT) =
      if TT == os then oneStepForest(OM, TM, CM, T, T', QS, B)
                  else manyStepsTree2(OM, TM, CM, T, T', QS, B)
      fi
      conditionForest(COND, OM, TM, CM, QS, B, TT) .

***(%
\end{verbatim}
}

The many-steps debugging tree is built with the function
\texttt{manyStepsTree}. This tree is computed \emph{on demand}, so that
the debugging subtrees corresponding to one-step rewrites are only generated
when they are pointed out as wrong. It uses an auxiliary function
\texttt{manyStepsTree2}, that also receives as parameter the module cleaned
of suspicious statements with \texttt{deleteSuspicious}:

{\codesize
\begin{verbatim}
%)

  op manyStepsTree : Module Maybe{Module} Term Term QidSet Bound -> Maybe{Tree} .
  ceq manyStepsTree(OM, CM, T, T', QS, B) =
                   contract(tree(T =>+ T', getOffspring*(F) + 1, F))
   if F := manyStepsTree2(OM, deleteSuspicious(OM, QS), CM, T, T', QS, B) .
  eq manyStepsTree(OM, CM, T, T', QS, B) = error [owise] .

***(%
\end{verbatim}
}

This auxiliary function uses the function \texttt{metaSearchPath} to
compute the trace. If it is not empty, the forest for the reduction of
the initial term to normal form is built with the function \verb"createForest" and
the tree for the rewrites is appended to this forest.
If the trace consists of only one step, it is expanded with the function
\verb"stepForest" shown above. Otherwise, the many-steps tree from the trace is
build with the function \verb"trace2tree":

{\codesize
\begin{verbatim}
%)

  op manyStepsTree2 : Module Module Maybe{Module} Term Term QidSet Bound ~> Maybe{Forest} .
  ceq manyStepsTree2(OM, TM, CM, T, T', QS, B) = F
   if {T'', Ty, R} TR := metaSearchPath(OM, T, T', nil, '*, unbounded, 0) /\
      F := createForest(OM, TM, CM, T, T'', QS, strat?(OM))
           if TR =/= nil
           then trace2tree(OM, TM, CM, {T'', Ty, R} TR, T', QS, B, mtForest, 0)
           else stepForest(OM, TM, CM, T'', T', R, QS, B, ms)
           fi .

***(%
\end{verbatim}
}

If the trace is empty, only the tree for the reduction is computed:

{\codesize
\begin{verbatim}
%)

  ceq manyStepsTree2(OM, TM, CM, T, T', QS, B) = createForest(OM, TM, CM, T, T', QS, strat?(OM))
   if nil == metaSearchPath(OM, T, T', nil, '*, unbounded, 0) .

***(%
\end{verbatim}
}

Finally, if the final term is not reachable from the initial term,
an error is returned. Note that errors due to non-termination cannot be detected:

{\codesize
\begin{verbatim}
%)

  eq manyStepsTree2(OM, TM, CM, T, T', QS, B) = noProof [owise] .

***(%
\end{verbatim}
}

The function \texttt{trace2tree} traverses the trace
and for those steps which are not secure (that is, they use suspicious statements
and cannot be inferred in the correct module) it builds a ``frozen'' node that
will be used later to build the many-steps tree with the function \texttt{divide}:

{\codesize
\begin{verbatim}
%)

  op trace2tree : Module Module Maybe{Module} Trace Term QidSet Bound Forest Nat -> Tree .
  eq trace2tree(OM, TM, CM, nil, T', QS, B, F, N) = mtForest .
  ceq trace2tree(OM, TM, CM, {T, Ty, R}, T', QS, B, F, N) = divide(F, N)
   if secure?(TM, CM, T, T', B) .
  eq trace2tree(OM, TM, CM, {T, Ty, R}, T', QS, B, F, N) =
                 divide(F tree(T =>f T', 1, mtForest), s(N)) [owise] .
  ceq trace2tree(OM, TM, CM, {T, Ty, R} {T', Ty', R'} TR, T'', QS, B, F, N) =
            trace2tree(OM, TM, CM, {T', Ty', R'} TR, T'', QS, B, F, N)
   if secure?(TM, CM, T, T', B) .
  eq trace2tree(OM, TM, CM, {T, Ty, R} {T', Ty', R'} TR, T'', QS, B, F, N) =
            trace2tree(OM, TM, CM, {T', Ty', R'} TR, T'', QS, B, F
                                          tree(T =>f T', 1, mtForest), s(N)) [owise] .

***(%
\end{verbatim}
}

The function \texttt{divide} creates a balanced tree from the
forest of leaves obtained from the trace.
It divides the forest received as parameter into two forests of approximately the
same size, recursively creates their trees, and
uses them as children of a new binary tree that has as root the
combination by \emph{transitivity} of the rewrites in their roots:

{\codesize
\begin{verbatim}
%)

  op divide : Forest Nat ~> Tree .

***(%
\end{verbatim}
}

We consider as basic case the forest composed by only one tree:

{\codesize
\begin{verbatim}
%)

  eq divide(A, 1) = A .

***(%
\end{verbatim}
}

The general case halves the forest and creates the corresponding trees, building
a new tree with them:

{\codesize
\begin{verbatim}
%)

  ceq divide(F, N) = tree(getFirstTerm(A) =>+ getSecondTerm(A'), N1 + 1, A A')
   if N > 1 /\
      N' := N quo 2 /\
      < F', F'' > := takeDrop(F, N') /\
      A := divide(F', N') /\
      A' := divide(F'', sd(N, N')) /\
      N1 := getOffspring(A) + getOffspring(A') .

***(%
\end{verbatim}
}

\noindent where the function \texttt{takeDrop} returns a pair composed by
the first \texttt{N} elements of the forest and the rest:

{\codesize
\begin{verbatim}
%)

  op takeDrop : Forest Nat -> Pair{Forest, Forest} .
  eq takeDrop(F, N) = takeDrop(F, N, mtForest) .

  op takeDrop : Forest Nat Forest -> Pair{Forest, Forest} .
  eq takeDrop(A F, s(N), F') = takeDrop(F, N, F' A) .
  eq takeDrop(F, N, F') = < F', F > [owise] .
 endfm

***(%
\end{verbatim}
}

\subsubsection{Debugging trees for missing answers}\label{subsec:misstree}

The module \texttt{MISSING-ANSWERS-TREE} is in charge of building the
debugging tree for missing answers:

{\codesize
\begin{verbatim}
%)

 fmod MISSING-ANSWERS-TREE is
  pr SYSTEM-TREE-CONSTRUCTION .
  pr SEARCH-TYPE .
  pr PAIR{Forest, TermList} .
  pr MAYBE{Type} * (op maybe to typeError) .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  vars M M' OM TM : Module .
  var  CM : Maybe{Module} .
  vars A A' : Tree .
  vars F F' F'' F1 AF RF CF FF : Forest .
  vars B B' BW BM : Bound .
  vars T T' T'' T1 T2 T3 PAT LHS RHS RHS' KT TN : Term .
  vars N N' AN : Nat .
  vars Q Q' Q'' : Qid .
  vars QS FS : QidSet .
  vars TL TL' TL'' TL1 : TermList .
  vars Ty Ty' Ty1 Ty2 : Type .
  var  TyL : TypeList .
  vars SB SB' : Substitution .
  vars CTXT CTXT' : Context .
  var  R : Rule .
  var  RS : RuleSet .
  var  J : Judgment .
  var  ST : SearchType .
  vars C C' : Condition .
  vars ST? UB? SP SC EXP BFS FST : Bool .
  vars TTW TTM : TreeType .
  vars TR TR' : Trace .
  var  TRS : TraceStep .
  vars Ct Const : Constant .
  vars V V' : Variable .
  var  ODS : OpDeclSet .
  var  OP : OpDecl .
  var  AtS : AttrSet .
  vars SSB SSB' : Set{Substitution} .
  var  RP : ResultPair .
  var  NL : NatList .
  var  Eq : Equation .
  var  EqS : EquationSet .
  var  Mb : MembAx .
  var  MAS : MembAxSet .
  var  K : Kind .
  var  GTL : GTermList .

  sort Set{Substitution} .
  subsort Substitution < Set{Substitution} .
  op mtSSB : -> Set{Substitution} [ctor] .
  op _._ : Set{Substitution} Set{Substitution} -> Set{Substitution}
    [ctor assoc comm id: mtSSB] .
  eq X:Substitution . X:Substitution = X:Substitution .

***(%
\end{verbatim}
}

\end{comment}

The debugging tree for normal forms is built with the
function \verb"createMissingTree". It receives the module where the
reduction took place, a correct module, the initial term, the reached
normal form, and a set of suspicious labels:

{\codesize
\begin{verbatim}
%)

  op createMissingTree : Module Maybe{Module} Term Term QidSet -> Tree .
  ceq createMissingTree(M, CM, T, T', QS) = A
   if TN := normal(M, T) /\
      TM := deleteSuspicious(M, QS) /\
      T'' := reduce(M, T') /\
      F := cleanTree*(M, false, none, createMissingForest(M, TM, CM, TN, T'', QS)) /\
      A := contract(tree('root : TN -> T'', getOffspring*(F) + 1, F)) .

  op contract* : Forest -> Forest .
  eq contract*(tree(J, N, F)) = F .
  eq contract*(F) = F .

***(%
\end{verbatim}
}

The function \verb"createMissingForest" checks whether the result can be obtained in the
trusted or correct modules. When this happens, it only generates a forest proving the term is
in normal form with \verb"proveNormal"; otherwise, it uses the auxiliary function
\verb"createMissingForest2":

{\codesize
\begin{verbatim}
%)

  op createMissingForest : Module Module Maybe{Module} Term Term QidSet -> Forest .
  ceq createMissingForest(OM, TM, CM, T, T', QS) = F
   if T == T' or-else (isSafe(OM, TM, CM, T) and-then
                      (reduce(TM, T) == T' or-else reduce(CM, T) == T')) /\
      F := proveNormal(OM, TM, CM, T', QS) .
  eq createMissingForest(OM, TM, CM, T, T', QS) =
           createMissingForest2(OM, TM, CM, T, T', QS) [owise] .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  op createMissingForest2 : Module Module Maybe{Module} Term Term QidSet -> Forest .
  eq createMissingForest2(OM, TM, CM, 'if_then_else_fi[T1, T2, T3], T', QS)  =
     createMissingForest(OM, TM, CM, T1, reduce(OM, T1), QS)
     if reduce(OM, T1) == 'true.Bool then
        createMissingForest(OM, TM, CM, T2, T', QS)
     else
        if reduce(OM, T1) == 'false.Bool then
           createMissingForest(OM, TM, CM, T3, T', QS)
        else
           createMissingForest(OM, TM, CM, T2, reduce(OM, T2), QS)
           createMissingForest(OM, TM, CM, T3, reduce(OM, T3), QS)
        fi
     fi .

***(%
\end{verbatim}
}

\end{comment}

\verb"createMissingForest2" generates the forest for the subterms
with \verb"reduceSubtermsMissing" and then distinguishes whether the final result
has been reached, proving in that case whether the term is in normal form with \verb"proveNormal",
or not, applying then the next equation with \verb"applyEqMissing":

{\codesize
\begin{verbatim}
%)

  ceq createMissingForest2(OM, TM, CM, T, T', QS) =
                                if T'' == T' then F proveNormal(OM, TM, CM, T', QS)
                                else F applyEqMissing(OM, TM, CM, T'', T', QS)
                                fi
   if < T'', F > := reduceSubtermsMissing(OM, TM, CM, T, QS) [owise] .

***(%
\end{verbatim}
}

The function \verb"reduceSubtermsMissing" is in charge of reducing the
subterms of the given term to normal form, returning a pair with the new
term and the forest proving these reductions. It uses an auxiliary function
\verb"reduceSubtermsMissing" with an accumulator to keep the temporary
results:

{\codesize
\begin{verbatim}
%)

  op reduceSubtermsMissing : Module Maybe{Module} Module Term QidSet
                             -> Pair{TermList, Forest} .
  ceq reduceSubtermsMissing(OM, TM, CM, Q[TL], QS) = < normal(OM, Q[TL']), F >
   if < TL', F > := reduceSubtermsMissing(OM, TM, CM, TL, QS, < empty, mtForest >) .
  eq reduceSubtermsMissing(OM, TM, CM, T, QS) = < T, mtForest > [owise] .

***(%
\end{verbatim}
}

This auxiliary function traverses the subterms, computing the appropriate
tree with \verb"createMissingForest", and returning the accumulated pair
once no more terms are available:

{\codesize
\begin{verbatim}
%)

  op reduceSubtermsMissing : Module Maybe{Module} Module Term QidSet
                             Pair{TermList, Forest} -> Pair{TermList, Forest} .
  eq reduceSubtermsMissing(OM, TM, CM, empty, QS, < TL, F >) = < TL, F > .
  ceq reduceSubtermsMissing(OM, TM, CM, (T, TL'), QS, < TL, F >) =
           reduceSubtermsMissing(OM, TM, CM, TL', QS,
                      < (TL, T'), F createMissingForest(OM, TM, CM, T, T', QS) >)
   if T' := reduce(OM, T) .

***(%
\end{verbatim}
}

The function \verb"applyEqMissing" checks whether the current term is in
normal form or the reduction is correct in the trusted or correct modules.
In these cases, the empty forest is returned, while otherwise
\verb"applyEqMissing2" is used.

{\codesize
\begin{verbatim}
%)

  op applyEqMissing : Module Module Maybe{Module} Term Term QidSet
                      -> Maybe{Forest} .
  eq applyEqMissing(OM, TM, CM, T, T', QS) =
         if (isSafe(OM, TM, CM, T) and-then
             (reduce(TM, T) == T' or-else reduce(CM, T) == T')) then mtForest
         else applyEqMissing2(OM, TM, CM, T, T', QS, getEqs(OM))
         fi .

***(%
\end{verbatim}
}

\verb"applyEqMissing2" tries to apply one equation and then apply
\verb"createMissingForest" to the obtained term until the normal form
is reached, following the approach for wrong answers. We first try to
use equations defined without the \verb"owise" attribute, and if they
cannot be used then equations with this attribute are tried. This function
returns \verb"noProof" when the normal form has not been obtained but
no equations can be applied to the current term:

{\codesize
\begin{verbatim}
%)

  op applyEqMissing2 : Module Module Maybe{Module} Term Term QidSet
                      EquationSet -> Maybe{Forest} .
  ceq applyEqMissing2(OM, TM, CM, T, T', QS, Eq EqS) =
              if in?(AtS, QS) then
              tree(label(AtS) : T -> T', getOffspring*(F) + 1, F)
              else F
              fi
   if ceq LHS = RHS if C [AtS] . := generalEq(Eq) /\
      not owise?(AtS) /\
      sameKind(OM, typeTermWithVars(OM, LHS), type(OM, T)) /\
      SB := metaMatch(OM, LHS, T, C, 0) /\
      RHS' := substituteDD(OM, RHS, SB) /\
      F := conditionForest(substituteDD(OM, C, SB), OM, TM, CM, QS)
           createMissingForest(OM, TM, CM, RHS', T', QS) .

  ceq applyEqMissing2(OM, TM, CM, T, T', QS, Eq EqS) =
             if in?(AtS, QS) then
             tree(label(AtS) : T -> T', getOffspring*(F) + 1, F)
             else F
             fi
   if ceq LHS = RHS if C [AtS] . := generalEq(Eq) /\
      owise?(AtS) /\
      sameKind(OM, typeTermWithVars(OM, LHS), type(OM, T)) /\
      SB := metaMatch(OM, LHS, T, C, 0) /\
      RHS' := substituteDD(OM, RHS, SB) /\
      F := conditionForest(substituteDD(OM, C, SB), OM, TM, CM, QS)
           createMissingForest(OM, TM, CM, RHS', T', QS) .
  eq applyEqMissing2(OM, TM, CM, T, T', QS, EqS) = noProof [owise] .

***(%
\end{verbatim}
}

\noindent where \texttt{match?} uses the predefined function
\verb"metaMatch" to check whether the terms match:

{\codesize
\begin{verbatim}
%)

  op match? : Module Term Equation -> Bool .
  ceq match?(M, T, eq T1 = T2 [AtS] .) = metaMatch(M, T', T, nil, 0) :: Substitution
   if T' := kindTerm(M, T1) /\
      sameKind(M, type(M, T), type(M, T')) .
  ceq match?(M, T, ceq T1 = T2 if C [AtS] .) = metaMatch(M, T', T, nil, 0) :: Substitution
   if T' := kindTerm(M, T1) /\
      sameKind(M, type(M, T), type(M, T')) .
  eq match?(M, T, Eq) = false [owise] .

***(%
\end{verbatim}
}

The function \verb"buildConditionForestEqs" proves that no equations can
be applied to the given term. It uses an auxiliary function
\verb"buildConditionForestEqs*" that traverses all the equations in the
module and checks that each of them cannot be applied with
\verb"buildConditionForestEqs2":

{\codesize
\begin{verbatim}
%)

  op buildConditionForestEqs : Module Module Maybe{Module} Term QidSet
                               -> Forest .
  eq buildConditionForestEqs(OM, TM, CM, T, QS) =
                buildConditionForestEqs*(OM, TM, CM, T, QS, getEqs(OM)) .

  op buildConditionForestEqs* : Module Module Maybe{Module} Term QidSet EquationSet
                                -> Forest .
  eq buildConditionForestEqs*(OM, TM, CM, T, QS, none) = mtForest .
  eq buildConditionForestEqs*(OM, TM, CM, T, QS, Eq EqS) =
           buildConditionForestEqs2(OM, TM, CM, T, QS, Eq)
           buildConditionForestEqs*(OM, TM, CM, T, QS, EqS) .

***(%
\end{verbatim}
}

\verb"buildConditionForestEqs2" checks whether the term with the variables
at the kind level matches the lefthand side of the equation. When it does
not match the equation is discarded, while when the term matches the lefthand
side we distinguish whether the equation is conditional or not. In the
first case the function only proves that the term at the sort level does
not match the lefthand side with \verb"sort-match" (remember we are proving
the equation cannot be applied), while in the second one we have also to
compute why the condition does not hold, which is proved with
\verb"buildConditionForestMissingAux":

{\codesize
\begin{verbatim}
%)

  op buildConditionForestEqs2 : Module Module Maybe{Module} Term QidSet Equation -> Forest .
  ceq buildConditionForestEqs2(OM, TM, CM, T, QS, Eq) = F
   if not match?(OM, T, Eq) /\
      F := createForest(OM, TM, CM, T, getTerm(metaReduce(OM, T)), QS, strat?(OM)) .

  ceq buildConditionForestEqs2(OM, TM, CM, T, QS, eq T1 = T2 [AtS] .) =
            F sort-match(OM, TM, CM, QS, T1, T)
   if match?(OM, T, eq T1 = T2 [AtS] .) /\
      SSB := allSubs(OM, T, T1 := T, 0, mtSSB) /\
      < F, TL > := applySubs(OM, TM, CM, QS, T2, SSB) .

  ceq buildConditionForestEqs2(OM, TM, CM, T, QS, ceq T1 = T2 if C [AtS] .) =
            F sort-match(OM, TM, CM, QS, T1, T)
   if match?(OM, T, ceq T1 = T2 if C [AtS] .) /\
      SSB := allSubs(OM, T, T1 := T, 0, mtSSB) /\
      < F, TL > := buildConditionForestMissingAux(OM, TM, CM, QS, T, T2,
                                  T1 := T /\ C, SSB, 2, getNumConds(C) + 1) .

***(%
\end{verbatim}
}

The function \verb"buildConditionForestMissingAux" receives, in addition to
the usual parameters, the condition to be checked, the set of substitutions
that satisfy the condition thus far, the next atomic condition to be
evaluated, and the total number of atomic conditions. When the index of the
current atomic condition is greater than the number of conditions, it just
computes the forest proving the reductions of the terms once the substitutions
are applied with \verb"applySubs":

{\codesize
\begin{verbatim}
%)

  op buildConditionForestMissingAux : Module Module Maybe{Module} QidSet Term Term
                                      Condition Set{Substitution} Nat Nat
                                      -> Pair{Forest, TermList} .
  eq buildConditionForestMissingAux(OM, TM, CM, QS, T, T2, C, SSB, s(N), N) =
                 applySubs(OM, TM, CM, QS, T2, SSB) .

***(%
\end{verbatim}
}

When the set of substitutions fulfilling the condition thus far is empty,
the empty forest is returned:

{\codesize
\begin{verbatim}
%)

  eq buildConditionForestMissingAux(M, TM, CM, QS, T, T2, C, mtSSB, N, N') =
                           < mtForest, empty > .

***(%
\end{verbatim}
}

While the function does not reach the last atomic condition, we extend the condition
thus far with the next atomic condition with \verb"getNFirst",
obtain the set of substitutions that fulfill this extended condition with
\verb"allSubs", apply the previous set of substitutions to the atomic condition, and
obtain the forest proving the extension of the set with \verb"substituteAndCreateForest":

{\codesize
\begin{verbatim}
%)

  ceq buildConditionForestMissingAux(M, TM, CM, QS, T, T2, C, SSB, N, N') =
                           < F F', TL' >
   if N <= N' /\
      C' := getNFirst(C, N) /\
      F := substituteAndCreateForest(M, TM, CM, QS, getLast(C'), SSB) /\
      SSB' := allSubs(M, T, C', 0, mtSSB) /\
      < F', TL' > := buildConditionForestMissingAux(M, TM, CM, QS, T, T2,
                                          C, SSB', s(N), N') [owise] .

***(%
\end{verbatim}
}

The function \verb"substituteAndCreateForest" traverses the set of substitutions
applying the auxiliary function \verb"createForestOnceSubstituted" to each
obtained condition:

{\codesize
\begin{verbatim}
%)

  op substituteAndCreateForest : Module Module Maybe{Module} QidSet Condition
                                 Set{Substitution} -> Forest .
  eq substituteAndCreateForest(OM, TM, CM, QS, C, mtSSB) = mtForest .

  ceq substituteAndCreateForest(M, TM, CM, QS, C, SB . SSB) = F F'
   if F := createForestOnceSubstituted(M, TM, CM, QS, substituteDD(M, C, SB)) /\
      F' := substituteAndCreateForest(M, TM, CM, QS, C, SSB) .

***(%
\end{verbatim}
}

\verb"createForestOnceSubstituted" distinguishes between the different kinds of
condition. For example, when a matching condition is found the forest for the
reduction to normal form of the righthand side is computed with
\verb"createMissingForest", while the forest for the matching is computed with
the auxiliary function \verb"sort-match":

{\codesize
\begin{verbatim}
%)

  op createForestOnceSubstituted : Module Module Maybe{Module} QidSet Condition
                                   -> Forest .
  ceq createForestOnceSubstituted(OM, TM, CM, QS, T := T') =
        createMissingForest(OM, TM, CM, T', T'', QS)
        sort-match(OM, TM, CM, QS, T, T'')
   if T'' := reduce(OM, T') .

***(%
\end{verbatim}
}

%TR
\begin{comment}

{\codesize
\begin{verbatim}
%)

  ceq createForestOnceSubstituted(OM, TM, CM, QS, T = T') =
       if T1 == T2 then
          createForest(OM, TM, CM, T, T1, QS, strat?(OM))
          createForest(OM, TM, CM, T', T2, QS, strat?(OM))
       else
          createMissingForest(OM, TM, CM, T, T1, QS)
          createMissingForest(OM, TM, CM, T', T2, QS)
       fi
   if T1 := getTerm(metaReduce(OM, T)) /\
      T2 := getTerm(metaReduce(OM, T')) .

  ceq createForestOnceSubstituted(OM, TM, CM, QS, T : Ty) =
                     createMissingForest(OM, TM, CM, T, T', QS)
                     tree(T' :ls Ty', 1 + getOffspring*(F F'), F F')
   if RP := metaReduce(OM, T) /\
      T' := getTerm(RP) /\
      Ty' := getType(RP) /\
      not sortLeq(OM, Ty', Ty) /\
      ST? := strat?(OM) /\
      F := createForest(OM, TM, CM, T', Ty', QS) /\
      F' := buildConditionForestMbs(OM, TM, CM, T', QS) .

  ceq createForestOnceSubstituted(OM, TM, CM, QS, T : Ty) = F
   if RP := metaReduce(OM, T) /\
      T' := getTerm(RP) /\
      Ty' := getType(RP) /\
      sortLeq(OM, Ty', Ty) /\
      ST? := strat?(OM) /\
      F := createForest(OM, TM, CM, T, T', QS, ST?)
           createForest(OM, TM, CM, T', Ty', QS) .

***(%
\end{verbatim}
}

The function \verb"buildConditionForestMbs"

{\codesize
\begin{verbatim}
%)

  op buildConditionForestMbs : Module Module Maybe{Module} Term QidSet -> Forest .
  eq buildConditionForestMbs(OM, TM, CM, T, QS) =
                buildConditionForestMbs*(OM, TM, CM, T, QS, getMbs(OM)) .

***(%
\end{verbatim}
}

\noindent where \texttt{buildConditionForestMbs*} traverses the set of membership
axioms, applying \verb"buildConditionForestMbs" to each of them:

{\codesize
\begin{verbatim}
%)

  op buildConditionForestMbs* : Module Module Maybe{Module} Term QidSet MembAxSet
                                -> Forest .
  eq buildConditionForestMbs*(OM, TM, CM, T, QS, none) = mtForest .
  eq buildConditionForestMbs*(OM, TM, CM, T, QS, Mb MAS) =
           buildConditionForestMbs(OM, TM, CM, T, QS, Mb)
           buildConditionForestMbs*(OM, TM, CM, T, QS, MAS) .

  op buildConditionForestMbs : Module Module Maybe{Module} Term QidSet MembAx
                               -> Forest .
  ceq buildConditionForestMbs(OM, TM, CM, T, QS, Mb) = mtForest
   if Ty := getType(metaReduce(OM, T)) /\
      not match?(OM, T, Mb) or-else not sortLeq(OM, sort(Mb), Ty) .

***(%
\end{verbatim}
}

\noindent where \verb"sort" returns the type indicated in the membership:

{\codesize
\begin{verbatim}
%)

  op sort : MembAx -> Type .
  eq sort(mb T1 : Ty [AtS] .) = Ty .
  eq sort(cmb T1 : Ty if C [AtS] .) = Ty .

  ceq buildConditionForestMbs(OM, TM, CM, T, QS, mb T1 : Ty [AtS] .) =
              F sort-match(OM, TM, CM, QS, T1, T)
   if SSB := allSubs(OM, T, T1 := T, 0, mtSSB) /\
      < F, TL > := applySubs(OM, TM, CM, QS, T1, SSB) [owise] .

  op proveNormal : Module Module Maybe{Module} Term QidSet -> Forest .
  ceq proveNormal(OM, TM, CM, T, QS) = mtForest
   if normalForm?(OM, T) .
  ceq proveNormal(OM, TM, CM, Q[TL], QS) = tree(normal(Q[TL]), N, F F')
   if not normalForm?(OM, Q[TL]) /\
      F := buildConditionForestEqs(OM, TM, CM, Q[TL], QS) /\
      F' := proveNormalSubterms(OM, TM, CM, TL, QS) /\
      N := 1 + getOffspring*(F F') .
  ceq proveNormal(OM, TM, CM, T, QS) = tree(normal(T), N, F)
   if F := buildConditionForestEqs(OM, TM, CM, T, QS) /\
      N := 1 + getOffspring*(F) [owise] .

  op proveNormalSubterms : Module Module Maybe{Module} TermList QidSet -> Forest .
  eq proveNormalSubterms(OM, TM, CM, empty, QS) = mtForest .
  eq proveNormalSubterms(OM, TM, CM, (T, TL), QS) = proveNormal(OM, TM, CM, T, QS)
                                                    proveNormalSubterms(OM, TM, CM, TL, QS) .

  op createMissingTreeMb : Module Maybe{Module} Term Type QidSet -> Tree .
  ceq createMissingTreeMb(M, CM, T, Ty, QS) = tree(T' :ls Ty, N, F1)
   if TM := deleteSuspicious(M, QS) /\
      RP := metaReduce(M, T) /\
      T' := getTerm(RP) /\
      F := createForest(M, TM, CM, T, T', QS, strat?(M)) /\
      F' := createForest(M, TM, CM, T', Ty, QS) /\
      F'' := buildConditionForestMbs(M, TM, CM, T', QS) /\
      F1 := cleanTree*(M, false, none, F F' F'') /\
      N := getOffspring*(F1) + 1 .

***(%
\end{verbatim}
}

The auxiliary function \verb"kindTerm" transforms a term by substituting its
variables with variables with the same name but declared at the kind level.
It uses the auxiliary function \verb"kindTerm*" to traverse a list of term
and apply \verb"kindTerm" to each of them:

{\codesize
\begin{verbatim}
%)

  op kindTerm : Module Term -> Term .
  eq kindTerm(M, Q[TL]) = Q[kindTerm*(M, TL)] .
  eq kindTerm(M, Const) = Const .
  ceq kindTerm(M, V) = qid(string(Q) + ":" + string(Ty'))
   if Q := getName(V) /\
      Ty := getType(V) /\
      Ty' := getKind(M, Ty) .

  op kindTerm* : Module TermList -> TermList .
  eq kindTerm*(M, empty) = empty .
  eq kindTerm*(M, (T, TL)) = kindTerm(M, T), kindTerm*(M, TL) .

***(%
\end{verbatim}
}

The function \verb"sort-match" computes the forest proving or disproving that
the matching at the kind level is correct when it is used at the sort level.
Sinve we check all the possible matching, we use an auxiliary function
\verb"sort-match2" with an extra argument that indicates the number of matching
to be used:

{\codesize
\begin{verbatim}
%)

  op sort-match : Module Module Maybe{Module} QidSet Term Term -> Forest .
  eq sort-match(OM, TM, CM, QS, T, T') =
                         sort-match2(OM, TM, CM, QS, kindTerm(OM, T), T, T', 0) .

***(%
\end{verbatim}
}

This \verb"sort-match2" function computes all the possible substitutions
with the predefined function \verb"metaMatch" and then uses \verb"sort-match3"
to generate the forest corresponding to each of these substitutions:

{\codesize
\begin{verbatim}
%)

  op sort-match2 : Module Module Maybe{Module} QidSet Term Term Term Nat
                   -> Forest .
  ceq sort-match2(OM, TM, CM, QS, KT, T, T', N) =
                          sort-match3(OM, TM, CM, QS, T, SB, mtForest)
                          sort-match2(OM, TM, CM, QS, KT, T, T', s(N))
   if sameKind(OM, type(OM, KT), type(OM, T')) /\
      SB := metaMatch(OM, KT, T', nil, N) .
  eq sort-match2(OM, TM, CM, QS, KT, T, T', N) = mtForest [owise] .

***(%
\end{verbatim}
}

\verb"sort-match3"

{\codesize
\begin{verbatim}
%)

  op sort-match3 : Module Module Maybe{Module} QidSet Term Substitution
                   Forest -> Forest .
  eq sort-match3(OM, TM, CM, QS, T, none, F) = F .
  ceq sort-match3(OM, TM, CM, QS, T, V <- T' ; SB, AF) =
               createForest(OM, TM, CM, T', T'', QS, strat?(OM))
               if isKind?(Ty)
               then sort-match3(OM, TM, CM, QS, T, SB, AF)
               else if sortLeq(OM, Ty', Ty)
                    then sort-match3(OM, TM, CM, QS, T, SB, AF F)
                    else tree(T'' :ls Ty', 1 + getOffspring*(F F'), F F')
                    fi
               fi
   if Ty := getSort(T, V) /\
      Ty' := type(OM, T') /\
      T'' := reduce(OM, T') /\
      F := if isKind?(Ty)
           then mtForest
           else createForest(OM, TM, CM, T'', Ty', QS)
           fi /\
      F' := if not isKind?(Ty) and-then not sortLeq(OM, Ty', Ty)
            then buildConditionForestMbs(OM, TM, CM, T'', QS)
            else mtForest
            fi .

***(%
\end{verbatim}
}

\noindent where \verb"getSort" extracts the type of the variable
in a term, returning \verb"typeError" if the term does not contain
the variable. It uses the auxiliary function \verb"getSort*"to traverse
term lists:

{\codesize
\begin{verbatim}
%)

  op getSort : Term Variable -> Maybe{Type} .
  eq getSort(Q[TL], V) = getSort*(TL, V) .
  eq getSort(Const, V) = typeError .
  eq getSort(V, V') = if getName(V) == getName(V')
                      then getType(V)
                      else typeError
                      fi .

  op getSort* : TermList Variable -> Maybe{Type} .
  eq getSort*(empty, V) = typeError .
  eq getSort*((T, TL), V) = if getSort(T, V) =/= typeError
                            then getSort(T, V)
                            else getSort*(TL, V)
                            fi .

***(%
\end{verbatim}
}

\noindent and \verb"isKind?" checks whether a type is a kind:

{\codesize
\begin{verbatim}
%)

  op isKind? : Type -> Bool .
  eq isKind?(K) = true .
  eq isKind?(Ty) = false [owise] .

***(%
\end{verbatim}
}

\noindent where \texttt{match?} uses the predefined function \texttt{metaMatch} to check
if the terms match:

{\codesize
\begin{verbatim}
%)

  op match? : Module Term MembAx -> Bool .
  ceq match?(M, T, mb T1 : Ty [AtS] .) = metaMatch(M, T', T, nil, 0) :: Substitution
   if T' := kindTerm(M, T1) /\
      sameKind(M, type(M, T), type(M, T')) .
  ceq match?(M, T, cmb T1 : Ty if C [AtS] .) = metaMatch(M, T', T, nil, 0) :: Substitution
   if T' := kindTerm(M, T1) /\
      sameKind(M, type(M, T), type(M, T')) .
  eq match?(M, T, Mb) = false [owise] .

  ceq buildConditionForestMbs(OM, TM, CM, T, QS, cmb T1 : Ty if C [AtS] .) =
       F' sort-match(OM, TM, CM, QS, T1, T)
   if SSB := allSubs(OM, T, T1 := T, 0, mtSSB) /\
      < F, TL > := buildConditionForestMissingAux(OM, TM, CM, QS, T, T1,
                                  T1 := T /\ C, SSB, 2, getNumConds(C) + 1) /\
      F' := createForest(OM, TM, CM, T, getTerm(metaReduce(OM, T)), QS, false) F [owise] .

***(%
\end{verbatim}
}

\end{comment}
%TR

The debugging tree for incomplete sets of reachable terms
is built with the function
\texttt{createMissingTree}, that receives the module where the
terms should be found, a correct module (possibly \texttt{undefMod}),
the initial term, the pattern, the
condition to be fulfilled, the bound in the number of rewrites for \emph{wrong}
rewrites, the number of steps that can be given in the search,
the search type, the type of tree to be built (one-step or many-steps)
for both wrong and missing answers, the set of suspicious labels,
the set of final sorts, a Boolean value indicating whether the search
introduced by the user was unbounded, and a Boolean value pointing out whether
the questions about solutions are prioritized.
The forest is generated with an auxiliary function \texttt{createMissingForest}
that receives, in addition to the values above, a Boolean value indicating whether
the forest currently built corresponds to the initial search or
to a search due to a rewrite condition, being its value in the first case \texttt{true}.
Once the tree has been built, the questions associated with terms that the user has
declared as final are pruned with \texttt{cleanTree*}:

{\codesize
\begin{verbatim}
%)

  op createMissingTree : Module Maybe{Module} Term Term Condition Bound Bound SearchType
                         TreeType TreeType QidSet Bool QidSet Bool Bool -> Tree .

  ceq createMissingTree(M, CM, T, PAT, C, BW, BM, ST, TTW, TTM, QS, BFS, FS, UB?, SP) =
        contract(tree(T ~>[B'] {clean(extractTerms(F))} s.t. PAT & C [true],
                                           1 + getOffspring*(F), F))
   if TM := deleteSuspicious(M, QS) /\
      T' := getTerm(metaReduce(M, T)) /\
      F := cleanTree*(M, BFS, FS, createForest(M, TM, CM, T, T', QS, strat?(M))
                           contract*(createMissingForest(labeling(M), TM, CM, T', PAT,
                                     C, BW, BM, ST, TTW, TTM, QS, FS, UB?, SP, true))) /\
      B' := if UB? then unbounded else BM fi .

***(%
\end{verbatim}
}

If the tree to be built cannot evolve (the bound is \texttt{0}) and zero or more
steps can be used, then we use the function \texttt{solutionTree} to create a
tree that proves whether the condition is satisfied or not:

{\codesize
\begin{verbatim}
%)

  op createMissingForest : Module Module Maybe{Module} Term Term Condition Bound Bound SearchType
                           TreeType TreeType QidSet QidSet Bool Bool Bool -> Forest .
  eq createMissingForest(OM, TM, CM, T, PAT, C, BW, 0, zeroOrMore, TTW, TTM, QS,
                         FS, UB?, SP, FST) =
         solutionTree(OM, TM, CM, T, PAT, C, BW, zeroOrMore, TTW, TTM, QS, FS, SP, FST) .

***(%
\end{verbatim}
}

\texttt{solutionTree} uses the function \texttt{solveCondition} to
decide whether the current term fulfills the condition, and then
examines whether the questions about solutions are prioritized.
If they are prioritized the tree is built on demand and only the node
referring to the fulfillment of the condition is generated. If the solutions are
not prioritized, the function distinguishes whether the condition is fulfilled or not.
In the first case, it uses the function \texttt{conditionForest}, already defined
for wrong answers, to create a forest for the satisfaction of the condition;
in the other case, the forest is computed with the function
\texttt{buildConditionForestMissingAux}, that proves that the condition cannot be
fulfilled:

{\codesize
\begin{verbatim}
%)

  op solutionTree : Module Module Maybe{Module} Term Term Condition Bound SearchType
                    TreeType TreeType QidSet QidSet Bool Bool -> Tree .
  ceq solutionTree(OM, TM, CM, T, PAT, C, BW, ST, TTW, TTM, QS, FS, SP, FST) =
       tree(sol(T, PAT, C, SC, not SP, FST), getOffspring*(F) + 1, F)
   if SC := solveCondition(OM, T, PAT, C) /\
      F := if SP
           then mtForest
           else if SC
                then conditionForest(substituteDD(OM, C, metaMatch(OM, PAT, T, C, 0)),
                                                OM, TM, CM, QS, BW, TTW)
                else createMissingForest(OM, TM, CM, T, reduce(OM, T), QS)
                     sort-match(OM, TM, CM, QS, PAT, T)
                     first(buildConditionForestMissingAux(OM, TM, CM, QS, FS, T, T, BW,
                             ST, TTW, TTM, SP, PAT := T /\ C, strat?(OM),
                             allSubs(OM, T, PAT := T, 0, mtSSB), 2, getNumConds(C) + 1))
                fi
           fi .


***(%
\end{verbatim}
}

The function \texttt{solveCondition} receives the module where the search
takes place, the term to be checked, the pattern, and the condition, and
checks whether the term is a solution by using the predefined function
\texttt{metaMatch}, that examines if two terms match while fulfilling a
given condition:

{\codesize
\begin{verbatim}
%)

  op solveCondition : Module Term Term Condition -> Bool .
  ceq solveCondition(M, T, PAT, C) = metaMatch(M, PAT, T, C, 0) =/= noMatch
   if sameKind(M, type(M, T), type(M, PAT)).
  eq solveCondition(M, T, PAT, C) = false [owise] .

***(%
\end{verbatim}
}

When the terms can still evolve (the bound is greater than \texttt{0}), we compute all
the possible reachable terms in exactly one step with the function
\texttt{oneStepMissingTree} and evolve each of them with \texttt{createMissingForest*}.
The solutions obtained are gathered with \texttt{extractTerms}, while
we check whether the current term is a valid solution with the function \texttt{solveCondition}.
Finally, if the tree selected by the user is for many-steps transitions we put a root
to the generated forest specifying the number of steps, while if we want one-step
transitions only the forest is returned:

{\codesize
\begin{verbatim}
%)

  ceq createMissingForest(OM, TM, CM, T, PAT, C, BW, s(N'), zeroOrMore, TTW, TTM,
                          QS, FS, UB?, SP, FST) =
              if TTM == os
              then RF
              else tree(T ~>[B'] {TL''} s.t. PAT & C [FST], 1 + getOffspring*(RF), RF)
              fi
   if tree(T =>1 {TL}, N, F) := oneStepMissingTree(OM, TM, CM, T, QS, FS, BW, zeroOrMore,
                                                   TTW, TTM, SP) /\
      F' := createMissingForest*(OM, TM, CM, TL, PAT, C, BW, N', zeroOrMore,
                                       TTW, TTM, QS, FS, UB?, SP, FST) /\
      TL' := if solveCondition(OM, T, PAT, C)
             then T
             else empty
             fi /\
      TL'' := clean((extractTerms(F'), TL')) /\
      CF := solutionTree(OM, TM, CM, T, PAT, C, BW, zeroOrMore, TTW, TTM, QS, FS, SP, FST) /\
      RF := CF tree(T =>1 {TL}, N, F) F' /\
      B' := if UB? then unbounded else s(N') fi .

***(%
\end{verbatim}
}

If the terms can evolve at least one step and the search type is \texttt{oneOrMore},
we use the method \texttt{oneStepMissingTree} to evolve the terms, and then we compute
the possible results from them for zero or more steps:

{\codesize
\begin{verbatim}
%)

  ceq createMissingForest(OM, TM, CM, T, PAT, C, BW, s(N'), oneOrMore, TTW, TTM,
                          QS, FS, UB?, SP, FST) =
               tree(T ~>[B'] {TL'} s.t. PAT & C [FST], 1 + getOffspring*(RF), RF)
   if tree(T =>1 {TL}, N, F) := oneStepMissingTree(OM, TM, CM, T, QS, FS, BW,
                                                   oneOrMore, TTW, TTM, SP) /\
      F' := createMissingForest*(OM, TM, CM, TL, PAT, C, BW, N', zeroOrMore,
                                       TTW, TTM, QS, FS, UB?, SP, FST) /\
      RF := tree(T =>1 {TL}, N, F) F' /\
      B' := if UB? then unbounded else s(N') fi /\
      TL' := clean(extractTerms(F')) .

***(%
\end{verbatim}
}

If the bound in this kind of search is \texttt{0} no solutions can be obtained and the
empty forest is returned:

{\codesize
\begin{verbatim}
%)

  eq createMissingForest(OM, TM, CM, T, PAT, C, BW, 0, oneOrMore, TTW, TTM,
                          QS, FS, UB?, SP, FST) = mtForest .

***(%
\end{verbatim}
}

When a final result is reached (the application of \texttt{oneStepMissingTree}
to the term computes the empty set of terms) in a \texttt{final} search, we use
\texttt{solutionTree} to build the appropriate tree:

{\codesize
\begin{verbatim}
%)

  ceq createMissingForest(OM, TM, CM, T, PAT, C, BW, BM, final, TTW, TTM, QS,
                          FS, UB?, SP, FST) =
          solutionTree(OM, TM, CM, T, PAT, C, BW, final, TTW, TTM, QS, FS, SP, FST)
          tree(T =>1 {empty}, N, F)
   if tree(T =>1 {empty}, N, F) := oneStepMissingTree(OM, TM, CM, T, QS, FS, BW,
                                                      final, TTW,  TTM, SP) .

***(%
\end{verbatim}
}

If the term can evolve (i.e., there are reachable terms in one step) but the number
of available rewrites reaches \texttt{0} only the tree with the one-step inference
is returned:

{\codesize
\begin{verbatim}
%)

  ceq createMissingForest(OM, TM, CM, T, PAT, C, BW, 0, final, TTW, TTM, QS, FS,
                          UB?, SP, FST) =
          tree(T =>1 {TL}, N, F)
   if tree(T =>1 {TL}, N, F) := oneStepMissingTree(OM, TM, CM, T, QS, FS, BW,
                                                   final, TTW, TTM, SP) /\
      TL =/= empty .

***(%
\end{verbatim}
}

If the bound is greater than \texttt{0} and the set of reachable terms in one step
is not empty, we continue the search with the terms in this set and the bound decreased
in one step:

{\codesize
\begin{verbatim}
%)

  ceq createMissingForest(OM, TM, CM, T, PAT, C, BW, s(N'), final, TTW, TTM,
                          QS, FS, UB?, SP, FST) =
        if TTM == os
        then RF
        else tree(T ~>[B'] {TL'} s.t. PAT & C [FST], 1 + getOffspring*(RF), RF)
        fi
   if tree(T =>1 {TL}, N, F) := oneStepMissingTree(OM, TM, CM, T, QS, FS, BW,
                                                   final, TTW, TTM, SP) /\
      TL =/= empty /\
      F' := createMissingForest*(OM, TM, CM, TL, PAT, C, BW, N', final,
                                       TTW, TTM, QS, FS, UB?, SP, FST) /\
      RF := tree(T =>1 {TL}, N, F) F' /\
      B' := if UB? then unbounded else s(N') fi /\
      TL' := clean(extractTerms(F')) .

***(%
\end{verbatim}
}

Given a list of terms, the function \texttt{createMissingForest*} computes the forest obtained
by evolving each of them:

{\codesize
\begin{verbatim}
%)

  op createMissingForest* : Module Module Maybe{Module} TermList Term Condition Bound Bound
                            SearchType TreeType TreeType QidSet QidSet Bool Bool Bool
                            -> Forest .
  eq createMissingForest*(OM, TM, CM, empty, PAT, C, BW, BM, ST, TTW, TTM, QS,
                          FS, UB?, SP, FST) = mtForest .
  eq createMissingForest*(OM, TM, CM, (T, TL), PAT, C, BW, BM, ST, TTW, TTM, QS, FS,
                          UB?, SP, FST) =
      createMissingForest(OM, TM, CM, T, PAT, C, BW, BM, ST, TTW, TTM, QS, FS, UB?, SP, FST)
      createMissingForest*(OM, TM, CM, TL, PAT, C, BW, BM, ST, TTW, TTM, QS, FS, UB?, SP, FST) .

***(%
\end{verbatim}
}

We use the function \texttt{oneStepMissingTree} to obtain all the possible results
obtained from a term with exactly one step. To do it, we first compute all the
results reached by rewriting the term one step at top with \texttt{oneStepTop}, and
then the subterms of the original term are rewritten one step with
\texttt{oneStepCongruence}.
The function \texttt{combineSubterms} is in charge of substituting the arguments in
the initial term with these new subterms:

{\codesize
\begin{verbatim}
%)

  op oneStepMissingTree : Module Module Maybe{Module} Term QidSet QidSet Bound SearchType
                          TreeType TreeType Bool -> Tree .
  ceq oneStepMissingTree(OM, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP) =
               tree(T =>1 {clean((TL, TL', TL1))}, 1 + getOffspring*(F F' F1), F F' F1)
   if tree(T =>1 {TL}, N, F) := oneStepTop(OM, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP) /\
      F' := oneStepCongruence(OM, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP) /\
      TL' := combineSubterms(OM, T, F') /\
      < TL1, F1 > := oneStepTopAC(OM, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP) .

***(%
\end{verbatim}
}

\texttt{oneStepTop} uses an auxiliary function \texttt{buildConditionForestMissing*}
that traverses all the rules and returns all their possible applications:

{\codesize
\begin{verbatim}
%)

  op oneStepTop : Module Module Maybe{Module} Term QidSet QidSet Bound SearchType
                  TreeType TreeType Bool -> Forest .
  ceq oneStepTop(OM, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP) =
                             tree(T =>1 {TL}, 1 + getOffspring*(F), F)
   if < F, TL > := buildConditionForestMissing*(OM, TM, CM, QS, FS, T, BW, ST, TTW, TTM, SP,
                                    getRls(OM), strat?(OM)) .

***(%
\end{verbatim}
}

\texttt{buildConditionForestMissing*} returns a pair with the generated forest and
the computed terms. When the set of rules to be checked is \texttt{none}, it returns
a pair with the empty forest and the empty term list:

{\codesize
\begin{verbatim}
%)

  op buildConditionForestMissing* : Module Module Maybe{Module} QidSet QidSet Term Bound
                                    SearchType TreeType TreeType Bool RuleSet Bool
                                    -> Pair{Forest, TermList} .

  eq buildConditionForestMissing*(M, TM, CM, QS, FS, T, BW, ST, TTW, TTM, SP, none, ST?) =
                         < mtForest, empty > .

***(%
\end{verbatim}
}

When at least one rule can be used, the function computes the reachable terms
by using the function \texttt{buildConditionForestMissing}, while the rest
of the rules are recursively traversed:

{\codesize
\begin{verbatim}
%)

  ceq buildConditionForestMissing*(M, TM, CM, QS, FS, T, BW, ST, TTW, TTM, SP, R RS, ST?) =
                         < F F', (TL, TL') >
   if < F, TL > := buildConditionForestMissing(M, TM, CM, QS, FS, T, BW, ST, TTW, TTM,
                                               SP, R, ST?) /\
      < F', TL' > := buildConditionForestMissing*(M, TM, CM, QS, FS, T, BW, ST,
                                                  TTW, TTM, SP, RS, ST?) .

***(%
\end{verbatim}
}

The function \texttt{buildConditionForestMissing} first checks whether the lefthand side
of the rule matches the current term. If this matching fails (checked with the
function \verb"match?"), the set of reachable
terms is \texttt{empty} and only the forest to compute the normal form of the current
term is generated:

{\codesize
\begin{verbatim}
%)

  op buildConditionForestMissing : Module Module Maybe{Module} QidSet QidSet Term Bound
                                   SearchType TreeType TreeType Bool Rule Bool
                                   -> Pair{Forest, TermList} .
  ceq buildConditionForestMissing(M, TM, CM, QS, FS, T, BW, ST, TTW, TTM, SP,
                                  R, ST?) = < F, empty >
   if not match?(M, T, R) /\
      F := createForest(M, TM, CM, T, getTerm(metaReduce(M, T)), QS, ST?) .

***(%
\end{verbatim}
}

\noindent where \texttt{match?} uses the predefined function \texttt{metaMatch} to check
whether the terms match:

{\codesize
\begin{verbatim}
%)

  op match? : Module Term Rule -> Bool .
  ceq match?(M, T, rl T1 => T2 [AtS] .) = metaMatch(M, T', T, nil, 0) :: Substitution
   if T' := kindTerm(M, T1) /\
      sameKind(M, type(M, T), type(M, T')) .
  ceq match?(M, T, crl T1 => T2 if C [AtS] .) = metaMatch(M, T', T, nil, 0) :: Substitution
   if T' := kindTerm(M, T1) /\
      sameKind(M, type(M, T), type(M, T')) .
  eq match?(M, T, R) = false [owise] .

***(%
\end{verbatim}
}

If the terms match in an unconditional rule, the function computes all the
substitutions obtained from the matching of the current term with the lefthand side
of the rule with the function \texttt{allSubs}, and uses them to instantiate the
righthand side with \texttt{applySubs}, that applies the substitutions and
computes the normal form of the obtained terms. Note that if the rule currently
applied has been trusted only the nodes corresponding to the reduction to normal
form are kept, while if the rule is suspicious a node with all the reachable terms
is created:

{\codesize
\begin{verbatim}
%)

  ceq buildConditionForestMissing(M, TM, CM, QS, FS, T, BW, ST, TTW, TTM, SP,
                                  rl T1 => T2 [AtS] ., ST?) = < F', TL >
   if SSB := allSubs(M, T, T1 := T, 0, mtSSB) /\
      < F, TL > := applySubs(M, TM, CM, QS, T2, SSB) /\
      F' := if trusted?(AtS, QS)
            then F
            else tree(T =>q[label(AtS)] {TL}, 1 + getOffspring*(F), F)
            fi [owise] .

***(%
\end{verbatim}
}

\noindent where \texttt{trusted} checks whether the rule is trusted, that is,
it is not labeled or it has a label that is not included in the set of
suspicious ones:

{\codesize
\begin{verbatim}
%)

  op trusted? : AttrSet QidSet -> Bool .
  eq trusted?(label(Q) AtS, Q ; QS) = false .
  eq trusted?(AtS, QS) = true [owise] .

***(%
\end{verbatim}
}

\noindent \texttt{allSubs} uses the predefined function \texttt{metaMatch}
to obtain all the possible substitutions:

{\codesize
\begin{verbatim}
%)

  op allSubs : Module Term Condition Nat Set{Substitution} -> Set{Substitution} .
  ceq allSubs(M, T, C, N, SSB) = allSubs(M, T, C, s(N), SB . SSB)
   if SB := metaMatch(M, T, T, C, N) .
  eq allSubs(M, T, C, N, SSB) = SSB [owise] .

***(%
\end{verbatim}
}

\noindent and \texttt{applySubs} uses the auxiliary function \texttt{substituteDD}
to instantiate the variables with their corresponding values, and then it uses
\texttt{createForest} to obtain the normal form of the instantiated terms:

{\codesize
\begin{verbatim}
%)

  op applySubs : Module Module Maybe{Module} QidSet Term Set{Substitution}
                 -> Pair{Forest, TermList} .
  eq applySubs(OM, TM, CM, QS, T, mtSSB) = < mtForest, empty > .
  ceq applySubs(OM, TM, CM, QS, T, SB . SSB) = < F' F, (T'', TL) >
   if < F, TL > := applySubs(OM, TM, CM, QS, T, SSB) /\
      T' := substituteDD(OM, T, SB) /\
      T'' := getTerm(metaReduce(OM, T')) /\
      F' := createForest(OM, TM, CM, T', T'', QS, strat?(OM)) .

***(%
\end{verbatim}
}

When a conditional rule is applied, we use the substitutions with its lefthand
side in the function \texttt{buildConditionForestMissingAux}, that uses
them to compute the substitutions that fulfill the condition and generate
all the terms obtained with each of them:

{\codesize
\begin{verbatim}
%)

  ceq buildConditionForestMissing(M, TM, CM, QS, FS, T, BW, ST, TTW, TTM, SP,
                                  crl T1 => T2 if C [AtS] ., ST?) =
       < F'', TL >
   if SSB := allSubs(M, T, T1 := T, 0, mtSSB) /\
      < F, TL > := buildConditionForestMissingAux(M, TM, CM, QS, FS, T, T2, BW, ST, TTW,
                                  TTM, SP, T1 := T /\ C, ST?, SSB, 2, getNumConds(C) + 1) /\
      F' := createForest(M, TM, CM, T, getTerm(metaReduce(M, T)), QS, ST?) F /\
      F'' := if trusted?(AtS, QS)
             then F'
             else tree(T =>q[label(AtS)] {TL}, 1 + getOffspring*(F'), F')
             fi [owise] .

***(%
\end{verbatim}
}

The function \texttt{buildConditionForestMissingAux} has as new parameters
the condition extended with the matching with the lefthand side of the rule,
the set of substitutions that satisfy the condition thus far,
and two natural numbers: the index of the atomic condition
currently evaluated and the size of the condition. Once the whole
condition has been analyzed we use the set of substitutions to instantiate
the righthand side of the rule:

{\codesize
\begin{verbatim}
%)

  op buildConditionForestMissingAux : Module Module Maybe{Module} QidSet QidSet Term Term
                                      Bound SearchType TreeType TreeType Bool Condition Bool
                                      Set{Substitution} Nat Nat -> Pair{Forest, TermList} .
  eq buildConditionForestMissingAux(M, TM, CM, QS, FS, T, T2, BW, ST, TTW, TTM, SP, C,
                                    ST?, SSB, s(N), N) =
                 applySubs(M, TM, CM, QS, T2, SSB) .

***(%
\end{verbatim}
}

If there are no substitutions that fulfill the current fragment of the condition
then it cannot be satisfied and the empty set of terms is obtained:

{\codesize
\begin{verbatim}
%)

  eq buildConditionForestMissingAux(M, TM, CM, QS, FS, T, T2, BW, ST, TTW, TTM, SP, C,
                                    ST?, mtSSB, N, N') = < mtForest, empty > .

***(%
\end{verbatim}
}

Otherwise, we apply the substitutions obtained thus far to the current
atomic condition and generate the corresponding forest with the function
\texttt{substituteAndCreateForest}. Then, the new set of substitutions
that satisfy the condition extended with the current atomic condition
(obtained with \texttt{getNFirst}) is computed with \texttt{allSubs}:

{\codesize
\begin{verbatim}
%)

  ceq buildConditionForestMissingAux(M, TM, CM, QS, FS, T, T2, BW, ST, TTW, TTM, SP, C,
                                     ST?, SSB, N, N') = < F F', TL' >
   if N <= N' /\
      C' := getNFirst(C, N) /\
      F := substituteAndCreateForest(M, TM, CM, QS, FS, BW, ST, TTW, TTM, SP,
                                     ST?, getLast(C'), SSB) /\
      SSB' := allSubs(M, T, C', 0, mtSSB) /\
      < F', TL' > := buildConditionForestMissingAux(M, TM, CM, QS, FS, T, T2, BW, ST,
                                          TTW, TTM, SP, C, ST?, SSB', s(N), N') [owise] .

***(%
\end{verbatim}
}

The function \texttt{substituteAndCreateForest} traverses a set of substitutions
and generates the forest obtained by instantiating and solving the given condition
with each of them. When the list of substitutions is empty,
the empty forest is returned:

{\codesize
\begin{verbatim}
%)

  op substituteAndCreateForest : Module Module Maybe{Module} QidSet QidSet Bound SearchType
                                 TreeType TreeType Bool Bool Condition Set{Substitution}
                                 -> Forest .
  eq substituteAndCreateForest(M, TM, CM, QS, FS, BW, ST, TTW, TTM, SP, ST?, C, mtSSB) = mtForest .

***(%
\end{verbatim}
}

When at least one more substitution must be used the condition is instantiated with it
and the function \texttt{createForestOnceSubstituted} is in charge of computing the forest:

{\codesize
\begin{verbatim}
%)

  ceq substituteAndCreateForest(M, TM, CM, QS, FS, BW, ST, TTW, TTM, SP, ST?, C, SB . SSB) =
             F F'
   if F := createForestOnceSubstituted(M, TM, CM, QS, FS, BW, ST, TTW, TTM, SP,
                                               ST?, substituteDD(M, C, SB)) /\
      F' := substituteAndCreateForest(M, TM, CM, QS, FS, BW, ST, TTW, TTM, SP, ST?, C, SSB) .

***(%
\end{verbatim}
}

The auxiliary function \texttt{createForestOnceSubstituted} distinguishes between the
different kinds of atomic condition:

\begin{itemize}

\item In matching conditions only the forest for the reduction of the term in
the righthand side to its normal form is computed:

{\codesize
\begin{verbatim}
%)

  op createForestOnceSubstituted : Module Module Maybe{Module} QidSet QidSet Bound
                                   SearchType TreeType TreeType Bool Bool Condition
                                   -> Forest .
  eq createForestOnceSubstituted(M, TM, CM, QS, FS, BW, ST, TTW, TTM, SP, ST?, T := T') =
        createForest(M, TM, CM, T', getTerm(metaReduce(M, T')), QS, ST?)
        sort-match(M, TM, CM, QS, T, T') .

***(%
\end{verbatim}
}

\item When the atomic condition is an equality, the forest for the reduction to normal
form of both terms is generated:

{\codesize
\begin{verbatim}
%)

  ceq createForestOnceSubstituted(M, TM, CM, QS, FS, BW, ST, TTW, TTM, SP, ST?, T = T') =
          if T1 == T2 then
            createForest(M, TM, CM, T, getTerm(metaReduce(M, T)), QS, ST?)
            createForest(M, TM, CM, T', getTerm(metaReduce(M, T')), QS, ST?)
          else
            createMissingForest(M, TM, CM, T, T1, QS)
            createMissingForest(M, TM, CM, T', T2, QS)
          fi
   if T1 := getTerm(metaReduce(M, T)) /\
      T2 := getTerm(metaReduce(M, T')) .

***(%
\end{verbatim}
}

\item In membership conditions the forest for the reduction of the term to normal
form and for the inference of its least sort are always computed. If this least
sort does not fulfill the condition a new node stating that it is the least sort
is created; otherwise, only the initial forest is returned:

{\codesize
\begin{verbatim}
%)

  ceq createForestOnceSubstituted(M, TM, CM, QS, FS, BW, ST, TTW, TTM, SP, ST?, T : Ty) =
                     createMissingForest(M, TM, CM, T, T', QS) F
   if RP := metaReduce(M, T) /\
      T' := getTerm(RP) /\
      Ty' := getType(RP) /\
      sortLeq(M, Ty', Ty) /\
      F := createForest(M, TM, CM, T, T', QS, ST?)
           createForest(M, TM, CM, T', Ty', QS) .

  ceq createForestOnceSubstituted(M, TM, CM, QS, FS, BW, ST, TTW, TTM, SP, ST?, T : Ty) =
                     tree(T' :ls Ty', 1 + getOffspring*(F F'), F F')
   if RP := metaReduce(M, T) /\
      T' := getTerm(RP) /\
      Ty' := getType(RP) /\
      not sortLeq(M, Ty', Ty) /\
      F := createMissingForest(M, TM, CM, T, T', QS)
           createForest(M, TM, CM, T', Ty', QS) /\
      F' := buildConditionForestMbs(M, TM, CM, T', QS) .

***(%
\end{verbatim}
}

\item Finally, rewrite conditions generate a forest for missing answers with the pattern
of the condition, \texttt{nil} as condition, \texttt{zeroOrMore} steps as type of
search, and \texttt{false} as last argument, indicating that the current search
corresponds to a rewrite condition:

{\codesize
\begin{verbatim}
%)

  ceq createForestOnceSubstituted(OM, TM, CM, QS, FS, BW, ST, TTW, TTM, SP, ST?, T => T') =
            createForest(OM, TM, CM, T, T'', QS, ST?)
            createMissingForest(OM, TM, CM, T'', T', nil, BW, getBound(OM, T, T', nil, 0),
                                zeroOrMore, TTW, TTM, QS, FS, true, SP, false)
   if T'' := getTerm(metaReduce(OM, T)) .

***(%
\end{verbatim}
}

\end{itemize}

The function \texttt{oneStepCongruence} is in charge of rewriting the subterms of the
current term. It uses an auxiliary function \texttt{oneStepCongruence*} that traverses
the subterms taking into account the \texttt{frozen} attribute (obtained with the function
\texttt{getFrozen}), that prevents some arguments from being rewritten:

{\codesize
\begin{verbatim}
%)

  op oneStepCongruence : Module Module Maybe{Module} Term QidSet QidSet Bound SearchType
                         TreeType TreeType Bool -> Forest .

  ceq oneStepCongruence(OM, TM, CM, Q[TL], QS, FS, BW, ST, TTW, TTM, SP) = F
   if F := oneStepCongruence*(OM, TM, CM, TL, QS, FS, BW, ST, TTW, TTM, SP,
                              getFrozen(OM, getOps(OM), Q[TL]), 1) .
  eq oneStepCongruence(OM, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP) = mtForest [owise] .

***(%
\end{verbatim}
}

\begin{comment}

We define an auxiliary function \verb"oneStepCongruenceAC" to deal with associative and
commutative operators:

{\codesize
\begin{verbatim}
%)

  op oneStepTopAC : Module Module Maybe{Module} Term QidSet QidSet Bound SearchType
                    TreeType TreeType Bool -> Pair{TermList, Forest} .
  ceq oneStepTopAC(OM, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP) = < TL, F >
   if < TL, F > := allRewsACNotTop*(OM, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP, getRls(OM)) .

  op allRewsACNotTop* : Module Module Maybe{Module} Term QidSet QidSet Bound SearchType
                        TreeType TreeType Bool RuleSet -> Pair{TermList, Forest} .
  eq allRewsACNotTop*(M, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP, none) = < empty, mtForest > .
  ceq allRewsACNotTop*(M, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP, R RS) = < (TL, TL'), F F' >
   if < TL, F > := allRewsACNotTop(M, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP, R, 0) /\
      < TL', F' > := allRewsACNotTop*(M, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP, RS) .

  op allRewsACNotTop : Module Module Maybe{Module} Term QidSet QidSet Bound SearchType
                       TreeType TreeType Bool Rule Nat -> Pair{TermList, Forest} .
  ceq allRewsACNotTop(OM, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP, R, N) =
         < (TL', TL1), tree(T' =>1 {TL}, N', F) F1 >
   if LHS := getLefthand(R) /\
      { SB, CTXT } := metaXmatch(OM, LHS, T, getCondition(R), 0, 0, N) /\
      CTXT =/= [] /\
      T' := substituteDD(OM, LHS, SB) /\
      tree(T' =>1 {TL}, N', F) := oneStepTop(OM, TM, CM, T', QS, FS, BW, ST, TTW, TTM, SP) /\
      TL' := multipleReplaceCtxt(CTXT, TL) /\
      < TL1, F1 > := allRewsACNotTop(OM, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP, R, s(N)) .
  eq allRewsACNotTop(OM, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP, R, N) = < empty, mtForest > [owise] .

  op multipleReplaceCtxt : Context TermList -> TermList .
  eq multipleReplaceCtxt(CTXT, empty) = empty .
  eq multipleReplaceCtxt(CTXT, (T, TL)) = replaceCtxt(CTXT, T), multipleReplaceCtxt(CTXT, TL) .

  op replaceCtxt : Context Term -> Term .
  eq replaceCtxt([], T) = T .
  eq replaceCtxt(Q[GTL], T) = Q[replaceCtxt*(GTL, T)] .
  eq replaceCtxt(T, T') = T [owise] .

  op replaceCtxt* : GTermList Term -> TermList .
  eq replaceCtxt*(empty, T) = empty .
  eq replaceCtxt*((T, GTL), T') = T, replaceCtxt*(GTL, T') .
  eq replaceCtxt*((CTXT, TL), T) = replaceCtxt(CTXT, T), TL .

***(%
\end{verbatim}
}

\end{comment}

\texttt{oneStepCongruence*} iterates over a list of terms, applying
\texttt{oneStepMissingTree} to those that are not frozen:

{\codesize
\begin{verbatim}
%)

  op oneStepCongruence* : Module Module Maybe{Module} TermList QidSet QidSet Bound SearchType
                          TreeType TreeType Bool NatList Nat -> Forest .
  eq oneStepCongruence*(OM, TM, CM, (T, TL), QS, FS, BW, ST, TTW, TTM, SP, NL, N) =
                if in?(N, NL)
                then mtForest
                else oneStepMissingTree(OM, TM, CM, T, QS, FS, BW, ST, TTW, TTM, SP)
                fi
                oneStepCongruence*(OM, TM, CM, TL, QS, FS, BW, ST, TTW, TTM, SP, NL, s(N)) .
  eq oneStepCongruence*(OM, TM, CM, empty, QS, FS, BW, ST, TTW, TTM, SP, NL, N) = mtForest .

  op oneStepCongruenceTogether : Module Term QidSet -> TermList .

***(%
\end{verbatim}
}

The function \texttt{combineSubterms} replaces the subterms of a given term by the
terms obtained by rewriting one step each of them. It uses an auxiliary function
\texttt{combineSubtermsAux} with the list of arguments already
used and the list of arguments to be rewritten as new parameters:

{\codesize
\begin{verbatim}
%)

  op combineSubterms : Module Term Forest -> TermList .
  eq combineSubterms(M, Q[TL], F) = combineSubtermsAux(M, Q, F, empty, TL) .
  eq combineSubterms(M, T, F) = empty [owise] .

***(%
\end{verbatim}
}

The terms to be combined are traversed with the function \texttt{combineSubtermsAux},
that extracts the terms rewritten one step from the forest with the function
\texttt{getPossibleTerms} and then creates the new terms with \texttt{createNewTerms}.

{\codesize
\begin{verbatim}
%)

  op combineSubtermsAux : Module Qid Forest TermList TermList -> TermList .
  eq combineSubtermsAux(M, Q, F, TL, empty) = empty .
  ceq combineSubtermsAux(M, Q, F, TL, (T, TL')) = createNewTerms(M, Q, TL, TL', TL''),
                                                  combineSubtermsAux(M, Q, F, (TL, T), TL')
   if TL'' := getPossibleTerms(F, T) .

***(%
\end{verbatim}
}

\noindent where \texttt{createNewTerms} replaces the current subterm with each
reachable term from it until no more terms are availabe:

{\codesize
\begin{verbatim}
%)

  op createNewTerms : Module Qid TermList TermList TermList -> TermList .
  eq createNewTerms(M, Q, TL, TL', empty) = empty .
  eq createNewTerms(M, Q, TL, TL', (T, TL'')) = createNewTerms(M, Q, TL, TL', TL''),
                                                getTerm(metaReduce(M, Q[TL, T, TL'])) .

***(%
\end{verbatim}
}

\noindent and \texttt{getPossibleTerms} traverses a forest extracting the terms
obtained from the given term in one step:

{\codesize
\begin{verbatim}
%)

  op getPossibleTerms : Forest Term -> TermList .
  eq getPossibleTerms(mtForest, T) = empty .
  eq getPossibleTerms(tree(T =>1 {TL}, N, F) F', T) = TL .
  eq getPossibleTerms(A F, T) = getPossibleTerms(F, T) [owise] .


***(%
\end{verbatim}
}

Finally, we explain the auxiliary functions used in the module \verb"MISSING-ANSWERS-TREE":

\begin{itemize}

\begin{comment}

\item The function \texttt{clean} deletes the repeated occurrences from
a list of terms:

{\codesize
\begin{verbatim}
%)

  op clean : TermList -> TermList .
  eq clean((TL, T, TL', T, TL'')) = clean((TL, T, TL', TL'')) .
  eq clean(TL) = TL [owise] .

***(%
\end{verbatim}
}

\end{comment}

\item The function \texttt{extractTerms} obtains all the reachable terms from a
given forest:

{\codesize
\begin{verbatim}
%)

  op extractTerms : Forest -> TermList .
  eq extractTerms(mtForest) = empty .
  eq extractTerms(tree(T ~>[B] {TL} s.t. PAT & C [FST], N, F) F') = TL, extractTerms(F') .
  eq extractTerms(tree((sol(T, PAT, C, true, EXP, FST)), N, F) F') = T, extractTerms(F') .
  eq extractTerms(A F) = extractTerms(F) [owise] .

***(%
\end{verbatim}
}

\item The function \texttt{getBound} computes the number of rewrites needed to
obtain all the reachable terms from an initial term by using the predefined
\texttt{metaSearch} function until no more terms are found:

{\codesize
\begin{verbatim}
%)

  op getBound : Module Term Term Trace Nat -> Nat .
  ceq getBound(M, T, T', TR, N) = getBound(M, T, T', TR', s(N))
   if TR' := metaSearchPath(M, T, T', nil, '+, unbounded, N) .
  eq getBound(M, T, T', TR, N) = length(TR) + 1 [owise] .

***(%
\end{verbatim}
}

\noindent where \texttt{length} computes the size of a trace:

{\codesize
\begin{verbatim}
%)

  op length : Trace -> Nat .
  eq length(nil) = 0 .
  eq length(TRS TR) = s(length(TR)) .

***(%
\end{verbatim}
}

\item Given a condition, the function \texttt{getNFirst} extracts its first \texttt{N}
atomic conditions:

{\codesize
\begin{verbatim}
%)

  op getNFirst : Condition Nat -> Condition .
  eq getNFirst(T = T' /\ C, s(N)) = T = T' /\ getNFirst(C, N) .
  eq getNFirst(T := T' /\ C, s(N)) = T := T' /\ getNFirst(C, N) .
  eq getNFirst(T => T' /\ C, s(N)) = T => T' /\ getNFirst(C, N) .
  eq getNFirst(T : Ty  /\ C, s(N)) = T : Ty /\ getNFirst(C, N) .
  eq getNFirst(C, N) = nil [owise] .

***(%
\end{verbatim}
}

\noindent \texttt{getLast} returns the last atomic condition:

{\codesize
\begin{verbatim}
%)

  op getLast : Condition -> Condition .
  eq getLast(C /\ T = T') = T = T' .
  eq getLast(C /\ T := T') = T := T' .
  eq getLast(C /\ T => T') = T => T' .
  eq getLast(C /\ T : Ty) = T : Ty .
  eq getLast(nil) = nil .

***(%
\end{verbatim}
}

\noindent and \texttt{getNumConds} computes the number of atomic conditions:

{\codesize
\begin{verbatim}
%)

  op getNumConds : Condition -> Nat .
  eq getNumConds(nil) = 0 .
  eq getNumConds(T = T' /\ C) = s(getNumConds(C)) .
  eq getNumConds(T := T' /\ C) = s(getNumConds(C)) .
  eq getNumConds(T => T' /\ C) = s(getNumConds(C)) .
  eq getNumConds(T : Ty  /\ C) = s(getNumConds(C)) .

***(%
\end{verbatim}
}

\item The function \verb"cleanTree*" receives a Boolean value indicating whether
the final mode is active, the set of final sorts and a forest, and
traverses this forest applying \verb"cleanTree" to each tree:

{\codesize
\begin{verbatim}
%)

  op cleanTree* : Module Bool QidSet Forest -> Forest .
  eq cleanTree*(M, BFS, FS, mtForest) = mtForest .
  eq cleanTree*(M, BFS, FS, A F) = cleanTree(M, BFS, FS, A)
                                   cleanTree*(M, BFS, FS, F) [owise] .

***(%
\end{verbatim}
}

\item \verb"cleanTree" is in charge of pruning the tree. If the current node
corresponds to a final inference (i.e., the set of reachable terms in one step
is \texttt{empty}) it checks,  with the functions \texttt{final?} and
\texttt{finalSorts?} respectively, if it has been trusted with the attribute
\texttt{metadata} or its sort has been introduced as final. If the inference
has been trusted the whole subtree is removed; otherwise the function is
applied to the forest:

{\codesize
\begin{verbatim}
%)

  op cleanTree : Module Bool QidSet Tree -> Forest .
  ceq cleanTree(M, true, FS, tree(T =>1 {empty}, N, F)) =
       if final?(M, getOps(M), T) or-else finalSorts?(M, T, FS)
       then mtForest
       else tree(T =>1 {empty}, 1 + getOffspring*(F'), F')
       fi
   if F' := cleanTree*(M, true, FS, F) .

***(%
\end{verbatim}
}

This function also deletes the nodes related to inferences of solutions
of rewrite conditions, that only depend on the pattern matching:

{\codesize
\begin{verbatim}
%)

  eq cleanTree(M, BFS, FS, tree(sol(T, PAT, nil, SC, EXP, false), N, F)) =
                                                      cleanTree*(M, BFS, FS, F) .

***(%
\end{verbatim}
}

Otherwise the inference is kept and the function \texttt{cleanTree*} is
applied to the forest:

{\codesize
\begin{verbatim}
%)

  ceq cleanTree(M, BFS, FS, tree(J, N, F)) =
                                tree(J, 1 + getOffspring*(F'), F')
   if F' := cleanTree*(M, BFS, FS, F) [owise] .

***(%
\end{verbatim}
}

\item The function \verb"final?" checks whether the operator at the top of the given
term has the value \verb"final" in the \texttt{metadata} attribute, using
the auxiliary functions \verb"noIter" to obtain the operator without the
\texttt{iter} attribute and \texttt{createAssocTypeList} to create a list of
parameters without flattening due to the \texttt{assoc} attribute:

{\codesize
\begin{verbatim}
%)

  op final? : Module OpDeclSet Term -> Bool .
  ceq final?(M, op Q : nil -> Ty [AtS metadata("final")] . ODS, Ct) = true
   if Q == getName(Ct) .
  ceq final?(M, op Q : Ty -> Ty' [AtS metadata("final")] . ODS, Q'[T]) = true
   if Q[Q''[T]] := noIter(Q'[T]) /\
      checkTypes(T, Ty, M) .
  ceq final?(M, op Q : TyL -> Ty [AtS metadata("final")] . ODS, Q[TL]) = true
   if checkTypes(TL, createAssocTypeList(TyL, AtS, size(TL)), M) .
  eq final?(M, ODS, T) = false [owise] .

***(%
\end{verbatim}
}

\begin{comment}

\item The function \texttt{createAssocTypeList} replicates the type
if an associative operator has been flattened:

{\codesize
\begin{verbatim}
%)

  op createAssocTypeList : TypeList AttrSet Nat -> TypeList .
  eq createAssocTypeList(Ty TyL, assoc AtS, N) = put(Ty, N).
  eq createAssocTypeList(TyL, AtS, N) = TyL [owise] .

***(%
\end{verbatim}
}

\noindent where \texttt{put} prints the given sort the number of times
indicated by the argument:

{\codesize
\begin{verbatim}
%)

  op put : Type Nat -> TypeList .
  eq put(Ty, 0) = nil .
  eq put(Ty, s(N)) = Ty put(Ty, N) .

***(%
\end{verbatim}
}

\end{comment}

\item \texttt{finalSorts?} checks with the function \texttt{normalForm?}
whether the term is a constructed term and then it traverses the list of sorts checking
whether any of them is the sort of the current term with the function \texttt{finalSort?}:

{\codesize
\begin{verbatim}
%)

  op finalSorts? : Module Term QidSet -> Bool .
  ceq finalSorts?(M, T, QS) = false
   if not normalForm?(M, T) .
  eq finalSorts?(M, T, none) = false .
  eq finalSorts?(M, T, Q ; QS) = finalSort?(M, T, Q) or-else
                                 finalSorts?(M, T, QS) [owise] .

***(%
\end{verbatim}
}

\item \texttt{finalSort?} computes the least sort of the current term with
the predefined function \texttt{leastSort} and then computes that this sort
is less than or equal to the current one with \texttt{sortLeq}:

{\codesize
\begin{verbatim}
%)

  op finalSort? : Module Term Type -> Bool .
  ceq finalSort?(M, T, Ty) = true
   if Ty' := leastSort(M, T) /\
      sortLeq(M, Ty', Ty) .
  eq finalSort?(M, T, Ty) = false [owise] .

***(%
\end{verbatim}
}

\item We extract the list of frozen arguments with \texttt{getFrozen},
that takes into account the \texttt{iter} and \texttt{assoc} attributes:

{\codesize
\begin{verbatim}
%)

  op getFrozen : Module OpDeclSet Term -> NatList .
  ceq getFrozen(M, op Q : Ty -> Ty' [AtS frozen(NL)] . ODS, Q'[T]) = NL
   if Q[Q''[T]] := noIter(Q'[T]) /\
      checkTypes(T, Ty, M) .
  ceq getFrozen(M, op Q : TyL -> Ty [AtS frozen(NL)] . ODS, Q[TL]) = NL
   if checkTypes(TL, createAssocTypeList(TyL, AtS, size(TL)), M) .
  eq getFrozen(M, ODS, T) = nil [owise] .

***(%
\end{verbatim}
}

\item We use the function \texttt{pruneFinalSort} to prune the debugging tree
when a sort is considered final on the fly. It traverses the tree and uses
\texttt{finalSort?} to find the nodes that have to be deleted:

{\codesize
\begin{verbatim}
%)

  op pruneFinalSort : Module Type Tree -> Tree .
  ceq pruneFinalSort(M, Ty, tree(T =>1 {empty}, N, F)) =
       if finalSort?(M, T, Ty)
       then mtForest
       else tree(T =>1 {empty}, 1 + getOffspring*(F'), F')
       fi
   if F' := pruneFinalSort*(M, Ty, F) [owise] .
  ceq pruneFinalSort(M, Ty, tree(J, N, F)) =
          tree(J, 1 + getOffspring*(F'), F')
   if F' := pruneFinalSort*(M, Ty, F) [owise] .

***(%
\end{verbatim}
}

\item The function \texttt{pruneFinalSort*} traverses a forest applying
\texttt{pruneFinalSort} to each tree:

{\codesize
\begin{verbatim}
%)

  op pruneFinalSort* : Module Type Forest -> Forest .
  eq pruneFinalSort*(M, Ty, mtForest) = mtForest .
  eq pruneFinalSort*(M, Ty, A F) = pruneFinalSort(M, Ty, A)
                                   pruneFinalSort*(M, Ty, F) [owise] .
 endfm

***(%
\end{verbatim}
}

\end{itemize}

{\begin{verbatim}
%)

fmod ENHANCED-OTHERWISE is
  pr MISSING-ANSWERS-TREE .

  vars OM TM OM' : Module .
  var  CM : Maybe{Module} .
  var  Q : Qid .
  var  IL : ImportList .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  var  ODS : OpDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RS : RuleSet .
  vars T T' L R R' T1 T2 : Term .
  var  TL : TermList .
  vars Eq Eq' : Equation .
  var  QS : QidSet .
  var  C : Condition .
  var  AtS : AttrSet .
  vars F : Forest .
  var  SB : Substitution .
  var  SSB : Set{Substitution} .

***(%
\end{verbatim}
}

The improved version of the \texttt{applyEq} equation, that takes into account the
negative information required by the \texttt{otherwise} attribute, checks whether
the attribute set contains this attribute and then uses \texttt{buildConditionForestEqs}
to generate the proofs for the equations that cannot be applied:

{\begin{verbatim}
%)

  ceq applyEq(OM, TM, CM, T, T', QS, Eq EqS) =
             if in?(AtS, QS) then
             tree(label(AtS) : T -> T', getOffspring*(F) + 1, F)
             else F
             fi
   if ceq L = R if C [AtS] . := generalEq(Eq) /\
      owise?(AtS) /\
      sameKind(OM, typeTermWithVars(OM, L), type(OM, T)) /\
      SB := metaMatch(OM, L, T, C, 0) /\
      R' := substituteDD(OM, R, SB) /\
      F := buildConditionForestEqsAux(OM, TM, CM, T, QS, Eq)
           conditionForest(substituteDD(OM, C, SB), OM, TM, CM, QS)
           createForest(OM, TM, CM, R', T', QS) .

***(%
\end{verbatim}
}

The function \texttt{removeEq} removes an equation from an equation set.

{\begin{verbatim}
%)

  op removeEq : Equation EquationSet -> EquationSet .
  eq removeEq(Eq, Eq EqS) = EqS .
  eq removeEq(Eq, EqS) = EqS [owise] .

  op buildConditionForestEqsAux : Module Module Maybe{Module} Term QidSet Equation
                               -> Forest .
  ceq buildConditionForestEqsAux(OM, TM, CM, T, QS, Eq) =
                buildConditionForestEqs*(OM', TM, CM, T, QS, EqS)
   if OM' := removeEq(Eq, OM) /\
      EqS := removeEq(Eq, getEqs(OM)) .

***(
  op buildConditionForestEqsOwise* : Module Module Maybe{Module} Term QidSet EquationSet
                                -> Forest .
  eq buildConditionForestEqsOwise*(OM, TM, CM, T, QS, none) = mtForest .
  eq buildConditionForestEqsOwise*(OM, TM, CM, T, QS, Eq EqS) =
           buildConditionForestEqsOwise2(OM, TM, CM, T, QS, Eq)
           buildConditionForestEqsOwise*(OM, TM, CM, T, QS, EqS) .

  op buildConditionForestEqsOwise2 : Module Module Maybe{Module} Term QidSet Equation -> Forest .
  ceq buildConditionForestEqsOwise2(OM, TM, CM, T, QS, Eq) = F
   if not match?(OM, T, Eq) /\
      F := createForest(OM, TM, CM, T, getTerm(metaReduce(OM, T)), QS, strat?(OM)) .

  ceq buildConditionForestEqsOwise2(OM, TM, CM, T, QS, eq T1 = T2 [AtS] .) =
            F sort-match(OM, TM, CM, QS, T1, T)
   if match?(OM, T, eq T1 = T2 [AtS] .) /\
      SSB := allSubs(OM, T, T1 := T, 0, mtSSB) /\
      < F, TL > := applySubs(OM, TM, CM, QS, T2, SSB) .

  ceq buildConditionForestEqsOwise2(OM, TM, CM, T, QS, ceq T1 = T2 if C [AtS] .) =
            F sort-match(OM, TM, CM, QS, T1, T)
   if match?(OM, T, ceq T1 = T2 if C [AtS] .) /\
      SSB := allSubs(OM, T, T1 := T, 0, mtSSB) /\
      < F, TL > := buildConditionForestMissingAux(OM, TM, CM, QS, T, T2,
                                  T1 := T /\ C, SSB, 2, getNumConds(C) + 1) .
)

  op removeEq : Equation Module -> Module .
  eq removeEq(Eq, fmod Q is IL sorts SS . SSDS ODS MAS EqS endfm) =
          fmod Q is IL sorts SS . SSDS ODS MAS removeEq(Eq, EqS) endfm .
  eq removeEq(Eq, mod Q is IL sorts SS . SSDS ODS MAS EqS RS endm) =
          mod Q is IL sorts SS . SSDS ODS MAS removeEq(Eq, EqS) RS endm .
endfm

fmod UNIVERSAL-DD-TRANSFORMATIONS is
  pr SYSTEM-TREE-CONSTRUCTION .
  pr SEMANTICS-TYPE .
  pr SDD .

  var  J : Judgment .
  var  M : Module .
  var  MM : Maybe{Module} .
  vars T T' T1 T2 TR1 TR2 TR3 LHS : Term .
  var  CPR : Maybe{Term} .
  vars TL TL' : TermList .
  var  MT : Maybe{Term} .
  vars A L R R' : Tree .
  vars F F' F'' FR : Forest .
  vars N N' N'' NR : Nat .
  vars Q Q' TO QR : Qid .
  vars S S' : SDDInfoSet .
  var  C : Constant .
  var  V : Variable .
  vars QS QS' LS : QidSet .
  var  TT : TreeType .
  var  BND : Bound .
  var  AtS : AttrSet .
  var  RS : RuleSet .
  var  COND : Condition .
  var  SB : Substitution .

  op keep-intended : Module Tree SDDInfoSet -> Tree .
  ceq keep-intended(M, tree(J, N, F), S) = tree(toSemantics(J), N', F')
   if F' := traverseSDD*(M, F, S) /\
      N' := getOffspring*(F') + 1 .

  op traverseSDD : Module Tree SDDInfoSet -> Forest .
  ceq traverseSDD(M, tree(J, N, F), S) = tree(toSemantics(J), N', F')
   if intended?(J, S) /\
      F' := traverseSDD*(M, F, S) /\
      N' := getOffspring*(F') + 1 .
  eq traverseSDD(M, tree(J, N, F), S) = traverseSDD*(M, F, S) [owise] .

  op traverseSDD* : Module Forest SDDInfoSet -> Forest .
  eq traverseSDD*(M, A F, S) = traverseSDD(M, A, S) traverseSDD*(M, F, S) .
  eq traverseSDD*(M, mtForest, S) = mtForest .

  op intended? : Judgment SDDInfoSet -> Bool .
  eq intended?(Q : T =>1 T', sdd(Q', MT) S) = Q == Q' or-else
                                              intended?(Q : T =>1 T', S) .
  eq intended?(J, S) = false [owise] .

  op toSemantics : Judgment -> Judgment .
  eq toSemantics(Q : T1 =>1 T2) = semantics(Q, T1, T2) .
  eq toSemantics(J) = J [owise] .

  *** We assume that the tree only contains nodes with judgments of the
  *** form Q : T =>1 T'
  op reduceSubtermsBigStep : Module Tree -> Tree .
  ceq reduceSubtermsBigStep(M, tree(Q : Q'[TL, T] =>1 T2, N, F)) =
                                        tree(Q : Q'[TL, T'] =>1 T2, N', F')
   if T' := modifyTermWithForest(M, T, F) /\
      F' := reduceSubtermsBigStep*(M, F) /\
      N' := getOffspring*(F') + 1 .

  op reduceSubtermsBigStep* : Module Forest -> Forest .
  eq reduceSubtermsBigStep*(M, mtForest) = mtForest .
  eq reduceSubtermsBigStep*(M, A F) = reduceSubtermsBigStep(M, A)
                                      reduceSubtermsBigStep*(M, F) .

  op modifyTermWithForest : Module Term Forest -> Term .
  eq modifyTermWithForest(M, C, F) = traverseForestLooking4Reductions(M, C, F) .
  eq modifyTermWithForest(M, V, F) = traverseForestLooking4Reductions(M, V, F) .
  eq modifyTermWithForest(M, Q[TL], F) =
        if traverseForestLooking4Reductions(M, Q[TL], F) == Q[TL]
        then Q[modifyTermWithForest*(M, TL, F)]
        else traverseForestLooking4Reductions(M, Q[TL], F)
        fi .

  op modifyTermWithForest* : Module TermList Forest -> TermList .
  eq modifyTermWithForest*(M, empty, F) = empty .
  eq modifyTermWithForest*(M, (T, TL), F) = modifyTermWithForest(M, T, F),
                                            modifyTermWithForest*(M, TL, F) .

  op traverseForestLooking4Reductions : Module Term Forest -> Term .
  eq traverseForestLooking4Reductions(M, T, mtForest) = T .
  eq traverseForestLooking4Reductions(M, T, tree(Q : Q'[TL, T1] =>1 T2, N, F) F') =
        if T == T1
        then T2
        else traverseForestLooking4Reductions(M, T, F')
        fi .

***(%
\end{verbatim}
}

The function \texttt{look4subterm} receives a term and the subterm we are looking for,
and returns whether the subterm appears in the term or not.

{\begin{verbatim}
%)

  op look4subterm : Term Term -> Bool .
  eq look4subterm(T, T) = true .
  ceq look4subterm(Q[TL], T) = look4subterm*(TL, T)
   if Q[TL] =/= T .
  eq look4subterm(T, T') = false [owise] .

  op look4subterm* : TermList Term -> Bool .
  eq look4subterm*(empty, T) = false .
  eq look4subterm*((T, TL), T') = look4subterm(T, T') or-else look4subterm*(TL, T') .

  op smallStepTransformation : Module Tree SDDInfoSet QidSet -> Tree .
  ceq smallStepTransformation(M, tree(Q : T =>1 T', N, L R), S, QS) =
                                                tree(Q' : T =>1 T', N'', F' F'')
   if Q ; QS' := QS /\
      tree(Q' : T1 =>1 T2, N', F) := L /\
      sdd(Q', MT) S' := S /\
      F' := smallStepTransformation*(M, F, S, QS) /\
      F'' := smallStepTransformation(M, R, S, QS) /\
      N'' := getOffspring*(F' F'') + 1 .
  ceq smallStepTransformation(M, tree(Q : T =>1 T', N, F), S, QS) =
                                                tree(Q : T =>1 T', N', F')
   if sdd(Q, MT) S' := S /\
      F' := smallStepTransformation*(M, F, S, QS) /\
      N' := getOffspring*(F') + 1 .
  ceq smallStepTransformation(M, tree(J, N, F), S, QS) = F'
   if F' := smallStepTransformation*(M, F, S, QS) [owise] .

  op smallStepTransformation* : Module Forest SDDInfoSet QidSet -> Forest .
  eq smallStepTransformation*(M, mtForest, S, QS) = mtForest .
  eq smallStepTransformation*(M, A F, S, QS) = smallStepTransformation(M, A, S, QS)
                                               smallStepTransformation*(M, F, S, QS) .

  op sstrans : Module Maybe{Module} QidSet TreeType Bound Tree SDDInfoSet QidSet -> Tree .
  ceq sstrans(M, MM, LS, TT, BND, A, S, QS) = sstrans(M, MM, LS, TT, BND, TO, A, S, QS)
   if Q ; QS' := QS /\
      TO := getTopOperator(M, Q) .

  op sstrans : Module Maybe{Module} QidSet TreeType Bound Qid Tree SDDInfoSet QidSet
               -> Tree .
  ceq sstrans(M, MM, LS, TT, BND, TO, tree(Q : T =>1 T', N, L R), S, QS) =
                                                tree(semantics(Q', T, T', CPR), N'', F' F'')
   if Q ; QS' := QS /\
      tree(Q' : T1 =>1 T2, N', F) := L /\
      sdd(Q', MT) S' := S /\
      F' := sstrans*(M, MM, LS, TT, BND, TO, F, S, QS) /\
      F'' := sstrans(M, MM, LS, TT, BND, TO, R, S, QS) /\
      N'' := getOffspring*(F' F'') + 1 /\
      CPR := getCulprit(M, getLHS(getRule(M, Q')), T1, MT) .
  ceq sstrans(M, MM, LS, TT, BND, TO, tree(Q : T =>1 T', N, L R), S, QS) =
                                                tree(semantics(Q, T, T'), N', F')
   if sdd(Q, MT) S' := S /\
      F' := sstrans*(M, MM, LS, TT, BND, TO, L R, S, QS) /\
      N' := getOffspring*(F') + 1 .
  *** We have to make sure the application of the statement on top of this rule (but not
  *** directly on top) reaches its final form.
  ceq sstrans(M, MM, LS, TT, BND, TO, tree(Q : T =>1 T', N, L R), S, QS) = F F'
   if Q ; QS' := QS /\
      not mainRule?(L, S) /\
      [F, T1, T2] := completeReduction(M, MM, LS, TT, BND, TO, L, S, QS) /\
      tree(QR : TR1 =>1 TR2, NR, FR) := R /\
      TR3 := substitute(T1, T2, TR1) /\
      A := createRewTree(labeling(M), MM, TR3, TR2, LS, TT, BND) /\
      F' := sstrans(M, MM, LS, TT, BND, TO, A, S, QS) .
  *** If the root is not a transitivity
  ceq sstrans(M, MM, LS, TT, BND, TO, tree(J, N, F), S, QS) = F'
   if F' := sstrans*(M, MM, LS, TT, BND, TO, F, S, QS) [owise] .

  op getCulprit : Module Term Term Maybe{Term} -> Maybe{Term} .
  ceq getCulprit(M, LHS, T, T') = T2
   if (T' <- T2 ; SB) := metaMatch(M, LHS, T, nil, 0) .
  eq getCulprit(M, LHS, T, MT) = maybe [owise] .

  op getRule : Module Qid ~> Rule .
  eq getRule(M, Q) = getRule(getRls(M), Q) .

  op getRule : RuleSet Qid ~> Rule .
  eq getRule(rl T => T' [label(Q) AtS] . RS, Q) = rl T => T' [label(Q) AtS] . .
  eq getRule(crl T => T' if COND [label(Q) AtS] . RS, Q) = crl T => T' if COND [label(Q) AtS] . .

  op getLHS : Rule -> Term .
  eq getLHS(rl T => T' [AtS] .) = T .
  eq getLHS(crl T => T' if COND [AtS] .) = T .

  op sstrans* : Module Maybe{Module} QidSet TreeType Bound Qid Forest SDDInfoSet QidSet
                -> Forest .
  eq sstrans*(M, MM, LS, TT, BND, TO, mtForest, S, QS) = mtForest .
  eq sstrans*(M, MM, LS, TT, BND, TO, A F, S, QS) = sstrans(M, MM, LS, TT, BND, TO, A, S, QS)
                                                    sstrans*(M, MM, LS, TT, BND, TO, F, S, QS) .

  op completeReduction : Module Maybe{Module} QidSet TreeType Bound Qid Tree
                         SDDInfoSet QidSet -> CompleteReductionResult .
  ceq completeReduction(M, MM, LS, TT, BND, TO, tree(Q : Q'[TL] =>1 T', N, F),
                        S, QS) = [F', T', T]
   if sdd(Q, MT) S' := S /\
      T := getTerm(metaRewrite(M, TO[TL], BND)) /\
      A := createRewTree(labeling(M), MM, TO[TL], T, LS, TT, BND) /\
      F' := sstrans(M, MM, LS, TT, BND, TO, A, S, QS) .
  eq completeReduction(M, MM, LS, TT, BND, TO, tree(Q : T =>1 T', N, F), S, QS) =
                             completeReduction*(M, MM, LS, TT, BND, TO, F, S, QS) [owise] .

  op completeReduction* : Module Maybe{Module} QidSet TreeType Bound Qid Forest
                          SDDInfoSet QidSet -> CompleteReductionResult .
  eq completeReduction*(M, MM, LS, TT, BND, TO, mtForest, S, QS) = noResult .
  eq completeReduction*(M, MM, LS, TT, BND, TO, A F, S, QS) =
              if completeReduction(M, MM, LS, TT, BND, TO, A, S, QS) == noResult
              then completeReduction*(M, MM, LS, TT, BND, TO, F, S, QS)
              else completeReduction(M, MM, LS, TT, BND, TO, A, S, QS)
              fi .

  op getTopOperator : Module Qid ~> Qid .
  eq getTopOperator(M, Q) = getTopOperator(getRls(M), Q) .

  op getTopOperator : RuleSet Qid ~> Qid .
  eq getTopOperator(rl TO[TL] => T2 [label(Q) AtS] . RS, Q) = TO .
  eq getTopOperator(crl TO[TL] => T2 if COND [label(Q) AtS] . RS, Q) = TO .

***(%
\end{verbatim}
}

The sort \texttt{CompleteReductionResult} contains (i) the new forest, obtained by
reducing the term to its normal form, computing the tree, and reducing it; (ii) the term
previously obtained in the reduction; and (iii) the new term obtained in the reduction:

{\begin{verbatim}
%)

  sort CompleteReductionResult .
  op noResult : -> CompleteReductionResult [ctor] .
  op [_,_,_] : Forest Term Term -> CompleteReductionResult [ctor] .

***(%
\end{verbatim}
}

The first term is substituted by the second one in the third one:

{\begin{verbatim}
%)

  op substitute : Term Term Term -> Term .
  eq substitute(T1, T2, T1) = T2 .
  eq substitute(T1, T2, Q[TL]) = Q[substitute*(T1, T2, TL)] .
  eq substitute(T1, T2, T) = T [owise] .

  op substitute* : Term Term TermList -> TermList .
  eq substitute*(T1, T2, empty) = empty .
  eq substitute*(T1, T2, (T, TL)) = substitute(T1, T2, T),
                                    substitute*(T1, T2, TL) .

  op mainRule? : Tree SDDInfoSet -> Bool .
  eq mainRule?(tree(Q : T =>1 T', N, F), sdd(Q, MT) S) = true .
  eq mainRule?(A, S) = false [owise] .
endfm

***(%
\end{verbatim}
}
%)
***(

    This file is part of the Maude 2 interpreter.

    Copyright 1997-2006 SRI International, Menlo Park, CA 94025, USA.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

)

***
***	Maude LTL satisfiability solver and model checker.
***	Version 2.3.
***

fmod LTL is
  protecting BOOL .
  sort Formula .

  *** primitive LTL operators
  ops True False : -> Formula [ctor format (g o)] .
  op ~_ : Formula -> Formula [ctor prec 53 format (r o d)] .
  op _/\_ : Formula Formula -> Formula [comm ctor gather (E e) prec 55 format (d r o d)] .
  op _\/_ : Formula Formula -> Formula [comm ctor gather (E e) prec 59 format (d r o d)] .
  op O_ : Formula -> Formula [ctor prec 53 format (r o d)] .
  op _U_ : Formula Formula -> Formula [ctor prec 63 format (d r o d)] .
  op _R_ : Formula Formula -> Formula [ctor prec 63 format (d r o d)] .

  *** defined LTL operators
  op _->_ : Formula Formula -> Formula [gather (e E) prec 65 format (d r o d)] .
  op _<->_ : Formula Formula -> Formula [prec 65 format (d r o d)] .
  op <>_ : Formula -> Formula [prec 53 format (r o d)] .
  op []_ : Formula -> Formula [prec 53 format (r d o d)] .
  op _W_ : Formula Formula -> Formula [prec 63 format (d r o d)] .
  op _|->_ : Formula Formula -> Formula [prec 63 format (d r o d)] . *** leads-to
  op _=>_ : Formula Formula -> Formula [gather (e E) prec 65 format (d r o d)] .
  op _<=>_ : Formula Formula -> Formula [prec 65 format (d r o d)] .

  vars f g : Formula .

  eq f -> g = ~ f \/ g .
  eq f <-> g = (f -> g) /\ (g -> f) .
  eq <> f = True U f .
  eq [] f = False R f .
  eq f W g = (f U g) \/ [] f .
  eq f |-> g = [](f -> (<> g)) .
  eq f => g = [] (f -> g) .
  eq f <=> g = [] (f <-> g) .

  *** negative normal form
  eq ~ True = False .
  eq ~ False = True .
  eq ~ ~ f = f .
  eq ~ (f \/ g) = ~ f /\ ~ g .
  eq ~ (f /\ g) = ~ f \/ ~ g .
  eq ~ O f = O ~ f .
  eq ~(f U g) = (~ f) R (~ g) .
  eq ~(f R g) = (~ f) U (~ g) .
endfm

fmod LTL-SIMPLIFIER is
  including LTL .

  *** The simplifier is based on:
  ***   Kousha Etessami and Gerard J. Holzman,
  ***   "Optimizing Buchi Automata", p153-167, CONCUR 2000, LNCS 1877.
  *** We use the Maude sort system to do much of the work.

  sorts TrueFormula FalseFormula PureFormula PE-Formula PU-Formula .
  subsort TrueFormula FalseFormula < PureFormula <
	  PE-Formula PU-Formula < Formula .

  op True : -> TrueFormula [ctor ditto] .
  op False : -> FalseFormula [ctor ditto] .
  op _/\_ : PE-Formula PE-Formula -> PE-Formula [ctor ditto] .
  op _/\_ : PU-Formula PU-Formula -> PU-Formula [ctor ditto] .
  op _/\_ : PureFormula PureFormula -> PureFormula [ctor ditto] .
  op _\/_ : PE-Formula PE-Formula -> PE-Formula [ctor ditto] .
  op _\/_ : PU-Formula PU-Formula -> PU-Formula [ctor ditto] .
  op _\/_ : PureFormula PureFormula -> PureFormula [ctor ditto] .
  op O_ : PE-Formula -> PE-Formula [ctor ditto] .
  op O_ : PU-Formula -> PU-Formula [ctor ditto] .
  op O_ : PureFormula -> PureFormula [ctor ditto] .
  op _U_ : PE-Formula PE-Formula -> PE-Formula [ctor ditto] .
  op _U_ : PU-Formula PU-Formula -> PU-Formula [ctor ditto] .
  op _U_ : PureFormula PureFormula -> PureFormula [ctor ditto] .
  op _U_ : TrueFormula Formula -> PE-Formula [ctor ditto] .
  op _U_ : TrueFormula PU-Formula -> PureFormula [ctor ditto] .
  op _R_ : PE-Formula PE-Formula -> PE-Formula [ctor ditto] .
  op _R_ : PU-Formula PU-Formula -> PU-Formula [ctor ditto] .
  op _R_ : PureFormula PureFormula -> PureFormula [ctor ditto] .
  op _R_ : FalseFormula Formula -> PU-Formula [ctor ditto] .
  op _R_ : FalseFormula PE-Formula -> PureFormula [ctor ditto] .

  vars p q r s : Formula .
  var pe : PE-Formula .
  var pu : PU-Formula .
  var pr : PureFormula .

  *** Rules 1, 2 and 3; each with its dual.
  eq (p U r) /\ (q U r) = (p /\ q) U r .
  eq (p R r) \/ (q R r) = (p \/ q) R r .
  eq (p U q) \/ (p U r) = p U (q \/ r) .
  eq (p R q) /\ (p R r) = p R (q /\ r) .
  eq True U (p U q) = True U q .
  eq False R (p R q) = False R q .

  *** Rules 4 and 5 do most of the work.
  eq p U pe = pe .
  eq p R pu = pu .

  *** An extra rule in the same style.
  eq O pr = pr .

  *** We also use the rules from:
  ***   Fabio Somenzi and Roderick Bloem,
  ***	"Efficient Buchi Automata from LTL Formulae",
  ***   p247-263, CAV 2000, LNCS 1633.
  *** that are not subsumed by the previous system.

  *** Four pairs of duals.
  eq O p /\ O q = O (p /\ q) .
  eq O p \/ O q = O (p \/ q) .
  eq O p U O q = O (p U q) .
  eq O p R O q = O (p R q) .
  eq True U O p = O (True U p) .
  eq False R O p = O (False R p) .
  eq (False R (True U p)) \/ (False R (True U q)) = False R (True U (p \/ q)) .
  eq (True U (False R p)) /\ (True U (False R q)) = True U (False R (p /\ q)) .

  *** <= relation on formula
  op _<=_ : Formula Formula -> Bool [prec 75] .

  eq p <= p = true .
  eq False <= p  = true .
  eq p <= True = true .

  ceq p <= (q /\ r) = true if (p <= q) /\ (p <= r) .
  ceq p <= (q \/ r) = true if p <= q .
  ceq (p /\ q) <= r = true if p <= r .
  ceq (p \/ q) <= r = true if (p <= r) /\ (q <= r) .

  ceq p <= (q U r) = true if p <= r .
  ceq (p R q) <= r = true if q <= r .
  ceq (p U q) <= r = true if (p <= r) /\ (q <= r) .
  ceq p <= (q R r) = true if (p <= q) /\ (p <= r) .
  ceq (p U q) <= (r U s) = true if (p <= r) /\ (q <= s) .
  ceq (p R q) <= (r R s) = true if (p <= r) /\ (q <= s) .

  *** condition rules depending on <= relation
  ceq p /\ q = p if p <= q .
  ceq p \/ q = q if p <= q .
  ceq p /\ q = False if p <= ~ q .
  ceq p \/ q = True if ~ p <= q .
  ceq p U q = q if p <= q .
  ceq p R q = q if q <= p .
  ceq p U q = True U q if p =/= True /\ ~ q <= p .
  ceq p R q = False R q if p =/= False /\ q <= ~ p .
  ceq p U (q U r) = q U r if p <= q .
  ceq p R (q R r) = q R r if q <= p .
endfm

fmod SAT-SOLVER is
  protecting LTL .

  *** formula lists and results
  sorts FormulaList SatSolveResult TautCheckResult .
  subsort Formula < FormulaList .
  subsort Bool < SatSolveResult TautCheckResult .
  op nil : -> FormulaList [ctor] .
  op _;_ : FormulaList FormulaList -> FormulaList [ctor assoc id: nil] .
  op model : FormulaList FormulaList -> SatSolveResult [ctor] .

  op satSolve : Formula ~> SatSolveResult
	[special (
	   id-hook SatSolverSymbol
	   op-hook trueSymbol           (True : ~> Formula)
	   op-hook falseSymbol		(False : ~> Formula)
	   op-hook notSymbol		(~_ : Formula ~> Formula)
	   op-hook nextSymbol		(O_ : Formula ~> Formula)
	   op-hook andSymbol		(_/\_ : Formula Formula ~> Formula)
	   op-hook orSymbol		(_\/_ : Formula Formula ~> Formula)
	   op-hook untilSymbol		(_U_ : Formula Formula ~> Formula)
	   op-hook releaseSymbol	(_R_ : Formula Formula ~> Formula)
	   op-hook formulaListSymbol
		   (_;_ : FormulaList FormulaList ~> FormulaList)
	   op-hook nilFormulaListSymbol	(nil : ~> FormulaList)
	   op-hook modelSymbol
		   (model : FormulaList FormulaList ~> SatSolveResult)
	   term-hook falseTerm		(false)
	 )] .

  op counterexample : FormulaList FormulaList -> TautCheckResult [ctor] .
  op tautCheck : Formula ~> TautCheckResult .
  op $invert : SatSolveResult -> TautCheckResult .

  var F : Formula .
  vars L C : FormulaList .
  eq tautCheck(F) = $invert(satSolve(~ F)) .
  eq $invert(false) = true .
  eq $invert(model(L, C)) = counterexample(L, C) .
endfm

fmod SATISFACTION is
  protecting BOOL .
  sorts State Prop .
  op _|=_ : State Prop -> Bool [frozen] .
endfm

fmod MODEL-CHECKER is
  protecting QID .
  including SATISFACTION .
  including LTL .
  subsort Prop < Formula .

  *** transitions and results
  sorts RuleName Transition TransitionList ModelCheckResult .
  subsort Qid < RuleName .
  subsort Transition < TransitionList .
  subsort Bool < ModelCheckResult .
  ops unlabeled deadlock : -> RuleName .
  op {_,_} : State RuleName -> Transition [ctor] .
  op nil : -> TransitionList [ctor] .
  op __ : TransitionList TransitionList -> TransitionList [ctor assoc id: nil] .
  op counterexample : TransitionList TransitionList -> ModelCheckResult [ctor] .

  op modelCheck : State Formula ~> ModelCheckResult
	[special (
	   id-hook ModelCheckerSymbol
	   op-hook trueSymbol           (True : ~> Formula)
	   op-hook falseSymbol		(False : ~> Formula)
	   op-hook notSymbol		(~_ : Formula ~> Formula)
	   op-hook nextSymbol		(O_ : Formula ~> Formula)
	   op-hook andSymbol		(_/\_ : Formula Formula ~> Formula)
	   op-hook orSymbol		(_\/_ : Formula Formula ~> Formula)
	   op-hook untilSymbol		(_U_ : Formula Formula ~> Formula)
	   op-hook releaseSymbol	(_R_ : Formula Formula ~> Formula)
           op-hook satisfiesSymbol      (_|=_ : State Formula ~> Bool)
	   op-hook qidSymbol		(<Qids> : ~> Qid)
	   op-hook unlabeledSymbol	(unlabeled : ~> RuleName)
	   op-hook deadlockSymbol	(deadlock : ~> RuleName)
	   op-hook transitionSymbol	({_,_} : State RuleName ~> Transition)
	   op-hook transitionListSymbol
		   (__ : TransitionList TransitionList ~> TransitionList)
	   op-hook nilTransitionListSymbol	(nil : ~> TransitionList)
	   op-hook counterexampleSymbol
		   (counterexample : TransitionList TransitionList ~> ModelCheckResult)
	   term-hook trueTerm		(true)
	 )] .
endfm

***(%

\section{Generating test cases}

\subsection{Building Maude terms}

We describe in this section how

{\codesize
\begin{verbatim}
%)

fmod TERM-GENERATION is
 pr MAP{Sort, OpDeclSet} * (sort Map{Sort, OpDeclSet} to OpsTable,
                            op _|->_ to _||->_,
                            op undefined to errOT) .
 pr MAP{Sort, TermList} * (sort Map{Sort, TermList} to ConsTable,
                           op _|->_ to _||->_,
                           op undefined to errCT) .
 pr META-LEVEL .
 pr EXT-BOOL .
 pr MODULES .

 var  M : Module .
 vars ODS POL : OpDeclSet .
 var  OD : OpDecl .
 var  MAS : MembAxSet .
 var  AtS : AttrSet .
 var  S : Sort .
 var  TyL : TypeList .
 var  Ty : Type .
 var  N N' : Nat .
 vars TL TL' TL'' ATL ATL' : TermList .
 vars PTL PTL' PTL'' : TermList .
 var  SS : SortSet .
 var  V : Variable .
 vars T T' T'' : Term .
 var  Q : Qid .
 var  B : Bool .
 var  CT : ConsTable .
 var  OT : OpsTable .
 var  CND : Condition .
 var  CNS : Constant .
 var  ST : Step .
 var  GR : GenRes .

 op generateTermsOp : Module Qid Nat -> GenRes .
 ceq generateTermsOp(M, Q, N) = generateTermsOp(M, Q, TyL, Ty, N)
  if op Q : TyL -> Ty [AtS] . ODS := getOps(M) .
 eq generateTermsOp(M, Q, N) = gr(empty, empty) [owise] .

 op generateTermsOp : Module Qid TypeList Type Nat -> GenRes .
 ceq generateTermsOp(M, Q, TyL, Ty, N) = termsModuloOp(M, TyL, Ty, N, TL', TL'', empty)
  if CT := createConsTable(M) /\
     OT := createOpsTable(M) /\
     TL := typeList2vars(TyL) /\
     gr(TL', TL'') := generateTerms(M, Ty, N, CT, OT, Q[TL], empty) .

 op termsModuloOp : Module TypeList Type Nat TermList TermList TermList -> GenRes .
 eq termsModuloOp(M, TyL, Ty, 0, TL, PTL, ATL) = gr(ATL, PTL) .
 ceq termsModuloOp(M, TyL, Ty, s(N), empty, PTL, ATL) =
                                           termsModuloOp(M, TyL, Ty, s(N), TL, PTL', ATL)
  if CT := createConsTable(M) /\
     OT := createOpsTable(M) /\
     gr(TL, PTL') := generateTerms(M, Ty, s(N), CT, OT, PTL, empty) .
 ceq termsModuloOp(M, TyL, Ty, s(N), (T, TL), PTL, ATL) =
                                           termsModuloOp(M, TyL, Ty, N, TL, PTL, (ATL, T''))
  if {T', Ty} := metaReduce(M, T) /\
     hasSort?(M, T', Ty) /\
     T'' := normal(M, T) /\
     not ATL contains T'' .
 eq termsModuloOp(M, TyL, Ty, s(N), (T, TL), PTL, ATL) =
                                          termsModuloOp(M, TyL, Ty, s(N), TL, PTL, ATL) [owise] .

 sort GenRes .
 op gr : TermList TermList -> GenRes [ctor] .

 *** Quita terminos iguales debido a matching modulo
 *** y comprueba memberships
 op termsModulo : Module Sort Nat TermList TermList TermList Bool -> GenRes .
 eq termsModulo(M, S, 0, TL, PTL, ATL, B) = gr(ATL, PTL) .
 ceq termsModulo(M, S, s(N), empty, PTL, ATL, B) = termsModulo(M, S, s(N), TL, PTL', ATL, B)
  if CT := createConsTable(M) /\
     OT := createOpsTable(M) /\
     gr(TL, PTL') := generateTerms(M, S, s(N), CT, OT, PTL, empty) .
 ceq termsModulo(M, S, s(N), (T, TL), PTL, ATL, B) = termsModulo(M, S, N, TL, PTL, (ATL, T'), B)
  if {T', Ty} := metaReduce(M, T) /\
     (not B) or-else hasSort?(M, T', S) /\
     not ATL contains T' .
 eq termsModulo(M, S, s(N), (T, TL), PTL, ATL, B) = termsModulo(M, S, s(N), TL, PTL, ATL, B) [owise] .

 op generateTerms : Module Sort Nat -> GenRes .
 ceq generateTerms(M, S, N) = termsModulo(M, S, N, TL, PTL, empty, B)
  if V := qid("V:" + string(S)) /\
     CT := createConsTable(M) /\
     OT := createOpsTable(M) /\
     gr(TL, PTL) := generateTerms(M, S, N, CT, OT, V, empty) /\
     B := usesMemberships?(M, S) .

 op generateTerms : Module Sort Nat TermList TermList -> GenRes .
 ceq generateTerms(M, S, N, PTL, ATL) = generateTerms(M, S, N, CT, OT, PTL, ATL)
  if CT := createConsTable(M) /\
     OT := createOpsTable(M) .


 *** Module, Sort de los terminos a ser generados, Nat con el numero de terminos a generar,
 *** ConsTable con las constantes de cada tipo, OpsTable con los constructores de cada tipo,
 *** TermList cola con los terminos a medio construir, Lista acumulada
 op generateTerms : Module Sort Nat ConsTable OpsTable TermList TermList -> GenRes .
 ceq generateTerms(M, S, s(N), CT, OT, (T, PTL), ATL) = generateTerms(M, S, N', CT, OT, PTL', ATL')
  if ST := step(M, T, CT, OT) /\
     PTL' := if ST == ground
             then PTL
             else (PTL, ST)
             fi /\
     N' := if ST == ground
           then N
           else s(N)
           fi /\
     ATL' := if ST == ground
             then (ATL, normal(M, T))
             else ATL
             fi .
 eq generateTerms(M, S, N, CT, OT, PTL, ATL) = gr(ATL, PTL) [owise] .

 op createConsTable : Module -> ConsTable [memo] .
 ceq createConsTable(M) = insert('String, initStr, insert('Char, initChar, CT))
  if CT := createConsTable(M, getOps(M), getSorts(M)) .

 op createConsTable : Module OpDeclSet SortSet -> ConsTable .
 eq createConsTable(M, ODS, none) = empty .
 eq createConsTable(M, ODS, S ; SS) = S ||-> getCons(M, ODS, S), createConsTable(M, ODS, SS) .

 op getCons : Module OpDeclSet Sort -> TermList .
 eq getCons(M, op Q : nil -> Ty [AtS] . ODS, S) =
      if hasSort?(M, qid(string(Q) + "." + string(Ty)), S)
      then qid(string(Q) + "." + string(Ty))
      else empty
      fi, getCons(M, ODS, S) .
 eq getCons(M, ODS, S) = empty [owise] .

 op initChar : -> TermList .
 eq initChar = '"a".Char, '"b".Char, '"c".Char, '"d".Char, '"e".Char .

 op initStr : -> TermList .
 eq initStr = '"ab".String, '"abc".String, '"abcd".String, '"abcde".String .

 op hasSort? : Module Term Sort -> Bool .
 ceq hasSort?(M, T, S) = false
  if Ty := type(M, T) /\
     not sameKind(M, S, Ty) .
 ceq hasSort?(M, T, S) = sortLeq(M, Ty, S)
  if Ty := type(M, T) /\
     sameKind(M, S, Ty) .
 eq hasSort?(M, T, S) = false [owise] .

 op createOpsTable : Module -> OpsTable [memo] .
 eq createOpsTable(M) = createOpsTable(M, getOps(M), getMbs(M), getSorts(M)) .

 op createOpsTable : Module OpDeclSet MembAxSet SortSet -> OpsTable .
 eq createOpsTable(M, ODS, MAS, none) = empty .
 eq createOpsTable(M, ODS, MAS, S ; SS) = S ||-> (getCtorsSubs*(ODS, S ; lesserSorts(M,S))
                                                 getCtorSuper(M, ODS, MAS, S)),
                                          createOpsTable(M, ODS, MAS, SS) .

 op getCtorsSubs* : OpDeclSet SortSet -> OpDeclSet .
 eq getCtorsSubs*(ODS, S ; SS) = getCtorsSubs(ODS, S) getCtorsSubs*(ODS, SS) .
 eq getCtorsSubs*(ODS, none) = none .

 op getCtorsSubs : OpDeclSet Sort -> OpDeclSet .
 ceq getCtorsSubs(op Q : TyL -> S [ctor AtS] . ODS, S) = op Q : TyL -> S [ctor AtS] .
                                                         getCtorsSubs(ODS, S)
  if TyL =/= nil .
 eq getCtorsSubs(ODS, S) = none [owise] .

 op getCtorSuper : Module OpDeclSet MembAxSet Sort -> OpDeclSet .
 eq getCtorSuper(M, ODS, mb T : S [AtS] . MAS, S) = getCtorsSuper*(ODS, greaterSorts(M, S)) .
 eq getCtorSuper(M, ODS, cmb T : S if CND [AtS] . MAS, S) = getCtorsSuper*(ODS, greaterSorts(M, S)) .
 eq getCtorSuper(M, ODS, MAS, S) = none [owise] .

 op getCtorsSuper* : OpDeclSet SortSet -> OpDeclSet .
 eq getCtorsSuper*(ODS, S ; SS) = getCtorsSuper(ODS, S) getCtorsSuper*(ODS, SS) .
 eq getCtorsSuper*(ODS, none) = none .

 op getCtorsSuper : OpDeclSet Sort -> OpDeclSet .
 ceq getCtorsSuper(op Q : TyL -> S [ctor AtS] . ODS, S) = op Q : TyL -> S [ctor AtS] .
                                                          getCtorsSuper(ODS, S)
  if TyL =/= nil .
 eq getCtorsSuper(ODS, S) = none [owise] .

 sort Step .
 subsort TermList < Step .

 op ground : -> Step [ctor] .
 op error-sort : -> Step [ctor] .

 op step : Module Term ConsTable OpsTable -> Step .
 eq step(M, CNS, CT, OT) = ground .
 eq step(M, Q[TL], CT, OT) = step*(M, Q, TL, empty, CT, OT) .
 ceq step(M, V, CT, OT) = CT[Ty], ops2terms(OT[Ty])
  if Ty := getType(V) .

 op step* : Module Qid TermList TermList ConsTable OpsTable -> Step .
 eq step*(M, Q, empty, TL, CT, OT) = ground .
 ceq step*(M, Q, (T, TL), TL', CT, OT) = if ST == ground
                                         then step*(M, Q, TL, (TL', T), CT, OT)
                                         else createTerms(Q, TL', ST, TL)
                                         fi
  if ST := step(M, T, CT, OT) .

 op createTerms : Qid TermList TermList TermList -> TermList .
 eq createTerms(Q, TL, (T, TL'), TL'') = Q[TL, T, TL''], createTerms(Q, TL, TL', TL'') .
 eq createTerms(Q, TL, empty, TL'') = empty .

 op ops2terms : OpDeclSet -> TermList .
 eq ops2terms(none) = empty .
 eq ops2terms(op Q : TyL -> Ty [AtS] . ODS) = Q[typeList2vars(TyL)], ops2terms(ODS) .

 op typeList2vars : TypeList -> TermList .
 eq typeList2vars(nil) = empty .
 eq typeList2vars(Ty TyL) = qid("V:" + string(Ty)), typeList2vars(TyL) .

 op _contains_ : TermList Term -> Bool .
 eq empty contains T = false .
 eq (T, TL) contains T' = if T == T'
                          then true
                          else TL contains T'
                          fi .

 op usesMemberships? : Module Sort -> Bool [memo] .
 eq usesMemberships?(M, S) = usesMemberships?(getMbs(M), S) .

 op usesMemberships? : MembAxSet Sort -> Bool .
 eq usesMemberships?(mb T : S [AtS] . MAS, S) = true .
 eq usesMemberships?(cmb T : S if CND [AtS] . MAS, S) = true .
 eq usesMemberships?(MAS, S) = false [owise] .
endfm

fmod TABLE-ENTRY is
 pr TERMSET .

 sort TermsTableEntry .
 op [_,_,_] : SortSet SortSet TermSet -> TermsTableEntry [ctor] .

 vars SS SS' : SortSet .
 vars TS TS' : TermSet .

 op addTerms : TermsTableEntry TermSet -> TermsTableEntry .
 eq addTerms([SS, SS', TS], TS') = [SS, SS', TS | TS'] .

 op getTermSet : TermsTableEntry -> TermSet .
 eq getTermSet([SS, SS', TS]) = TS .
endfm

view TermsTableEntry from TRIV to TABLE-ENTRY is
 sort Elt to TermsTableEntry .
endv

fmod COVERAGE is
 pr QID-LIST .

 sort Coverage .
 subsort Qid < Coverage .

 vars C C' : Coverage .
 var  Q : Qid .

 op noCoverage : -> Coverage [ctor] .
 op _&_ : Coverage Coverage -> Coverage [ctor assoc comm id: noCoverage] .

 eq Q & Q = Q .

 op coverage2qidlist : Coverage -> QidList .
 eq coverage2qidlist(noCoverage) = nil .
 eq coverage2qidlist(Q & C) = Q coverage2qidlist(C) .

 op _<=_ : Coverage Coverage -> Bool .
 eq noCoverage <= C = true .
 eq Q & C <= Q & C' = C <= C' .
 eq C <= C' = false [owise] .

 op _\\\_ : Coverage Coverage -> Coverage .
 eq (Q & C) \\\ (Q & C') = C \\\ C' .
 eq C \\\ C' = C [owise] .

 op _int_ : Coverage Coverage -> Coverage .
 eq (Q & C) int (Q & C') = Q & (C int C') .
 eq C int C' = noCoverage [owise] .
endfm

view Coverage from TRIV to COVERAGE is
 sort Elt to Coverage .
endv

fmod CHECKED-OPS is
 pr META-LEVEL .

 sort CheckedOp .
 op [_,_] : Qid TypeList -> CheckedOp .
endfm

view CheckedOp from TRIV to CHECKED-OPS is
 sort Elt to CheckedOp .
endv

view TermsTable from TRIV to MAP{Sort,TermsTableEntry} * (sort Map{Sort,TermsTableEntry} to TermsTable) is
 sort Elt to TermsTable .
endv

view CheckedOpsSet from TRIV to SET{CheckedOp} is
 sort Elt to Set{CheckedOp} .
endv

fmod COVERAGE-TYPE is
 sort CoverageType .
 ops global function system : -> CoverageType .
endfm

fmod GLOBAL-COVERAGE is
 pr PAIR{CheckedOpsSet,Coverage} * (sort Pair{CheckedOpsSet,Coverage} to CoverageResult) .
 pr MAP{Sort,TermsTableEntry} * (sort Map{Sort,TermsTableEntry} to TermsTable) .
 pr MAP{Term,Coverage} * (sort Map{Term,Coverage} to CoverageTable) .
 pr COMPUTED-COVERAGE .
 pr TERM-GENERATION .
 pr SUBSTITUTION .
 pr TERMS .

 var  M : Module .
 vars Q L : Qid .
 var  QS : QidSet .
 vars T T' LHS RHS : Term .
 var  S : Sort .
 var  SS : SortSet .
 var  TS : TermSet .
 var  Ty : Type .
 var  TyL : TypeList .
 vars TL TL' : TermList .
 var  AttrS : AttrSet .
 var  CONST : Constant .
 vars CT CT' : CoverageTable .
 vars C C' : Coverage .
 var  MAS : MembAxSet .
 var  EqS : EquationSet .
 var  Eq : Equation .
 vars COND COND' : Condition .
 var  V : Variable .
 var  SCO : Set{CheckedOp} .
 vars CR CR' CR'' CR''' : CoverageResult .
 var  SB : Substitution .
 var  N : Nat .

 op globalCoverage* : Module TermSet -> CoverageTable .
 eq globalCoverage*(M, emptyTermSet) = empty .
 ceq globalCoverage*(M, T | TS) = insert(T, C, CT)
  if CT := globalCoverage*(M, TS) /\
     C := globalCoverage(M, T) .

 op globalCoverage : Module Term -> Coverage .
 eq globalCoverage(M, Q[TL]) = globalCoverageSubterms(M, Q[empty], TL) .
 eq globalCoverage(M, T) = globalCoverageTop(M, T, getEqs(M)) [owise] .

 op globalCoverageSubterms : Module Term TermList -> Coverage .
 eq globalCoverageSubterms(M, T, empty) = globalCoverageTop(M, normal(M, T), getEqs(M)) .
 eq globalCoverageSubterms(M, Q[TL], (T, TL')) =
                   globalCoverage(M, T) &
                   globalCoverageSubterms(M, Q[TL, reduce(M, T)], TL') .

 op globalCoverageTop : Module Term EquationSet -> Coverage .
 ceq globalCoverageTop(M, T, Eq EqS) = coverageLabel(AttrS) & C
   if ceq LHS = RHS if COND [AttrS] . := generalEq(Eq) /\
      not owise?(AttrS) /\
      sameKind(M, type(M, T), type(M, LHS)) /\
      SB := metaMatch(M, LHS, T, COND, 0) /\
      T' := substituteDD(M, RHS, SB) /\
      C := globalCoverage(M, T') &
           globalCoverageConds(M, substituteDD(M, COND, SB)) .

 ceq globalCoverageTop(M, T, Eq EqS) = coverageLabel(AttrS) & C
   if ceq LHS = RHS if COND [AttrS] . := generalEq(Eq) /\
      owise?(AttrS) /\
      sameKind(M, type(M, T), type(M, LHS)) /\
      SB := metaMatch(M, LHS, T, COND, 0) /\
      T' := substituteDD(M, RHS, SB) /\
      C := globalCoverage(M, T') &
           globalCoverageConds(M, substituteDD(M, COND, SB)) .

 eq globalCoverageTop(M, T, Eq EqS) = noCoverage [owise] .

 op globalCoverageConds : Module Condition -> Coverage .
 eq globalCoverageConds(M, nil) = noCoverage .
 eq globalCoverageConds(M, T = T' /\ COND) = globalCoverage(M, T) &
                                             globalCoverage(M, T') &
                                             globalCoverageConds(M, COND) .
 eq globalCoverageConds(M, T := T' /\ COND) = globalCoverage(M, T') &
                                              globalCoverageConds(M, COND) .
 eq globalCoverageConds(M, T => T' /\ COND) = globalCoverage(M, T) &
                                              globalCoverageConds(M, COND) .
 eq globalCoverageConds(M, T : S /\ COND) = globalCoverage(M, T) &
                                            globalCoverageConds(M, COND) &
                                            globalCoverageMAS(M, T, getMbs(M), lesserSorts(M, S)) .

 op globalCoverageMAS : Module Term MembAxSet SortSet -> Coverage .
 ceq globalCoverageMAS(M, T, cmb LHS : S if COND [AttrS] . MAS, S ; SS) =
                                  globalCoverageConds(M, COND)
  if sameKind(M, type(M, T), type(M, LHS)) /\
     SB := metaMatch(M, LHS, T, COND, 0) .
 eq globalCoverageMAS(M, T, MAS, SS) = noCoverage [owise] .

 op neededCoverage : Module Qid TypeList CoverageResult -> CoverageResult .
 op neededCoverage : Module Qid TypeList CoverageResult EquationSet -> CoverageResult .

 eq neededCoverage(M, Q, TyL, < ([Q, TyL], SCO), C >) = < ([Q, TyL], SCO), C > .
 eq neededCoverage(M, Q, TyL, CR) = neededCoverage(M, Q, TyL, CR, getEqs(M)) [owise] .
 ceq neededCoverage(M, Q, TyL, CR, Eq EqS) = neededCoverage(M, Q, TyL, CR''', EqS)
  if usable?(M, Q, TyL, Eq) /\
     ceq LHS = RHS if COND [AttrS] . := generalEq(Eq) /\
     CR' := globalCoverageTerm(M, RHS, addOp2Checked(Q, TyL, CR)) /\
     CR'' := globalCoverageCond*(M, COND, CR') /\
     CR''' := addLabel2Coverage(coverageLabel(AttrS), CR'') .
 eq neededCoverage(M, Q, TyL, CR, EqS) = addOp2Checked(Q, TyL, CR) [owise] .

 op usable? : Module Qid TypeList Equation -> Bool .
 ceq usable?(M, Q, TyL, Eq) =
                  metaMatch(M, T, LHS, nil, 0) =/= noMatch
  if ceq LHS = RHS if COND [AttrS] . := generalEq(Eq) /\
     T := createTerm(M, Q, TyL) /\
     sameKind(M, type(M, T), type(M, LHS)) .
 eq usable?(M, Q, TyL, Eq) = false [owise] .

 op globalCoverageTerm : Module Term CoverageResult -> CoverageResult .
 ceq globalCoverageTerm(M, Q[TL], CR) = neededCoverage(M, Q, TyL, CR')
  if TyL := getTypeList(M, TL) /\
     CR' := globalCoverageTerm*(M, TL, CR) .
 ceq globalCoverageTerm(M, CONST, CR) = neededCoverage(M, Q, nil, CR)
  if Q := getName(CONST) .
 eq globalCoverageTerm(M, V, CR) = CR .

 op globalCoverageTerm* : Module TermList CoverageResult -> CoverageResult .
 eq globalCoverageTerm*(M, empty, CR) = CR .
 ceq globalCoverageTerm*(M, (T, TL), CR) = globalCoverageTerm*(M, TL, CR')
  if CR' := globalCoverageTerm(M, T, CR) .

 op globalCoverageCond : Module Condition CoverageResult -> CoverageResult .
 ceq globalCoverageCond(M, T = T', CR) = CR''
  if CR' := globalCoverageTerm(M, T, CR) /\
     CR'' := globalCoverageTerm(M, T', CR') .
 eq globalCoverageCond(M, T := T', CR) = globalCoverageTerm(M, T', CR) .
 ceq globalCoverageCond(M, T : S, CR) = globalCoverageMAS(M, T, getMbs(M), lesserSorts(M, S), CR')
  if CR' := globalCoverageTerm(M, T, CR) .
 eq globalCoverageCond(M, T => T', CR) = globalCoverageTerm(M, T, CR) .

 op globalCoverageCond* : Module Condition CoverageResult -> CoverageResult .
 eq globalCoverageCond*(M, nil, CR) = CR .
 ceq globalCoverageCond*(M, COND /\ COND', CR) = CR''
  if COND =/= nil /\
     COND' =/= nil /\
     CR' := globalCoverageCond*(M, COND, CR) /\
     CR'' := globalCoverageCond*(M, COND', CR') .
 eq globalCoverageCond*(M, COND, CR) = globalCoverageCond(M, COND, CR) [owise] .

 op globalCoverageMAS : Module Term MembAxSet SortSet CoverageResult -> CoverageResult .
 ceq globalCoverageMAS(M, T, cmb LHS : S if COND [AttrS] . MAS, S ; SS, CR) =
                 globalCoverageMAS(M, T, MAS, S ; SS, CR')
  if sameKind(M, type(M, T), type(M, LHS)) /\
     SB := metaMatch(M, LHS, T, COND, 0) /\
     CR' := globalCoverageCond*(M, COND, CR) .
 eq globalCoverageMAS(M, T, MAS, SS, CR) = CR [owise] .

 op coverageLabel : AttrSet -> Coverage .
 eq coverageLabel(label(L) AttrS) = L .
 eq coverageLabel(AttrS) = noCoverage [owise] .

 op addOp2Checked : Qid TypeList CoverageResult -> CoverageResult .
 eq addOp2Checked(Q, TyL, < SCO, C >) = < ([Q, TyL], SCO), C > .

 op addLabel2Coverage : Coverage CoverageResult -> CoverageResult .
 eq addLabel2Coverage(C, < SCO, C' >) = < SCO, C & C' > .

 op minimumCoverage : CoverageTable -> TermSet .
 eq minimumCoverage(empty) = emptyTermSet .
 ceq minimumCoverage((T |-> C, CT)) = minimumCoverage(CT)
  if C <= getCoverageTable(CT) .
 eq minimumCoverage(CT) = getEntries(CT) [owise] .

 op getEntries : CoverageTable -> TermSet .
 eq getEntries(empty) = emptyTermSet .
 eq getEntries((T |-> C, CT)) = T | getEntries(CT) .

 op getCoverageTable : CoverageTable -> Coverage .
 eq getCoverageTable(empty) = noCoverage .
 eq getCoverageTable((T |-> C, CT)) = C & getCoverageTable(CT) .

 sort AdditionalInfo .
 op <_,_,_> : CoverageTable TermSet Coverage -> AdditionalInfo [ctor] .

 op firstAI : AdditionalInfo -> CoverageTable .
 eq firstAI(< CT, TS, C >) = CT .

 op selectTermsGC : Module Qid TypeList Type QidSet Nat -> AdditionalInfo .
 ceq selectTermsGC(M, Q, TyL, Ty, QS, s(N)) = selectTermsGC(M, Q, TyL, Ty, TL, CT, T, C, N)
  if gr(T, TL) := generateTermsOp(M, Q, 1) /\
     C := second(neededCoverage(M, Q, TyL, < empty, noCoverage >)) int qidset2coverage(QS) /\
     CT := globalCoverage*(M, T) .
 eq selectTermsGC(M, Q, TyL, Ty, QS, 0) = < empty, nil, noCoverage > .

 op selectTermsGC : Module Qid TypeList Type TermList CoverageTable TermSet Coverage Nat
                  -> AdditionalInfo .
 eq selectTermsGC(M, Q, TyL, Ty, TL, CT, TS, C, 0) =
                            < CT, TS, C \\\ getCoverageTable(CT) > .
 ceq selectTermsGC(M, Q, TyL, Ty, TL, CT, TS, C, N) = < CT, TS, noCoverage >
  if getCoverageTable(CT) == C .
 ceq selectTermsGC(M, Q, TyL, Ty, TL, CT, TS, C, s(N)) =
                             selectTermsGC(M, Q, TyL, Ty, TL', (CT, CT'), (TS | T), C, N)
  if gr(T, TL') := generateTerms(M, Ty, 1, TL, empty) /\
     CT' := globalCoverage*(M, T) [owise] .

 op qidset2coverage : QidSet -> Coverage .
 eq qidset2coverage(none) = noCoverage .
 eq qidset2coverage(Q ; QS) = Q & qidset2coverage(QS) .
endfm

***(%
\end{verbatim}
}

The module \verb"CALL-COVERAGE" is in charge of computing the code coverage
with the call coverage strategy.

{\codesize
\begin{verbatim}
%)

fmod CALL-COVERAGE is
 pr MAP{Term,CallSet} * (sort Map{Term,CallSet} to CallCoverageTable) .
 pr MAYBE{Equation} .
 pr SUBSTITUTION .
 pr MAYBE{Term} .
 pr TERMSET .
 pr TERMS .
 pr UNIT .

 vars M M' : Module .
 var  Q : Qid .
 var  QS : QidSet .
 var  Ty : Type .
 var  TyL : TypeList .
 vars T T' T'' L R : Term .
 var  TS : TermSet .
 var  CONST : Constant .
 var  V : Variable .
 var  TL : TermList .
 vars Eq Eq' : Equation .
 vars EqS EqS' : EquationSet .
 var  AttrS : AttrSet .
 var  COND : Condition .
 var  C : Call .
 vars SC SC' SC1 SC2 SC3 : Set{Call} .
 var  SB : Substitution .
 var  MT : Maybe{Term} .
 var  MEq : Maybe{Equation} .
 var  CCT : CallCoverageTable .

 op callCoverage : Module TermSet Qid TypeList -> CallCoverageTable .
 ceq callCoverage(M, TS, Q, TyL) = CCT
  if SC := initialCalls(M, createTerm(M, Q, TyL), getEqs(M)) /\
     T := createTerm(M, Q, TyL) /\
     CCT := getCallCoverageTable(M, TS, SC) .

 op getCallCoverageTable : Module TermSet Set{Call} -> CallCoverageTable .
 eq getCallCoverageTable(M, emptyTermSet, SC) = empty .
 ceq getCallCoverageTable(M, T | TS, SC) = T |-> SC1, CCT
  if SC1 := getEquationsUsed(M, T, getEqs(M), maybe, maybe, SC) /\
     CCT := getCallCoverageTable(M, TS, SC) .

 op initialCalls : Module Term EquationSet -> Set{Call} .
 eq initialCalls(M, T, none) = empty .
 eq initialCalls(M, T, Eq EqS) = initialCallsEq(M, T, Eq),
                                 initialCalls(M, T, EqS) .

 op initialCallsEq : Module Term Equation -> Set{Call} .
 ceq initialCallsEq(M, T, Eq) = initialCallsTerm(M, T, Eq, R),
                                initialCallsCond(M, T, Eq, COND)
  if ceq L = R if COND [AttrS] . := generalEq(Eq) .

 op initialCallsTerm : Module Term Equation Term -> Set{Call} .
 eq initialCallsTerm(M, T, Eq, Q[TL]) = initialCallsTermTop(M, T, Eq, Q[TL]),
                                        initialCallsTerm*(M, T, Eq, TL) .
 eq initialCallsTerm(M, T, Eq, CONST) = initialCallsTermTop(M, T, Eq, CONST) .
 eq initialCallsTerm(M, T, Eq, V) = empty .

 op initialCallsTerm* : Module Term Equation TermList -> Set{Call} .
 eq initialCallsTerm*(M, T, Eq, empty) = empty .
 eq initialCallsTerm*(M, T, Eq, (T', TL)) = initialCallsTerm(M, T, Eq, T'),
                                            initialCallsTerm*(M, T, Eq, TL) .

 op initialCallsTermTop : Module Term Equation Term -> Set{Call} .
 ceq initialCallsTermTop(M, T, Eq, T') = [Eq, T', none]
  if sameKind(M, type(M, T), type(M, T')) /\
     SB := metaMatch(M, T, T', nil, 0) .
 eq initialCallsTermTop(M, T, Eq, T') = empty [owise] .

 op initialCallsCond : Module Term Equation Condition -> Set{Call} .
 eq initialCallsCond(M, T, Eq, nil) = empty .
 eq initialCallsCond(M, T, Eq, T' = T'' /\ COND) = initialCallsTerm(M, T, Eq, T'),
                                                   initialCallsTerm(M, T, Eq, T''),
                                                   initialCallsCond(M, T, Eq, COND) .
 eq initialCallsCond(M, T, Eq, T' := T'' /\ COND) = initialCallsTerm(M, T, Eq, T''),
                                                    initialCallsCond(M, T, Eq, COND) .
 eq initialCallsCond(M, T, Eq, T' : Ty /\ COND) = initialCallsTerm(M, T, Eq, T'),
                                                  initialCallsCond(M, T, Eq, COND) .
 eq initialCallsCond(M, T, Eq, T' => T'' /\ COND) = initialCallsTerm(M, T, Eq, T'),
                                                    initialCallsCond(M, T, Eq, COND) .

 op getEquationsNeeded : Module Term EquationSet -> EquationSet .
 ceq getEquationsNeeded(M, T, Eq EqS) = Eq getEquationsNeeded(M, T, EqS)
  if ceq L = R if COND [label(Q) AttrS] . := generalEq(Eq) /\
     sameKind(M, type(M, T), type(M, L)) /\
     metaMatch(M, T, L, nil, 0) =/= noMatch .
 eq getEquationsNeeded(M, T, EqS) = none [owise] .

 op removeEquation : Module Equation -> Module [memo] .
 ceq removeEquation(M, Eq) = setEqs(M, EqS)
  if Eq EqS := getEqs(M) .
 eq removeEquation(M, Eq) = M [owise] .

 op look4functionEq : Module Term Equation -> TermList .
 ceq look4functionEq(M, T, Eq) = look4functionTerm(M, T, R),
                                 look4functionCond(M, T, COND)
  if ceq L = R if COND [AttrS] . := generalEq(Eq) .

 op look4functionTerm : Module Term Term -> TermList .
 eq look4functionTerm(M, T, Q[TL]) = look4functionTop(M, T, Q[TL])
                                     look4functionTerm*(M, T, TL) .
 eq look4functionTerm(M, T, CONST) = look4functionTop(M, T, CONST) .
 eq look4functionTerm(M, T, V) = empty .

 op look4functionTop : Module Term Term -> TermList .
 ceq look4functionTop(M, T, T') = T'
  if sameKind(M, type(M, T), type(M, T')) /\
     SB := metaMatch(M, T, T', nil, 0) .
 eq look4functionTop(M, T, T') = empty [owise] .

 op look4functionTerm* : Module Term TermList -> TermList .
 eq look4functionTerm*(M, T, empty) = empty .
 eq look4functionTerm*(M, T, (T', TL)) = look4functionTerm(M, T, T'),
                                         look4functionTerm*(M, T, TL) .

 op look4functionCond : Module Term Condition -> TermList .
 eq look4functionCond(M, T, nil) = empty .
 eq look4functionCond(M, T, T' = T'' /\ COND) = look4functionTerm(M, T, T'),
                                                look4functionTerm(M, T, T''),
                                                look4functionCond(M, T, COND) .
 eq look4functionCond(M, T, T' := T'' /\ COND) = look4functionTerm(M, T, T''),
                                                 look4functionCond(M, T, COND) .
 eq look4functionCond(M, T, T' : Ty /\ COND) = look4functionTerm(M, T, T'),
                                               look4functionCond(M, T, COND) .
 eq look4functionCond(M, T, T' => T'' /\ COND) = look4functionTerm(M, T, T'),
                                                 look4functionCond(M, T, COND) .

 op getEquationsUsed : Module Term EquationSet Maybe{Equation} Maybe{Term} Set{Call}
                       -> Set{Call} .
 ceq getEquationsUsed(M, T, Eq EqS, MEq, MT, SC) = SC3
  if ceq L = R if COND [AttrS] . := generalEq(Eq) /\
     not owise?(AttrS) /\
     sameKind(M, type(M, T), type(M, L)) /\
     SB := metaMatch(M, L, T, COND, 0) /\
     SC1 := addEquation2Call(MEq, MT, Eq, SC) /\
     SC2 := getAllEqsUsedTerm(M, Eq, R, SB, SC1) /\
     SC3 := getAllEqsUsedCond(M, Eq, COND, SB, SC2) .
 eq getEquationsUsed(M, T, EqS, MEq, MT, SC) = SC [owise] .

 op getAllEqsUsedTerm : Module Equation Term Substitution Set{Call} -> Set{Call} .
 ceq getAllEqsUsedTerm(M, Eq, Q[TL], SB, SC) = SC2
  if T' := substituteDD(M, Q[TL], SB) /\
     SC1 := getEquationsUsed(M, T', getEqs(M), Eq, Q[TL], SC) /\
     SC2 := getAllEqsUsedTerm*(M, Eq, TL, SB, SC1) .
 ceq getAllEqsUsedTerm(M, Eq, CONST, SB, SC) = SC1
  if SC1 := getEquationsUsed(M, CONST, getEqs(M), Eq, CONST, SC) .
 ceq getAllEqsUsedTerm(M, Eq, V, SB, SC) = SC1
  if T := substituteDD(M, V, SB) /\
     SC1 := getEquationsUsed(M, T, getEqs(M), Eq, V, SC) .

 op getAllEqsUsedTerm* : Module Equation TermList Substitution Set{Call} -> Set{Call} .
 eq getAllEqsUsedTerm*(M, Eq, empty, SB, SC) = SC .
 ceq getAllEqsUsedTerm*(M, Eq, (T, TL), SB, SC) = getAllEqsUsedTerm*(M, Eq, TL, SB, SC1)
  if SC1 := getAllEqsUsedTerm(M, Eq, T, SB, SC) .

 op getAllEqsUsedCond : Module Equation Condition Substitution Set{Call} -> Set{Call} .
 eq getAllEqsUsedCond(M, Eq, nil, SB, SC) = SC .
 eq getAllEqsUsedCond(M, Eq, T = T' /\ COND, SB, SC) =
                                           getAllEqsUsedTerm(M, Eq, T, SB, SC),
                                           getAllEqsUsedTerm(M, Eq, T', SB, SC),
                                           getAllEqsUsedCond(M, Eq, COND, SB, SC) .
 eq getAllEqsUsedCond(M, Eq, T := T' /\ COND, SB, SC) =
                                           getAllEqsUsedTerm(M, Eq, T', SB, SC),
                                           getAllEqsUsedCond(M, Eq, COND, SB, SC) .
 eq getAllEqsUsedCond(M, Eq, T : Ty /\ COND, SB, SC) =
                                           getAllEqsUsedTerm(M, Eq, T, SB, SC),
                                           getAllEqsUsedCond(M, Eq, COND, SB, SC) .
 eq getAllEqsUsedCond(M, Eq, T => T' /\ COND, SB, SC) =
                                           getAllEqsUsedTerm(M, Eq, T, SB, SC),
                                           getAllEqsUsedCond(M, Eq, COND, SB, SC) .

 op addEquation2Call : Maybe{Equation} Maybe{Term} Equation Set{Call} -> Set{Call} .
 eq addEquation2Call(Eq, T, Eq', ([Eq, T, EqS], SC)) = [Eq, T, EqS Eq'], SC .
 eq addEquation2Call(MEq, MT, Eq', SC) = SC [owise] .

 op minimumCallCoverage : CallCoverageTable -> TermSet .
 ceq minimumCallCoverage((T |-> SC, CCT)) = minimumCallCoverage(CCT)
  if SC' := totalCoverage(CCT) /\
     minorCallCoverage(SC, SC') .
 eq minimumCallCoverage(CCT) = getTermsCCT(CCT) [owise] .

 op totalCoverage : CallCoverageTable -> Set{Call} .
 eq totalCoverage(CCT) = totalCoverage(CCT, empty) .

 op totalCoverage : CallCoverageTable Set{Call} -> Set{Call} .
 eq totalCoverage(empty, SC) = SC .
 eq totalCoverage((T |-> SC, CCT), SC') = totalCoverage(CCT, callUnion(SC, SC')) .

 op callUnion : Set{Call} Set{Call} -> Set{Call} .
 eq callUnion(empty, SC) = SC .
 eq callUnion(([ Eq, T, EqS ], SC), ([ Eq, T, EqS' ], SC')) =
                                        callUnion(SC, ([ Eq, T, EqS EqS' ], SC')) .
 eq callUnion((C, SC), SC') = callUnion(SC, (C, SC')) [owise] .

 op noCallCovered : CallCoverageTable EquationSet -> Set{Call} .
 ceq noCallCovered(CCT, EqS) = SC'
  if SC := totalCoverage(CCT) /\
     SC' := removeCovered(SC, EqS) .

 op removeCovered : Set{Call} EquationSet -> Set{Call} .
 eq removeCovered(empty, EqS) = empty .
 eq removeCovered(([Eq, T, EqS], SC), EqS) = removeCovered(SC, EqS) .
 eq removeCovered(([Eq, T, EqS], SC), EqS') =
                     [Eq, T, EqS -eqs EqS'], removeCovered(SC, EqS') [owise] .

 op _-eqs_ : EquationSet EquationSet -> EquationSet .
 eq (Eq EqS) -eqs (Eq EqS') = EqS -eqs EqS' .
 eq EqS -eqs EqS' = EqS [owise] .

 op minorCallCoverage : Set{Call} Set{Call} -> Bool .
 eq minorCallCoverage(empty, SC) = true .
 eq minorCallCoverage(([Eq, T, EqS], SC), ([Eq, T, EqS EqS'], SC')) =
                     minorCallCoverage(SC, SC') .
 eq minorCallCoverage(SC, SC') = false [owise] .

 op getTermsCCT : CallCoverageTable -> TermSet .
 eq getTermsCCT(empty) = emptyTermSet .
 eq getTermsCCT((T |-> SC, CCT)) = T | getTermsCCT(CCT) .

 op requiredCallCoverage : Module Term -> Set{Call} .
 ceq requiredCallCoverage(M, T) = SC'
  if SC := initialCalls(M, T, getEqs(M)) /\
     EqS := getEquationsNeeded(M, T, getEqs(M)) /\
     SC' := putEqs(SC, EqS) .

 op putEqs : Set{Call} EquationSet -> Set{Call} .
 eq putEqs(empty, EqS) = empty .
 eq putEqs(([Eq, T, EqS], SC), EqS') = [Eq, T, EqS'], putEqs(SC, EqS') .

 op _\\\_ : Set{Call} Set{Call} -> Set{Call} .
 eq ([Eq, T, EqS], SC) \\\ ([Eq, T, EqS'], SC') =
                 if EqS -eqs EqS' == none
                 then SC \\\ SC'
                 else [Eq, T, EqS -eqs EqS'], (SC \\\ SC')
                 fi .
 eq SC \\\ SC' = SC [owise] .
endfm

fmod MB-COVERAGE-ENTRY is
 pr GLOBAL-COVERAGE .

 sort MbCoverage .
 op mbc : Set{CheckedOp} Coverage Coverage -> MbCoverage [ctor] .

 op emptyMBC : -> MbCoverage .
 eq emptyMBC = mbc(empty, noCoverage, noCoverage) .

 vars C C' C'' C1 C2 : Coverage .
 vars SCO SCO' : Set{CheckedOp} .

 op addNegInfo : MbCoverage Coverage -> MbCoverage .
 eq addNegInfo(mbc(SCO, C, C'), C'') = mbc(SCO, C, C' & C'') .

 op addCoverage : MbCoverage Coverage -> MbCoverage .
 eq addCoverage(mbc(SCO, C, C'), C'') = mbc(SCO, C & C'', C' & C'') .

 op getCovRes : MbCoverage -> CoverageResult .
 eq getCovRes(mbc(SCO, C, C')) = < SCO, C > .

 op addCovRes : MbCoverage CoverageResult -> MbCoverage .
 eq addCovRes(mbc(SCO, C, C'), < SCO', C'' >) = mbc((SCO, SCO'), C & C'', C' ) .

 op setCovRes : MbCoverage CoverageResult -> MbCoverage .
 eq setCovRes(mbc(SCO, C, C'), < SCO', C'' > ) = mbc(SCO', C'', C') .

 sort CoveragePair .
 op cp : Coverage Coverage -> CoveragePair [ctor] .

 op getCoveragePair : MbCoverage -> CoveragePair .
 eq getCoveragePair(mbc(SCO, C, C')) = cp(C, C') .

 op _\\\_ : CoveragePair CoveragePair -> CoveragePair .
 eq cp(C, C') \\\ cp(C1, C2) = cp(C \\\ C1, C' \\\ C2) .

 op _&&_ : CoveragePair CoveragePair -> CoveragePair .
 eq cp(C, C') && cp(C1, C2) = cp(C & C1, C' & C2) .

 op firstCP : CoveragePair -> Coverage .
 eq firstCP(cp(C, C')) = C .
endfm

view MbCoverageEntry from TRIV to MB-COVERAGE-ENTRY is
 sort Elt to MbCoverage .
endv

fmod MB-COVERAGE is
 pr MAP{Term, MbCoverageEntry} * (sort Map{Term, MbCoverageEntry} to MbCoverageTable) .

 var  V : Variable .
 var  CONST : Constant .
 var  Q : Qid .
 var  M : Module .
 vars T T' LHS LHS' : Term .
 var  TL : TermList .
 var  TS : TermSet .
 var  AtS : AttrSet .
 vars CR CR' : CoverageResult .
 var  S : Sort .
 vars Ty Ty' : Type .
 var  COND : Condition .
 vars MBC MBC' MBC'' : MbCoverage .
 var  MCT : MbCoverageTable .
 var  MAS : MembAxSet .
 var  MA : MembAx .
 vars C C' C'' C1 C2 : Coverage .
 var  SCO : Set{CheckedOp} .
 var  SB : Substitution .
 var  CP : CoveragePair .

 op mbCoverage : Module TermSet Sort -> MbCoverageTable .
 eq mbCoverage(M, emptyTermSet, S) = empty .
 ceq mbCoverage(M, T | TS, S) = T |-> MBC, mbCoverage(M, TS, S)
  if MBC := getMbCoverage(M, T, S) .

 op getMbCoverage : Module Term Sort -> MbCoverage .
 eq getMbCoverage(M, T, S) = getMbCoverage(M, T, S, emptyMBC, getMbs(M)) .

 op getMbCoverage : Module Term Sort MbCoverage MembAxSet -> MbCoverage .
 ceq getMbCoverage(M, T, S, MBC, MA MAS) = getMbCoverage(M, T, S, MBC'', MAS)
  if C := negativeInfo(M, T, S, MA) /\
     MBC' := addNegInfo(MBC, C) /\
     CR := getCovRes(MBC') /\
     CR' := positiveInfo(M, T, S, MA, CR) /\
     MBC'' := addCovRes(MBC', CR') .
 eq getMbCoverage(M, T, S, MBC, none) = MBC .

 op negativeInfo : Module Term Sort MembAx -> Coverage .
 ceq negativeInfo(M, T, S, mb LHS : S [AtS] .) = coverageLabel(AtS)
  if LHS' := term2kind(M, LHS) /\
     metaMatch(M, LHS', T, nil, 0) =/= noMatch /\
     metaMatch(M, LHS, T, nil, 0) == noMatch .
 ceq negativeInfo(M, T, S, cmb LHS : S if COND [AtS] .) = coverageLabel(AtS)
  if LHS' := term2kind(M, LHS) /\
     metaMatch(M, LHS', T, nil, 0) =/= noMatch /\
     metaMatch(M, LHS, T, COND, 0) == noMatch .
 eq negativeInfo(M, T, S, MA) = noCoverage [owise] .

 op positiveInfo : Module Term Sort MembAx CoverageResult -> CoverageResult .
 ceq positiveInfo(M, T, S, mb LHS : S [AtS] ., < SCO, C >) = < SCO, C & C' >
  if metaMatch(M, LHS, T, nil, 0) == noMatch /\
     C' := coverageLabel(AtS) .
 ceq positiveInfo(M, T, S, cmb LHS : S if COND [AtS] ., < SCO, C >) = < SCO, C & C' & C'' >
  if SB := metaMatch(M, LHS, T, COND, 0) /\
     C' := coverageLabel(AtS) /\
     C'' := globalCoverageConds(M, substituteDD(M, COND, SB)) .
 eq positiveInfo(M, T, S, MA, CR) = CR [owise] .

 op neededMbCoverage : Module Sort -> CoveragePair .
 eq neededMbCoverage(M, S) =  getCoveragePair(neededMbCoverage(M, S, emptyMBC, getMbs(M))) .

 op neededMbCoverage : Module Sort MbCoverage MembAxSet -> MbCoverage .
 ceq neededMbCoverage(M, S, MBC, mb T : S [AtS] . MAS) = neededMbCoverage(M, S, MBC', MAS)
  if not ground?(T) /\
     C := coverageLabel(AtS) /\
     MBC' := addCoverage(MBC, C) .
 ceq neededMbCoverage(M, S, MBC, cmb T : S if COND [AtS] . MAS) =
                                                neededMbCoverage(M, S, MBC'', MAS)
  if not ground?(T) /\
     C := coverageLabel(AtS) /\
     CR := getCovRes(MBC) /\
     CR' := globalCoverageCond*(M, COND, CR) /\
     MBC' := setCovRes(MBC, CR') /\
     MBC'' := addCoverage(MBC', C) .
 eq neededMbCoverage(M, S, MBC, MAS) = MBC [owise] .

 op ground? : Term -> Bool .
 eq ground?(V) = false .
 eq ground?(Q[TL]) = ground?*(TL) .

 op ground?* : TermList -> Bool .
 eq ground?*(empty) = true .
 eq ground?*((T, TL)) = ground?(T) and ground?*(TL) .

 op term2kind : Module Term -> Term .
 eq term2kind(M, Q[TL]) = Q[term2kind*(M, TL)] .
 eq term2kind(M, CONST) = CONST .
 ceq term2kind(M, V) = qid(string(Q) + ":" + string(Ty'))
  if Q := getName(V) /\
     Ty := getType(V) /\
     Ty' := getKind(M, Ty) .

 op term2kind* : Module TermList -> TermList .
 eq term2kind*(M, empty) = empty .
 eq term2kind*(M, (T, TL)) = term2kind(M, T), term2kind*(M, TL) .

 op getMbCoverage : MbCoverageTable -> CoveragePair .
 eq getMbCoverage(MCT) = getMbCoverage(MCT, cp(noCoverage, noCoverage)) .

 op getMbCoverage : MbCoverageTable CoveragePair -> CoveragePair .
 eq getMbCoverage(empty, CP) = CP .
 eq getMbCoverage((T |-> mbc(SCO, C, C'), MCT), cp(C1, C2)) =
                                             getMbCoverage(MCT, cp(C & C1, C' & C2)) .

 op minimumMbCoverage : MbCoverageTable -> TermSet .
 ceq minimumMbCoverage((T |-> mbc(SCO, C, C'), T' |-> mbc(SCO, C, C'), MCT)) =
          minimumMbCoverage((T |-> mbc(SCO, C, C'), MCT))
  if numCtors(T) <= numCtors(T') .
 ceq minimumMbCoverage((MCT, T |-> mbc(SCO, C, C'))) = minimumMbCoverage(MCT)
  if cp(C1 & C, C2 & C') := getMbCoverage(MCT) [owise] .
 eq minimumMbCoverage(MCT) = mbEntries(MCT) [owise] .

 op mbEntries : MbCoverageTable -> TermSet .
 eq mbEntries(empty) = emptyTermSet .
 eq mbEntries((T |-> MBC, MCT)) = T | mbEntries(MCT) .

 op numCtors : Term -> Nat .
 eq numCtors(CONST) = 0 .
 eq numCtors(V) = 0 .
 eq numCtors(Q[TL]) = s(numCtors*(TL)) .

 op numCtors* : TermList -> Nat .
 eq numCtors*(empty) = 0 .
 eq numCtors*((T, TL)) = s(numCtors*(TL)) .
endfm

fmod TERMS-WITH-BOUND is
 pr BOUND-WITH-MINUS .

 sort TermWithBound .
 op <_._> : Term Bound -> TermWithBound [ctor] .
endfm

view BoundedTerm from TRIV to TERMS-WITH-BOUND is
 sort Elt to TermWithBound .
endv

view CoveragePair from TRIV to MB-COVERAGE-ENTRY is
 sort Elt to CoveragePair .
endv

fmod SYSTEM-COVERAGE is
 pr MAP{Term,CoveragePair} * (sort Map{Term,CoveragePair} to SysTable) .
 pr LIST{BoundedTerm} * (sort List{BoundedTerm} to Queue) .
 pr COVERAGE-TYPE .
 pr MB-COVERAGE .

 var  M : Module .
 vars S S' : Sort .
 vars SS SS' SS'' : SortSet .
 var  TyL : TypeList .
 var  K : Kind .
 var  AtS : AttrSet .
 var  ODS : OpDeclSet .
 var  MAS : MembAxSet .
 var  RS : RuleSet .
 var  Rl : Rule .
 var  Q : Qid .
 vars QIL QIL' : QidList .
 vars L L' R T T' T1 T1' T2 T2' : Term .
 var  Ty : Type .
 vars TL TL' : TermList .
 vars TS TS' : TermSet .
 var  COND : Condition .
 vars AC AC' C C' C'' C1 C2 RC RC' : Coverage .
 vars QS QS' : QidSet .
 vars RAR RAR' : RuleAppRes .
 var  RT? : ResultTriple? .
 var  TB : TermWithBound .
 vars QU QU' : Queue .
 var  B : Bound .
 vars N N' : Nat .
 vars CR CR' CR'' : CoverageResult .
 var  SB : Substitution .
 vars CP CP' CP1 CP2 CP3 RCP : CoveragePair .
 vars ST ST' : SysTable .
 vars SI SI' : SysInfo .
 vars RCI RCI' : RuleCoveredInfo .
 vars ARI ARI' : AllRulesInfo .
 var  SCR : SysCovRes .
 var  CI : CoverageInfo .
 var  CT : CoverageType .
 var  HASMB? : Bool .

 op relatedSorts : Module Sort -> SortSet .
 eq relatedSorts(M, S) = relatedSorts(M, S, none) .

 op relatedSorts : Module Sort SortSet -> SortSet .
 eq relatedSorts(M, S, SS) =
               relatedSorts(M, S, S ; lesserSorts(M, S) ; greaterSorts(M, S) ; SS, getOps(M)) .

 op relatedSorts : Module Sort SortSet OpDeclSet -> SortSet .
 ceq relatedSorts(M, S, SS, op Q : TyL -> S [AtS] . ODS) = relatedSorts(M, S, SS'', ODS)
  if SS' := typeList2SortSet(TyL) /\
     SS'' := relatedSorts*(M, SS', SS' ; SS) .
 eq relatedSorts(M, S, SS, ODS) = SS [owise] .

 op typeList2SortSet : TypeList -> SortSet .
 eq typeList2SortSet(nil) = none .
 eq typeList2SortSet(K TyL) = typeList2SortSet(TyL) .
 eq typeList2SortSet(S TyL) = S ; typeList2SortSet(TyL) .

 op relatedSorts* : Module SortSet SortSet -> SortSet .
 eq relatedSorts*(M, none, SS) = SS .
 eq relatedSorts*(M, S ; SS, S ; SS') = relatedSorts*(M, SS, S ; SS') .
 ceq relatedSorts*(M, S ; SS, SS') = relatedSorts*(M, SS, SS'' ; SS')
  if SS'' := relatedSorts(M, S, SS') [owise] .

 sort SysCovRes .
 op __ : CoveragePair AllRulesInfo -> SysCovRes [ctor] .
 op ___ : CoveragePair SysTable SysInfo -> SysCovRes [ctor] .
 op ___ : CoveragePair CoveragePair AllRulesInfo -> SysCovRes [ctor] .

 op sysCov : Module TermSet Bound CoveragePair QidSet -> SysCovRes .
 eq sysCov(M, emptyTermSet, B, CP, QS) = CP empty empty .
 ceq sysCov(M, T | TS, B, CP, QS) = CP3 (T |-> CP2, ST) (createSysInfo(T, ARI), SI)
  if CP1 CP2 ARI := sysCoverage(M, T, B, CP, QS) /\
     CP3 ST SI := sysCov(M, TS, B, CP1, QS) .

 op sysCoverage : Module Term Bound CoveragePair QidSet -> SysCovRes .
 eq sysCoverage(M, T, B, CP, QS) =
              sysCoverage(M, < T . B >, CP, set2list(QS), cp(noCoverage, noCoverage), noInfo) .

 op sysCoverage : Module Queue CoveragePair QidList CoveragePair AllRulesInfo
                  -> SysCovRes .
 eq sysCoverage(M, QU, cp(noCoverage, noCoverage), QIL, CP, ARI) =
                                              cp(noCoverage, noCoverage) CP ARI .
 eq sysCoverage(M, nil, CP, QIL, CP', ARI) = CP CP' ARI .
 eq sysCoverage(M, < T . 0 > QU, CP, QIL, CP', ARI) = sysCoverage(M, QU, CP, QIL, CP', ARI) .
 ceq sysCoverage(M, < T . B > QU, CP1, QIL, CP2, ARI) =
                     sysCoverage(M, QU QU', CP1 \\\ CP3, QIL, CP2 && CP3, ARI ARI')
  if < QU', CP3, ARI' > := applyAllRules(M, T, B minus 1, QIL) [owise] .

 sort RuleAppRes .
 op <_,_,_> : Queue CoveragePair AllRulesInfo -> RuleAppRes [ctor] .

 op applyAllRules : Module Term Bound QidList -> RuleAppRes .
 eq applyAllRules(M, T, B, QIL) = applyAllRules(M, T, B, QIL, QIL, 0, < nil, cp(noCoverage, noCoverage), noInfo >) .

 op applyAllRules : Module Term Bound QidList QidList Nat RuleAppRes -> RuleAppRes .
 eq applyAllRules(M, T, B, nil, QIL, N, RAR) = RAR .
 ceq applyAllRules(M, T, B, Q QIL, QIL', N, < QU, cp(AC, AC'), ARI >) =
                  applyAllRules(M, T, B, Q QIL, QIL', s(N),
                                < QU < T1' . B >, cp(AC & C & C1 & Q, AC' & C2), ARI ARI' applied(Q, T, T1') >)
  if {T1, Ty, SB} := metaApply(M, T, Q, none, N) /\
     T1' := reduce(M, T1) /\
     *** R := getRightTerm(getRls(M), Q) /\
     cp(C1, C2) ARI' := applyAllRulesCond(M, substituteDD(M, getCondsRl(getRls(M), Q), SB),
                                       unbounded, QIL', cp(noCoverage, noCoverage) noInfo) /\
     C := globalCoverage(M, T1) &
          *** globalCoverage(M, R) &
          globalCoverageConds(M, substituteDD(M, getCondsRl(getRls(M), Q), SB)) .
 ceq applyAllRules(M, T, B, Q QIL, QIL', N, < QU, cp(AC, AC'), ARI >) =
                applyAllRules(M, T, B, QIL, QIL', 0,
                              < QU, cp(AC, AC' & C), ARI ARI' >)
  if C := if (N == 0 and negativeInfo(M, T, getRl(getRls(M), Q)))
          then Q
          else noCoverage
          fi /\
     ARI' := if (N == 0 and negativeInfo(M, T, getRl(getRls(M), Q)))
          then fail(Q, T)
          else noInfo
          fi [owise] .

 op getRl : RuleSet Qid ~> Rule .
 eq getRl(rl L => R [label(Q) AtS] . RS, Q) = rl L => R [AtS] . .
 eq getRl(crl L => R if COND [label(Q) AtS] . RS, Q) = crl L => R if COND [AtS] . .

 op negativeInfo : Module Term Rule -> Bool .
 ceq negativeInfo(M, T, rl L => R [AtS] .) = true
  if L' := term2kind(M, L) /\
     metaMatch(M, L', T, nil, 0) =/= noMatch .
 ceq negativeInfo(M, T, crl L => R if COND [AtS] .) = true
  if L' := term2kind(M, L) /\
     metaMatch(M, L', T, nil, 0) =/= noMatch .
 eq negativeInfo(M, T, Rl) = false [owise] .

 op applyAllRulesCond : Module Condition Bound QidList SysCovRes -> SysCovRes .
 eq applyAllRulesCond(M, nil, B, QIL, SCR) = SCR .
 eq applyAllRulesCond(M, T = T' /\ COND, B, QIL, SCR) =
                                         applyAllRulesCond(M, COND, B, QIL, SCR) .
 eq applyAllRulesCond(M, T := T' /\ COND, B, QIL, SCR) =
                                         applyAllRulesCond(M, COND, B, QIL, SCR) .
 ceq applyAllRulesCond(M, T => T' /\ COND, B, QIL, cp(AC, AC') ARI) =
                                         applyAllRulesCond(M, COND, B, QIL, cp(AC & C1, AC' & C2) (ARI ARI'))
  if < QU, cp(C1, C2), ARI' > := applyAllRules(M, T, B, QIL, QIL, 0, < nil, cp(noCoverage, noCoverage), noInfo >) .
 eq applyAllRulesCond(M, T : S /\ COND, B, QIL, SCR) = applyAllRulesCond(M, COND, B, QIL, SCR) .

 op neededCoverageRls : Module SortSet Bool -> CoveragePair .
 eq neededCoverageRls(M, none, HASMB?) = cp(noCoverage, noCoverage) .
 ceq neededCoverageRls(M, S ; SS, HASMB?) = cp(C & C1, C' & C2)
  if cp(C, C') := neededCoverageRl(M, S, HASMB?) /\
     cp(C1, C2) := neededCoverageRls(M, SS, HASMB?) .

 op neededCoverageRl : Module Sort Bool -> CoveragePair .
 eq neededCoverageRl(M, S, HASMB?) = neededCoverageRl(M, S, HASMB?, < empty, noCoverage >, getRls(M)) .

 op neededCoverageRl : Module Sort Bool CoverageResult RuleSet -> CoveragePair .
 ceq neededCoverageRl(M, S, false, CR, rl L => R [label(Q) AtS] . RS) = cp(Q & C1, C2)
  if sameKind(M, S, type(M, L)) /\
     CR' := globalCoverageTerm(M, R, CR) /\
     cp(C1, C2) := neededCoverageRl(M, S, false, CR', RS) .
 ceq neededCoverageRl(M, S, true, CR, rl L => R [label(Q) AtS] . RS) = cp(Q & C1, Q & C2)
  if sameKind(M, S, type(M, L)) /\
     CR' := globalCoverageTerm(M, R, CR) /\
     cp(C1, C2) := neededCoverageRl(M, S, true, CR', RS) .
 ceq neededCoverageRl(M, S, HASMB?, CR, crl L => R if COND [label(Q) AtS] . RS) = cp(Q & C1, Q & C2)
  if sameKind(M, S, type(M, L)) /\
     CR' := globalCoverageTerm(M, R, CR) /\
     CR'' := globalCoverageCond*(M, COND, CR') /\
     cp(C1, C2) := neededCoverageRl(M, S, HASMB?, CR'', RS) .
 eq neededCoverageRl(M, S, HASMB?, CR, RS) = cp(second(CR), noCoverage) [owise] .

 op getCondsRl : RuleSet Qid ~> Condition .
 eq getCondsRl(rl L => R [label(Q) AtS] . RS, Q) = nil .
 eq getCondsRl(crl L => R if COND [label(Q) AtS] . RS, Q) = COND .

 op getRightTerm : RuleSet Qid ~> Term .
 eq getRightTerm(rl L => R [label(Q) AtS] . RS, Q) = R .
 eq getRightTerm(crl L => R if COND [label(Q) AtS] . RS, Q) = R .

 op minimumSysCoverage : SysTable -> TermSet .
 ceq minimumSysCoverage((T |-> cp(C, C'), ST)) = minimumSysCoverage(ST)
  if cp(C1 & C, C2 & C') := getSysCoverage(ST) .
 eq minimumSysCoverage(ST) = sysEntries(ST) [owise] .

 op sysEntries : SysTable -> TermSet .
 eq sysEntries(empty) = emptyTermSet .
 eq sysEntries((T |-> cp(C, C'), ST)) = T | sysEntries(ST) .

 op getSysCoverage : SysTable -> CoveragePair .
 eq getSysCoverage(empty) = cp(noCoverage, noCoverage) .
 eq getSysCoverage((T |-> CP1, ST)) = CP1 && getSysCoverage(ST) .

 op insertOnlyIfNew : Term AllRulesInfo SysInfo -> SysInfo .
 eq insertOnlyIfNew(T, fail(Q, T1), (T |-> ARI fail(Q, T2), SI)) = (T |-> ARI fail(Q, T2), SI) .
 eq insertOnlyIfNew(T, applied(Q, T1, T1'), (T |-> ARI applied(Q, T2, T2'), SI)) =
                                                           (T |-> ARI applied(Q, T2, T2'), SI) .
 eq insertOnlyIfNew(T, RCI, (T |-> ARI, SI)) = T |-> ARI RCI, SI [owise] .
 eq insertOnlyIfNew(T, RCI, SI) = T |-> RCI, SI [owise] .

 op createSysInfo : Term AllRulesInfo -> SysInfo .
 eq createSysInfo(T, noInfo) = empty .
 eq createSysInfo(T, RCI ARI) = insertOnlyIfNew(T, RCI, createSysInfo(T, ARI)) .

 sort CallCoverageTuple .
 op <_,_,_> : TermSet TermSet CoverageInfo -> CallCoverageTuple [ctor] .

 op getCI : CallCoverageTuple -> CoverageInfo .
 eq getCI(< TS, TS', CI >) = CI .

 op selectTermsSys : Module Sort Bound QidSet Nat CoverageType -> CallCoverageTuple .
 eq selectTermsSys(M, S, B, QS, 0, CT) = < emptyTermSet, emptyTermSet, noCoverageInfo > .
 ceq selectTermsSys(M, S, B, QS, s(N), system) = selectTermsSys(M, S, B, N, TL, RCP, T, ST, SI)
  if gr(T, TL) := generateTerms(M, S, 1) /\
     cp(C, C') := neededCoverageRls(M, getSorts(M), hasMb?(M)) /\
     CP' := cp(C int qidset2coverage(QS), C' int qidset2coverage(QS)) /\
     RCP ST SI := sysCov(M, T, B, CP', extractLabels(getRls(M))) .
 ceq selectTermsSys(M, S, B, QS, s(N), CT) = selectTermsSys(M, S, B, N, TL, RCP, T, ST, SI)
  if gr(T, TL) := generateTerms(M, S, 1) /\
     cp(C, C') := neededCoverageRls(M, getSorts(M), hasMb?(M)) /\
     CP' := cp(C int qidset2coverage(QS), noCoverage) /\
     RCP ST SI := sysCov(M, T, B, CP', extractLabels(getRls(M))) [owise] .

 op selectTermsSys : Module Sort Bound Nat TermList CoveragePair TermSet SysTable
                     SysInfo -> CallCoverageTuple .
 ceq selectTermsSys(M, S, B, N, TL, cp(noCoverage, noCoverage), TS, ST, SI) =
                                  < TS, TS', sysCoverage(none, none, onlyMinimum(TS', SI)) >
  if TS' := minimumSysCoverage(ST) .
 ceq selectTermsSys(M, S, B, 0, TL, CP, TS, ST, SI) = < TS, TS', cp2ci(CP, TS', SI) >
  if TS' := minimumSysCoverage(ST) .
 ceq selectTermsSys(M, S, B, s(N), TL, CP, TS, ST, SI) =
                                 selectTermsSys(M, S, B, N, TL', RCP, (TS | T), (ST, ST'), (SI, SI'))
  if gr(T, TL') := generateTerms(M, S, 1, TL, empty) /\
     RCP ST' SI' := sysCov(M, T, B, CP, extractLabels(getRls(M))) [owise] .

 op onlyMinimum : TermSet SysInfo -> SysInfo .
 eq onlyMinimum(T | TS, (T |-> ARI, SI)) = T |-> ARI, onlyMinimum(TS, SI) .
 eq onlyMinimum(TS, SI) = empty [owise] .

 op cp2ci : CoveragePair TermSet SysInfo -> CoverageInfo .
 eq cp2ci(cp(C, C'), TS, SI) = sysCoverage(coverage2qidset(C), coverage2qidset(C'), onlyMinimum(TS, SI)) .

 op coverage2qidset : Coverage -> QidSet .
 eq coverage2qidset(noCoverage) = none .
 eq coverage2qidset(Q & C) = Q ; coverage2qidset(C) .

 op getTerms : CoverageInfo ~> TermSet .
 eq getTerms(sysCoverage(QS, QS', SI)) = getTerms(SI) .

 op getTerms : SysInfo -> TermSet .
 eq getTerms((T |-> ARI, SI)) = T | getTerms(SI) .
 eq getTerms((empty).SysInfo) = emptyTermSet .

 op set2list : QidSet -> QidList .
 eq set2list(Q ; QS) = Q set2list(QS) .
 eq set2list(none) = nil .

 op hasMb? : Module -> Bool .
 eq hasMb?(M) = hasMb?(getMbs(M)) .

 op hasMb? : MembAxSet -> Bool .
 eq hasMb?(none) = false .
 eq hasMb?(MAS) = true [owise] .
endfm

fmod TEST-PROPERTIES is
 pr SYSTEM-COVERAGE .
 pr SEARCH-TYPE .

 vars T PAT T' T1 T1' : Term .
 vars TL TL' : TermList .
 vars TS TS' : TermSet .
 vars M M' : Module .
 var  COND : Condition .
 var  B : Bound .
 var  STy : SearchType .
 vars LTC LTC' : List{TestCase} .
 vars Ty Ty' : Type .
 var  V : Variable .
 var  TGR : TestGenerationResult .
 var  Q : Qid .
 vars SB SB' : Substitution .
 var  SB? : [Substitution] .
 var  N : Nat .
 var  S : Sort .
 var  QS : QidSet .
 var  IL : ImportList .
 var  SS : SortSet .
 var  SSDS : SubsortDeclSet .
 var  ODS : OpDeclSet .
 var  OD : OpDecl .
 var  MAS : MembAxSet .
 var  EqS : EquationSet .
 var  Eq : Equation .
 var  RS : RuleSet .
 var  RT : ResultTriple .
 var  CT : CoverageType .
 vars CP CP' CP1 CP2 CP3 RCP : CoveragePair .
 vars QU QU' : Queue .
 vars ARI ARI' : AllRulesInfo .
 vars SI SI' : SysInfo .
 vars QIL QIL' : QidList .
 var  RAR : RuleAppRes .
 vars AC AC' C C' C1 C2 C3 : Coverage .
 vars ST ST' : SysTable .
 var  SCO : Set{CheckedOp} .
 var  CI : CoverageInfo .
 var  TC : TestCase .

***(%
\end{verbatim}
}



{\codesize
\begin{verbatim}
%)

 op sysCovInv : Module TermSet Bound CoveragePair QidSet Term Condition -> SysCovRes .
 eq sysCovInv(M, emptyTermSet, B, CP, QS, PAT, COND) = CP empty empty .
 ceq sysCovInv(M, T | TS, B, CP, QS, PAT, COND) = CP3 (T |-> CP2, ST) (createSysInfo(T, ARI), SI)
  if CP1 CP2 ARI := sysCoverageInv(M, T, B, CP, QS, PAT, COND) /\
     CP3 ST SI := sysCovInv(M, TS, B, CP1, QS, PAT, COND) .

 op sysCoverageInv : Module Term Bound CoveragePair QidSet Term Condition -> SysCovRes .
 eq sysCoverageInv(M, T, B, CP, QS, PAT, COND) =
              sysCoverageInv(M, < T . B >, CP, set2list(QS), cp(noCoverage, noCoverage), noInfo, PAT, COND) .

 op sysCoverageInv : Module Queue CoveragePair QidList CoveragePair AllRulesInfo Term Condition
                  -> SysCovRes .
 eq sysCoverageInv(M, QU, cp(noCoverage, noCoverage), QIL, CP, ARI, PAT, COND) =
                                              cp(noCoverage, noCoverage) CP ARI .
 eq sysCoverageInv(M, nil, CP, QIL, CP', ARI, PAT, COND) = CP CP' ARI .
 eq sysCoverageInv(M, < T . 0 > QU, CP, QIL, CP', ARI, PAT, COND) =
                              sysCoverageInv(M, QU, CP, QIL, CP', ARI, PAT, COND) .
 ceq sysCoverageInv(M, < T . B > QU, CP1, QIL, CP2, ARI, PAT, COND) =
                     sysCoverageInv(M, QU QU', CP1 \\\ CP3, QIL, CP2 && CP3, ARI ARI', PAT, COND)
  if < QU', CP3, ARI' > := applyAllRulesInv(M, T, B minus 1, QIL, PAT, COND) [owise] .

 op applyAllRulesInv : Module Term Bound QidList Term Condition -> RuleAppRes .
 eq applyAllRulesInv(M, T, B, QIL, PAT, COND) =
          applyAllRulesInv(M, T, B, QIL, QIL, 0, PAT, COND, < nil, cp(noCoverage, noCoverage), noInfo >) .

 op applyAllRulesInv : Module Term Bound QidList QidList Nat Term Condition RuleAppRes -> RuleAppRes .
 eq applyAllRulesInv(M, T, B, nil, QIL, N, PAT, COND, RAR) = RAR .
 ceq applyAllRulesInv(M, T, B, Q QIL, QIL', N, PAT, COND, < QU, cp(AC, AC'), ARI >) =
                  applyAllRulesInv(M, T, B, Q QIL, QIL', s(N), PAT, COND,
                                < QU < T1' . B >, cp(AC & C & C1 & Q & C3, AC' & C2), ARI ARI' applied(Q, T, T1') >)
  if {T1, Ty, SB} := metaApply(M, T, Q, none, N) /\
     T1' := reduce(M, T1) /\
     cp(C1, C2) ARI' := applyAllRulesCond(M, substituteDD(M, getCondsRl(getRls(M), Q), SB),
                                       unbounded, QIL', cp(noCoverage, noCoverage) noInfo) /\
     *** The coverage generated by the condition of the invariant
     SB' := metaMatch(M, PAT, T1', nil, 0) /\
     C3 := globalCoverageConds(M, substituteDD(M, COND, SB')) /\
     C := globalCoverage*(M, T1)[T1] &
          globalCoverageConds(M, substituteDD(M, getCondsRl(getRls(M), Q), SB)) .
 ceq applyAllRulesInv(M, T, B, Q QIL, QIL', N, PAT, COND, < QU, cp(AC, AC'), ARI >) =
                applyAllRulesInv(M, T, B, QIL, QIL', 0, PAT, COND,
                              < QU, cp(AC, AC' & C), ARI ARI' >)
  if C := if (N == 0 and negativeInfo(M, T, getRl(getRls(M), Q)))
          then Q
          else noCoverage
          fi /\
     ARI' := if (N == 0 and negativeInfo(M, T, getRl(getRls(M), Q)))
          then fail(Q, T)
          else noInfo
          fi [owise] .

 op selectTermsInv : Module Sort Bound QidSet Nat CoverageType Term Condition -> CallCoverageTuple .
 eq selectTermsInv(M, S, B, QS, 0, CT, PAT, COND) = < emptyTermSet, emptyTermSet, noCoverageInfo > .
 ceq selectTermsInv(M, S, B, QS, s(N), system, PAT, COND) =
                                  selectTermsInv(M, S, B, N, TL, RCP, T, ST, SI, PAT, COND)
  if gr(T, TL) := generateTerms(M, S, 1) /\
     cp(C, C') := neededCoverageRls(M, getSorts(M), hasMb?(M)) /\
     < SCO, C1 > := globalCoverageCond*(M, COND, < empty, noCoverage >) /\
     CP' := cp((C & C1) int qidset2coverage(QS), C' int qidset2coverage(QS)) /\
     RCP ST SI := sysCovInv(M, T, B, CP', extractLabels(getRls(M)), PAT, COND) .
 ceq selectTermsInv(M, S, B, QS, s(N), CT, PAT, COND) =
                                  selectTermsInv(M, S, B, N, TL, RCP, T, ST, SI, PAT, COND)
  if gr(T, TL) := generateTerms(M, S, 1) /\
     cp(C, C') := neededCoverageRls(M, getSorts(M), hasMb?(M)) /\
     < SCO, C1 > := globalCoverageCond*(M, COND, < empty, noCoverage >) /\
     CP' := cp((C & C1) int qidset2coverage(QS), noCoverage) /\
     RCP ST SI := sysCovInv(M, T, B, CP', extractLabels(getRls(M)), PAT, COND) [owise] .

 op selectTermsInv : Module Sort Bound Nat TermList CoveragePair TermSet SysTable
                     SysInfo Term Condition -> CallCoverageTuple .
 ceq selectTermsInv(M, S, B, N, TL, cp(noCoverage, noCoverage), TS, ST, SI, PAT, COND) =
                                  < TS, TS', sysCoverage(none, none, onlyMinimum(TS', SI)) >
  if TS' := minimumSysCoverage(ST) .
 ceq selectTermsInv(M, S, B, 0, TL, CP, TS, ST, SI, PAT, COND) = < TS, TS', cp2ci(CP, TS', SI) >
  if TS' := minimumSysCoverage(ST) .
 ceq selectTermsInv(M, S, B, s(N), TL, CP, TS, ST, SI, PAT, COND) =
                          selectTermsInv(M, S, B, N, TL', RCP, (TS | T), (ST, ST'), (SI, SI'), PAT, COND)
  if gr(T, TL') := generateTerms(M, S, 1, TL, empty) /\
     RCP ST' SI' := sysCovInv(M, T, B, CP, extractLabels(getRls(M)), PAT, COND) [owise] .

 op testInvariant : Module Sort Term Condition SearchType Bound QidSet Nat CoverageType
                    -> TestGenerationResult .
 ceq testInvariant(M, S, PAT, COND, STy, B, QS, N, CT) =
                                           < testInvariant(M, PAT, COND, STy, B, QS, TS), CI >
  if CI := getCI(selectTermsInv(M, S, B, QS, N, CT, PAT, COND)) /\
     TS := getTerms(CI) .

 op testInvariant : Module Term Condition SearchType Bound QidSet TermSet -> List{TestCase} .
 eq testInvariant(M, PAT, COND, STy, B, QS, emptyTermSet) = nil .
 ceq testInvariant(M, PAT, COND, STy, B, QS, TS | T) =
                           if fulfill?(TC)
                           then TC testInvariant(M, PAT, COND, final, B, QS, TS)
                           else TC allUnchecked(TS)
                           fi
  if Q := if STy == final
          then '!
          else if STy == zeroOrMore
               then '*
               else '+
               fi
          fi /\
     TC := testInvariant(M, T, PAT, COND, B, Q) .

 op testInvariant : Module Term Term Condition Bound Qid -> TestCase .
 ceq testInvariant(M, T, PAT, COND, B, Q) = < T, T', failureProp >
  if {T', Ty, SB} := metaSearch(M, T, PAT, COND, Q, B, 0) .
 eq testInvariant(M, T, PAT, COND, B, Q) = < T, T, fulfillProp > [owise] .

 op allUnchecked : TermSet -> List{TestCase} .
 eq allUnchecked(T | TS) = < T, T, uncheckedProp > allUnchecked(TS) .
 eq allUnchecked(emptyTermSet) = nil .
endfm

fmod LTL-SYNTAX is
 sort @Formula@ .
 subsort Bool < @Formula@ .

 *** primitive LTL operators
 *** ops True False : -> @Formula@ [ctor format (g o)] .
 op ~_ : @Formula@ -> @Formula@ [ctor prec 53 format (r o d)] .
 op _/\_ : @Formula@ @Formula@ -> @Formula@ [comm ctor gather (E e) prec 55 format (d r o d)] .
 op _\/_ : @Formula@ @Formula@ -> @Formula@ [comm ctor gather (E e) prec 59 format (d r o d)] .
 op O_ : @Formula@ -> @Formula@ [ctor prec 53 format (r o d)] .
 op _U_ : @Formula@ @Formula@ -> @Formula@ [ctor prec 63 format (d r o d)] .
 op _R_ : @Formula@ @Formula@ -> @Formula@ [ctor prec 63 format (d r o d)] .

 *** defined LTL operators
 op _->_ : @Formula@ @Formula@ -> @Formula@ [gather (e E) prec 65 format (d r o d)] .
 op _<->_ : @Formula@ @Formula@ -> @Formula@ [prec 65 format (d r o d)] .
 op <>_ : @Formula@ -> @Formula@ [prec 53 format (r o d)] .
 op []_ : @Formula@ -> @Formula@ [prec 53 format (r d o d)] .
 op _W_ : @Formula@ @Formula@ -> @Formula@ [prec 63 format (d r o d)] .
 op _|->_ : @Formula@ @Formula@ -> @Formula@ [prec 63 format (d r o d)] . *** leads-to
 op _=>_ : @Formula@ @Formula@ -> @Formula@ [gather (e E) prec 65 format (d r o d)] .
 op _<=>_ : @Formula@ @Formula@ -> @Formula@ [prec 65 format (d r o d)] .
endfm

fmod TEST-MODEL-CHECK is
 pr TEST-PROPERTIES .
 *** pr LTL-SYNTAX .

 vars M M' M'' MCM : Module .
 vars T T' T1 T2 T1' T2' PAT F F' : Term .
 vars Q Q' : Qid .
 vars TL TL' : TermList .
 vars V V' : Variable .
 vars C C' : Constant .
 var  S : Sort .
 var  QIL : QidList .
 var  QS : QidSet .
 var  IL : ImportList .
 var  SS : SortSet .
 var  SSD : SubsortDecl .
 var  SSDS : SubsortDeclSet .
 var  OD : OpDecl .
 var  ODS : OpDeclSet .
 var  MAS : MembAxSet .
 var  Eq : Equation .
 var  EqS : EquationSet .
 var  RS : RuleSet .
 vars N N' : Nat .
 vars TS AT : TermSet .
 var  NL : NatList .
 var  TyL : TypeList .
 var  Ty : Type .
 var  AtS : AttrSet .
 var  B : Bound .
 var  CT : CoverageType .
 var  COND : Condition .
 var  CI : CoverageInfo .

 op atoms : Term -> TermSet .
 eq atoms('true.Bool) = emptyTermSet .
 eq atoms('false.Bool) = emptyTermSet .
 eq atoms('~_[T]) = atoms(T) .
 eq atoms('_/\_[T1, T2]) = atoms(T1) | atoms(T2) .
 eq atoms('_\/_[T1, T2]) = atoms(T1) | atoms(T2) .
 eq atoms('O_[T]) = atoms(T) .
 eq atoms('_U_[T1, T2]) = atoms(T1) | atoms(T2) .
 eq atoms('_R_[T1, T2]) = atoms(T1) | atoms(T2) .
 eq atoms('_->_[T1, T2]) = atoms(T1) | atoms(T2) .
 eq atoms('_<->_[T1, T2]) = atoms(T1) | atoms(T2) .
 eq atoms('<>_[T]) = atoms(T) .
 eq atoms('`[`]_[T]) = atoms(T) .
 eq atoms('_W_[T1, T2]) = atoms(T1) | atoms(T2) .
 eq atoms('_|->_[T1, T2]) = atoms(T1) | atoms(T2) .
 eq atoms('_=>_[T1, T2]) = atoms(T1) | atoms(T2) .
 eq atoms('_<=>_[T1, T2]) = atoms(T1) | atoms(T2) .
 eq atoms(V) = emptyTermSet .
 eq atoms(T) = T [owise] .

***(%

The function \verb"@formula@2formula" receives the pattern given in the command and the term
standing for a \verb"@Formula@" and returns a term standing for a valid \verb"Formula" to
perform model checking:


{\codesize
\begin{verbatim}
%)

 op @formula@2formula : Term Term -> Term .
 eq @formula@2formula(PAT, 'true.Bool) = 'True.Formula .
 eq @formula@2formula(PAT, 'false.Bool) = 'False.Formula .
 ceq @formula@2formula(PAT, '~_[T]) = '~_[T']
  if T' := @formula@2formula(PAT, T) .
 ceq @formula@2formula(PAT, '_/\_[T1, T2]) = '_/\_[T1', T2']
  if T1' := @formula@2formula(PAT, T1) /\
     T2' := @formula@2formula(PAT, T2) .
 ceq @formula@2formula(PAT, '_\/_[T1, T2]) = '_\/_[T1', T2']
  if T1' := @formula@2formula(PAT, T1) /\
     T2' := @formula@2formula(PAT, T2) .
 ceq @formula@2formula(PAT, 'O_[T]) = 'O_[T']
  if T' := @formula@2formula(PAT, T) .
 ceq @formula@2formula(PAT, '_U_[T1, T2]) = '_U_[T1', T2']
  if T1' := @formula@2formula(PAT, T1) /\
     T2' := @formula@2formula(PAT, T2) .
 ceq @formula@2formula(PAT, '_R_[T1, T2]) = '_R_[T1', T2']
  if T1' := @formula@2formula(PAT, T1) /\
     T2' := @formula@2formula(PAT, T2) .
 ceq @formula@2formula(PAT, '_->_[T1, T2]) = '_->_[T1', T2']
  if T1' := @formula@2formula(PAT, T1) /\
     T2' := @formula@2formula(PAT, T2) .
 ceq @formula@2formula(PAT, '_<->_[T1, T2]) = '_<->_[T1', T2']
  if T1' := @formula@2formula(PAT, T1) /\
     T2' := @formula@2formula(PAT, T2) .
 ceq @formula@2formula(PAT, '<>_[T]) = '<>_[T']
  if T' := @formula@2formula(PAT, T) .
 ceq @formula@2formula(PAT, '`[`]_[T]) = '`[`]_[T']
  if T' := @formula@2formula(PAT, T) .
 ceq @formula@2formula(PAT, '_W_[T1, T2]) = '_W_[T1', T2']
  if T1' := @formula@2formula(PAT, T1) /\
     T2' := @formula@2formula(PAT, T2) .
 ceq @formula@2formula(PAT, '_|->_[T1, T2]) = '_|->_[T1', T2']
  if T1' := @formula@2formula(PAT, T1) /\
     T2' := @formula@2formula(PAT, T2) .
 ceq @formula@2formula(PAT, '_=>_[T1, T2]) = '_=>_[T1', T2']
  if T1' := @formula@2formula(PAT, T1) /\
     T2' := @formula@2formula(PAT, T2) .
 ceq @formula@2formula(PAT, '_<=>_[T1, T2]) = '_<=>_[T1', T2']
  if T1' := @formula@2formula(PAT, T1) /\
     T2' := @formula@2formula(PAT, T2) .
 eq @formula@2formula(PAT, C) = qid(string(getName(C)) + ".Prop") .
 eq @formula@2formula(PAT, T) = transformTerm(PAT, T) [owise] .

 op transformTerm : Term Term -> Term .
 ceq transformTerm(PAT, Q[TL]) = if TL' == empty
                                 then qid(string(Q') + ".Prop")
                                 else Q'[TL']
                                 fi
  if Q' := propName(Q) /\
     TL' := transformTerm*(PAT, TL) .
 eq transformTerm(PAT, T) = T [owise] .

 op transformTerm* : Term TermList -> TermList .
 eq transformTerm*(PAT, empty) = empty .
 eq transformTerm*(PAT, (T, TL)) = if usesPart(PAT, T)
                                   then transformTerm*(PAT, TL)
                                   else T, transformTerm*(PAT, TL)
                                   fi .

 op createMCModule : Module Sort Term Term -> Module .
 ceq createMCModule(M, S, PAT, F) = M'
  if MCM := addSubsort(moduleWithLTL(M), subsort S < 'State .) /\
     M' := addOps&Eqs*(M, PAT, atoms(F), MCM) .

 op addOps&Eqs* : Module Term TermSet Module -> Module .
 eq addOps&Eqs*(M, PAT, emptyTermSet, MCM) = MCM .
 ceq addOps&Eqs*(M, PAT, T | TS, MCM) = addOps&Eqs*(M, PAT, TS, M')
  if M' := addOps&Eqs(M, PAT, T, MCM) .

 op addOps&Eqs : Module Term Term Module -> Module .
 ceq addOps&Eqs(M, PAT, Q[TL], MCM) = addEq(addOp(MCM, OD), Eq)
  if NL := argumentsRelatedPat(PAT, Q[TL]) /\
     OD := pruneOp*(getOps(M), Q, NL) /\
     Q' := propName(Q) /\
     TL' := removeArguments(TL, NL) /\
     Eq := if TL' == empty
           then eq '_|=_[PAT, qid(string(Q') + ".Prop")] = Q[TL] [none] .
           else eq '_|=_[PAT, Q'[TL']] = Q[TL] [none] .
           fi .
 ceq addOps&Eqs(M, PAT, C, MCM) = addEq(addOp(MCM, OD), Eq)
  if Q := propName(getName(C)) /\
     OD := op Q : nil -> 'Prop [none] . /\
     C' := qid(string(Q) + ".Prop") /\
     Eq := eq '_|=_[PAT, C'] = C [none] . .
 eq addOps&Eqs(M, PAT, V, MCM) = MCM .

 op pruneOp* : OpDeclSet Qid NatList ~> OpDecl .
 eq pruneOp*(op Q : TyL -> Ty [AtS] . ODS, Q, NL) = pruneOp(op Q : TyL -> Ty [AtS] ., NL) .

 op pruneOp : OpDecl NatList -> OpDecl .
 eq pruneOp(op Q : TyL -> Ty [AtS] ., NL) =
                               op propName(Q) : removeArity(TyL, NL) -> 'Prop [AtS] . .

 op removeArity : TypeList NatList -> TypeList .
 eq removeArity(TyL, NL) = removeArity(TyL, NL, 0) .

 op removeArity : TypeList NatList Nat -> TypeList .
 eq removeArity(Ty TyL, N NL, N') = if N == N'
                                    then removeArity(TyL, NL, s(N'))
                                    else Ty removeArity(TyL, N NL, s(N'))
                                    fi .
 eq removeArity(TyL, NL, N) = TyL [owise] .

 op removeArguments : TermList NatList -> TermList .
 eq removeArguments(TL, NL) = removeArguments(TL, NL, 0) .

 op removeArguments : TermList NatList Nat -> TermList .
 eq removeArguments((T, TL), N NL, N') = if N == N'
                                         then removeArguments(TL, NL, s(N'))
                                         else T, removeArguments(TL, N NL, s(N'))
                                         fi .
 eq removeArguments(TL, NL, N) = TL [owise] .

***(%

The function \verb"propName" adds the suffix \verb"Prop" to the given quoted identifier:

{\codesize
\begin{verbatim}
%)

 op propName : Qid -> Qid .
 eq propName(Q) = qid(string(Q) + "Prop") .

***(%

\end{verbatim}
}

The function \verb"usesPart" indicates whether the first term received as argument
uses a subterm of the second argument:

{\codesize
\begin{verbatim}
%)

 op usesPart : Term Term -> Bool .
 eq usesPart(Q[TL], T) = subterm(Q[TL], T) or-else usesPart*(TL, T) .
 eq usesPart(T, T') = subterm(T, T') [owise] .

 op usesPart* : TermList Term -> Bool .
 eq usesPart*(empty, T) = false .
 eq usesPart*((T, TL), T') = usesPart(T, T') or-else usesPart*(TL, T') .

***(%

The function \verb"subterm" indicates whether the first argument is a subterm of
the second one:

{\codesize
\begin{verbatim}
%)

 op subterm : Term Term -> Bool .
 eq subterm(T, T) = true .
 ceq subterm(T, Q[TL]) = subterm*(T, TL)
  if Q[TL] =/= T .
 eq subterm(T, T') = false [owise] .

 op subterm* : Term TermList -> Bool .
 eq subterm*(T, empty) = false .
 eq subterm*(T', (T, TL)) = subterm(T, T') or-else subterm*(T', TL) .

***(%

The function \verb"argumentsRelatedPat" receives the pattern given in the model
checking command and a term standing for one of the propositions and returns a
list of natural numbers indicating the positions where a relation is found.

{\codesize
\begin{verbatim}
%)

 op argumentsRelatedPat : Term Term -> NatList .
 eq argumentsRelatedPat(PAT, Q[TL]) = argumentsRelatedPat(PAT, TL, 0) .
 eq argumentsRelatedPat(PAT, T) = nil [owise] .

 op argumentsRelatedPat : Term TermList Nat -> NatList .
 eq argumentsRelatedPat(PAT, (T, TL), N) = if usesPart(T, PAT)
                                           then N argumentsRelatedPat(PAT, TL, s(N))
                                           else argumentsRelatedPat(PAT, TL, s(N))
                                           fi .
 eq argumentsRelatedPat(PAT, empty, N) = nil .

 op testMC : Module Sort Term Term Bound QidSet Nat CoverageType -> TestGenerationResult .
 ceq testMC(M, S, PAT, F, B, QS, N, CT) = < testMC(MCM, F', TS), CI >
  if MCM := createMCModule(M, S, PAT, F) /\
     AT := atoms(F) /\
     CI := getCI(selectTermsInv(M, S, B, QS, N, CT, PAT, createCondition(AT))) /\
     TS := getTerms(CI) /\
     F' := @formula@2formula(PAT, F) .

 op testMC : Module Term TermSet -> List{TestCase} .
 eq testMC(M, F, emptyTermSet) = nil .
 ceq testMC(M, F, (T | TS)) =
        if T' == 'true.Bool
        then < T, T, fulfillPropMC > testMC(M, F, TS)
        else < T, T', failurePropMC >
        fi
  if T' := reduce(M, 'modelCheck[T, F]) .
 eq testMC(M, F, (T | TS)) = testMC(M, F, TS) [owise] .

 op createTerm* : Module TermSet ~> Term .
 eq createTerm*(M, (T | T' | TL)) = '_or_[T, createTerm*(M, (T' | TL))] .
 eq createTerm*(M, T) = T .

 op createCondition : TermSet -> Condition .
 eq createCondition(emptyTermSet) = nil .
 eq createCondition(T | TS) = T = 'true.Bool /\ createCondition(TS) .

 op addOp : Module OpDecl -> Module .
 eq addOp(fmod Q is IL sorts SS . SSDS ODS MAS EqS endfm, OD) =
             fmod Q is IL sorts SS . SSDS OD ODS MAS EqS endfm .
 eq addOp(mod Q is IL sorts SS . SSDS ODS MAS EqS RS endm, OD) =
            mod Q is IL sorts SS . SSDS OD ODS MAS EqS RS endm .

 op addSubsort : Module SubsortDecl -> Module .
 eq addSubsort(fmod Q is IL sorts SS . SSDS ODS MAS EqS endfm, SSD) =
                 fmod Q is IL sorts SS . SSDS SSD ODS MAS EqS endfm .
 eq addSubsort(mod Q is IL sorts SS . SSDS ODS MAS EqS RS endm, SSD) =
                mod Q is IL sorts SS . SSDS SSD ODS MAS EqS RS endm .

 op addEq : Module Equation -> Module .
 eq addEq(fmod Q is IL sorts SS . SSDS ODS MAS EqS endfm, Eq) =
             fmod Q is IL sorts SS . SSDS ODS MAS EqS Eq endfm .
 eq addEq(mod Q is IL sorts SS . SSDS ODS MAS EqS RS endm, Eq) =
            mod Q is IL sorts SS . SSDS ODS MAS EqS Eq RS endm .

 op moduleWithLTL : Module -> Module .
 eq moduleWithLTL(fmod Q is IL sorts SS . SSDS ODS MAS EqS endfm) =
             fmod Q is protecting 'MODEL-CHECKER . IL sorts SS . SSDS removeTruthOps(ODS) MAS EqS endfm .
 eq moduleWithLTL(mod Q is IL sorts SS . SSDS ODS MAS EqS RS endm) =
            mod Q is protecting 'MODEL-CHECKER . IL sorts SS . SSDS removeTruthOps(ODS) MAS EqS RS endm .

 op removeTruthOps : OpDeclSet -> OpDeclSet .
 eq removeTruthOps(op '_==_ : TyL -> Ty [AtS] . ODS) = removeTruthOps(ODS) .
 eq removeTruthOps(op '_=/=_ : TyL -> Ty [AtS] . ODS) = removeTruthOps(ODS) .
 eq removeTruthOps(op 'if_then_else_fi : TyL -> Ty [AtS] . ODS) = removeTruthOps(ODS) .
 eq removeTruthOps(ODS) = ODS [owise] .

endfm

fmod TEST-CONFORMANCE is
 pr BOUND-WITH-MINUS .
 pr SYSTEM-COVERAGE .
 pr LIST{TestCase} .
 pr MODULES .
 pr TERMSET .

 var  N N' : Nat .
 vars M UM CM : Module .
 var  TS : TermSet .
 vars T T' PAT OT T1 T2 T3 T4 : Term .
 var  V : Variable .
 var  Ty Ty1 Ty2 : Type .
 var  B : Bound .
 var  SB SB1 SB2 : Substitution .
 var  RT? : ResultTriple? .
 var  S : Sort .
 var  Q : Qid .
 var  QS : QidSet .
 var  CT : CoverageType .
 var  CI : CoverageInfo .
 var  AtS : AttrSet .
 var  RS : RuleSet .
 var  CND : Condition .
 vars QIL QIL' sigma : QidList .
 vars LTC LTC' : List{TestCase} .

 op testConformance : Module Module Sort Bound QidSet Nat CoverageType -> TestGenerationResult .
 ceq testConformance(UM, CM, S, B, QS, N, CT) =
                                 < testConformance*(UM, CM, TS, B, QIL), CI >
  if CI := getCI(selectTermsSys(CM, S, B, QS, N, CT)) /\
     TS := getTerms(CI) /\
     QIL := intQSQIL(QS, ruleLabels(getRls(CM))) .

 *** User module --- Conformance module
 op testConformance* : Module Module TermSet Bound QidList -> List{TestCase} .
 eq testConformance*(UM, CM, emptyTermSet, B, QIL) = nil .
 eq testConformance*(UM, CM, T | TS, B, QIL) = testConformance(UM, T, CM, T, B, QIL, QIL, nil, T)
                                               testConformance*(UM, CM, TS, B, QIL) .

 op testConformance : Module Term Module Term Bound QidList QidList QidList Term -> List{TestCase} .
 eq testConformance(UM, T, CM, T', 0, QIL, QIL', sigma, OT) = < OT, OT, okConformance > .
 eq testConformance(UM, T, CM, T', B, nil, QIL, sigma, OT) = < OT, OT, okConformance > .
 ceq testConformance(UM, T, CM, T', B, Q QIL, QIL', sigma, OT) =
                                          testConformance(UM, T, CM, T', B, QIL, QIL', sigma, OT)
  if B =/= 0 /\
     metaApply(UM, T, Q, none, 0) == failure /\
     metaApply(CM, T', Q, none, 0) == failure .
 ceq testConformance(UM, T, CM, T', B, Q QIL, QIL', sigma, OT) =
         if LTC == < OT, OT, okConformance >
         then testConformance(UM, T, CM, T', B, QIL, QIL', sigma, OT)
         else LTC
         fi
  if B =/= 0 /\
     LTC := testConformance(UM, T, 0, CM, T', 0, B minus 1, Q, QIL', sigma Q, OT, nil) [owise] .

 op testConformance : Module Term Nat Module Term Nat Bound Qid QidList QidList Term List{TestCase}
                      -> List{TestCase} .
 ceq testConformance(UM, T, N, CM, T', N', B, Q, QIL, sigma, OT, LTC) =
           if LTC == nil
           then < OT, OT, okConformance >
           else LTC
           fi
  if metaApply(CM, T', Q, none, N') == failure .
 ceq testConformance(UM, T, N, CM, T', N', B, Q, QIL, sigma, OT, LTC) =
           if LTC == nil
           then failureConformance(OT, sigma, T, T')
           else LTC
           fi
  if metaApply(UM, T, Q, none, N) == failure .
 ceq testConformance(UM, T, N, CM, T', N', B, Q, QIL, sigma, OT, LTC) =
                            if LTC' == < OT, OT, okConformance >
                            then LTC'
                            else testConformance(UM, T, s(N), CM, T', N', B, Q, QIL, sigma, OT, LTC')
                            fi
  if {T1, Ty1, SB1} := metaApply(UM, T, Q, none, N) /\
     T3 := reduce(UM, T1) /\
     {T2, Ty2, SB2} := metaApply(CM, T', Q, none, N') /\
     T4 := reduce(CM, T2) /\
     LTC' := testConformance(UM, T3, CM, T4, B, QIL, QIL, sigma, OT) .

 op ruleLabels : RuleSet -> QidList .
 eq ruleLabels(rl T => T' [label(Q) AtS] . RS) = Q ruleLabels(RS) .
 eq ruleLabels(crl T => T' if CND [label(Q) AtS] . RS) = Q ruleLabels(RS) .
 eq ruleLabels(RS) = nil [owise] .

 op intQSQIL : QidSet QidList -> QidList .
 eq intQSQIL(QS, nil) = nil .
 eq intQSQIL(Q ; QS, Q QIL) = Q intQSQIL(QS, QIL) .
 eq intQSQIL(QS, Q QIL) = intQSQIL(QS, QIL) [owise] .
endfm

fmod TEST-GENERATION is
 pr PAIR{TermsTable,TermList} * (sort Pair{TermsTable,TermList} to TermsGeneratedPair) .
 pr TEST-CONFORMANCE .
 pr TEST-MODEL-CHECK .
 pr GLOBAL-COVERAGE .
 pr TEST-PROPERTIES .
 pr SYSTEM-COVERAGE .
 pr TERM-GENERATION .
 pr COVERAGE-TYPE .
 pr CALL-COVERAGE .
 pr MB-COVERAGE .

 vars N N' AC AC' : Nat .
 vars M M' CM LM : Module .
 vars Q Q' L : Qid .
 vars T T' T'' T1 T2 PAT F : Term .
 var  COND : Condition .
 vars TT TT' TT'' : TermsTable .
 vars SS SS' SBS SPS : SortSet .
 vars S S' : Sort .
 var  K : Kind .
 vars TS TS' TS'' TS3 : TermSet .
 var  TTE? : [TermsTableEntry] .
 vars ODS ODS' : OpDeclSet .
 var  OD : OpDecl .
 vars Ty Ty' Ty1 Ty2 : Type .
 vars TyL TyL' : TypeList .
 vars TL TL' : TermList .
 vars AttrS AttrS' AtS : AttrSet .
 var  CONST : Constant .
 vars CT CT' : CoverageTable .
 vars C C' C'' : Coverage .
 var  V : Variable .
 vars LTC LTC' : List{TestCase} .
 var  MM : Maybe{Module} .
 var  CTy : CoverageType .
 vars SC SC1 SC2 : Set{Call} .
 var  CCT : CallCoverageTable .
 var  CI : CoverageInfo .
 var  MCT : MbCoverageTable .
 var  MBC : MbCoverage .
 vars CP CP' RCP : CoveragePair .
 var  QS : QidSet .
 var  Eq : Equation .
 var  EqS : EquationSet .
 vars ST ST' : SysTable .
 vars SI SI' : SysInfo .
 var  B : Bound .
 var  ARI : AllRulesInfo .
 var  STy : SearchType .
 vars OT OT' : OpsTable .
 vars CtT CtT' CtT'' : ConsTable .
 var  NL : NatList .

 op _-ts_ : TermSet TermSet -> TermSet .
 eq (T | TS) -ts (T | TS') = TS -ts TS' .
 eq TS -ts TS' = TS [owise] .

 op sizeTS : TermSet -> Nat .
 eq sizeTS(emptyTermSet) = 0 .
 eq sizeTS(T | TS) = s(sizeTS(TS)) .

 op haveLesserSort : Module TermSet SortSet -> TermSet .
 ceq haveLesserSort(M, T | TS, S ; SS) = T | haveLesserSort(M, TS, S ; SS)
  if S := type(M, T) .
 eq haveLesserSort(M, TS, SS) = emptyTermSet [owise] .

 op getTermsOfSort : TermsTable Sort -> TermSet .
 ceq getTermsOfSort(TT, S) = TS | getTermsWithSubsort(TT, S)
  if [SBS, SPS, TS] := TT[S] .
 eq getTermsOfSort(TT, S) = getTermsWithSubsort(TT, S) [owise] .

 op getTermsWithSubsort : TermsTable Sort -> TermSet .
 eq getTermsWithSubsort((S |-> [S' ; SBS, SPS, TS], TT), S') = TS | getTermsWithSubsort(TT, S') .
 eq getTermsWithSubsort(TT, S) = emptyTermSet [owise] .

 op generateTestCases : Module Maybe{Module} TermSet -> List{TestCase} .
 eq generateTestCases(M, MM, emptyTermSet) = nil .
 ceq generateTestCases(M, MM, T | TS) = < T, T', noInfo > LTC
  if T' := reduce(M, T) /\
     LTC := generateTestCases(M, MM, TS) .

 op selectTermsCC : Module Qid TypeList Type Qid TypeList QidSet Nat -> CallCoverageTuple .
 ceq selectTermsCC(M, Q, TyL, Ty, Q', TyL', QS, s(N)) =
                          selectTermsCC(M, Q, TyL, Ty, Q', TyL', N, TL, SC2, T, QS)
  if gr(T, TL) := generateTermsOp(M, Q, 1) /\
     T' := createTerm(M, Q', TyL') /\
     SC := keepSuspicious(requiredCallCoverage(M, T'), QS) /\
     CCT := callCoverage(M, T, Q', TyL') /\
     SC1 := totalCoverage(CCT) /\
     SC2 := SC \\\ SC1 .
 eq selectTermsCC(M, Q, TyL, Ty, Q', TyL', QS, 0) = < emptyTermSet, emptyTermSet, noCoverageInfo > .

 op selectTermsCC : Module Qid TypeList Type Qid TypeList Nat TermList Set{Call} TermSet QidSet
                    -> CallCoverageTuple .
 eq selectTermsCC(M, Q, TyL, Ty, Q', TyL', 0, TL, SC, TS, QS) =
         < TS, minimumCallCoverage(keepSuspiciousCCT(callCoverage(M, TS, Q', TyL'), QS)), callCoverage(SC) > .
 eq selectTermsCC(M, Q, TyL, Ty, Q', TyL', N, TL, empty, TS, QS) =
      < TS, minimumCallCoverage(keepSuspiciousCCT(callCoverage(M, TS, Q', TyL'), QS)), callCoverage(empty) > .
 ceq selectTermsCC(M, Q, TyL, Ty, Q', TyL', s(N), TL, SC, TS, QS) =
                                selectTermsCC(M, Q, TyL, Ty, Q', TyL', N, TL', SC2, (TS | T), QS)
  if gr(T, TL') := generateTerms(M, Ty, 1, TL, empty) /\
     CCT := callCoverage(M, T, Q', TyL') /\
     SC1 := totalCoverage(CCT) /\
     SC2 := SC \\\ SC1 [owise] .

 op selectTermsMb : Module Sort QidSet Nat -> CallCoverageTuple .
 ceq selectTermsMb(M, S, QS, s(N)) = selectTermsMb(M, S, N, TL, CP \\\ CP', T)
  if gr(T, TL) := generateTerms(M, S, 1) /\
     MCT := mbCoverage(M, T, S) /\
     CP := neededMbCoverage(M, S) /\
     CP' := getMbCoverage(MCT) .
 eq selectTermsMb(M, S, QS, 0) = < emptyTermSet, emptyTermSet, noCoverageInfo > .

 op selectTermsMb : Module Sort Nat TermList CoveragePair TermSet -> CallCoverageTuple .
 eq selectTermsMb(M, S, 0, TL, CP, TS) = < TS, minimumMbCoverage(mbCoverage(M, TS, S)), cp2ci(CP) > .
 eq selectTermsMb(M, S, N, TL, cp(noCoverage, noCoverage), TS) =
            < TS, minimumMbCoverage(mbCoverage(M, TS, S)), mbCoverage(nil, nil) > .
 ceq selectTermsMb(M, S, s(N), TL, CP, TS) = selectTermsMb(M, S, N, TL', CP \\\ CP', (TS | T))
  if gr(T, TL') := generateTerms(M, S, 1, createConsTable(M), createOpsTable(M), TL, empty) /\
     MCT := mbCoverage(M, T, S) /\
     CP' := getMbCoverage(MCT) [owise] .

 op cp2ci : CoveragePair -> CoverageInfo .
 eq cp2ci(cp(C, C')) = mbCoverage(coverage2qidlist(C), coverage2qidlist(C')) .

 op checkInvariant : Module Sort Qid Nat Qid -> CallCoverageTuple .
 ceq checkInvariant(M, S, Q, N, Q') = < TS, TS', noCoverageInfo >
  if gr(TL, TL') := generateTerms(M, S, N) /\
     TS := tl2ts(TL) /\
     V := createVar(M, 0, S) /\
     TS' := checkInvariant*(M, TS, V, Q[V] = 'false.Bool, Q', emptyTermSet) .

 op checkInvariant* : Module TermSet Variable Condition Qid TermSet -> TermSet .
 eq checkInvariant*(M, emptyTermSet, V, COND, Q, TS) = TS .
 eq checkInvariant*(M, T | TS, V, COND, Q, TS') =
                 if checkInvariant(M, T, V, COND, Q)
                 then checkInvariant*(M, TS, V, COND, Q, TS')
                 else checkInvariant*(M, TS, V, COND, Q, TS' | T)
                 fi .

 *** The function receives the negated condition, thus we must look for states fulfilling it.
 *** Si devuelve cierto es que el invariante se cumple, porque no ha encontrado un estado
 *** que satisfaga la negacion de la condicion
 op checkInvariant : Module Term Variable Condition Qid -> Bool .
 eq checkInvariant(M, T, V, COND, Q) = metaSearch(M, T, V, COND, Q, unbounded, 0) == failure .

 op keepSuspiciousCCT : CallCoverageTable QidSet -> CallCoverageTable .
 eq keepSuspiciousCCT(empty, QS) = empty .
 eq keepSuspiciousCCT((T |-> SC, CCT), QS) = T |-> keepSuspicious(SC, QS),
                                             keepSuspiciousCCT(CCT, QS) .

 op keepSuspicious : Set{Call} QidSet -> Set{Call} .
 eq keepSuspicious(empty, QS) = empty .
 ceq keepSuspicious(([eq T = T' [label(Q) AttrS] ., T'', EqS], SC), QS) =
                                     keepSuspicious(SC, QS)
  if not contains(QS, Q) .
 ceq keepSuspicious(([ceq T = T' if COND [label(Q) AttrS] ., T'', EqS], SC), QS) =
                                     keepSuspicious(SC, QS)
  if not contains(QS, Q) .
 eq keepSuspicious(([Eq, T, EqS], SC), QS) = [Eq, T, keepSuspicious(EqS, QS)],
                                             keepSuspicious(SC, QS) [owise] .

 op contains : QidSet Qid -> Bool .
 eq contains(Q ; QS, Q) = true .
 eq contains(QS, Q) = false [owise] .

 op keepSuspicious : EquationSet QidSet -> EquationSet .
 eq keepSuspicious(none, QS) = none .
 eq keepSuspicious(eq T = T' [label(Q) AttrS] . EqS, Q ; QS) = eq T = T' [label(Q) AttrS] .
                                                               keepSuspicious(EqS, QS) .
 eq keepSuspicious(ceq T = T' if COND [label(Q) AttrS] . EqS, Q ; QS) =
                                       ceq T = T' if COND [label(Q) AttrS] .
                                       keepSuspicious(EqS, QS) .
 eq keepSuspicious(Eq EqS, QS) = keepSuspicious(EqS, QS) [owise] .

 op keepSuspicious : CoveragePair QidSet -> CoveragePair .
 ceq keepSuspicious(cp(C, C'), QS) = cp(C int C'', C' int C'')
  if C'' := qidset2coverage(QS) .

 op _minus_ : TermSet TermSet -> TermSet .
 eq (T | TS) minus (T | TS') = TS minus TS' .
 eq TS minus TS' = TS [owise] .

 op checkTestCases : Module Module TermList -> List{TestCase} .
 eq checkTestCases(M, CM, empty) = nil .
 ceq checkTestCases(M, CM, (T, TL)) =
      --- The result term and type are equal to the ones in the correct module
      if T1 == T2 and Ty1 == Ty2
      then < T, T1, ok >
      --- The result is different to the one in the correct module and:
      else --- The sort Ty1 is less than Ty2
           if T1 == T2 and sortLeq(M, Ty1, Ty2)
           then < T, T1, lessSortCM >
           else --- The sort Ty2 is less than Ty1
                if T1 == T2 and sortLeq(M, Ty2, Ty1)
                then < T, T1, lessSortCM >
                else --- It is not in normal form
                     if not normalForm?(M, T1)
                     then < T, T1, notNormal >
                     --- Just different terms, no more info can be provided
                     else < T, T1, notEqualCM >
                     fi
                fi
           fi
      fi checkTestCases(M, CM, TL)
  if { T1, Ty1 } := metaReduce(M, T) /\
     { T2, Ty2 } := metaReduce(CM, T) /\
     sameKind(CM, Ty1, Ty2) .
 eq checkTestCases(M, CM, (T, TL)) = < T, reduce(M, T), wrongSign >
                                     checkTestCases(M, CM, TL) [owise] .

 op checkNoCoverage : Module TermSet -> List{TestCase} .
 eq checkNoCoverage(M, emptyTermSet) = nil .
 eq checkNoCoverage(M, T | TS) = if normalForm?(M, reduce(M, T))
                                 then nil
                                 else < T, reduce(M, T), notNormal >
                                 fi checkNoCoverage(M, TS) .

 op reduceUserTerms : Module TermSet -> List{TestCase} .
 eq reduceUserTerms(M, emptyTermSet) = nil .
 eq reduceUserTerms(M, T | TS) = < T, reduce(M, T), noInfo >
                                 reduceUserTerms(M, TS) .

 op reduceUserTermsMb : Module TermSet Sort -> List{TestCase} .
 eq reduceUserTermsMb(M, emptyTermSet, S) = nil .
 eq reduceUserTermsMb(M, T | TS, S) = if type(M, T) == S
                                      then < T, type(M, T), noInfo >
                                      else < T, type(M, T), userBigger >
                                      fi reduceUserTermsMb(M, TS, S) .

 op reduceUserTermsSys : TermSet -> List{TestCase} .
 eq reduceUserTermsSys(emptyTermSet) = nil .
 eq reduceUserTermsSys(T | TS) = < T, T, sysCov > reduceUserTermsSys(TS) .

 --- Module under test, Correct module, Terms
 op checkMbs : Module Module TermList -> List{TestCase} .
 eq checkMbs(M, CM, empty) = nil .
 ceq checkMbs(M, CM, (T, TL)) =
      --- The type is equal to the one in the correct module
      if Ty1 == Ty2
      then < T, Ty1, ok >
      else --- The sort Ty1 is less than Ty2
           if sortLeq(M, Ty1, Ty2)
           then < T, Ty1, lessSortCM >
           --- The sort Ty2 is less than Ty1
           else < T, Ty1, greatSortCM >
           fi
      fi checkMbs(M, CM, TL)
  if { T1, Ty1 } := metaReduce(M, T) /\
     { T2, Ty2 } := metaReduce(CM, T) /\
     sameKind(CM, Ty1, Ty2) .

 op generateTestCases : Module Maybe{Module} Qid QidSet Nat CoverageType -> TestGenerationResult .
 ceq generateTestCases(M, MM, Q, QS, N, CTy) = generateTestCases(M, MM, Q, TyL, Ty, Q, TyL, QS, N, CTy)
  if op Q : TyL -> Ty [AttrS] . ODS := getOps(M) .
 eq generateTestCases(M, MM, Q, QS, N, CTy) = testGenError [owise] .

 op generateTestCases : Module Maybe{Module} Qid Qid QidSet Nat CoverageType
                        -> TestGenerationResult .
 ceq generateTestCases(M, MM, Q, Q', QS, N, CTy) = generateTestCases(M, MM, Q, TyL, Ty, Q', TyL', QS, N, CTy)
  if op Q : TyL -> Ty [AttrS] . ODS := getOps(M) /\
     op Q' : TyL' -> Ty' [AttrS'] . ODS' := getOps(M) .
 eq generateTestCases(M, MM, Q, QS, N, CTy) = testGenError [owise] .

 op generateTestCases : Module Maybe{Module} Qid TypeList Type Qid TypeList QidSet Nat CoverageType
                        -> TestGenerationResult .
 ceq generateTestCases(M, undefMod, Q, TyL, Ty, Q', TyL', QS, N, global) =
                                      < LTC LTC', globalCoverage(coverage2qidlist(C)) >
  if < CT, TS, C > := selectTermsGC(M, Q, TyL, Ty, QS, N) /\
     TS' := minimumCoverage(CT) /\
     TS'' := TS minus TS' /\
     LTC := generateTestCases(M, undefMod, TS') /\
     LTC' := checkNoCoverage(M, TS'') .
 ceq generateTestCases(M, CM, Q, TyL, Ty, Q', TyL', QS, N, CTy) = < LTC, noCoverageInfo >
  if gr(TL, TL') := generateTermsOp(M, Q, N) /\
     LTC := checkTestCases(M, CM, TL) .
 ceq generateTestCases(M, undefMod, Q, TyL, Ty, Q', TyL', QS, N, function) =
        < checkNoCoverage(M, TS) reduceUserTerms(M, TS'), CI >
  if < TS, TS', CI > := selectTermsCC(M, Q, TyL, Ty, Q', TyL', QS, N) .
 eq generateTestCases(M, MM, Q, TyL, Ty, Q', TyL', QS, N, CTy) = testGenError [owise] .

 op generateTestCasesMb : Module Maybe{Module} Sort QidSet Nat -> TestGenerationResult .
 ceq generateTestCasesMb(M, undefMod, S, QS, N) = < reduceUserTermsMb(M, TS', S), CI >
  if < TS, TS', CI > := selectTermsMb(M, S, QS, N) .
 ceq generateTestCasesMb(M, CM, S, QS, N) = < LTC, noCoverageInfo >
  if gr(TL, TL') := generateTermsOp(M, S, N) /\
     LTC := checkMbs(M, CM, TL) .
 eq generateTestCasesMb(M, MM, S, QS, N) = testGenError [owise] .

 op generateTestCasesSys : Module Maybe{Module} Sort Qid Bound QidSet Nat CoverageType -> TestGenerationResult .
 ceq generateTestCasesSys(M, undefMod, S, S, B, QS, N, CTy) = < reduceUserTermsSys(TS'), CI >
  if LM := labeling(M) /\
     < TS, TS', CI > := selectTermsSys(M, S, B, QS, N, CTy) .
 eq generateTestCasesSys(M, MM, S, Q, B, QS, N, CTy) = testGenError [owise] .

 op generateTestCasesInv : Module Maybe{Module} Sort SearchType Bound Term Condition QidSet Nat
                           CoverageType -> TestGenerationResult .
 eq generateTestCasesInv(M, undefMod, S, STy, B, PAT, COND, QS, N, CTy) =
     testInvariant(M, S, PAT, COND, STy, B, QS, N, CTy) .
 eq generateTestCasesInv(M, MM, S, STy, B, PAT, COND, QS, N, CTy) = testGenError [owise] .

 op genTestCasesMC : Module Maybe{Module} Sort Bound Term Term QidSet Nat CoverageType
                     -> TestGenerationResult .
 eq genTestCasesMC(M, undefMod, S, B, PAT, F, QS, N, CTy) =
     testMC(M, S, PAT, F, B, QS, N, CTy) .
 eq genTestCasesMC(M, MM, S, B, PAT, F, QS, N, CTy) = testGenError [owise] .

 op generateTestConf : Module Maybe{Module} Sort QidSet Bound Nat CoverageType
                       -> TestGenerationResult .
 eq generateTestConf(M, M', S, QS, B, N, CTy) = testConformance(M, M', S, B, QS, N, CTy) .
 eq generateTestConf(M, MM, S, QS, B, N, CTy) = testGenError [owise] .

 op tl2ts : TermList -> TermSet .
 eq tl2ts(empty) = emptyTermSet .
 eq tl2ts((T, TL)) = T | tl2ts(TL) .

***(%

The function \verb"randomTesting" receives
the module where testing takes place,
the identifier of the function under test,
a list of natural numbers indicating an upper bound on the number of
terms appearing in the corresponding argument (\verb"0" stands for unbounded),
the number of terms of other (auxiliary) sorts that can be generated,
the seed to generate random numbers, and
the number of test cases to be generated:

{\codesize
\begin{verbatim}
%)

 vars a b seed seed' m : Nat .
 var  RGP : RandGenPair .

 op randomTesting : Module Qid NatList Nat Nat Nat -> RandGenPair .
 ceq randomTesting(M, Q, NL, N, seed, N') = RGP
  if CtT := createConsTable(M) /\
     OT := createOpsTable(M) /\
     CtT' := initialTermsTable(M, CtT, OT, N) /\
     M' := quitNonexec(M) /\
     op Q : TyL -> Ty [AttrS] . ODS := getOps(M') /\
     RGP := genRandTerms(M', Q, TyL, NL, N', seed, CtT', OT, empty) .

 op randomTesting : Module Qid NatList Nat Nat Nat ConsTable -> RandGenPair .
 ceq randomTesting(M, Q, NL, N, seed, N', CtT) = RGP
  if OT := createOpsTable(M) /\
     M' := quitNonexec(M) /\
     op Q : TyL -> Ty [AttrS] . ODS := getOps(M') /\
     RGP := genRandTerms(M', Q, TyL, NL, N', seed, CtT, OT, empty) .

 op genRandTerms : Module Qid TypeList NatList Nat Nat ConsTable OpsTable TermList
                   -> RandGenPair .
 eq genRandTerms(M, Q, TyL, NL, 0, seed, CtT, OT, TL) = << TL, CtT >> .
 ceq genRandTerms(M, Q, TyL, NL, s(N), seed, CtT, OT, TL) =
                    genRandTerms(M, Q, TyL, NL, N, seed', CtT', OT, (Q[TL'], TL))
  if << TL', seed', CtT' >> := genRandTerms*(M, TyL, NL, seed, CtT, OT, empty) .

 sort RandGenPair .
 op <<_,_,_>> : TermList Nat ConsTable -> RandGenPair [ctor] .
 op <<_,_>> : TermList ConsTable -> RandGenPair [ctor] .
 op <<_,_>> : QidList ConsTable -> RandGenPair [ctor] .
 op <<_,_>> : Term TermList -> RandGenPair [ctor] .

***(
 ATENCION:
 Hay muchas papeletas de perder las combinaciones mas simples, quizas deberia hacer
 un par de pasadas (tamanno N) de terminos simples y luego ir construyendo.

 Ademas, habria que hacer modulo con algo seguro mas grande que el numero de operadores,
 no con 5 siempre.
)

 op genRandTerms* : Module TypeList NatList Nat ConsTable OpsTable TermList -> RandGenPair .
 eq genRandTerms*(M, nil, NL, seed, CtT, OT, TL) = << TL, seed, CtT >> .
 ceq genRandTerms*(M, Ty TyL, 0 NL, seed, CtT, OT, TL) =
                                 genRandTerms*(M, TyL, NL, seed', CtT', OT, (TL, T))
  if seed' := nextRand(3, 5, seed, 5) /\
     op Q : TyL' -> Ty' [AtS] . := getRandOpDecl(seed', OT[Ty]) /\
     << T, CtT' >> := createRandTerm(M, Q, TyL', Ty, CtT, seed', TyL', empty) .
 ceq genRandTerms*(M, Ty TyL, N NL, seed, CtT, OT, TL) =
                            genRandTerms*(M, TyL, NL, seed, CtT', OT, (TL, T))
  if << T, CtT' >> := nextTerm(Ty, CtT, seed) [owise] .

 op createRandTerm : Module Qid TypeList Type ConsTable Nat TypeList TermList
                     -> RandGenPair .
 eq createRandTerm(M, Q, nil, Ty, CtT, seed, TyL, TL') =
                     if sortLeq(M, type(M, Q[TL']), Ty)
                     then << Q[TL'], insertTerm(M, Q[TL'], CtT) >>
                     else createRandTerm(M, Q, TyL, Ty, CtT, seed, TyL, empty)
                     fi .
 ceq createRandTerm(M, Q, Ty TyL, Ty', CtT, seed, TyL', TL) =
               createRandTerm(M, Q, TyL, Ty', CtT', seed, TyL', (TL, T))
  if << T, CtT' >> := nextTerm(Ty, CtT, seed) .

 op nextTerm : Type ConsTable Nat -> RandGenPair .
 ceq nextTerm(Ty, (Ty ||-> TL, CtT), seed) = << T, (Ty ||-> TL', CtT) >>
  if << T, TL' >> := getRandTerm(seed, TL) .

 op nextRand : Nat Nat Nat Nat -> Nat .
 eq nextRand(a, b, seed, m) = (a * seed + b) rem m .

 op getRandTerm : Nat TermList ~> RandGenPair .
 eq getRandTerm(0, (T, TL)) = << T, (TL, T) >> .
 eq getRandTerm(s(N), (T, TL)) = getRandTerm(N, (TL, T)) .

 op getRandOpDecl : Nat OpDeclSet -> OpDecl .
 eq getRandOpDecl(N, ODS) = getRandOpDecl(N, ODS, none) .

 op getRandOpDecl : Nat OpDeclSet OpDeclSet -> OpDecl .
 eq getRandOpDecl(0, OD ODS, ODS') = OD .
 eq getRandOpDecl(s(N), OD ODS, ODS') = getRandOpDecl(N, ODS, ODS' OD) .
 eq getRandOpDecl(N, none, ODS) = getRandOpDecl(N, ODS, none) .

 op insertTerm  : Module Term ConsTable Nat -> ConsTable .
 eq insertTerm(M, T, CtT, N) = insertTerm(M, T, CtT, N, empty) .

 op insertTerm  : Module Term ConsTable Nat ConsTable -> ConsTable .
 eq insertTerm(M, T, empty, N, CtT) = CtT .
 eq insertTerm(M, T, (S ||-> TL, CtT), N, CtT') =
      if hasSort?(M, T, S)
      then if not contains(TL, T)
           then if sizeTL(TL) < N
                then insertTerm(M, T, CtT, N, (S ||-> (TL, T), CtT'))
                else insertTerm(M, T, CtT, N, (S ||-> TL, CtT'))
                fi
           else insertTerm(M, T, CtT, N, (S ||-> TL, CtT'))
           fi
      else insertTerm(M, T, CtT, N, (S ||-> TL, CtT'))
      fi .

*** Unbounded

 op insertTerm  : Module Term ConsTable -> ConsTable .
 eq insertTerm(M, T, CtT) = insertTerm(M, T, CtT, empty) .

 op insertTerm  : Module Term ConsTable ConsTable -> ConsTable .
 eq insertTerm(M, T, empty, CtT) = CtT .
 eq insertTerm(M, T, (S ||-> TL, CtT), CtT') =
      if hasSort?(M, T, S)
      then if not contains(TL, T)
           then insertTerm(M, T, CtT, (S ||-> (TL, T), CtT'))
           else insertTerm(M, T, CtT, (S ||-> TL, CtT'))
           fi
      else insertTerm(M, T, CtT, (S ||-> TL, CtT'))
      fi .

 op initialTermsTable : Module ConsTable OpsTable Nat -> ConsTable .
 ceq initialTermsTable(M, CtT, OT, N) = initialTermsTable(M, insertTerm(M, T, CtT, N), OT, N)
  if (S ||-> TL, CtT') := CtT /\
     size(TL) < N /\
     (S ||-> OD ODS, OT') := OT /\
     T := createTerm(M, OD, CtT) /\
     sortLeq(M, type(M, T), S) /\
     not contains(TL, T) .
 eq initialTermsTable(M, CtT, OT, N) = CtT [owise] .

 op createTerm : Module OpDecl ConsTable ~> Term .
 ceq createTerm(M, op Q : TyL -> Ty [AtS] ., CtT) = createTerm(M, Q, TyL, CtT, empty)
  if TyL =/= nil .

 op createTerm : Module Qid TypeList ConsTable TermList ~> Term .
 eq createTerm(M, Q, nil, CtT, TL) = Q[TL] .
 eq createTerm(M, Q, Ty TyL, (Ty ||-> (TL, T), CtT), TL') =
             createTerm(M, Q, TyL, (Ty ||-> (T, TL), CtT), (TL', T)) .

 op sizeTL : TermList -> Nat .
 eq sizeTL(empty) = 0 .
 eq sizeTL((T, TL)) = s(size(TL)) .

 op contains : TermList Term -> Bool .
 eq contains(empty, T) = false .
 eq contains((T, TL), T') = if T == T'
                            then true
                            else contains(TL, T')
                            fi .

 *** Connection with C++
 sorts IsabelTest IsabelTestList .
 subsort IsabelTest < IsabelTestList .
 op it : Term Term Type -> IsabelTest [ctor] .
 op mt-il : -> IsabelTestList [ctor] .
 op __ : IsabelTestList IsabelTestList -> IsabelTestList [ctor assoc id: mt-il] .

 var  ITL : IsabelTestList .
 vars QIL QIL' : QidList .

 op generateIsabelTestCases : Module Qid Nat Nat -> RandGenPair .
 ceq generateIsabelTestCases(M, Q, N, seed) = << printIsabelTL(M', ITL), CtT >>
  if M' := quitNonexec(M) /\
     op Q : TyL -> Ty [AttrS] . ODS := getOps(M') /\
     << TL, CtT >> := randomTesting(M, Q, 0, 40, seed, 1) /\
     ITL := computeIsabelTestList(M', TL) .

 op generateIsabelTestCases : Module Qid Nat Nat ConsTable -> RandGenPair .
 ceq generateIsabelTestCases(M, Q, N, seed, CtT) = << printIsabelTL(M', ITL), CtT' >>
  if M' := quitNonexec(M) /\
     op Q : TyL -> Ty [AttrS] . ODS := getOps(M') /\
     << TL, CtT' >> := randomTesting(M, Q, 0 2, 3, seed, N, CtT) /\
     ITL := computeIsabelTestList(M', TL) .

 op computeIsabelTestList : Module TermList -> IsabelTestList .
 eq computeIsabelTestList(M, empty) = mt-il .
 ceq computeIsabelTestList(M, (T, TL)) = it(T, T', Ty) computeIsabelTestList(M, TL)
  if {T', Ty} := metaReduce(M, T) .

 op printIsabelTL : Module IsabelTestList -> QidList .
 eq printIsabelTL(M, ITL) = printIsabelTL(M, ITL, nil) .

 op printIsabelTL : Module IsabelTestList QidList -> QidList .
 eq printIsabelTL(M, mt-il, QIL) = QIL .
 ceq printIsabelTL(M, it(T, T', Ty) ITL, QIL) = printIsabelTL(M, ITL, QIL QIL')
  if QIL' := metaPrettyPrint(M, T, mixfix number rat format) '\s
             metaPrettyPrint(M, T', mixfix number rat format) '\s
             Ty '\n .
endfm

***(%
\end{verbatim}
}

%)fmod COV-INFO is
 pr META-LEVEL .

 sort CovInfo .

 *** Current term,
 *** Steps left
 op [_,_] : Term Bound -> CovInfo [ctor] .
endfm

view CovInfo from TRIV to COV-INFO is
 sort Elt to CovInfo .
endv

view CovInfoList from TRIV to LIST{CovInfo} * (sort List{CovInfo} to CovInfoList) is
 sort Elt to CovInfoList .
endv

view ConditionMap from TRIV to MAP{Qid, Condition} * (sort Map{Qid,Condition} to ConditionMap) is
 sort Elt to ConditionMap .
endv

view MembAxSet from TRIV to META-MODULE is
 sort Elt to MembAxSet .
endv

fmod MODULE-TRANSFORMATION-FOR-NARROWING is
 pr PAIR{RuleSet, ConditionMap} * (sort Pair{RuleSet, ConditionMap} to RSPair) .
 pr PAIR{MembAxSet, ConditionMap} * (sort Pair{MembAxSet, ConditionMap}
                                     to MASPair) .
 pr PAIR{Module, ConditionMap} * (sort Pair{Module, ConditionMap}
                                  to TransfPair) .
 pr MODULES .
 pr TERMS .

 var  M : Module .
 var  Q : Qid .
 var  IL : ImportList .
 var  SS : SortSet .
 var  SSDS : SubsortDeclSet .
 var  ODS : OpDeclSet .
 vars Mb Mb' : MembAx .
 vars MAS MAS' : MembAxSet .
 var  Eq : Equation .
 var  EqS : EquationSet .
 vars R R' R'' : Rule .
 vars RS RS' RS'' RS1 RS2 : RuleSet .
 vars T T' : Term .
 var  TL : TermList .
 var  AtS : AttrSet .
 var  C : Condition .
 var  N : Nat .
 var  S : Sort .
 var  K : Kind .
 var  Ty : Type .
 var  CONST : Constant .
 var  V : Variable .
 vars FCM CM CM' CM'' : ConditionMap .

 op module4narrowing : Module -> TransfPair .
 ceq module4narrowing(M) =
     < mod Q is IL sorts SS . SSDS ODS MAS' none RS predefRules endm, FCM >
  if fmod Q is IL sorts SS . SSDS ODS MAS EqS endfm := fullLabeling(M) /\
     < MAS', CM > := mas4narrowing(M, MAS) /\
     < RS, CM' > := eqs2rlsNarrow(M, EqS) /\
     FCM := (CM, CM', predefCM) .
 ceq module4narrowing(M) =
      < mod Q is IL sorts SS . SSDS ODS MAS' none (RS' RS'' predefRules) endm, FCM >
  if mod Q is IL sorts SS . SSDS ODS MAS EqS RS endm := fullLabeling(M) /\
     < MAS', CM > := mas4narrowing(M, MAS) /\
     < RS', CM' > := eqs2rlsNarrow(M, EqS) /\
     < RS'', CM'' > := rls4narrowing(M, RS) /\
     FCM := (CM, CM', CM'', predefCM) .

 op eqs2rlsNarrow : Module EquationSet -> RSPair .
 eq eqs2rlsNarrow(M, none) = < none, empty > .
 ceq eqs2rlsNarrow(M, Eq EqS) = < R RS, (CM, CM') >
  if < R, CM > := eq2rl(M, Eq) /\
     < RS, CM' > := eqs2rlsNarrow(M, EqS) .

 op eq2rl : Module Equation -> RSPair .
 eq eq2rl(M, eq T = T' [owise AtS] .) =
       < rl up2kind(M, T) => up2kind(M, T') [metadata("owise") AtS] .,
         label(AtS) |-> mbs(M, T) > .
 eq eq2rl(M, eq T = T' [AtS] .) =
       < rl up2kind(M, T) => up2kind(M, T') [AtS] .,
         label(AtS) |-> mbs(M, T) > .
 eq eq2rl(M, ceq T = T' if C [owise AtS] .) =
       < rl up2kind(M, T) => up2kind(M, T') [metadata("owise") nonexec AtS] .,
         label(AtS) |-> (mbs(M, T) /\ conds2rlConds(M, C, 0)) > .
 eq eq2rl(M, ceq T = T' if C [AtS] .) =
       < rl up2kind(M, T) => up2kind(M, T') [nonexec AtS] .,
         label(AtS) |-> (mbs(M, T) /\ conds2rlConds(M, C, 0)) > .

 op conds2rlConds : Module Condition Nat -> Condition .
 eq conds2rlConds(M, nil, N) = nil .
 eq conds2rlConds(M, T := T' /\ C, N) = up2kind(M, T') => up2kind(M, T) /\ mbs(M, T)
                                        /\ conds2rlConds(M, C, N) .
 eq conds2rlConds(M, T : S /\ C, N) = up2kind(M, T) : S /\ conds2rlConds(M, C, s(N)) .
 eq conds2rlConds(M, T = T' /\ C, N) = up2kind(M, T) => createVar(getKind(M, type(M, T)), N) /\
                                       up2kind(M, T') => createVar(getKind(M, type(M, T)), N) /\
                                       conds2rlConds(M, C, s(N)) .
 eq conds2rlConds(M, T => T' /\ C, N) = up2kind(M, T) => up2kind(M, T') /\ mbs(M, T) /\
                                        conds2rlConds(M, C, N) .

 op mas4narrowing : Module MembAxSet -> MASPair .
 eq mas4narrowing(M, none) = < none, empty > .
 ceq mas4narrowing(M, Mb MAS) = < Mb' MAS', (CM, CM') >
  if < Mb', CM > := mb4narrowing(M, Mb) /\
     < MAS', CM' > := mas4narrowing(M, MAS) .

 op mb4narrowing : Module MembAx -> MASPair .
 eq mb4narrowing(M, mb T : S [AtS] .) =
             < mb up2kind(M, T) : S [AtS] ., label(AtS) |-> mbs(M, T) > .
 eq mb4narrowing(M, cmb T : S if C [AtS] .) =
             < mb up2kind(M, T) : S [AtS] .,
               label(AtS) |-> (mbs(M, T) /\ conds2rlConds(M, C, 0)) > .

 op rls4narrowing : Module RuleSet -> RSPair .
 eq rls4narrowing(M, none) = < none, empty > .
 ceq rls4narrowing(M, R RS) = < R' RS', (CM, CM') >
  if < R', CM > := rl4narrowing(M, R) /\
     < RS', CM' > := rls4narrowing(M, RS) .

 op rl4narrowing : Module Rule -> RSPair .
 eq rl4narrowing(M, rl T => T' [AtS] .) =
     < rl up2kind(M, T) => up2kind(M, T') [AtS] ., label(AtS) |-> (mbs(M, T) /\ mbs(M, T')) > .
 eq rl4narrowing(M, crl T => T' if C [AtS] .) =
     < rl up2kind(M, T) => up2kind(M, T') [nonexec AtS] .,
       label(AtS) |-> (mbs(M, T) /\ mbs(M, T') /\ conds2rlConds(M, C, 0)) > .

 op createVar : Type Nat -> Variable .
 eq createVar(S, N) = qid("V$#" + string(N, 10) + ":" + string(S)) .
 eq createVar(K, N) = qid("V$#" + string(N, 10) + ":" + string(K)) .

 op getConditionMap : Module -> ConditionMap .
 eq getConditionMap(M) = getConditionMap(getRls(M)) .

 op getConditionMap : RuleSet -> ConditionMap .
 eq getConditionMap(rl T => T' [label(Q) AtS] . RS) = getConditionMap(RS), Q |-> nil .
 eq getConditionMap(crl T => T' if C [label(Q) AtS] . RS) = getConditionMap(RS), Q |-> C .
 eq getConditionMap(RS) = empty [owise] .

 op quitConditions : Module -> Module .
 eq quitConditions(mod Q is IL sorts SS . SSDS ODS MAS EqS RS endm) =
            mod Q is IL sorts SS . SSDS ODS MAS EqS quitConditions(RS) endm .
 eq quitConditions(M) = M [owise] .

 op quitConditions : RuleSet -> RuleSet .
 eq quitConditions(crl T => T' if C [AtS] . RS) = rl T => T' [nonexec AtS] . quitConditions(RS) .
 eq quitConditions(RS) = RS [owise] .

 op quitConditions : MembAxSet -> MembAxSet .
 eq quitConditions(cmb T : S if C [AtS] . MAS) = mb T : S [nonexec AtS] . quitConditions(MAS) .
 eq quitConditions(MAS) = MAS [owise] .

 op up2kind : Module Term -> Term .
 eq up2kind(M, Q[TL]) = Q[up2kind*(M, TL)] .
 eq up2kind(M, CONST) = CONST .
 ceq up2kind(M, V) = qid(string(Q) + ":" + string(K))
  if Q := getName(V) /\
     Ty := getType(V) /\
     K := getKind(M, Ty) .

 op up2kind* : Module TermList -> TermList .
 eq up2kind*(M, empty) = empty .
 eq up2kind*(M, (T, TL)) = up2kind(M, T), up2kind*(M, TL) .

 op mbs : Module Term -> Condition .
 eq mbs(M, Q[TL]) = mbs*(M, TL) .
 eq mbs(M, CONST) = nil .
 ceq mbs(M, V) = if Ty :: Kind
                 then nil
                 else up2kind(M, V) : Ty
                 fi
  if Ty := getType(V) .

 op mbs* : Module TermList -> Condition .
 eq mbs*(M, empty) = nil .
 eq mbs*(M, (T, TL)) = mbs(M, T) /\ mbs*(M, TL) .

 op fullLabeling : Module -> Module .
 eq fullLabeling(fmod Q is IL sorts SS . SSDS ODS MAS EqS endfm) =
  fmod Q is
   IL
   sorts SS .
   SSDS
   ODS
   labelingMb(MAS, 0)
   labelingEq(EqS, 0)
  endfm .
 eq fullLabeling(mod Q is IL sorts SS . SSDS ODS MAS EqS RS endm) =
  mod Q is
   IL
   sorts SS .
   SSDS
   ODS
   labelingMb(MAS, 0)
   labelingEq(EqS, 0)
   labeling(RS, 0)
  endm .

 op labelingEq : EquationSet Nat -> EquationSet .
 ceq labelingEq(Eq EqS, N) = Eq labelingEq(EqS, N)
  if label?(Eq) .
 eq labelingEq(Eq EqS, N) = putLabelEq(Eq, N) labelingEq(EqS, s(N)) .
 eq labelingEq(none, N) = none .

 op labelingMb : MembAxSet Nat -> MembAxSet .
 ceq labelingMb(Mb MAS, N) = Mb labelingMb(MAS, N)
  if label?(Mb) .
 eq labelingMb(Mb MAS, N) = putLabelMb(Mb, N) labelingMb(MAS, s(N)) .
 eq labelingMb(none, N) = none .

 op putLabelEq : Equation Nat -> Equation .
 eq putLabelEq(eq T = T' [AtS] ., N) = eq T = T' [createLabelEq(N) AtS] . .
 eq putLabelEq(ceq T = T' if C [AtS] ., N) = ceq T = T' if C [createLabelEq(N) AtS] . .

 op createLabelEq : Nat -> Attr .
 eq createLabelEq(N) = label(qid("$@labelEq(" + string(N, 10) + ")@$")) .

 op putLabelMb : MembAx Nat -> MembAx .
 eq putLabelMb(mb T : S [AtS] ., N) = mb T : S [createLabelMb(N) AtS] . .
 eq putLabelMb(cmb T : S if C [AtS] ., N) = cmb T : S if C [createLabelMb(N) AtS] . .

 op createLabelMb : Nat -> Attr .
 eq createLabelMb(N) = label(qid("$@labelMb(" + string(N, 10) + ")@$")) .

 op label? : Equation -> Bool .
 eq label?(eq T = T' [label(Q) AtS] .) = true .
 eq label?(ceq T = T' if C [label(Q) AtS] .) = true .
 eq label?(Eq) = false [owise] .

 op label? : MembAx -> Bool .
 eq label?(mb T : S [label(Q) AtS] .) = true .
 eq label?(cmb T : S if C [label(Q) AtS] .) = true .
 eq label?(Mb) = false [owise] .

 op quitMbs : Module -> Module .
 eq quitMbs(fmod Q is IL sorts SS . SSDS ODS MAS EqS endfm) =
            fmod Q is IL sorts SS . SSDS ODS none EqS endfm .
 eq quitMbs(mod Q is IL sorts SS . SSDS ODS MAS EqS RS endm) =
            mod Q is IL sorts SS . SSDS ODS none EqS RS endm .

 op predefRules : -> RuleSet .
 eq predefRules =
   (*** rl 'if_then_else_fi['true.Bool, 'NL:NatList, 'NL':NatList] => 'NL:NatList [label('@aux1)] .
    *** rl 'if_then_else_fi['false.Bool, 'NL:NatList, 'NL':NatList] => 'NL':NatList [label('@aux2)] .
    rl '_<_['0.Zero, 's_['N:Nat]] => 'true.Bool [label('@aux3)] .
    rl '_<_['s_['N:Nat], '0.Zero] => 'false.Bool [label('@aux4)] .
    rl '_<_['s_['N:Nat], 's_['N':Nat]] => '_<_['N:Nat, 'N':Nat] [label('@aux5)] .
    rl '_<=_['0.Zero, 'N:Nat] => 'true.Bool [label('@aux6)] .
    rl '_<=_['s_['N:Nat], '0.Zero] => 'false.Bool [label('@aux7)] .
    rl '_<=_['s_['N:Nat], 's_['N':Nat]] => '_<=_['N:Nat, 'N':Nat] [label('@aux8)] .
    rl 'not_['true.Bool] => 'false.Bool [label('@aux9)] .
    rl 'not_['false.Bool] => 'true.Bool [label('@aux10)] .) .

 op predefCM : -> ConditionMap .
 eq predefCM = ('@aux1 |-> nil, '@aux2 |-> nil, '@aux3 |-> nil, '@aux4 |-> nil,
                '@aux5 |-> nil, '@aux6 |-> nil, '@aux7 |-> nil, '@aux8 |-> nil) .
endfm

fmod NARROWING-MAP-FIELD is
 pr META-LEVEL .
 pr NAT-SET .

 sort NarrField .
 op [_,_,_] : QidSet Substitution Term -> NarrField [ctor] .
 op [_,_] : QidSet Substitution -> NarrField [ctor] .
 op [_,_,_] : NatSet Substitution Term -> NarrField [ctor] .

 var Q : Qid .
 var SB : Substitution .
 var T : Term .

 op first : NarrField -> Qid .
 op second : NarrField -> Substitution .
 op third : NarrField -> Term .

 eq first([Q, SB, T]) = Q .
 eq second([Q, SB, T]) = SB .
 eq third([Q, SB, T]) = T .
endfm

view NarrField from TRIV to NARROWING-MAP-FIELD is
 sort Elt to NarrField .
endv

fmod CONDITION-SOLUTION is
 pr META-LEVEL .
 pr NAT-SET .

 sort ConditionSolution .
 op |_,_| : Substitution QidSet -> ConditionSolution [ctor] .
 op |_,_| : Substitution NatSet -> ConditionSolution [ctor] .
 op <<_,_>> : Substitution Qid -> ConditionSolution [ctor] .
endfm

view ConditionSolution from TRIV to CONDITION-SOLUTION is
 sort Elt to ConditionSolution .
endv

fmod SIMPLE-TRIPLE is
 pr META-TERM .

 sort SimpleTriple .
 op {_,_,_} : Qid Term Nat -> SimpleTriple [ctor] .
endfm

view SimpleTriple from TRIV to SIMPLE-TRIPLE is
 sort Elt to SimpleTriple .
endv

fmod COVERAGE-NARROWING is
 pr MAP{Term, QidSet} * (sort Map{Term,QidSet} to NarrowingCov, op _|->_ to _to_).
 pr LIST{ConditionSolution} * (sort List{ConditionSolution} to CondSolList) .
 pr LIST{SimpleTriple} * (sort List{SimpleTriple} to SimpleTripleList) .
 pr MAP{Term, NarrField} * (sort Map{Term, NarrField} to NarrowingMap) .
 pr LIST{CovInfo} * (sort List{CovInfo} to CovInfoList) .
 pr MODULE-TRANSFORMATION-FOR-NARROWING .
 pr META-NARROWING-SEARCH * (op addEqs to addEqsSE, op addOps to addOpsSE, op addSorts to addSortsSE) .
 pr SUBSTITUTION-HANDLING .
 pr COMPUTED-COVERAGE .
 pr BOUND-WITH-MINUS .
 pr SYSTEM-COVERAGE .
 pr SUBSTITUTION .
 pr MAYBE{Term} .
 pr TERMS .

 vars M M' M'' : Module .
 vars T T' T'' TI TC TI' TC' T1 T2 T3 T4 : Term .
 vars MT MT' : Maybe{Term} .
 var  TL : TermList .
 vars Q Q' : Qid .
 vars QS QS' QS'' SUS : QidSet .
 var  IL : ImportList .
 var  SS : SortSet .
 var  SSDS : SubsortDeclSet .
 vars ODS ODS' : OpDeclSet .
 vars MAS MAS' : MembAxSet .
 var  EqS : EquationSet .
 var  R : Rule .
 vars RlS RlS' : RuleSet .
 var  C : Constant .
 var  V : Variable .
 var  TyL : TypeList .
 var  Ty : Type .
 var  AtS : AttrSet .
 vars COND COND' : Condition .
 var  RTS : ResultTripleSet .
 var  RT : ResultTriple .
 var  CI : CovInfo .
 vars CIL CIL' : CovInfoList .
 var  TS : TermSet .
 vars B B' B'' : Bool .
 vars SB SB' SB'' : Substitution .
 var  CM : ConditionMap .
 vars BND BND' : Bound .
 var  TNS : TraceNarrowSet .
 var  TN : TraceNarrow .
 var  TNSt :  TraceNarrowStep .
 vars NM NM' : NarrowingMap .
 var  NF : NarrField .
 var  NC : NarrowingCov .
 var  STR : String .
 var  S : Sort .
 var  CSL : CondSolList .
 vars N N' : Nat .
 var  DO : DisplayOption .
 vars STL STL' : SimpleTripleList .
 var  K : Kind .
 vars COV COV' COV1 COV2 COV3 : Coverage .
 vars CP CP' : CoveragePair .
 var  TSt : TestStatus .
 var  LTC : List{TestCase} .

 op numSolConds : -> Nat .
 eq numSolConds = 7 .

 sort DisplayOption .
 ops simple small : -> DisplayOption [ctor] .

 op coverageNarrowing : Module Qid Bound QidSet DisplayOption CoverageType -> TestGenerationResult .
 eq coverageNarrowing(M, Q, BND, QS, DO, global) = globalCoverageNarrowing(M, Q, BND, QS, DO) .
 eq coverageNarrowing(M, Q, BND, QS, DO, system) = sysCoverageNarrowing(M, Q, BND, QS, DO) .

***(%

The function \verb"globalCoverageNarrowing" receives
the module where narrowing takes place,
the identifier of the function being tested,
a bound in the number of steps,
the set of suspicious statements, and
the display option

{\codesize
\begin{verbatim}
%)

 subsort NarrowingMap < TestGenerationResult .

 op globalCoverageNarrowing : Module Qid Bound QidSet DisplayOption -> TestGenerationResult .
 ceq globalCoverageNarrowing(M, Q, BND, QS, DO) =
                *** NM
                < nc2ltc(M, map2cov(NM, renameVarsTerm(T), QS, DO)), globalCoverage(set2list(QS')) >
  if T := createTerm(M, Q) /\
     V := createVar(getKindCoarity(M, Q)) /\
     < M', CM > := module4narrowing(M) /\
     MAS := getMbs(M') /\
     M'' := quitMbs(M') /\
     op Q : TyL -> Ty [AtS] . ODS := getOps(M) /\
     COV := second(neededCoverage(fullLabeling(M), Q, TyL, < empty, noCoverage >)) /\
     COV' := (COV & neededCovCM(fullLabeling(M), CM, COV)) int qidset2coverage(QS) /\
     SUS := coverage2qidset(COV') /\
     { NM, QS' } := globalCovNarr(M'', SUS, [T, BND], empty, V, MAS, CM) .
 eq globalCoverageNarrowing(M, Q, BND, QS, DO) = testGenError [owise] .

 sort GlobalCovPair .
 op {_,_} : NarrowingMap QidSet -> GlobalCovPair [ctor] .

 op globalCovNarr : Module QidSet CovInfoList NarrowingMap Variable MembAxSet
                    ConditionMap -> GlobalCovPair .
 eq globalCovNarr(M, QS, nil, NM, V, MAS, CM) = { NM, QS } .
 eq globalCovNarr(M, none, CIL, NM, V, MAS, CM) = { NM, none } .
 eq globalCovNarr(M, QS, [T, 0] CIL, NM, V, MAS, CM) =
                       globalCovNarr(M, QS, CIL, NM, V, MAS, CM) .
 ceq globalCovNarr(M, QS, [T, BND] CIL, NM, V, MAS, CM) =
                       globalCovNarr(M, QS', CIL', NM', V, MAS, CM)
  if BND =/= 0 /\
     TNS := metaNarrowSearchPath(M, T, V, empty, '*, 1, unbounded, unbounded) /\
     [CIL', NM', QS'] := genTermsNarrowingPath(M, T, BND minus 1, CIL, NM, QS, MAS, CM, TNS) .

 sort TermsNarrowing .
 op [_,_,_] : CovInfoList NarrowingMap QidSet -> TermsNarrowing [ctor] .

 op genTermsNarrowingPath : Module Term Bound CovInfoList NarrowingMap QidSet MembAxSet
            ConditionMap TraceNarrowSet -> TermsNarrowing .
 eq genTermsNarrowingPath(M, T, BND, CIL, NM, QS, MAS, CM, empty) = [CIL, NM, QS] .
 ceq genTermsNarrowingPath(M, T, BND, CIL, NM, QS, MAS, CM, (TNSt | TNS)) =
                       genTermsNarrowingPath(M, T, BND, CIL', NM', QS', MAS, CM, TNS)
  if [CIL', NM', QS'] := genTermsNarrStep(M, T, BND, CIL, NM, QS, MAS, CM, TNSt) .

 op genTermsNarrStep : Module Term Bound CovInfoList NarrowingMap QidSet MembAxSet
            ConditionMap TraceNarrowStep -> TermsNarrowing .
 ceq genTermsNarrStep(M, T, BND, CIL, NM, QS, MAS, CM,
                      {T', SB, Ty, rl T1 => T2 [label(Q) AtS] .}) =
            queueFromConds(M, T, T', BND, CIL, NM, Q, QS, CSL)
  if SB' := metaMatch(M, getLHS(M, getRls(M), Q), T1, nil, 0) /\
     CSL := solveConditions(M, substituteDD(CM[Q], renameRightVarsSub(SB') << renameVarsSub(SB)), renameVarsSub(SB),
            none, MAS, CM) .

 op queueFromConds : Module Term Term Bound CovInfoList NarrowingMap Qid QidSet
                     CondSolList -> TermsNarrowing .
 eq queueFromConds(M, T, T', BND, CIL, NM, Q, QS, nil) = [CIL, NM, QS] .
 ceq queueFromConds(M, T, T', BND, CIL, NM, Q, QS, | SB, QS' | CSL) =
                queueFromConds(M, T, T', BND, CIL', NM', Q, QS'', CSL)
  if SB' := SB |> renameVarsTerm(T) /\
     QS'' := quitSet(QS, Q ; QS') /\
     T1 := renameVarsTerm(T) /\
     T2 := substituteDD(T', SB) /\
     T3 := renameVarsTerm(T2) /\
     MT := unifies(M, T3, NM) /\
     MT' := unifies(M, T3, CIL) /\
     SB'' := renameVarsSub(SB') /\
     CIL' := if MT =/= maybe or MT' =/= maybe
             then CIL
             else CIL [T3, BND]
             fi /\
     NM' := if MT =/= maybe
            then (NM, T1 |-> [Q ; QS', SB'', MT])
            else (NM, T1 |-> [Q ; QS', SB'', T3])
            fi .

***(%

A default value is used as bound in the number of steps in conditions. It cannot
be unbounded because it cannot traverse, in general, all the rules.

{\codesize
\begin{verbatim}
%)

 op solveConditions : Module Condition Substitution QidSet MembAxSet ConditionMap
                      -> CondSolList .
 eq solveConditions(M, nil, SB, QS, MAS, CM) = | SB, QS | .
 ceq solveConditions(M, T : S /\ COND, SB, QS, MAS, CM) = solveConditions(M, COND, SB, QS, MAS, CM)
  if not definedByMbs?(MAS, S) .
 ceq solveConditions(M, T : S /\ COND, SB, QS, MAS, CM) =
               membershipsOps(M, getOps(M), COND, SB, QS, MAS, CM, T, S)
               applyMbs(M, MAS, COND, SB, QS, MAS, CM, T, S)
  if definedByMbs?(MAS, S) .
 ceq solveConditions(M, T => T' /\ COND, SB, QS, MAS, CM) =
                                      continueSolveConditions(M, COND, MAS, CM, CSL)
  if T1 := substituteDD(T, SB) /\
     T2 := substituteDD(T', SB) /\
     CSL := allSteps(M, T1, T2, SB, QS) .

 op applyMbs : Module MembAxSet Condition Substitution QidSet MembAxSet ConditionMap Term Sort
               -> CondSolList .
 ceq applyMbs(M, mb T : S [label(Q) AtS] . MAS, COND, SB, QS, MAS', CM, T', S) =
          solveConditions(M, substituteDD(CM[Q], SB'') /\ COND, SB << SB'', QS ; Q, MAS', CM)
          applyMbs(M, MAS, COND, SB, QS, MAS', CM, T', S)
  if {SB', N} := metaUnify(M, T =? T', 0, 0) /\
     SB'' := renameRightVarsSub(SB') .
 eq applyMbs(M, MAS, COND, SB, QS, MAS', CM, T, S) = nil [owise] .

 op membershipsOps : Module OpDeclSet Condition Substitution QidSet MembAxSet ConditionMap Term
                     Sort -> CondSolList .
 ceq membershipsOps(M, op Q : nil -> S [AtS] . ODS, COND, SB, QS, MAS, CM, V, S) =
                   solveConditions(M, COND, (SB << (V <- T)), QS, MAS, CM)
                   membershipsOps(M, ODS, COND, SB, QS, MAS, CM, V, S)
  if T := qid(string(Q) + "." + string(S)) .
 ceq membershipsOps(M, op Q : nil -> S [AtS] . ODS, COND, SB, QS, MAS, CM, T, S) =
                   solveConditions(M, COND, SB, QS, MAS, CM)
  if T := qid(string(Q) + "." + string(S)) .
 eq membershipsOps(M, ODS, COND, SB, QS, MAS, CM, T, S) = nil [owise] .

 op continueSolveConditions : Module Condition MembAxSet ConditionMap CondSolList
                              -> CondSolList .
 eq continueSolveConditions(M, COND, MAS, CM, nil) = nil .
 eq continueSolveConditions(M, COND, MAS, CM, | SB, QS | CSL) =
              solveConditions(M, COND, SB, QS, MAS, CM)
              continueSolveConditions(M, COND, MAS, CM, CSL) .

 op allSteps : Module Term Term Substitution QidSet -> CondSolList .
 eq allSteps(M, T, T, SB, QS) = | SB, QS | .
 ceq allSteps(M, T, T', SB, QS) = traverseTraceCond*(TNS, M, T', SB, QS)
  if TNS := metaNarrowSearchPath(M, T, T', empty, '*, unbounded, numSolConds, unbounded) [owise] .



 op traverseTraceCond* : TraceNarrowSet Module Term Substitution QidSet
                         -> CondSolList .
 eq traverseTraceCond*(empty, M, T, SB, QS) = nil .
 eq traverseTraceCond*(TN | TNS, M, T, SB, QS) =
                  traverseTraceCond(TN, M, T, SB, QS)
                  traverseTraceCond*(TNS, M, T, SB, QS) .

 op traverseTraceCond : TraceNarrow Module Term Substitution QidSet -> CondSolList .
 eq traverseTraceCond(nil, M, T, SB, QS) = | SB, QS | .
 eq traverseTraceCond({T, SB, Ty, rl T1 => T2 [label(Q) AtS] .} TN,
                      M, T', SB', QS') =
          traverseTraceCond(TN, M, T', ((SB' .. SB) ;
                            metaMatch(M, T', T, nil, 0)), Q ; QS') .
*** TODO: Rename variables

 *** TODO: Comprobar que la unificacion no se come resultados, como por ejemplo una
 ***
 op unifies : Module Term NarrowingMap -> Maybe{Term} .
 eq unifies(M, T, empty) = maybe .
 *** eq unifies(M, T, NM) = maybe .
 eq unifies(M, T, (V |-> NF, NM)) = unifies(M, T, NM) .
 eq unifies(M, T, (T' |-> NF, NM)) =
                 if metaUnify(M, T =? T', 0, 0) :: UnificationPair
                 then T'
                 else unifies(M, T, NM)
                 fi [owise] .

 op unifies : Module Term CovInfoList -> Maybe{Term} .
 eq unifies(M, T, nil) = maybe .
 eq unifies(M, T, [T', BND] CIL) =
                 if metaUnify(M, T =? T', 0, 0) :: UnificationPair
                 then T'
                 else unifies(M, T, CIL)
                 fi .

 op quitOwise : AttrSet -> AttrSet .
 eq quitOwise(owise AtS) = AtS .
 eq quitOwise(AtS) = AtS [owise] .

 op createTerm : Module Qid ~> Term .
 eq createTerm(M, Q) = createTerm(M, Q, getOps(M)) .

 op createTerm : Module Qid OpDeclSet ~> Term .
 eq createTerm(M, Q, op Q : TyL -> Ty [AtS] . ODS) = createTerm(M, Q, TyL) .

 op createVar : Qid -> Variable .
 eq createVar(Q) = qid("V#$%:" + string(Q)) .

 op getKindCoarity : Module Qid ~> Sort .
 eq getKindCoarity(M, Q) = getKind(M, getCoarity(getOps(M), Q)) .

 op getCoarity : OpDeclSet Qid ~> Sort .
 eq getCoarity(op Q : TyL -> Ty [AtS] . ODS, Q) = Ty .

 op checkTheory : Module -> Bool .
 eq checkTheory(M) = checkTheory(getOps(M)) .

 op checkTheory : OpDeclSet -> Bool .
 ceq checkTheory(op Q : TyL -> Ty [AtS] . ODS) = (B and not B' and not B'') or *** C
                                                 (B and B') or *** AC and ACU
                                                 (not B and not B' and not B'') *** nothing
  if B := comm?(AtS) /\
     B' := assoc?(AtS) /\
     B'' := id?(AtS) .

 ops assoc? comm? id? : AttrSet -> Bool .

 eq assoc?(assoc AtS) = true .
 eq assoc?(AtS) = false [owise] .

 eq comm?(comm AtS) = true .
 eq comm?(AtS) = false [owise] .

 eq id?(id(T) AtS) = true .
 eq id?(AtS) = false .

 op quitSet : QidSet QidSet -> QidSet .
 eq quitSet(Q ; QS, Q ; QS') = quitSet(QS, QS') .
 eq quitSet(QS, QS') = QS [owise] .

 op keepSet : QidSet QidSet -> QidSet .
 eq keepSet(Q ; QS, Q ; QS') = Q ; keepSet(QS, QS') .
 eq keepSet(QS, QS') = none [owise] .

 op renameVarsSub : Substitution -> Substitution .
 eq renameVarsSub(none) = none .
 eq renameVarsSub(V <- T ; SB) = renameVar(V) <- renameVarsTerm(T) ;
                                 renameVarsSub(SB) .

 op renameRightVarsSub : Substitution -> Substitution .
 eq renameRightVarsSub(none) = none .
 eq renameRightVarsSub(V <- T ; SB) = V <- renameVarsTerm(T) ;
                                      renameRightVarsSub(SB) .

 op renameVarsTerm : Term -> Term .
 eq renameVarsTerm(Q[TL]) = Q[renameVarsTerm*(TL)] .
 eq renameVarsTerm(C) = C .
 eq renameVarsTerm(V) = renameVar(V) .

 op renameVarsTerm* : TermList -> TermList .
 eq renameVarsTerm*(empty) = empty .
 eq renameVarsTerm*((T, TL)) = renameVarsTerm(T), renameVarsTerm*(TL) .

 op renameVar : Variable -> Variable .
 ceq renameVar(V) = qid(string(Q) + "#:" + string(Ty))
  if Q := getName(V) /\
     Ty := getType(V) .

 op renameVarsTermUnif : Term -> Term .
 eq renameVarsTermUnif(Q[TL]) = Q[renameVarsTermUnif*(TL)] .
 eq renameVarsTermUnif(C) = C .
 eq renameVarsTermUnif(V) = renameVarUnif(V) .

 op renameVarsTermUnif* : TermList -> TermList .
 eq renameVarsTermUnif*(empty) = empty .
 eq renameVarsTermUnif*((T, TL)) = renameVarsTermUnif(T), renameVarsTermUnif*(TL) .

 op renameVarUnif : Variable -> Variable .
 ceq renameVarUnif(V) = qid(string(Q) + "$%:" + string(Ty))
  if Q := getName(V) /\
     Ty := getType(V) .

 op substituteTerm : Term Term Term -> Term .
 eq substituteTerm(T, T, T') = T' .
 eq substituteTerm(Q[TL], T, T') = Q[substituteTerm*(TL, T, T')] [owise] .
 eq substituteTerm(C, T, T') = C [owise] .
 eq substituteTerm(V, T, T') = V [owise] .

 op substituteTerm* : TermList Term Term -> Term .
 eq substituteTerm*(empty, T, T') = empty .
 eq substituteTerm*((T, TL), T1, T2) = substituteTerm(T, T1, T2),
                                       substituteTerm*(TL, T1, T2) .

 op map2cov : NarrowingMap Term QidSet DisplayOption -> NarrowingCov .
 eq map2cov(NM, T, SUS, simple) = stl2nc(map2cov(NM, T, T, 0, SUS, nil)) .
 eq map2cov((T |-> [QS, SB, T'], NM), T, SUS, small) =
        reduce2minimum(
           (map2cov(NM, T, SUS, small),
            traverseMap(NM, substituteDD(renameVarsTerm(T), SB),
                        renameVarsTerm(T'), QS, SUS))
        ) .
 eq map2cov(NM, T, SUS, DO) = empty [owise] .

 op traverseMap : NarrowingMap Term Term QidSet QidSet -> NarrowingCov .
 ceq traverseMap((T |-> [QS, SB, T'], NM), T1, T, QS', SUS) =
               if in?(NM, T)
               then traverseMap(NM, T1, T, QS', SUS)
               else empty
               fi, NC
  if NC := traverseMap(NM, substituteDD(renameVarsTerm(T1), SB), renameVarsTerm(T'), QS ; QS', SUS) .
 eq traverseMap(NM, T, T', QS, SUS) = T to keepSet(QS, SUS) [owise] .

 op reduce2minimum : NarrowingCov -> NarrowingCov .
 eq reduce2minimum((T to QS, T' to (QS ; QS'), NC)) = reduce2minimum((T' to (QS ; QS'), NC)) .
 eq reduce2minimum(NC) = NC [owise] .

 op map2cov : NarrowingMap Term Term Nat QidSet SimpleTripleList -> SimpleTripleList .
 ceq map2cov((T |-> [QS, SB, T'], NM), T, T1, N, SUS, STL) =
                                        map2cov(NM, T, T1, N, SUS, STL')
  if QS' := keepSet(QS, SUS) /\
     N' := sizeQS(QS') + N /\
     T2 := substituteDD(renameVarsTerm(T1), SB) /\
     STL' := map2cov(NM, renameVarsTerm(T'), T2, N', SUS, insert*(QS', T2, N', STL)) .
 eq map2cov(NM, T, T1, N, SUS, STL) = STL [owise] .

 op stl2nc : SimpleTripleList -> NarrowingCov .
 eq stl2nc(nil) = empty .
 eq stl2nc({Q, T, N} STL) = T to Q, stl2nc(STL) .

 op insert* : QidSet Term Nat SimpleTripleList -> SimpleTripleList .
 eq insert*(none, T, N, STL) = STL .
 eq insert*(Q ; QS, T, N, STL) = insert*(QS, T, N, insert(Q, T, N, STL)) .

 op insert : Qid Term Nat SimpleTripleList -> SimpleTripleList .
 eq insert(Q, T, N, nil) = {Q, T, N} .
 eq insert(Q, T, N, {Q', T', N'} STL) = if Q == Q'
                                        then if N < N'
                                             then {Q, T, N} STL
                                             else {Q', T', N'} STL
                                             fi
                                        else {Q', T', N'} insert(Q, T, N, STL)
                                        fi .

 op in? : NarrowingMap Term -> Bool .
 eq in?((T |-> NF, NM), T) = true .
 eq in?(NM, T) = false [owise] .

 ops getLHS getRHS : Module RuleSet Qid ~> Term .
 eq getLHS(M, rl T => T' [label(Q) AtS] . RlS, Q) = up2kind(M, T) .
 eq getRHS(M, rl T => T' [label(Q) AtS] . RlS, Q) = up2kind(M, T') .

 op definedByMbs? : MembAxSet Sort -> Bool .
 eq definedByMbs?(mb T : S [AtS] . MAS, S) = true .
 eq definedByMbs?(MAS, S) = false [owise] .

 op sizeQS : QidSet -> Nat .
 eq sizeQS(none) = 0 .
 eq sizeQS(Q ; QS) = s(sizeQS(QS)) .

 op instantiate : Module Term -> Term .
 eq instantiate(M, Q[TL]) = normal(M, Q[instantiate*(M, TL)]) .
 eq instantiate(M, C) = C .
 eq instantiate(M, V) = getConst(M, getOps(M), getType(V)) .

 op instantiate* : Module TermList -> TermList .
 eq instantiate*(M, empty) = empty .
 eq instantiate*(M, (T, TL)) = instantiate(M, T), instantiate*(M, TL) .

 op getConst : Module OpDeclSet Type ~> Term .
 ceq getConst(M, op Q : nil -> S [AtS] . ODS, Ty) = qid(string(Q) + "." + string(S))
  if K := getKind(M, S) /\
     K == getKind(M, Ty) .

 op nc2ltc : Module NarrowingCov -> List{TestCase} .
 eq nc2ltc(M, empty) = nil .
 ceq nc2ltc(M, (T to QS, NC)) = if in?(T', LTC)
                                then LTC
                                else < T', T1, noInfo > LTC
                                fi
  if T' := instantiate(M, T) /\
     T1 := reduce(M, T') /\
     LTC := nc2ltc(M, NC) .

 op in? : Term List{TestCase} -> Bool .
 eq in?(T, nil) = false .
 eq in?(T, < T', T'', TSt > LTC) = if T == T'
                                   then true
                                   else in?(T, LTC)
                                   fi .

 op neededCovCM : Module ConditionMap Coverage -> Coverage .
 eq neededCovCM(M, CM, noCoverage) = noCoverage .
 eq neededCovCM(M, (Q |-> COND, CM), Q & COV) =
         neededCovCM(M, COND) &
         neededCovCM(M, CM, COV) .

 op neededCovCM : Module Condition -> Coverage .
 eq neededCovCM(M, nil) = noCoverage .
 eq neededCovCM(M, T = T' /\ COND) = neededCovCM(M, COND) .
 eq neededCovCM(M, T := T' /\ COND) = neededCovCM(M, COND) .
 eq neededCovCM(M, T => T' /\ COND) = neededCovCM(M, COND) .
 eq neededCovCM(M, T : S /\ COND) = mbs4sort(getMbs(M), lesserSorts(M, S) ; S) &
                                    neededCovCM(M, COND) .

 op mbs4sort : MembAxSet SortSet -> Coverage .
 eq mbs4sort(mb T : S [label(Q) AtS] . MAS, S ; SS) = Q & mbs4sort(MAS, S ; SS) .
 eq mbs4sort(cmb T : S if COND [label(Q) AtS] . MAS, S ; SS) = Q & mbs4sort(MAS, S ; SS) .
 eq mbs4sort(MAS, SS) = noCoverage [owise] .

 op globalCovNarrSort : Module Sort Bound QidSet DisplayOption -> TestGenerationResult .
 *** Realmente implementar globalCovNarrSort
 ceq globalCoverageNarrowing(M, S, BND, QS, DO) =
               *** testGenError
               < nc2ltc(M, map2cov*(NM, CIL, QS, DO)), globalCoverage(set2list(QS')) >
  if CIL := initialList(M, getCtors(getOps(M), S), BND) /\
     V := createVar(getKind(M, S)) /\
     < M', CM > := module4narrowing(M) /\
     MAS := getMbs(M') /\
     M'' := quitMbs(M') /\
     op Q : TyL -> Ty [AtS] . ODS := getOps(M) /\
     COV := firstCP(neededCoverageRl(M, S, hasMb?(M))) /\
     COV' := (COV & neededCovCM(fullLabeling(M), CM, COV)) int qidset2coverage(QS) /\
     SUS := coverage2qidset(COV') /\
     { NM, QS' } := globalCovNarr(M'', SUS, CIL, empty, V, MAS, CM) .
 eq globalCovNarrSort(M, S, BND, QS, DO) = testGenError [owise] .

 op sysCoverageNarrowing : Module Sort Bound QidSet DisplayOption -> TestGenerationResult .
 ceq sysCoverageNarrowing(M, S, BND, QS, DO) =
               *** testGenError
               < nc2ltc(M, map2cov*(NM, CIL, QS, DO)), globalCoverage(set2list(none)) >
  if CIL := initialList(M, getCtors(getOps(M), S), BND) /\
     V := createVar(getKind(M, S)) /\
     < M', CM > := module4narrowing(M) /\
     MAS := getMbs(M') /\
     M'' := quitMbs(M') /\
     cp(COV, COV') := neededCoverageRls(M, getSorts(M), hasMb?(M)) /\
     COV1 := (COV & neededCovCM(fullLabeling(M), CM, COV)) int qidset2coverage(QS) /\
     COV2 := COV' int qidset2coverage(QS) /\
     CP := cp(COV1, COV2) /\
     {NM, CP'} := sysCovNarr(M'', CP, CIL, empty, V, MAS, CM) .
 eq sysCoverageNarrowing(M, S, BND, QS, DO) = testGenError [owise] .

 sort SysCovTuple .
 op {_,_} : NarrowingMap CoveragePair -> SysCovTuple [ctor] .

 op sysCovNarr : Module CoveragePair CovInfoList NarrowingMap Variable MembAxSet
                 ConditionMap -> SysCovTuple .
 eq sysCovNarr(M, CP, nil, NM, V, MAS, CM) = { NM, CP } .
 eq sysCovNarr(M, cp(noCoverage, noCoverage), CIL, NM, V, MAS, CM) = { NM, cp(noCoverage, noCoverage) } .
 eq sysCovNarr(M, CP, [T, 0] CIL, NM, V, MAS, CM) =
                       sysCovNarr(M, CP, CIL, NM, V, MAS, CM) .
 ceq sysCovNarr(M, CP, [T, BND] CIL, NM, V, MAS, CM) =
                       sysCovNarr(M, CP', CIL', NM', V, MAS, CM)
  if BND =/= 0 /\
     TNS := metaNarrowSearchPath(M, T, V, empty, '*, 1, unbounded, unbounded) /\
     [CIL', NM', CP'] := genTermsSysNarrPath(M, T, BND minus 1, CIL, NM, CP, MAS, CM, TNS) .

 sort SysTermsNarr .
 op [_,_,_] : CovInfoList NarrowingMap CoveragePair -> SysTermsNarr [ctor] .

 op genTermsSysNarrPath : Module Term Bound CovInfoList NarrowingMap CoveragePair MembAxSet
            ConditionMap TraceNarrowSet -> SysTermsNarr .
 eq genTermsSysNarrPath(M, T, BND, CIL, NM, CP, MAS, CM, empty) = [CIL, NM, CP] .
 ceq genTermsSysNarrPath(M, T, BND, CIL, NM, CP, MAS, CM, (TNSt | TNS)) =
                       genTermsSysNarrPath(M, T, BND, CIL', NM', CP', MAS, CM, TNS)
  if [CIL', NM', CP'] := genTermsSysNarrStep(M, T, BND, CIL, NM, CP, MAS, CM, TNSt) .

 op genTermsSysNarrStep : Module Term Bound CovInfoList NarrowingMap CoveragePair MembAxSet
            ConditionMap TraceNarrowStep -> SysTermsNarr .
 ceq genTermsSysNarrStep(M, T, BND, CIL, NM, CP, MAS, CM,
                      {T', SB, Ty, rl T1 => T2 [label(Q) AtS] .}) =
            queueFromSysConds(M, T, T', BND, CIL, NM, Q, CP, CSL)
  if SB' := metaMatch(M, getLHS(M, getRls(M), Q), T1, nil, 0) /\
     CSL := solveSysConds(M, substituteDD(CM[Q], renameRightVarsSub(SB') << renameVarsSub(SB)), renameVarsSub(SB),
            none, Q, MAS, CM) .

 ***************************************
 *** Queue from conditions processed ***
 ***************************************

 op queueFromSysConds : Module Term Term Bound CovInfoList NarrowingMap Qid CoveragePair
                        CondSolList -> SysTermsNarr .
 eq queueFromSysConds(M, T, T', BND, CIL, NM, Q, CP, nil) = [CIL, NM, CP] .
 ceq queueFromSysConds(M, T, T', BND, CIL, NM, Q, cp(COV, COV'), | SB, QS' | CSL) =
                queueFromSysConds(M, T, T', BND, CIL', NM', Q, cp(COV1, COV'), CSL)
  if QS := coverage2qidset(COV) /\
     SB' := SB |> renameVarsTerm(T) /\
     QS'' := quitSet(QS, Q ; QS') /\
     COV1 := qidset2coverage(QS'') /\
     T1 := renameVarsTerm(T) /\
     T2 := substituteDD(T', SB) /\
     T3 := renameVarsTerm(T2) /\
     MT := unifies(M, T3, NM) /\
     MT' := unifies(M, T3, CIL) /\
     SB'' := renameVarsSub(SB') /\
     CIL' := if MT =/= maybe or MT' =/= maybe
             then CIL
             else CIL [T3, BND]
             fi /\
     NM' := if MT =/= maybe
            then (NM, T1 |-> [Q ; QS', SB'', MT])
            else (NM, T1 |-> [Q ; QS', SB'', T3])
            fi .
 ceq queueFromSysConds(M, T, T', BND, CIL, NM, Q, cp(COV, COV'), << SB, Q' >> CSL) =
                queueFromSysConds(M, T, T', BND, CIL, NM', Q, cp(COV, COV1), CSL)
  if QS := coverage2qidset(COV') /\
     SB' := SB |> renameVarsTerm(T) /\
     QS'' := quitSet(QS, Q) /\
     COV1 := qidset2coverage(QS'') /\
     T1 := renameVarsTerm(T) /\
     SB'' := renameVarsSub(SB') /\
     NM' := (NM, T1 |-> [Q, SB'']) .

 *********************************************
 *** Conditions solved for system coverage ***
 *********************************************

 op solveSysConds : Module Condition Substitution QidSet Qid MembAxSet ConditionMap
                    -> CondSolList .
 eq solveSysConds(M, nil, SB, QS, Q, MAS, CM) = | SB, QS | .
 ceq solveSysConds(M, T : S /\ COND, SB, QS, Q, MAS, CM) = solveSysConds(M, COND, SB, QS, Q, MAS, CM)
  if not definedByMbs?(MAS, S) .
 ceq solveSysConds(M, T : S /\ COND, SB, QS, Q, MAS, CM) =
               mbSysOps(M, getOps(M), COND, SB, QS, Q, MAS, CM, T, S)
               applySysMbs(M, MAS, COND, SB, QS, Q, MAS, CM, T, S)
  if definedByMbs?(MAS, S) .
 ceq solveSysConds(M, T => T' /\ COND, SB, QS, Q, MAS, CM) =
                                      contSolveSysConds(M, Q, COND, MAS, CM, CSL)
  if T1 := substituteDD(T, SB) /\
     T2 := substituteDD(T', SB) /\
     CSL := allSteps(M, T1, T2, SB, QS) .

 op applySysMbs : Module MembAxSet Condition Substitution QidSet Qid MembAxSet ConditionMap Term
                  Sort -> CondSolList .
 ceq applySysMbs(M, mb T : S [label(Q) AtS] . MAS, COND, SB, QS, Q', MAS', CM, T', S) =
          solveSysConds(M, substituteDD(CM[Q], SB'') /\ COND, SB << SB'', QS ; Q, Q', MAS', CM)
          applySysMbs(M, MAS, COND, SB, QS, Q', MAS', CM, T', S)
  if {SB', N} := metaUnify(M, T =? T', 0, 0) /\
     SB'' := renameRightVarsSub(SB') .
 eq applySysMbs(M, MAS, COND, SB, QS, Q, MAS', CM, T, S) = << SB, Q >> [owise] .

 op mbSysOps : Module OpDeclSet Condition Substitution QidSet Qid MembAxSet ConditionMap Term
               Sort -> CondSolList .
 ceq mbSysOps(M, op Q : nil -> S [AtS] . ODS, COND, SB, QS, Q', MAS, CM, V, S) =
                   solveSysConds(M, COND, (SB << (V <- T)), QS, Q', MAS, CM)
                   mbSysOps(M, ODS, COND, SB, QS, Q', MAS, CM, V, S)
  if T := qid(string(Q) + "." + string(S)) .
 ceq mbSysOps(M, op Q : nil -> S [AtS] . ODS, COND, SB, QS, Q', MAS, CM, T, S) =
                   solveSysConds(M, COND, SB, QS, Q', MAS, CM)
  if T := qid(string(Q) + "." + string(S)) .
 eq mbSysOps(M, ODS, COND, SB, QS, Q, MAS, CM, T, S) = nil [owise] .

 op contSolveSysConds : Module Qid Condition MembAxSet ConditionMap CondSolList -> CondSolList .
 eq contSolveSysConds(M, Q, COND, MAS, CM, nil) = nil .
 eq contSolveSysConds(M, Q, COND, MAS, CM, | SB, QS | CSL) =
              solveSysConds(M, COND, SB, QS, Q, MAS, CM)
              contSolveSysConds(M, Q, COND, MAS, CM, CSL) .
 eq contSolveSysConds(M, Q, COND, MAS, CM, << SB, Q' >> CSL) =
              << SB, Q' >> contSolveSysConds(M, Q, COND, MAS, CM, CSL) .

 ***************************
 *** Auxiliary functions ***
 ***************************

 op getCtors : OpDeclSet Sort -> QidSet .
 eq getCtors(op Q : TyL -> S [ctor AtS] . ODS, S) = Q ; getCtors(ODS, S) .
 eq getCtors(ODS, S) = none [owise] .

 op initialList : Module QidSet Bound -> CovInfoList .
 eq initialList(M, none, BND) = nil .
 eq initialList(M, Q ; QS, BND) = [createTerm(M, Q), BND] initialList(M, QS, BND) .

 op map2cov* : NarrowingMap CovInfoList QidSet DisplayOption -> NarrowingCov .
 eq map2cov*(NM, nil, QS, DO) = empty .
 eq map2cov*(NM, [T, BND] CIL, QS, DO) = map2cov(NM, renameVarsTerm(T), QS, DO),
                                         map2cov*(NM, CIL, QS, DO) .
endfm

fmod INVARIANT-NARROWING is
 pr COVERAGE-NARROWING .

 vars M M1 M2 M3 : Module .
 vars T T' T'' PAT : Term .
 var  C : Constant .
 var  TL : TermList .
 var  S : Sort .
 var  Ty : Type .
 var  TyL : TypeList .
 var  Q : Qid .
 vars BND IBND : Bound .
 vars SUS RL QS : QidSet .
 vars V V' : Variable .
 var  CM : ConditionMap .
 var  ODS : OpDeclSet .
 var  MAS : MembAxSet .
 var  RS : RuleSet .
 var  AtS : AttrSet .
 var  COND : Condition .
 vars CIL CIL' : CovInfoList .
 vars NM NM' : NarrowingMap .
 var  TNS : TraceNarrowSet .
 vars SB SB' : Substitution .
 var  NIR : NarrInvRes .
 var  CSL : CondSolList .
 var  STR : String .
 var  SBL : SBL .

 sort NarrInvRes .
 op fulfilled : -> NarrInvRes [ctor] .
 op fails : Term -> NarrInvRes [ctor] .

 op narrInv : Module Sort Term Condition Bound Qid -> TestGenerationResult .
 ceq narrInv(M, S, PAT, COND, BND, Q) =
                 nir2tgr(M, NIR, PAT, COND, BND, Q)
 if CIL := initialList(M, getCtors(getOps(M), S), BND) /\
    V := createVar(getKind(M, S), 1) /\
    M1 := fullLabeling(M) /\
    RL := ruleLabels(M1) /\
    < M2, CM > := module4narrowing(M1) /\
    MAS := getMbs(M2) /\
    M3 := quitMbs(M2) /\
    NIR := narrInvAux(M3, CIL, empty, RL, MAS, CM, V, up2kind(M, PAT),
                      conds2rlConds(M, COND, 0)) .
 eq narrInv(M, S, PAT, COND, BND, Q) = testGenError [owise] .

 op nir2tgr : Module NarrInvRes Term Condition Bound Qid -> TestGenerationResult .
 eq nir2tgr(M, fulfilled, PAT, COND, BND, Q) = < (nil).List{TestCase}, noCoverageInfo > .
 ceq nir2tgr(M, fails(T), PAT, COND, BND, Q) = < < T', T'', failureProp >, noCoverageInfo >
  if T' := instantiate(M, T) /\
     T'' := getTerm(metaSearch(M, T', PAT, COND, '*, BND, 0)) .

 op narrInvAux : Module CovInfoList NarrowingMap QidSet MembAxSet ConditionMap Variable
                 Term Condition -> NarrInvRes .
 eq narrInvAux(M, nil, NM, RL, MAS, CM, V, PAT, COND) = fulfilled .
 eq narrInvAux(M, [T, 0] CIL, NM, RL, MAS, CM, V, PAT, COND) =
            narrInvAux(M, CIL, NM, RL, MAS, CM, V, PAT, COND) .
 ceq narrInvAux(M, [T, BND] CIL, NM, RL, MAS, CM, V, PAT, COND) =
                     if (NIR == fulfilled)
                     then narrInvAux(M, CIL', NM', RL, MAS, CM, V, PAT, COND)
                     else NIR
                     fi
  if BND =/= 0 /\
     TNS := metaNarrowSearchPath(M, T, V, empty, '*, 1, unbounded, unbounded) /\
     [CIL', NM', QS] := genTermsNarrowingPath(M, T, BND minus 1, CIL, NM, none, MAS, CM, TNS) /\
     TL := getReachedTerms(NM', renameVarsTerm(T), RL) /\
     NIR := checkProperty*(M, TL, PAT, COND, NM', MAS, CM) .

 op getReachedTerms : NarrowingMap Term QidSet -> TermList .
 eq getReachedTerms((T |-> [Q ; QS, SB, T'], NM), T, Q ; RL) = T', getReachedTerms(NM, T, Q ; RL) .
 eq getReachedTerms(NM, T, RL) = empty [owise] .

 op checkProperty* : Module TermList Term Condition NarrowingMap MembAxSet ConditionMap
                     -> NarrInvRes .
 eq checkProperty*(M, empty, PAT, COND, NM, MAS, CM) = fulfilled .
 ceq checkProperty*(M, (T, TL), PAT, COND, NM, MAS, CM) =
               if NIR == fulfilled
               then checkProperty*(M, TL, PAT, COND, NM, MAS, CM)
               else NIR
               fi
  if NIR := checkProperty(M, T, PAT, COND, NM, MAS, CM) .

 op checkProperty : Module Term Term Condition NarrowingMap MembAxSet ConditionMap
                    -> NarrInvRes .
 ceq checkProperty(M, T, PAT, COND, NM, MAS, CM) = if CSL == nil
                                                   then fulfilled
                                                   else fails(backwardsTerm(T, NM, getFstSB(CSL)))
                                                   fi
  if SB := metaMatch(M, PAT, T, nil, 0) /\
     CSL := solveConditions(M, substituteDD(COND, SB), none, none, MAS, CM) .
 eq checkProperty(M, T, PAT, COND, NM, MAS, CM) = fails(backwardsTerm(T, NM, none)) [owise] .

 op ruleLabels : Module -> QidSet .
 eq ruleLabels(M) = ruleLabels*(getRls(M), none) .

 op ruleLabels* : RuleSet QidSet -> QidSet .
 eq ruleLabels*(rl T => T' [label(Q) AtS] . RS, QS) = ruleLabels*(RS, QS ; Q) .
 eq ruleLabels*(crl T => T' if COND [label(Q) AtS] . RS, QS) = ruleLabels*(RS, QS ; Q) .
 eq ruleLabels*(RS, QS) = QS [owise] .

 sort SBL .
 subsort Substitution < SBL .
 op mtSBL : -> SBL [ctor] .
 op _$_ : SBL SBL -> SBL [ctor assoc id: mtSBL] .

 op backwardsTerm : Term NarrowingMap SBL -> Term .
 ceq backwardsTerm(T, (T'' |-> [QS, SB, T'], NM), SBL) = backwardsTerm(T'', NM, SB $ SBL)
  if T' := backwardsRenameTerm(T) .
 eq backwardsTerm(T, NM, SBL) = substituteSBL(T, SBL) [owise] .

 op substituteSBL : Term SBL -> Term .
 eq substituteSBL(T, mtSBL) = T .
 eq substituteSBL(T, SB $ SBL) = substituteSBL(substituteDD(T, SB), SBL) .

 op backwardsRenameTerm : Term -> Term .
 eq backwardsRenameTerm(Q[TL]) = Q[backwardsRenameTerm*(TL)] .
 eq backwardsRenameTerm(C) = C .
 eq backwardsRenameTerm(V) = backwardsRenameVar(V) .

 op backwardsRenameTerm* : TermList -> TermList .
 eq backwardsRenameTerm*(empty) = empty .
 eq backwardsRenameTerm*((T, TL)) = backwardsRenameTerm(T), backwardsRenameTerm*(TL) .

 op backwardsRenameVar : Variable -> Variable .
 ceq backwardsRenameVar(V) = qid(substr(STR, 0, sd(length(STR), 1)) + ":" + string(Ty))
  if Q := getName(V) /\
     Ty := getType(V) /\
     STR := string(Q) .

 op getFstSB : CondSolList ~> SBL .
 eq getFstSB(| SB, QS | CSL) = SB .

 op oneStep : Qid -> Qid .
 eq oneStep('+) = '* .
 eq oneStep(Q) = Q [owise] .
endfm

fmod CONFORMANCE-NARROWING is
 pr MAP{Term, QidList} * (sort Map{Term, QidList} to ConfInfo,
                          op _|->_ to _mapsTo_) .
 pr INVARIANT-NARROWING .

 sort ConfRes .
 op ok : -> ConfRes [ctor] .
 op fail : Term QidList Qid -> ConfRes [ctor] .

 vars M CM CM1 CM2 CM3 UM UM1 UM2 UM3 : Module .
 vars T T' T1 : Term .
 var  CIL : CovInfoList .
 var  S : Sort .
 var  BND : Bound .
 var  V : Variable .
 var  Q : Qid .
 vars URL CRL UQS CQS QS QS' SUS : QidSet .
 vars QIL QIL' QIL'' : QidList .
 vars UCM CCM : ConditionMap .
 vars UMAS CMAS : MembAxSet .
 var  TNS : TraceNarrowSet .
 vars UNM CNM NM : NarrowingMap .
 var  SB : Substitution .
 vars CI CI' UCI CCI : ConfInfo .
 var  N : Nat .
 var  TC : TestCase .

 op narrConf : Module Module Sort Bound QidSet -> TestGenerationResult .
 ceq narrConf(UM, CM, S, BND, SUS) = < instantiate(CM, TC), noCoverageInfo >
  if CIL := initialList(CM, getCtors(getOps(CM), S), BND) /\
     V := createVar(getKind(CM, S), 1) /\
     UM1 := fullLabeling(UM) /\
     URL := ruleLabels(UM1) /\
     < UM2, UCM > := module4narrowing(UM1) /\
     UMAS := getMbs(UM2) /\
     UM3 := quitMbs(UM2) /\
     CM1 := fullLabeling(CM) /\
     CRL := SUS intQS ruleLabels(CM1) /\
     < CM2, CCM > := module4narrowing(CM1) /\
     CMAS := getMbs(CM2) /\
     CM3 := quitMbs(CM2) /\
     TC := narrConfAux(CIL, UM3, UMAS, URL, UCM, CM3, CMAS, CRL, CCM, V) .

 op narrConfAux : CovInfoList Module MembAxSet QidSet ConditionMap
                  Module MembAxSet QidSet ConditionMap Variable -> TestCase .
 eq narrConfAux(nil, UM, UMAS, URL, UCM, CM, CMAS, CRL, CCM, V) = okConformance .
 ceq narrConfAux([T, BND] CIL, UM, UMAS, URL, UCM, CM, CMAS, CRL, CCM, V) =
           if TC == okConformance
           then narrConfAux(CIL, UM, UMAS, URL, UCM, CM, CMAS, CRL, CCM, V)
           else TC
           fi
  if { UNM, UQS } := globalCovNarr(UM, '@##aux1##@, [T, BND], empty, V, UMAS, UCM) /\
     { CNM, CQS } := globalCovNarr(CM, '@##aux1##@, [T, BND], empty, V, CMAS, CCM) /\
     UCI := confInfo(UNM, renameVarsTerm(T), CRL) /\
     CCI := confInfo(CNM, renameVarsTerm(T), CRL) /\
     TC := compConf(CCI, UCI) .

 op confInfo : NarrowingMap Term QidSet -> ConfInfo .
 eq confInfo((T |-> [QS, SB, T'], NM), T, SUS) =
            clean((confInfo(NM, T, SUS),
                   confInfoAux(NM, substituteDD(renameVarsTerm(T), SB),
                              renameVarsTerm(T'), set2list(QS), SUS))) .
 eq confInfo(NM, T, SUS) = empty [owise] .

 op confInfoAux : NarrowingMap Term Term QidList QidSet -> ConfInfo .
 ceq confInfoAux((T |-> [QS, SB, T'], NM), T1, T, QIL, SUS) =
               if in?(NM, T)
               then confInfoAux(NM, T1, T, QIL, SUS)
               else empty
               fi, CI
  if CI := confInfoAux(NM, substituteDD(renameVarsTerm(T1), SB), renameVarsTerm(T'),
                       QIL set2list(QS), SUS) .
 eq confInfoAux(NM, T, T', QIL, SUS) = T mapsTo keepSet2List(QIL, SUS) [owise] .

 op keepSet2List : QidList QidSet -> QidList .
 eq keepSet2List(nil, QS) = nil .
 eq keepSet2List(Q QIL, Q ; QS) = Q keepSet2List(QIL, Q ; QS) .
 eq keepSet2List(Q QIL, QS) = keepSet2List(QIL, QS) [owise] .

 op clean : ConfInfo -> ConfInfo .
 eq clean((T mapsTo QIL, T mapsTo QIL, CI)) = clean((T mapsTo QIL, CI)) .
 eq clean(CI) = CI [owise] .

 op compConf : ConfInfo ConfInfo -> TestCase .
 eq compConf(empty, CI) = okConformance .
 eq compConf(CI, (T mapsTo QIL, CI')) = compConf(quitAllPrefixes(CI, QIL), CI') .
 ceq compConf((T mapsTo QIL, CI), CI') = failureConformance(T, QIL'', Q)
  if QIL' := largestCoincidence(QIL, CI', T) /\
     Q := different(QIL, QIL') /\
     QIL'' := equalPart(QIL, QIL') [owise] .

 op largestCoincidence : QidList ConfInfo Term -> QidList .
 ceq largestCoincidence(QIL, (T mapsTo QIL', CI), T) = QIL'
  if N := count(QIL, QIL') /\
     QIL'' := largestCoincidence(QIL, CI, T) /\
     count(QIL, QIL'') <= N .

 op count : QidList QidList -> Nat .
 eq count(Q QIL, Q QIL') = s(count(QIL, QIL')) .
 eq count(QIL, QIL') = 0 [owise] .

 op different : QidList QidList ~> Qid .
 eq different(Q QIL, Q QIL') = different(QIL, QIL') .
 eq different(Q QIL, QIL') = Q [owise] .

 op equalPart : QidList QidList -> QidList .
 eq equalPart(Q QIL, Q QIL') = Q equalPart(QIL, QIL') .
 eq equalPart(Q QIL, QIL') = nil [owise] .

 op quitAllPrefixes : ConfInfo QidList -> ConfInfo .
 eq quitAllPrefixes((T mapsTo QIL, CI), QIL QIL') = quitAllPrefixes(CI, QIL QIL') .
 eq quitAllPrefixes(CI, QIL) = CI [owise] .

 op instantiate : Module TestCase -> TestCase .
 eq instantiate(M, failureConformance(T, QIL, Q)) = failureConformance(instantiate(M, T), QIL, Q) .
 eq instantiate(M, TC) = TC [owise] .

 op _intQS_ : QidSet QidSet -> QidSet .
 eq (Q ; QS) intQS (Q ; QS') = Q ; (QS intQS QS') .
 eq QS intQS QS' = none [owise] .
endfm

***(%

\section{Universal testing}

We present in this section

{\codesize
\begin{verbatim}
%)

fmod INDEX-PAIR is
 pr META-LEVEL .

 var T : Term .
 var N : Nat .

 sort IndexPair .
 op ||_,_|| : TermList Nat -> IndexPair [ctor] .

 op fst : IndexPair -> Term .
 eq fst(|| T, N ||) = T .

 op snd : IndexPair -> Nat .
 eq snd(|| T, N ||) = N .
endfm

fmod INDEX-UNIVERSAL-TESTING is
 pr MODULE-TRANSFORMATION-FOR-NARROWING .
 pr INDEX-PAIR .
 pr NAT-SET .

 vars M M' : Module .
 var  S : Sort .
 var  Q : Qid .
 vars T T' T'' T1 T2 : Term .
 vars TL TL' : TermList .
 var  IL : ImportList .
 var  SS : SortSet .
 var  SSDS : SubsortDeclSet .
 var  OD : OpDecl .
 var  ODS : OpDeclSet .
 var  MAS : MembAxSet .
 var  EqS : EquationSet .
 vars RS RS' : RuleSet .
 var  R : Rule .
 var  V : Variable .
 var  C : Constant .
 vars N N' N'' : Nat .
 vars NS NS' : NatSet .
 var  Ty : Type .
 var  COND : Condition .
 var  AtS : AttrSet .

 op opUniv : -> Qid .
 eq opUniv = 'stmntIndx .

 op index : Module Sort -> Module .
 ceq index(M, S) = fmod Q is IL sorts SS . SSDS OD ODS MAS EqS endfm
  if fmod Q is IL sorts SS . SSDS ODS MAS EqS endfm := M /\
     OD := genUnivOpDecl(S) .

 op index : Module Sort -> Module .
 ceq index(M, S) =
      mod Q is IL sorts SS . SSDS OD ODS MAS EqS RS' endm
  if mod Q is IL sorts SS . SSDS ODS MAS EqS RS endm := M /\
     OD := genUnivOpDecl(S) /\
     RS' := index*(M, S, RS) .

 op genUnivOpDecl : Sort -> OpDecl .
 eq genUnivOpDecl(S) = op 'stmntIndx : S 'Nat -> S [format('g 'o)] . .

***(%
\end{verbatim}
}

In the recursive case we keep the original rule in addition to the transformed one
in order to execute program statements introduced during the computation but that
are not in the required coverage and thus are not indexed:

{\codesize
\begin{verbatim}
%)

 op index* : Module Sort RuleSet -> RuleSet .
 eq index*(M, S, none) = none .
 eq index*(M, S, R RS) = R index(M, S, R) index*(M, S, RS) .

 op index : Module Sort Rule -> Rule .
 ceq index(M, S, rl T => T' [AtS] .) = rl T1 => T2 [changeLabel(AtS)] .
  if T1 := fst(indexVar(M, S, T)) /\
     T2 := useIndices(T1, T') .
 ceq index(M, S, crl T => T' if COND [AtS] .) = crl T1 => T2
                                                 if useIndicesCond(T1, COND) [changeLabel(AtS)] .
  if T1 := fst(indexVar(M, S, T)) /\
     T2 := useIndices(T1, T') .

 op index : Module Sort Term -> IndexPair .
 eq index(M, S, T) = index(M, S, T, 0) .

 op index : Module Sort Term Nat -> IndexPair .
 eq index(M, S, C, N) = if sortLeq(M, getType(C), S)
                        then || opUniv[C, upTerm(N)], s(N) ||
                        else || C, N ||
                        fi .
 eq index(M, S, V, N) = if sortLeq(M, getType(V), S)
                        then || opUniv[V, upTerm(N)], s(N) ||
                        else || V, N ||
                        fi .
 ceq index(M, S, Q[TL], N) = if sortLeq(M, Ty, S)
                             then || opUniv[Q[TL'], upTerm(N')], s(N') ||
                             else || Q[TL'], N' ||
                             fi
  if || TL', N' || := index*(M, S, TL, N) /\
     Ty := getType(metaReduce(M, Q[TL])) .

 op index* : Module Sort TermList Nat -> IndexPair .
 eq index*(M, S, empty, N) = || empty, N || .
 ceq index*(M, S, (T, TL), N) = || (T', TL'), N'' ||
  if || T', N' || := index(M, S, T, N) /\
     || TL', N'' || := index*(M, S, TL, N') .


 op indexVar : Module Sort Term -> IndexPair .
 eq indexVar(M, S, T) = indexVar(M, S, T, 0) .

 op indexVar : Module Sort Term Nat -> IndexPair .
 eq indexVar(M, S, C, N) = if sortLeq(M, getType(C), S)
                           then || opUniv[C, createVar('Nat, N)], s(N) ||
                           else || C, N ||
                           fi .
 eq indexVar(M, S, V, N) = if sortLeq(M, getType(V), S)
                           then || opUniv[V, createVar('Nat, N)], s(N) ||
                           else || V, N ||
                           fi .
 ceq indexVar(M, S, Q[TL], N) = if sortLeq(M, Ty, S)
                                then || opUniv[Q[TL'], createVar('Nat, N')], s(N') ||
                                else || Q[TL'], N' ||
                                fi
  if || TL', N' || := indexVar*(M, S, TL, N) /\
     Ty := getType(metaReduce(M, Q[TL])) .

 op indexVar* : Module Sort TermList Nat -> IndexPair .
 eq indexVar*(M, S, empty, N) = || empty, N || .
 ceq indexVar*(M, S, (T, TL), N) = || (T', TL'), N'' ||
  if || T', N' || := indexVar(M, S, T, N) /\
     || TL', N'' || := indexVar*(M, S, TL, N') .

 op quitIndex : Term -> Term .
 eq quitIndex(V) = V .
 eq quitIndex(C) = C .
 eq quitIndex('stmntIndx[T, T']) = quitIndex(T) .
 eq quitIndex(Q[TL]) = Q[quitIndex*(TL)] [owise] .

 op quitIndex* : TermList -> TermList .
 eq quitIndex*((T, TL)) = quitIndex(T), quitIndex*(TL) .
 eq quitIndex*(empty) = empty .

 op useIndices : Term Term -> Term .
 eq useIndices('stmntIndx[T, T'], T'') = useIndices(T, useIndex(quitIndex(T), T', T'')) .
 ceq useIndices(Q[TL], T) = useIndices*(TL, T)
  if Q =/= 'stmntIndx .
 eq useIndices(V, T) = T .
 eq useIndices(C, T) = T .

 op useIndices* : TermList Term -> Term .
 eq useIndices*(empty, T) = T .
 eq useIndices*((T, TL), T') = useIndices*(TL, useIndices(T, T')) .

 op useIndex : Term Term Term -> Term .
 eq useIndex(T, T', T) = opUniv[T, T'] .
 ceq useIndex(T, T', Q[TL]) = Q[useIndex*(T, T', TL)]
  if T =/= Q[TL] .
 eq useIndex(T, T', T'') = T'' [owise] .

 op useIndex* : Term Term TermList -> TermList .
 eq useIndex*(T, T', (T'', TL)) = useIndex(T, T', T''), useIndex*(T, T', TL) .
 eq useIndex*(T, T', empty) = empty .

 op useIndicesCond : Term Condition -> Condition .
 eq useIndicesCond(T, nil) = nil .
 eq useIndicesCond(T, T1 = T2 /\ COND) = T1 = T2 /\ useIndicesCond(T, COND) .
 eq useIndicesCond(T, T1 := T2 /\ COND) = T1 := T2 /\ useIndicesCond(T, COND) .
 eq useIndicesCond(T, T1 : S /\ COND) = T1 : S /\ useIndicesCond(T, COND) .
 eq useIndicesCond(T, T1 => T2 /\ COND) = useIndices(T, T1) => useIndices(T, T2) /\
                                          useIndicesCond(T, COND) .

 op changeLabel : AttrSet -> AttrSet .
 eq changeLabel(label(Q) AtS) = label(qid("extraInfo-" + string(Q))) AtS .
 eq changeLabel(AtS) = AtS [owise] .
endfm

fmod UNIVERSAL-TESTING is
 pr INDEX-UNIVERSAL-TESTING .
 pr COVERAGE-NARROWING .
 pr RULE-STMNT-REL .

 vars M M' M1 M2 : Module .
 vars T T' T1 T2 T3 LHS PAT : Term .
 vars MT MT' : Maybe{Term} .
 vars S S' : Sort .
 var  Ty : Type .
 vars NS NS' NS'' : NatSet .
 var  N : Nat .
 var  ODS : OpDeclSet .
 vars MAS MAS' : MembAxSet .
 var  CM : ConditionMap .
 var  V : Variable .
 var  B : Bound .
 vars NM NM' : NarrowingMap .
 vars CIL CIL' : CovInfoList .
 var  TNS : TraceNarrowSet .
 var  TN : TraceNarrow .
 var  TNSt :  TraceNarrowStep .
 vars SB SB' SB'' ESB : Substitution .
 var  CSL : CondSolList .
 var  Q : Qid .
 var  AtS : AttrSet .
 var  COND : Condition .

 sort UTestRes .
 op errorUTR : -> UTestRes [ctor] .
 op {_,_} : NarrowingMap NatSet -> UTestRes [ctor] .

 op utest-cases : Module Term Sort NatSet Bound -> UTestRes .
 ceq utest-cases(M, T, S, NS, B) = univCovNarr(M2, NS', [T', B], empty, V, MAS, CM)
  if || T', N || := index(M, S, T) /\
     M' := index(M, S) /\
     < M1, CM > := module4narrowing(M') /\
     M2 := quitMbs(M1) /\
     MAS := getMbs(M') /\
     NS' := if NS == mtNS
            then genNatSetUpTo(N)
            else NS
            fi /\
     S' := getType(metaReduce(M, T)) /\
     V := varSort(S') .

 op univCovNarr : Module NatSet CovInfoList NarrowingMap Term MembAxSet
                  ConditionMap -> UTestRes .
 eq univCovNarr(M, NS, nil, NM, PAT, MAS, CM) = { NM, NS } .
 eq univCovNarr(M, mtNS, CIL, NM, PAT, MAS, CM) = { NM, mtNS } .
 eq univCovNarr(M, NS, [T, 0] CIL, NM, PAT, MAS, CM) =
                       univCovNarr(M, NS, CIL, NM, PAT, MAS, CM) .
 ceq univCovNarr(M, NS, [T, B] CIL, NM, PAT, MAS, CM) =
                       univCovNarr(M, NS', CIL', NM', PAT, MAS, CM)
  if B =/= 0 /\
     TNS := metaNarrowSearchPath(M, T, PAT, empty, '*, 1, unbounded, unbounded) /\
     [CIL', NM', NS'] := genUTermsNarrPath(M, T, B minus 1, CIL, NM, NS, MAS, CM, TNS) .

 sort UTermsNarrowing .
 op [_,_,_] : CovInfoList NarrowingMap NatSet -> UTermsNarrowing [ctor] .

 op genUTermsNarrPath : Module Term Bound CovInfoList NarrowingMap NatSet MembAxSet
                        ConditionMap TraceNarrowSet -> UTermsNarrowing .
 eq genUTermsNarrPath(M, T, B, CIL, NM, NS, MAS, CM, empty) = [CIL, NM, NS] .
 ceq genUTermsNarrPath(M, T, B, CIL, NM, NS, MAS, CM, (TNSt | TNS)) =
                       genUTermsNarrPath(M, T, B, CIL', NM', NS', MAS, CM, TNS)
  if [CIL', NM', NS'] := genUTermsNarrStep(M, T, B, CIL, NM, NS, MAS, CM, TNSt) .

 op genUTermsNarrStep : Module Term Bound CovInfoList NarrowingMap NatSet MembAxSet
                        ConditionMap TraceNarrowStep -> UTermsNarrowing .
 ceq genUTermsNarrStep(M, T, B, CIL, NM, NS, MAS, CM,
                      {T', SB, Ty, rl T1 => T2 [label(Q) AtS] .}) =
              queueFromConds(M, T, T', B, CIL, NM, NS, CSL)
  if SB' := metaMatch(M, getLHS(M, getRls(M), Q), T1, nil, 0) /\
     ESB := combineExtraVars(metaMatch(M, getRHS(M, getRls(M), Q), T2, nil, 0), SB') /\
     SB'' := renameRightVarsSub(ESB) << renameVarsSub(SB) /\
     CSL := solveUConds(M, substituteDD(CM[Q], SB''),
                              renameVarsSub(SB), mtNS, MAS, CM) .

 op queueFromConds : Module Term Term Bound CovInfoList NarrowingMap NatSet
                     CondSolList -> UTermsNarrowing .
 eq queueFromConds(M, T, T', B, CIL, NM, NS, nil) = [CIL, NM, NS] .
 ceq queueFromConds(M, T, T', B, CIL, NM, NS, | SB, NS' | CSL) =
                queueFromConds(M, T, T', B, CIL', NM', NS'', CSL)
  if SB' := SB |> renameVarsTerm(T) /\
     NS'' := NS \ NS' /\
     T1 := renameVarsTerm(T) /\
     T2 := substituteDD(renameVarsTerm(T'), SB) /\
     T3 := renameVarsTerm(T2) /\
     MT := unifies(M, T3, NM) /\
     MT' := unifies(M, T3, CIL) /\
     SB'' := renameVarsSub(SB') /\
     CIL' := if MT =/= maybe or MT' =/= maybe
             then CIL
             else CIL [T3, B]
             fi /\
     NM' := if MT =/= maybe
            then (NM, T1 |-> [NS', SB'', MT])
            else (NM, T1 |-> [NS', SB'', T3])
            fi .

 op solveUConds : Module Condition Substitution NatSet MembAxSet ConditionMap
                  -> CondSolList .
 eq solveUConds(M, nil, SB, NS, MAS, CM) = | SB, NS | .
 ceq solveUConds(M, T : S /\ COND, SB, NS, MAS, CM) = solveUConds(M, COND, SB, NS, MAS, CM)
  if not definedByMbs?(MAS, S) .
 ceq solveUConds(M, T : S /\ COND, SB, NS, MAS, CM) =
               mbUOps(M, getOps(M), COND, SB, NS, MAS, CM, T, S)
               applyUMbs(M, MAS, COND, SB, NS, MAS, CM, T, S)
  if definedByMbs?(MAS, S) .
 ceq solveUConds(M, T => T' /\ COND, SB, NS, MAS, CM) =
                                      contSolveUCond(M, COND, MAS, CM, CSL)
  if T1 := substituteDD(T, SB) /\
     T2 := substituteDD(T', SB) /\
     CSL := allSteps(M, T1, T2, SB, NS) .

 op applyUMbs : Module MembAxSet Condition Substitution NatSet MembAxSet ConditionMap
                Term Sort -> CondSolList .
 ceq applyUMbs(M, mb T : S [label(Q) AtS] . MAS, COND, SB, NS, MAS', CM, T', S) =
          solveUConds(M, substituteDD(CM[Q], SB'') /\ COND, SB << SB'', NS, MAS', CM)
          applyUMbs(M, MAS, COND, SB, NS, MAS', CM, T', S)
  if {SB', N} := metaUnify(M, T =? T', 0, 0) /\
     SB'' := renameRightVarsSub(SB') .
 eq applyUMbs(M, MAS, COND, SB, NS, MAS', CM, T, S) = nil [owise] .

 op mbUOps : Module OpDeclSet Condition Substitution NatSet MembAxSet ConditionMap Term
             Sort -> CondSolList .
 ceq mbUOps(M, op Q : nil -> S [AtS] . ODS, COND, SB, NS, MAS, CM, V, S) =
                solveUConds(M, COND, (SB << (V <- T)), NS, MAS, CM)
                mbUOps(M, ODS, COND, SB, NS, MAS, CM, V, S)
  if T := qid(string(Q) + "." + string(S)) .
 ceq mbUOps(M, op Q : nil -> S [AtS] . ODS, COND, SB, NS, MAS, CM, T, S) =
                   solveUConds(M, COND, SB, NS, MAS, CM)
  if T := qid(string(Q) + "." + string(S)) .
 eq mbUOps(M, ODS, COND, SB, NS, MAS, CM, T, S) = nil [owise] .

 op contSolveUCond : Module Condition MembAxSet ConditionMap CondSolList
                     -> CondSolList .
 eq contSolveUCond(M, COND, MAS, CM, nil) = nil .
 eq contSolveUCond(M, COND, MAS, CM, | SB, NS | CSL) =
              solveUConds(M, COND, SB, NS, MAS, CM)
              contSolveUCond(M, COND, MAS, CM, CSL) .

 op allSteps : Module Term Term Substitution NatSet -> CondSolList .
 eq allSteps(M, T, T, SB, NS) = | SB, NS | .
 ceq allSteps(M, T, T', SB, NS) = travUTraceCond*(TNS, M, T, SB, NS)
                                  *** travUTraceCond*(TNS, M, T', SB, NS)
  if TNS := metaNarrowSearchPath(M, T, T', empty, '*, unbounded, numSolConds, unbounded) [owise] .



*** Esto es incorrecto, hace falta tambien que se comprueben las posibles condiciones
*** de las reglas

 op travUTraceCond* : TraceNarrowSet Module Term Substitution NatSet -> CondSolList .
 eq travUTraceCond*(empty, M, T, SB, NS) = nil .
 eq travUTraceCond*(TN | TNS, M, T, SB, NS) =
                  travUTraceCond(TN, M, T, SB, NS)
                  travUTraceCond*(TNS, M, T, SB, NS) .

 op travUTraceCond : TraceNarrow Module Term Substitution NatSet -> CondSolList .
 eq travUTraceCond(nil, M, T, SB, NS) = | SB, NS | .
 eq travUTraceCond({T, SB, Ty, rl T1 => T2 [label(Q) AtS] .} TN, M, T', SB', NS') =
          travUTraceCond(TN, M, T', ((SB' .. SB) ;
                                    metaMatch(M, T1, T', nil, 0)), NS') .
***                                    metaMatch(M, T', T, nil, 0)), NS') .

 op varSort : Sort -> Variable .
 eq varSort(S) = qid("V#$%:" + string(S)) .

 op combineExtraVars : Substitution Substitution -> Substitution .
 eq combineExtraVars(V <- T ; SB, V <- T' ; SB') = combineExtraVars(SB, V <- T' ; SB') .
 eq combineExtraVars(SB, SB') = SB ; SB' [owise] .
endfm

***(%
\end{verbatim}
}

%)
***(%

\subsection{Debugging tree navigation}\label{subsec:dbt}

Regarding the navigation of the debugging tree, we have implemented two
strategies. In the top-down strategy
the selection of the next node of the
debugging tree is done by the user, thus we do not need any extra function to
compute it (apart from those in module \verb"TREE"). On the other hand,
the divide and query strategy selects each time the node
whose subtree's size is the closest one to half the size of
the whole tree, keeping only this subtree if its root is incorrect,
and deleting the whole subtree otherwise.

The algorithm in charge of calculating the next node
uses auxiliary functions that return pairs
consisting of a list of natural numbers (identifying the best node found
thus far) and a natural number
(specifying the cost associated with this node):

{\codesize
\begin{verbatim}
%)

fmod DIVIDE-QUERY-STRATEGY is
  pr PAIR{NatList, Nat} .
  pr PROOF-TREE .
  pr EXT-BOOL .

  var  J : Judgment .
  vars N N' NODES LAST_DIFF BEST_DIFF NEW_DIFF : Nat .
  var  F : Forest .
  vars NL NL' BEST_NODE : NatList .
  var  T : Tree .

***(%
\end{verbatim}
}

The function \texttt{searchBestNode} calculates the best node
by searching for a subtree that minimizes the function \texttt{getDiff},
where the first argument is the size of the whole tree and the second one
the size of the subtree. That is, a subtree whose size is the closest one to
half the size of the tree:

{\codesize
\begin{verbatim}
%)

  op searchBestNode : Tree -> NatList .

  eq searchBestNode(tree(J, NODES, F)) =
      first(searchBestNode(tree(J, NODES, F), NODES, 10 * NODES,
                           10 * NODES, nil, nil)) .

***(%
\end{verbatim}
}

It uses an auxiliary function that receives the tree, the total number of
nodes in the whole tree, the last and the best difference so far, the identifier
of the best node, and the identifier of the root of the subtree it is
currently traversing. The last and best differences are initialized
with a value big enough (ten times the number of nodes), in order to
avoid the selection of the initial root as the best node.
This function keeps the information about the last difference in order to
stop searching when the current difference is bigger than the last one. Since
we use the symmetric difference function, the difference between the size of
the whole tree and the double of the size of the current subtree will initially
decrease (while the double of the size of the subtree is bigger than the size
of the tree) and finally it will increase (when the size of the
tree is bigger than the double of the size of the subtree). Thus, in this
case the function returns the current best node and best difference:

{\codesize
\begin{verbatim}
%)

  op searchBestNode : Tree Nat Nat Nat NatList NatList -> Pair{NatList, Nat} .
  ceq searchBestNode(T, NODES, LAST_DIFF, BEST_DIFF, BEST_NODE, NL) =
                                                        < BEST_NODE, BEST_DIFF >
   if LAST_DIFF <= getDiff(NODES, getOffspring(T)) .

***(%
\end{verbatim}
}

If the new difference is better than the last one, the function recursively
traverses the forest of the current node with the function
\texttt{searchBestNode*}:

{\codesize
\begin{verbatim}
%)

  ceq searchBestNode(tree(J, N, F), NODES, LAST_DIFF, BEST_DIFF, BEST_NODE, NL) =
       if J == unknown then
         searchBestNode*(F, NODES, LAST_DIFF, BEST_DIFF, BEST_NODE, NL, 0)
       else
         if NEW_DIFF <= BEST_DIFF then
           searchBestNode*(F, NODES, NEW_DIFF, NEW_DIFF, NL, NL, 0)
         else
           searchBestNode*(F, NODES, NEW_DIFF, BEST_DIFF, BEST_NODE, NL, 0)
         fi
       fi
   if NEW_DIFF := getDiff(NODES, N) /\
      LAST_DIFF > NEW_DIFF .

***(%
\end{verbatim}
}

As said above, this function recursively traverses the forest and creates
the new node identifiers with its accumulator parameter:

{\codesize
\begin{verbatim}
%)

  op searchBestNode* : Forest Nat Nat Nat NatList NatList Nat -> Pair{NatList, Nat} .

  eq searchBestNode*(mtForest, NODES, LAST_DIFF, BEST_DIFF, BEST_NODE, NL, N) =
                                                     < BEST_NODE, BEST_DIFF > .

  ceq searchBestNode*(T F, NODES, LAST_DIFF, BEST_DIFF, BEST_NODE, NL, N) =
       if N' <= BEST_DIFF then
         searchBestNode*(F, NODES, LAST_DIFF, N', NL', NL, s(N))
       else
         searchBestNode*(F, NODES, LAST_DIFF, BEST_DIFF, BEST_NODE, NL, s(N))
       fi
   if < NL', N' > := searchBestNode(T, NODES, LAST_DIFF, BEST_DIFF, BEST_NODE, NL N) .

  op getDiff : Nat Nat -> Nat .
  eq getDiff(N, N') = sd(N, 2 * N') .
endfm

***(%
\end{verbatim}
}

\subsection{The debugger environment}\label{subsec:io}

We implement our system on top of Full Maude, a language that extends
Maude with support for object-oriented specification and advanced module
operations \cite[Part II]{maude-book}. The implementation of Full Maude includes code
for parsing user input and pretty-printing; storing modules, theories, and views; and
transforming object-oriented modules into system modules.

To parse some input using the built-in function \texttt{metaParse},
Full Maude needs the meta-representation of the signature in which the
input has to be parsed. Thus, we define the signature of the
debugger in a module that extends the Full Maude signature:

{\codesize
\begin{verbatim}
%)

 fmod DD-SIGNATURE is
  inc FULL-MAUDE-SIGN .

  op debug_. : @Bubble@ -> @Command@ .
  op missing_. : @Bubble@ -> @Command@ .
  op top-down`strategy`. : -> @Command@ .
  op divide-query`strategy`. : -> @Command@ .
  op single-stepping`strategy`. : -> @Command@ .
  op one-step`tree`. : -> @Command@ .
  op many-steps`tree`. : -> @Command@ .
  op one-step`missing`tree`. : -> @Command@ .
  op many-steps`missing`tree`. : -> @Command@ .
  op correct`module_. : @ModExp@ -> @Command@ .
  op delete`correct`module`. : -> @Command@ .
  op set`bound_. : @Token@ -> @Command@ .
  op set`debug`select`on`. : -> @Command@ .
  op set`debug`select`off`. : -> @Command@ .
  op debug-include_. : @Bubble@ -> @Command@ .
  op debug-exclude_. : @Bubble@ -> @Command@ .
  op debug-include-eqs_. : @Bubble@ -> @Command@ .
  op debug-exclude-eqs_. : @Bubble@ -> @Command@ .
  op debug-include-mbs_. : @Bubble@ -> @Command@ .
  op debug-exclude-mbs_. : @Bubble@ -> @Command@ .
  op debug-include-rls_. : @Bubble@ -> @Command@ .
  op debug-exclude-rls_. : @Bubble@ -> @Command@ .
  op debug-select_. : @NeTokenList@ -> @Command@ .
  op debug-deselect_. : @NeTokenList@ -> @Command@ .
  op solutions`prioritized`on`. : -> @Command@ .
  op solutions`prioritized`off`. : -> @Command@ .
  op set`final`select`on`. : -> @Command@ .
  op set`final`select`off`. : -> @Command@ .
  op final`select_. : @Bubble@ -> @Command@ .
  op final`deselect_. : @Bubble@ -> @Command@ .
  op yes`. : -> @Command@ .
  op no`. : -> @Command@ .
  op trust`. : -> @Command@ .
  op its`sort`is`final`. : -> @Command@ .
  op _is`wrong`. : @Token@ -> @Command@ .
  op _is`not`a`solution`. : @Token@ -> @Command@ .
  op _:`yes`. : @Token@ -> @Command@ .
  op _:`no`. : @Token@ -> @Command@ .
  op _:`don't`know`. : @Token@ -> @Command@ .
  op _:`trust`. : @Token@ -> @Command@ .
  op _:`its`sort`is`final`. : @Token@ -> @Command@ .
  op _:_is`wrong`. : @Token@ @Token@ -> @Command@ .
  op _:_is`not`a`solution`. : @Token@ @Token@ -> @Command@ .
  op all`:`yes`. : -> @Command@ .
  op don't`know`. : -> @Command@ .
  op undo`. : -> @Command@ .
  op start`. : -> @Command@ .
  op initialize`intended`semantics`. : -> @Command@ .
  op initialize`transitivity`rules`. : -> @Command@ .
  op intended`semantics_. : @Token@ -> @Command@ .
  op intended`semantics_culprit_. : @Token@ @Bubble@ -> @Command@ .
  op transitivity`rules_. : @NeTokenList@ -> @Command@ .
  op debug-big-step-semantics_=>_. : @Bubble@ @Bubble@ -> @Command@ .
  op debug-small-step-semantics_=>_. : @Bubble@ @Bubble@ -> @Command@ .
  op big-step`semantics`. : -> @Command@ .
  op small-step`semantics`. : -> @Command@ .

***(%
 endfm
\end{verbatim}
}

\begin{comment}

Testing commands

{\codesize
\begin{verbatim}
%)

  op set`test`select`on`. : -> @Command@ .
  op set`test`select`off`. : -> @Command@ .
  op test-include_. : @Bubble@ -> @Command@ .
  op test-exclude_. : @Bubble@ -> @Command@ .
  op test-include-eqs_. : @Bubble@ -> @Command@ .
  op test-exclude-eqs_. : @Bubble@ -> @Command@ .
  op test-include-mbs_. : @Bubble@ -> @Command@ .
  op test-exclude-mbs_. : @Bubble@ -> @Command@ .
  op test-include-rls_. : @Bubble@ -> @Command@ .
  op test-exclude-rls_. : @Bubble@ -> @Command@ .
  op test-select_. : @NeTokenList@ -> @Command@ .
  op test-deselect_. : @NeTokenList@ -> @Command@ .
  op sort`test`select_. : @Bubble@ -> @Command@ .
  op sort`test`deselect_. : @Bubble@ -> @Command@ .
  op isabel-test_. : @Token@ -> @Command@ .
  op isabel-next`. : -> @Command@ .
  op test_. : @Bubble@ -> @Command@ .
  op test-sort_. : @Bubble@ -> @Command@ .
  op show`not`normal`. : -> @Command@ .
  op show`correct`. : -> @Command@ .
  op show`incorrect`. : -> @Command@ .
  op show_incorrect`. : @Token@ -> @Command@ .
  op next_incorrect`. : @Token@ -> @Command@ .
  op global`coverage`. : -> @Command@ .
  op function`coverage`. : -> @Command@ .
  op system`coverage`. : -> @Command@ .
  op set`test`bound_. : @Token@ -> @Command@ .
  op set`test`depth_. : @Token@ -> @Command@ .
  op invoke`debugger`with`normal`form_. : @Token@ -> @Command@ .
  op invoke`debugger`with`user`test`case_. : @Token@ -> @Command@ .
  op invoke`debugger`with`incorrect`test`case_. : @Token@ -> @Command@ .
  op invoke`debugger`with`greater`sort_. : @Token@ -> @Command@ .
  op invoke`debugger`with`lesser`sort_. : @Token@ -> @Command@ .
  op invoke`debugger`with`invariant_. : @Token@ -> @Command@ .
  op invoke`debugger`with`nonreachable`test`case_. : @Token@ -> @Command@ .
  op correct`test`module_. : @ModExp@ -> @Command@ .
  op delete`correct`test`module`. : -> @Command@ .
  op display`small`set`. : -> @Command@ .
  op display`simple`set`. : -> @Command@ .
  op narrowing`on`. : -> @Command@ .
  op narrowing`off`. : -> @Command@ .

***(%
 endfm
\end{verbatim}
}

\end{comment}

\begin{comment}

Semantics-based testing commands

{\codesize
\begin{verbatim}
%)

  op semantics`module_. : @Token@ -> @Command@ .
  op set-sort-statements_. : @Token@ -> @Command@ .
  op show-applied-statements`. : -> @Command@ .
  op show-semantics-rules`. : -> @Command@ .
  op rule_is`not`associated`to`any`statement`. : @Token@ -> @Command@ .
  op rule_is`associated`to_. : @Token@ @NeTokenList@ -> @Command@ .
  op statements`in`coverage_. : @NeTokenList@ -> @Command@ .
  op object`program_. : @Bubble@ -> @Command@ .
  op show`object`program`. : -> @Command@ .
  op show`tree`. : -> @Command@ .
  op show`latex`tree`. : -> @Command@ .
  op show`suspicious`labels`. : -> @Command@ .
  op debugging`relation`module_._enddr : @ModExp@ @Bubble@ -> @Command@ .
  op yeah!`. : -> @Command@ .
  op never!`. : -> @Command@ .
  op who`knows`. : -> @Command@ .
 endfm

***(%
\end{verbatim}
}

\end{comment}

\begin{comment}

We define lists of module expressions, that can be introduced
by the user:

{\codesize
\begin{verbatim}
%)

 fmod MOD-EXPRS-LIST is
  inc MOD-EXPRS .
  sort @NeModExpList@ .
  subsort @ModExp@ < @NeModExpList@ .
  op __ : @NeModExpList@ @NeModExpList@ -> @NeModExpList@ [prec 60 assoc] .
 endfm

***(%
\end{verbatim}
}

\end{comment}

\begin{comment}

{\codesize
\begin{verbatim}
%)

 fmod DEB-REL-LIST is
  pr MOD-EXPRS .

  sorts @DebRel@ @DebRelList@ .
  subsort @DebRel@ < @DebRelList@ .

  op _debugs_. : @Token@ @Token@ -> @DebRel@ [ctor] .
  op __ : @DebRelList@ @DebRelList@ -> @DebRelList@ [ctor prec 60 assoc] .
 endfm

***(%
\end{verbatim}
}

\end{comment}

This signature is included in the meta-module \texttt{GRAMMAR}
to obtain the grammar \texttt{DD-GRAMMAR}, that allows to parse
both Full Maude modules and commands together with the debugger commands:

{\codesize
\begin{verbatim}
%)

 fmod META-DD-SIGN is
  inc META-CAFE2MAUDE-SIGNATURE .
  inc META-FULL-MAUDE-SIGN .
  inc UNIT .

  op DD-GRAMMAR : -> FModule [memo] .
  eq DD-GRAMMAR = addImports((including 'DD-SIGNATURE .), CafeGRAMMAR) .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  op MODEX-LIST : -> FModule .
  eq MODEX-LIST
    = (fmod 'MODEX-LIST-GRAMMAR is
        including 'MOD-EXPRS-LIST .
        including 'QID .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '`, '. '`{ '`} ':)))] .
        op 'viewToken : 'Qid -> '@ViewToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        none
        none
     endfm) .

  op DR-LIST : -> FModule .
  eq DR-LIST
    = (fmod 'DR-LIST-GRAMMAR is
        including 'DEB-REL-LIST .
        including 'QID .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '`, '. '`{ '`} ':)))] .
        op 'viewToken : 'Qid -> '@ViewToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        none
        none
     endfm) .

***(%
\end{verbatim}
}

\end{comment}

{\codesize
\begin{verbatim}
  ...
%)

 endfm

***(%
\end{verbatim}
}

\end{comment}

The module \texttt{DD-COMMAND-PROCESSING} is in charge of processing
the commands dealing with suspicious statements, final sorts, and the
debugging commands:

{\codesize
\begin{verbatim}
%)

fmod DD-COMMAND-PROCESSING is
  pr CONFORMANCE-NARROWING .
  pr ENHANCED-OTHERWISE . *** MISSING-ANSWERS-TREE .
  pr COMMAND-PROCESSING .
  pr TEST-GENERATION .
  pr COVERAGE-TYPE .
  pr META-DD-SIGN .
  pr SEARCH-TYPE .
  pr GEN-MODE .
  pr DEB-REL .
  pr PRINT .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  vars T T' T'' TN TN' T1 T2 : Term .
  var  TL : TermList .
  vars DB DB' : Database .
  vars M M' UM CM : Module .
  var  M? : [Module] .
  var  ME : ModuleExpression .
  vars B B' SP BFS NARR? : Bool .
  vars QIL QIL' : QidList .
  var  VDS : OpDeclSet .
  vars Q Q' : Qid .
  vars T? T2? : [Term] .
  var  RP? : [ResultPair] .
  var  S? : [Sort] .
  var  MM : Maybe{Module} .
  vars BND BND' BNDW TD : Bound .
  vars QS QS' FS : QidSet .
  var  A : Tree .
  var  S : Sort .
  vars TT TTM TTW : TreeType .
  var  A? : Maybe{Tree} .
  var  J : Judgment .
  var  ST : SearchType .
  var  C? : [Condition] .
  var  C : Condition .
  vars N TB : Nat .
  var  N? : [Nat] .
  vars LTC LTC' : List{TestCase} .
  var  CT : CoverageType .
  var  CI : CoverageInfo .
  var  SS : SortSet .
  var  CONST : Constant .
  var  IL : ImportList .
  var  SSDS : SubsortDeclSet .
  var  ODS : OpDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RS : RuleSet .
  var  DO : DisplayOption .
  var  DR : DebRel? .
  var  GM : GenMode .

***(%
\end{verbatim}
}

\end{comment}

For example, the parsing of the debugging command for wrong answers returns a tuple containing the
generated tree, the module where the computation took place, the set
of suspicious statements, and a list of quoted identifiers indicating the errors
occurred during the parsing:

{\codesize
\begin{verbatim}
%)

  sort DebugTuple .
  op <_,_,_,_> : Forest Maybe{Module} QidSet QidList -> DebugTuple .

***(%
\end{verbatim}
}

The parsing of the command is done in the \texttt{GRAMMAR-DEB} module, where the first
bubble can contain either a module or just the initial term:

{\codesize
\begin{verbatim}
%)

  op GRAMMAR-DEB : -> FModule [memo] .
  eq GRAMMAR-DEB = addOps(op '_->_. : '@Bubble@ '@Bubble@ -> '@Judgment@ [none] .
                          op '_:_. : '@Bubble@ '@Bubble@ -> '@Judgment@ [none] .
                          op '_=>*_. : '@Bubble@ '@Bubble@ -> '@Judgment@ [none] .,
                          addSorts('@Judgment@, GRAMMAR-RED)) .

***(%
\end{verbatim}
}

The function \texttt{procDebug} processes a bubble and returns either a tree for
the corresponding debug command or an error message. It receives
the term to be parsed,
a correct module (possibly \texttt{undefMod}),
a Boolean indicating whether debug-select is on or off,
the set of suspicious labels,
the selected type of tree,
the bound of the search in the correct module,
the default module, and
Full Maude's database of modules.

After finding out the kind of the debugging command (reduction, membership, or rewrite)
and if a module name has been selected by the command, the function \texttt{procDebug} builds
the appropriate tree by using the functions \texttt{createTree} and \texttt{createRewTree} explained
in Section~\ref{subsec:dtc}:

{\codesize
\begin{verbatim}
%)

  op procDebug : Term Maybe{Module} Bool QidSet TreeType Bound ModuleExpression
                 Database -> DebugTuple .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  eq procDebug(T, MM, B, QS, TT, BND, ME, DB)
    = if compiledModule(ME, DB)
      then procDeb(T, MM, B, QS, TT, BND, ME, DB, getFlatModule(ME, DB), getVars(ME, DB))
      else procDeb(T, MM, B, QS, TT, BND, modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB)),
             getFlatModule(modExp(evalModExp(ME, DB)),
               database(evalModExp(ME, DB))),
             getVars(modExp(evalModExp(ME, DB)),
               database(evalModExp(ME, DB))))
      fi .
  eq procDebug(T, MM, B, QS, TT, BND, ME, DB) = < mtForest, undefMod, none, 'Debugging 'process 'aborted. > [owise] .

  op procDeb : Term Maybe{Module} Bool QidSet TreeType Bound ModuleExpression Database Module
               OpDeclSet -> DebugTuple .
  eq procDeb(T, MM, B, QS, TT, BND, ME, DB, M, VDS)
    = solveBubblesDeb(T, MM, B, QS, TT, BND, DB, M, VDS,
               included('META-MODULE, getImports(getTopModule(ME, DB)), DB)) .
  eq procDeb(T, MM, B, QS, TT, BND, ME, DB, unitError(QIL), VDS) = < mtForest, undefMod, none, QIL > .
  eq procDeb(T, MM, B, QS, TT, BND, ME, DB, noModule, VDS) = < mtForest, undefMod, none, ('\n '\r 'Error: '\o getMsg(DB)) > .

  op solveBubblesDeb : Term Maybe{Module} Bool QidSet TreeType Bound Database Module OpDeclSet
                       Bool -> DebugTuple .
  eq solveBubblesDeb('bubble['__[TL]], MM, B', QS, TT, BND, DB, M, VDS, B)
    =  if metaParse(GRAMMAR-DEB, downQidList('__[TL, ''..Qid]), '@RedInPart@) :: ResultPair
       then solveBubblesDebIn(getTerm(metaParse(GRAMMAR-DEB, downQidList('__[TL, ''..Qid]), '@RedInPart@)),
                              MM, B', QS, TT, BND, DB, M, VDS)
          else if metaParse(GRAMMAR-DEB, downQidList('__[TL, ''..Qid]), '@Judgment@) :: ResultPair
               then solveBubblesDebInf2(getTerm(metaParse(GRAMMAR-DEB, downQidList('__[TL, ''..Qid]), '@Judgment@)),
                                       MM, B', QS, TT, BND, DB, M, VDS, B)
               else < mtForest, undefMod, none, ('\r 'Warning: '\o
                      printSyntaxError(
                        metaParse(GRAMMAR-DEB, downQidList('__[TL, ''..Qid]), '@Judgment@), downQidList('__[TL, ''..Qid])) '\n
                      '\r 'Error: '\o 'no 'parse 'for downQidList('__[TL, ''..Qid]) '\n) >
               fi
          fi .

  op solveBubblesDebIn : Term Maybe{Module} Bool QidSet TreeType Bound Database Module OpDeclSet -> DebugTuple .
  ceq solveBubblesDebIn('in_:_.[T, T'], MM, B, QS, TT, BND, DB, M, VDS)
    = if unitInDb(ME, DB')
      then solveBubblesDebInf(T', MM, B, QS, TT, BND, DB', getFlatModule(ME, DB'), getVars(ME, DB'),
                              included('META-MODULE, getImports(getTopModule(ME, DB')), DB'))
      else < mtForest, undefMod, none, ('\n '\r 'Error: '\o  'It 'is 'not 'possible 'to
                               'compile eMetaPrettyPrint(ME) '. '\n) >
      fi
    if < DB' ; ME > := evalModExp(parseModExp(T), DB) .
  eq solveBubblesDebIn('in_:_.[T, T'], MM, B, QS, TT, BND, DB, M, VDS)
    = < mtForest, undefMod, none, ('\n '\r 'Error: '\o
      'It 'is 'not 'possible 'to 'compile eMetaPrettyPrint(parseModExp(T)) '. '\n) > [owise] .

  op solveBubblesDebInf : Term Maybe{Module} Bool QidSet TreeType Bound Database Module OpDeclSet Bool -> DebugTuple .
  eq solveBubblesDebInf('bubble['__[TL]], MM, B', QS, TT, BND, DB, M, VDS, B)
    =  if metaParse(GRAMMAR-DEB, downQidList('__[TL, ''..Qid]), '@Judgment@) :: ResultPair
       then solveBubblesDebInf2(getTerm(metaParse(GRAMMAR-DEB, downQidList('__[TL, ''..Qid]), '@Judgment@)),
                              MM, B', QS, TT, BND, DB, M, VDS, B)
          else < mtForest, undefMod, none, ('\n '\r 'Error: '\o
                      printSyntaxError(
                        metaParse(GRAMMAR-DEB, downQidList('__[TL, ''..Qid]),
                        '@Judgment@), downQidList('__[TL, ''..Qid])) '\n
                      '\r 'Error: '\o
                      'no 'parse 'for downQidList('__[TL, ''..Qid]) '\n) >
          fi .

  op solveBubblesDebInf2 : Term Maybe{Module} Bool QidSet TreeType Bound Database Module OpDeclSet Bool -> DebugTuple .
  ceq solveBubblesDebInf2('_->_.[T, T'], MM, B', QS, TT, BND, DB, M, VDS, B) =
      if T? :: Term
      then solveBubblesDebWithRed(T', MM, B', QS, DB, M, VDS, B, T?)
      else < mtForest, undefMod, none, ('\n '\r 'Error: '\o getMsg(T?)) >
      fi
   if T? := solveBubbles(T, M, B, VDS, DB) .

  ceq solveBubblesDebInf2('_:_.[T, T'], MM, B', QS, TT, BND, DB, M, VDS, B) =
      if T? :: Term
      then solveBubblesDebWithMb(T', MM, B', QS, M, T?, DB)
      else < mtForest, undefMod, none, ('\n '\r 'Error: '\o getMsg(T?)) >
      fi
   if T? := solveBubbles(T, M, B, VDS, DB) .

  ceq solveBubblesDebInf2('_=>*_.[T, T'], MM, B', QS, TT, BND, DB, M, VDS, B) =
      if T? :: Term
      then solveBubblesDebWithRew(T', MM, B', QS, TT, BND, DB, M, VDS, B, T?)
      else < mtForest, undefMod, none, ('\n '\r 'Error: '\o getMsg(T?)) >
      fi
   if T? := solveBubbles(T, M, B, VDS, DB) .

  op solveBubblesDebWithRed : Term Maybe{Module} Bool QidSet Database Module OpDeclSet Bool Term -> DebugTuple .
  ceq solveBubblesDebWithRed(T', MM, B', QS, DB, M, VDS, B, T)
    = if T? :: Term
      then generateTreeRed(T, T?, M, MM, B', QS, DB)
      else < mtForest, undefMod, none, ('\n '\r 'Error: '\o getMsg(T?)) >
      fi
    if T? := solveBubbles(T', M, B, VDS, DB) .

  op solveSort : Term Module -> [Sort] .
  ceq solveSort('bubble[T], M) =
      if RP? :: ResultPair then
        if parseSort(getTerm(RP?)) :: Sort then
           if parseSort(getTerm(RP?)) in getSorts(M) then parseSort(getTerm(RP?))
           else qidError('\n '\r 'Error: '\o 'the 'sort downQidList(T) 'does 'not 'exist. '\n)
           fi
        else parseSort(getTerm(RP?))
        fi
      else qidError('\n '\r 'Error: '\o 'no 'parse 'for downQidList(T) '\n)
      fi
   if RP? := metaParse(GRAMMAR-DEB, downQidList(T), '@Sort@) .

  op solveBubblesDebWithMb : Term Maybe{Module} Bool QidSet Module Term Database -> DebugTuple .

  ceq solveBubblesDebWithMb(T', MM, B, QS, M, T, DB)
    = if S? :: Sort
      then generateTreeMb(T, S?, M, MM, B, QS, DB)
      else < mtForest, undefMod, none, ('\n '\r 'Error: '\o getMsg(S?)) >
      fi
    if S? := solveSort(T', M) .

  op solveBubblesDebWithRew : Term Maybe{Module} Bool QidSet TreeType Bound Database Module OpDeclSet Bool Term -> DebugTuple .
  ceq solveBubblesDebWithRew(T', MM, B', QS, TT, BND, DB, M, VDS, B, T)
    = if T? :: Term
      then generateTreeRew(T, T?, M, MM, B', QS, TT, BND, DB)
      else < mtForest, undefMod, none, ('\n '\r 'Error: '\o getMsg(T?)) >
      fi
    if T? := solveBubbles(T', M, B, VDS, DB) .

  op generateTreeRed : Term Term Module Maybe{Module} Bool QidSet Database -> DebugTuple .
  ceq generateTreeRed(T, T', M, MM, B, QS, DB) =
      if normal(M, T') =/= reduce(M, T') then < mtForest, undefMod, none, ('\n '\r 'Error: '\o 'The 'second 'term 'is 'not 'fully 'reduced. '\n) >
      else if reduce(M, T) =/= reduce(M, T') then < mtForest, undefMod, none, ('\n '\r 'Error: '\o 'The 'first 'term 'does 'not 'reduce 'to
                                                   'the 'second 'one. '\n) >
           else if valid?(createTree(M, MM, TN, TN', QS')) then < createTree(M, MM, TN, TN', QS'), M, QS', nil >
                else < mtForest, undefMod, none, noInformation >
                fi
           fi
      fi
   if TN := normal(M, T) /\
      TN' := normal(M, T') /\
      QS' := if B then QS else extractLabels(M) fi .

  op generateTreeMb : Term Sort Module Maybe{Module} Bool QidSet Database -> DebugTuple .
  ceq generateTreeMb(T, S, M, MM, B, QS, DB) =
      if not sortLeq(M, getType(metaReduce(M, T)), S)
      then < mtForest, undefMod, none, '\n '\r 'Error: '\o 'The 'term 'has 'not 'sort S 'but getType(metaReduce(M, T)) '. '\n >
      else if valid?(createTree(M, MM, TN, S, QS')) then < createTree(M, MM, TN, S, QS'), M, QS', nil >
           else < mtForest, undefMod, none, noInformation >
           fi
      fi
   if TN := normal(M, T) /\
      QS' := if B then QS else extractLabels(M) fi .

  op generateTreeRew : Term Term Module Maybe{Module} Bool QidSet TreeType Bound Database -> DebugTuple .
  ceq generateTreeRew(T, T', M, MM, B, QS, TT, BND, DB) =
      if TN' =/= reduce(M, T') then < mtForest, undefMod, none, ('\n '\r 'Error: '\o 'The 'second 'term 'is 'not 'fully 'reduced. '\n) >
      else if A? == error then < mtForest, undefMod, none, ('\n '\r 'Error: '\o 'Unreachable 'state. '\n) >
                          else if valid?(A?) then < A?, M, QS', nil >
                                             else < mtForest, undefMod, none, noInformation >
                               fi
           fi
      fi
   if TN := normal(M, T) /\
      TN' := normal(M, T') /\
      QS' := if B then QS else extractLabels(M) fi /\
      A? := createRewTree(labeling(M), MM, TN, TN', QS', TT, BND) .

  op valid? : Tree -> Bool .
  eq valid?(tree(J, 1, mtForest)) = hasLabel?(J) .
  eq valid?(A) = true [owise] .

  op hasLabel? : Judgment -> Bool .
  eq hasLabel?(Q : T -> T') = true .
  eq hasLabel?(Q : T : S) = true .
  eq hasLabel?(Q : T =>1 T') = true .
  eq hasLabel?(J) = false [owise] .

***(%
\end{verbatim}
}

The parsing of the debugging command for missing answers
returns a term of sort \texttt{MissTuple}, that contains the generated tree, the module
where the debugging takes place, the type of search, the pattern used in the search,
the condition, the set of suspicious statements, and a list of quoted identifiers
with an error message:

{\codesize
\begin{verbatim}
%)

  sort MissTuple .
  op <_,_,_,_,_,_,_> : Forest Maybe{Module} SearchType Maybe{Term} Condition QidSet QidList
                       -> MissTuple [ctor] .

***(%
\end{verbatim}
}

Debugging commands for missing answers are parsed in the grammar \texttt{GRAMMAR-MISS},
that defines:

\begin{itemize}
\item The bound part, a token enclosed by square brackets.
\item The type of search: of zero or more steps (\verb"=>*"), one or more steps
(\verb"=>+"), and final (\verb=>!").
\item The condition part, started with the \verb"s.t.".
\end{itemize}

{\codesize
\begin{verbatim}
%)

  op GRAMMAR-MISS : -> FModule [memo] .
  eq GRAMMAR-MISS = addOps(op '`[_`]_. : '@Token@ '@Bubble@ -> '@MissingBound@ [none] .
                           op '_=>*_. : '@Bubble@ '@Bubble@ -> '@MissingSearch@ [none] .
                           op '_=>+_. : '@Bubble@ '@Bubble@ -> '@MissingSearch@ [none] .
                           op '_=>!_. : '@Bubble@ '@Bubble@ -> '@MissingSearch@ [none] .
                           op '_->_. : '@Bubble@ '@Bubble@ -> '@MissingSearch@ [none] .
                           op '_:_. : '@Bubble@ '@Bubble@ -> '@MissingSearch@ [none] .
                           op '_s.t._. : '@Bubble@ '@Bubble@ -> '@MissingCondition@ [none] .,
                           addSorts('@MissingBound@ ; '@MissingSearch@ ;
                                    '@MissingCondition@, GRAMMAR-RED)) .

***(%
\end{verbatim}
}

The function \texttt{procMissing} processes a bubble and returns either a tree for
the corresponding debug command or an error message.
In addition to the bubble containing the term to be parsed,
this function receives
a correct module (possibly \texttt{undefMod}),
a Boolean indicating whether selection mode for suspicious labels is activated,
the set of suspicious labels,
the selected type of tree (one-step or many-steps),
the bound of the search in the correct module,
the default module, and
the Full Maude's database of modules, and returns a value of
sort \texttt{MissTuple}, using to build the tree the function
\texttt{createMissingTree} shown in the previous section:

{\codesize
\begin{verbatim}
%)

  op procMissing : Term ModuleExpression Maybe{Module} TreeType TreeType Bool QidSet Bool
                   QidSet Bool Bound Database -> MissTuple .

  eq procMissing(T, ME, MM, TTW, TTM, B, QS, BFS, FS, SP, BNDW, DB)
    = if compiledModule(ME, DB)
      then procMiss(T, ME, MM, TTW, TTM, B, QS, BFS, FS, SP, BNDW, DB, getFlatModule(ME, DB),
                    getVars(ME, DB))
      else procMiss(T, modExp(evalModExp(ME, DB)), MM, TTW, TTM, B, QS, BFS, FS, SP, BNDW,
                   database(evalModExp(ME, DB)), getFlatModule(modExp(evalModExp(ME, DB)),
                   database(evalModExp(ME, DB))), getVars(modExp(evalModExp(ME, DB)),
                   database(evalModExp(ME, DB))))
      fi .
  eq procMissing(T, ME, MM, TTW, TTM, B, QS, BFS, FS, SP, BNDW, DB) =
       < mtForest, undefMod, final, maybe, nil, none,
         '\n '\r 'Error: '\o 'Debugging 'process 'aborted. > [owise] .

  op procMiss : Term ModuleExpression Maybe{Module} TreeType TreeType Bool QidSet Bool QidSet Bool
                Bound Database Module OpDeclSet -> MissTuple .
  eq procMiss(T, ME, MM, TTW, TTM, B, QS, BFS, FS, SP, BNDW, DB, M, VDS)
    = solveBubblesMiss(T, MM, TTW, TTM, B, QS, BFS, FS, SP, BNDW, DB, M, VDS,
               included('META-MODULE, getImports(getTopModule(ME, DB)), DB)) .
  eq procMiss(T, ME, MM, TTW, TTM, B, QS,  BFS, FS, SP, BNDW, DB, unitError(QIL), VDS) =
                 < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Error: '\o QIL) > .
  eq procMiss(T, ME, MM, TTW, TTM, B, QS,  BFS, FS, SP, BNDW, DB, noModule, VDS) =
                 < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Error: '\o getMsg(DB)) > .

  op solveBubblesMiss : Term Maybe{Module} TreeType TreeType Bool QidSet Bool QidSet Bool Bound
                        Database Module OpDeclSet Bool -> MissTuple .
  eq solveBubblesMiss('bubble['__[TL]], MM, TTW, TTM, B, QS, BFS, FS, SP, BNDW, DB, M, VDS, B')
    =  if metaParse(GRAMMAR-MISS, downQidList('__[TL, ''..Qid]), '@MissingBound@) :: ResultPair
       then solveBubblesMissBND(getTerm(metaParse(GRAMMAR-MISS, downQidList('__[TL, ''..Qid]), '@MissingBound@)),
                                MM, TTW, TTM, B, QS, BFS, FS, SP, BNDW, DB, M, VDS, B')
          else solveBubblesMiss2('bubble['__[TL]], MM, TTW, TTM, B, QS, BFS, FS, SP, BNDW, unbounded,
                                 DB, M, VDS, B')
          fi .

  op solveBubblesMissBND : Term Maybe{Module} TreeType TreeType Bool QidSet Bool QidSet Bool
                           Bound Database Module OpDeclSet Bool -> MissTuple .
  ceq solveBubblesMissBND('`[_`]_.['token[T], T'], MM, TTW, TTM, B, QS, BFS, FS, SP, BNDW, DB, M, VDS, B') =
        if N? :: Nat
        then solveBubblesMiss2(T', MM, TTW, TTM, B, QS, BFS, FS, SP, BNDW, N?, DB, M, VDS, B')
        else < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Error: '\o 'Wrong 'bound 'value.) >
        fi
   if N? := downNat*(T) .

  op solveBubblesMiss2 : Term Maybe{Module} TreeType TreeType Bool QidSet Bool QidSet Bool Bound
                         Bound Database Module OpDeclSet Bool -> MissTuple .
  eq solveBubblesMiss2('bubble['__[TL]], MM, TTW, TTM, B, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B')
    =  if metaParse(GRAMMAR-MISS, downQidList('__[TL, ''..Qid]), '@RedInPart@) :: ResultPair
       then solveBubblesMissIn(getTerm(metaParse(GRAMMAR-MISS, downQidList('__[TL, ''..Qid]), '@RedInPart@)),
                              MM, TTW, TTM, B, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS)
          else if metaParse(GRAMMAR-MISS, downQidList('__[TL, ''..Qid]), '@MissingSearch@) :: ResultPair
               then solveBubblesMissing2(getTerm(metaParse(GRAMMAR-MISS,
                                         downQidList('__[TL, ''..Qid]), '@MissingSearch@)),
                                         MM, TTW, TTM, if B then QS else extractLabels(M) fi, BFS, FS,
                                         SP, BNDW, BND, DB, M, VDS, B')
               else < mtForest, undefMod, final, maybe, nil, none, ('\r 'Warning: '\o
                      printSyntaxError(
                        metaParse(GRAMMAR-MISS, downQidList('__[TL, ''..Qid]), '@MissingSearch@), downQidList('__[TL, ''..Qid])) '\n
                      '\r 'Error: '\o 'no 'parse 'for downQidList('__[TL, ''..Qid]) '\n) >
               fi
          fi .

  op solveBubblesMissIn : Term Maybe{Module} TreeType TreeType Bool QidSet Bool QidSet Bool Bound
                          Bound Database Module OpDeclSet -> MissTuple .
  ceq solveBubblesMissIn('in_:_.[T, T'], MM, TTW, TTM, B, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS)
    = if unitInDb(ME, DB')
      then solveBubblesMissing(T', MM, TTW, TTM, if B then QS else extractLabels(getFlatModule(ME, DB')) fi,
                               BFS, FS, SP, BNDW, BND, DB', getFlatModule(ME, DB'),
                               getVars(ME, DB'), included('META-MODULE,
                               getImports(getTopModule(ME, DB')), DB'))
      else < mtForest, undefMod, final, maybe, nil, none,
             ('\n '\r 'Error: '\o  'It 'is 'not 'possible 'to
              'compile eMetaPrettyPrint(ME) '. '\n) >
      fi
    if < DB' ; ME > := evalModExp(parseModExp(T), DB) .
  eq solveBubblesMissIn('in_:_.[T, T'], MM, TTW, TTM, B, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS)
    = < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Error: '\o
      'It 'is 'not 'possible 'to 'compile eMetaPrettyPrint(parseModExp(T)) '. '\n) > [owise] .

  op solveBubblesMissing : Term Maybe{Module} TreeType TreeType QidSet Bool QidSet Bool Bound
                           Bound Database Module OpDeclSet Bool -> MissTuple .
  eq solveBubblesMissing('bubble['__[TL]], MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B)
    =  if metaParse(GRAMMAR-MISS, downQidList('__[TL, ''..Qid]), '@MissingSearch@) :: ResultPair
       then solveBubblesMissing2(getTerm(metaParse(GRAMMAR-MISS, downQidList('__[TL, ''..Qid]), '@MissingSearch@)),
                              MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B)
          else < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Warning: '\o
                      printSyntaxError(
                        metaParse(GRAMMAR-MISS, downQidList('__[TL, ''..Qid]),
                        '@MissingSearch@), downQidList('__[TL, ''..Qid])) '\n
                      '\r 'Error: '\o
                      'no 'parse 'for downQidList('__[TL, ''..Qid]) '\n) >
          fi .

  op solveBubblesMissing2 : Term Maybe{Module} TreeType TreeType QidSet Bool QidSet Bool Bound
                            Bound Database Module OpDeclSet Bool -> MissTuple .
  ceq solveBubblesMissing2('_=>*_.[T, T'], MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B) =
      if T? :: Term
      then solveBubblesMissing3(T', MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B, T?, zeroOrMore)
      else < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Error: '\o getMsg(T?)) >
      fi
   if T? := solveBubbles(T, M, B, VDS, DB) .

  ceq solveBubblesMissing2('_=>+_.[T, T'], MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B) =
      if T? :: Term
      then solveBubblesMissing3(T', MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B, T?, oneOrMore)
      else < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Error: '\o getMsg(T?)) >
      fi
   if T? := solveBubbles(T, M, B, VDS, DB) .

  ceq solveBubblesMissing2('_=>!_.[T, T'], MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B) =
      if T? :: Term
      then solveBubblesMissing3(T', MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B, T?, final)
      else < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Error: '\o getMsg(T?)) >
      fi
   if T? := solveBubbles(T, M, B, VDS, DB) .

  ceq solveBubblesMissing2('_->_.[T, T'], MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B) =
      if T? :: Term
      then if T2? :: Term
           then solveMissingRed(M, MM, T?, T2?, QS)
           else < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Error: '\o getMsg(T2?)) >
           fi
      else < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Error: '\o getMsg(T?)) >
      fi
   if T? := solveBubbles(T, M, B, VDS, DB) /\
      T2? := solveBubbles(T', M, B, VDS, DB) .
  ceq solveBubblesMissing2('_:_.[T, T'], MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B) =
      if T? :: Term
      then if S? :: Sort
           then solveMissingMb(M, MM, T?, S?, QS)
           else < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Error: '\o getMsg(S?)) >
           fi
      else < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Error: '\o getMsg(T?)) >
      fi
   if T? := solveBubbles(T, M, B, VDS, DB) /\
      S? := solveSort(T', M) .

  op solveBubblesMissing3 : Term Maybe{Module} TreeType TreeType QidSet Bool QidSet Bool
                            Bound Bound Database Module OpDeclSet Bool Term SearchType
                            -> MissTuple .
  eq solveBubblesMissing3('bubble['__[TL]], MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B, T1, ST)
    =  if metaParse(GRAMMAR-MISS, downQidList('__[TL, ''..Qid]), '@MissingCondition@) :: ResultPair
       then solveBubblesMissCond(getTerm(metaParse(GRAMMAR-MISS, downQidList('__[TL, ''..Qid]), '@MissingCondition@)),
                                 MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B, T1, ST)
          else if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
               then resolveMissing(MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, M, T1,
                                   solveBubbles('bubble['__[TL]], M, B, VDS, DB), ST, nil)
               else < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Error: '\o
                      getMsg(solveBubbles('bubble['__[TL]], M, B, VDS, DB))) >
               fi
          fi .
  ceq solveBubblesMissing3(T, MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B, T1, ST) =
         if T? :: Term
         then resolveMissing(MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, M, T1, T?, ST, nil)
         else < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Error: '\o getMsg(T?)) >
         fi
   if T? := solveBubbles(T, M, B, VDS, DB) .

  op solveBubblesMissCond : Term Maybe{Module} TreeType TreeType QidSet Bool QidSet Bool Bound
                            Bound Database Module OpDeclSet Bool Term SearchType
                            -> MissTuple .
  ceq solveBubblesMissCond('_s.t._.[T, T'], MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B, T1, ST)
    = if T? :: Term
      then solveBubblesMissing4(T', MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B, T1, T?, ST)
      else < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Error: '\o getMsg(T?)) >
      fi
   if T? := solveBubbles(T, M, B, VDS, DB) .

  op solveBubblesMissing4 : Term Maybe{Module} TreeType TreeType QidSet Bool QidSet Bool Bound
                            Bound Database Module OpDeclSet Bool Term Term SearchType
                            -> MissTuple .
  ceq solveBubblesMissing4(T, MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, DB, M, VDS, B, T1, T2, ST) =
         if C? :: Condition
         then resolveMissing(MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, M, T1, T2, ST, C?)
         else < mtForest, undefMod, final, maybe, nil, none, ('\n '\r 'Error: '\o getMsg(C?)) >
         fi
   if C? := solveBubblesCond(T, M, addInfoConds(M), B, VDS, DB) .

  op resolveMissing : Maybe{Module} TreeType TreeType QidSet Bool QidSet Bool Bound Bound Module
                      Term Term SearchType Condition -> MissTuple .
  ceq resolveMissing(MM, TTW, TTM, QS, BFS, FS, SP, BNDW, BND, M, T1, T2, ST, C) =
               < createMissingTree(M, MM, T1, T2, C, BNDW, BND', ST, TTW, TTM, QS, BFS, FS, B, SP),
                 M, ST, T2, C, QS, nil >
   if B := BND == unbounded /\
      BND' := if B then getBound(M, T1, getVar(M, T1), nil, 0)
                   else BND
              fi .

  op solveMissingRed : Module Maybe{Module} Term Term QidSet -> MissTuple .
  eq solveMissingRed(M, MM, T1, T2, QS) =
      < createMissingTree(M, MM, T1, T2, QS), M, final, T2, nil, QS, nil > .

  op solveMissingMb : Module Maybe{Module} Term Term QidSet -> MissTuple .
  eq solveMissingMb(M, MM, T, S, QS) =
      < createMissingTreeMb(M, MM, T, S, QS), M, final, T, nil, QS, nil > .

  op getMsg : Condition ~> QidList .
  eq getMsg(conditionError(QIL)) = QIL .

  op downNat* : Term -> [Nat] .
  eq downNat*(T) = rat(string(downQid(T)), 10) .

  op getVar : Module Term -> Variable .
  eq getVar(M, T) = qid("V@:" + string(leastSort(M, T))) .

***(%
\end{verbatim}
}

\end{comment}

The processing of the commands for selecting or deselecting the labels of
a list of modules is accomplished by the function \texttt{procInclude}. It
receives a Boolean indicating whether the selection option is enabled or not, the term
to be parsed (with the list of modules) and the Full Maude's database, and
it returns a pair with the set of labels from existing modules, and an
error message for the problematic modules:

{\codesize
\begin{verbatim}
%)

  sort IncludePair .
  op <_:_> : QidSet QidList -> IncludePair [ctor] .

  op procInclude : Term Database -> IncludePair .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  ceq procInclude('bubble[T], DB) =
        if RP? :: ResultPair then labels(getTerm(RP?), DB)
        else < none : ('\r 'Warning: '\o printSyntaxError(RP?, QIL) '\n
                       '\r 'Error: '\o 'no 'parse 'for QIL '\n) >
        fi
   if QIL := downQidList(T) /\
      RP? := metaParse(MODEX-LIST, QIL, '@NeModExpList@) .

  ops procIncludeEqs procIncludeMbs procIncludeRls : Term Database -> IncludePair .

  ceq procIncludeEqs('bubble[T], DB) =
        if RP? :: ResultPair then labelsEqs(getTerm(RP?), DB)
        else < none : ('\r 'Warning: '\o printSyntaxError(RP?, QIL) '\n
                       '\r 'Error: '\o 'no 'parse 'for QIL '\n) >
        fi
   if QIL := downQidList(T) /\
      RP? := metaParse(MODEX-LIST, QIL, '@NeModExpList@) .

  ceq procIncludeMbs('bubble[T], DB) =
        if RP? :: ResultPair then labelsMbs(getTerm(RP?), DB)
        else < none : ('\r 'Warning: '\o printSyntaxError(RP?, QIL) '\n
                       '\r 'Error: '\o 'no 'parse 'for QIL '\n) >
        fi
   if QIL := downQidList(T) /\
      RP? := metaParse(MODEX-LIST, QIL, '@NeModExpList@) .

  ceq procIncludeRls('bubble[T], DB) =
        if RP? :: ResultPair then labelsRls(getTerm(RP?), DB)
        else < none : ('\r 'Warning: '\o printSyntaxError(RP?, QIL) '\n
                       '\r 'Error: '\o 'no 'parse 'for QIL '\n) >
        fi
   if QIL := downQidList(T) /\
      RP? := metaParse(MODEX-LIST, QIL, '@NeModExpList@) .

  op labels : Term Database -> IncludePair .
  ceq labels('__[T, T'], DB) = < QS ; QS' : QIL QIL' >
   if  < QS : QIL > := labels(T, DB)  /\
       < QS' : QIL' > := labels(T', DB) .
  ceq labels(T, DB) = if M? :: Module then < extractLabels(M?) : nil > else < none : getMsg(M?) > fi
   if  ME := parseModExp(T) /\
       M? := if compiledModule(ME, DB)
             then getFlatModule(ME, DB)
             else getFlatModule(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB)))
             fi [owise] .

  op labelsEqs : Term Database -> IncludePair .
  ceq labelsEqs('__[T, T'], DB) = < QS ; QS' : QIL QIL' >
   if  < QS : QIL > := labelsEqs(T, DB)  /\
       < QS' : QIL' > := labelsEqs(T', DB) .
  ceq labelsEqs(T, DB) = if M? :: Module
                         then < extractLabels(getEqs(M?)) : nil >
                         else < none : getMsg(M?) > fi
   if  ME := parseModExp(T) /\
       M? := if compiledModule(ME, DB)
             then getFlatModule(ME, DB)
             else getFlatModule(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB)))
             fi [owise] .

  op labelsMbs : Term Database -> IncludePair .
  ceq labelsMbs('__[T, T'], DB) = < QS ; QS' : QIL QIL' >
   if  < QS : QIL > := labelsMbs(T, DB)  /\
       < QS' : QIL' > := labelsMbs(T', DB) .
  ceq labelsMbs(T, DB) = if M? :: Module
                         then < extractLabels(getMbs(M?)) : nil >
                         else < none : getMsg(M?) > fi
   if  ME := parseModExp(T) /\
       M? := if compiledModule(ME, DB)
             then getFlatModule(ME, DB)
             else getFlatModule(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB)))
             fi [owise] .

  op labelsRls : Term Database -> IncludePair .
  ceq labelsRls('__[T, T'], DB) = < QS ; QS' : QIL QIL' >
   if  < QS : QIL > := labelsRls(T, DB)  /\
       < QS' : QIL' > := labelsRls(T', DB) .
  ceq labelsRls(T, DB) = if M? :: Module
                         then < extractLabels(getRls(M?)) : nil >
                         else < none : getMsg(M?) > fi
   if  ME := parseModExp(T) /\
       M? := if compiledModule(ME, DB)
             then getFlatModule(ME, DB)
             else getFlatModule(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB)))
             fi [owise] .

  op list2set : QidList -> QidSet .
  eq list2set(Q QIL) = Q ; list2set(QIL) .
  eq list2set(nil) = none .

  op getMsg : Module ~> QidList .
  eq getMsg(unitError(QIL)) = QIL .
  eq getMsg(M?) = 'There 'are 'errors 'in 'some 'modules. [owise] .

  op procFinals : Term -> IncludePair .
  ceq procFinals('bubble[T]) =
        if RP? :: ResultPair then < sorts(getTerm(RP?)) : nil >
        else < none : ('\r 'Warning: '\o printSyntaxError(RP?, QIL) '\n
                       '\r 'Error: '\o 'no 'parse 'for QIL '\n) >
        fi
   if QIL := downQidList(T) /\
      RP? := metaParse(MODEX-LIST, QIL, '@NeModExpList@) .

  op sorts : Term -> QidSet .
  eq sorts('__[T, T']) = sorts(T) ; sorts(T') .
  eq sorts(T) = viewExp2Qid(parseModExp(T)) [owise] .

***(%
\end{verbatim}
}

The sort \verb"TestTuple"

{\codesize
\begin{verbatim}
  ...
%)

  sort TestTuple .
  op <_,_,_,_,_,_> : Maybe{Module} List{TestCase} CoverageInfo Maybe{Term} Condition QidList
                     -> TestTuple [ctor] .

  op GRAMMAR-TEST : -> FModule [memo] .
  eq GRAMMAR-TEST = addOps(op '`[_`]_. : '@Token@ '@Bubble@ -> '@TestBound@ [none] .
                           op '_:_. : '@Bubble@ '@Bubble@ -> '@TestGen@ [none] .
                           op '_wrt_. : '@Bubble@ '@Bubble@ -> '@TestGen@ [none] .
                           op '_=>+_. : '@Bubble@ '@Bubble@ -> '@TestGen@ [none] .
                           op '_=>*_. : '@Bubble@ '@Bubble@ -> '@TestGen@ [none] .
                           op '_=>!_. : '@Bubble@ '@Bubble@ -> '@TestGen@ [none] .
                           op '_models_. : '@Bubble@ '@Bubble@ -> '@TestGen@ [none] .
                           op '_s.t._. : '@Bubble@ '@Bubble@ -> '@TestCondition@ [none] .
                           op '_for_. : '@Bubble@ '@Bubble@ -> '@TestFormula@ [none] .,
                           addSorts('@TestBound@ ; '@TestGen@ ; '@TestCondition@ ;
                                    '@TestFormula@, GRAMMAR-RED)) .

  op procTest : Term ModuleExpression Maybe{Module} QidSet SortSet Bool Nat Bound CoverageType
                GenMode DisplayOption Database -> TestTuple .
  eq procTest(T, ME, MM, QS, SS, B, TB, TD, CT, GM, DO, DB)
    = if compiledModule(ME, DB)
      then procTest(T, ME, MM, QS, SS, B, TB, TD, CT, GM, DO, DB, getFlatModule(ME, DB),
                    getVars(ME, DB))
      else procTest(T, modExp(evalModExp(ME, DB)), MM, QS, SS, B, TB, TD, CT, GM, DO,
                   database(evalModExp(ME, DB)), getFlatModule(modExp(evalModExp(ME, DB)),
                   database(evalModExp(ME, DB))), getVars(modExp(evalModExp(ME, DB)),
                   database(evalModExp(ME, DB))))
      fi .
  eq procTest(T, ME, MM, QS, SS, B, TB, TD, CT, GM, DO, DB) =
       < undefMod, nil, noCoverageInfo, maybe, nil,
         '\n '\r 'Error: '\o 'Debugging 'process 'aborted. > [owise] .

  op procTest : Term ModuleExpression Maybe{Module} QidSet SortSet Bool Nat Bound CoverageType
                GenMode DisplayOption Database Module OpDeclSet -> TestTuple .
  eq procTest(T, ME, MM, QS, SS, B, TB, TD, CT, GM, DO, DB, M, VDS)
    = solveBubblesTest(T, MM, QS, SS, B, TB, TD, CT, GM, DO, DB, M, VDS,
               included('META-MODULE, getImports(getTopModule(ME, DB)), DB)) .
  eq procTest(T, ME, MM, QS, SS, B, TB, TD, CT, GM, DO, DB, unitError(QIL), VDS) =
                 < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o QIL) > .
  eq procTest(T, ME, MM, QS, SS, B, TB, TD, CT, GM, DO, DB, noModule, VDS) =
                 < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o getMsg(DB)) > .

  op solveBubblesTest : Term Maybe{Module} QidSet SortSet Bool Nat Bound CoverageType GenMode
                        DisplayOption Database Module OpDeclSet Bool -> TestTuple .
  eq solveBubblesTest('bubble['__[TL]], MM, QS, SS, B, TB, TD, CT, GM, DO, DB, M, VDS, B')
    =  if metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@TestBound@) :: ResultPair
       then solveBubblesTestBnd(getTerm(metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@TestBound@)),
                               MM, QS, SS, B, TB, TD, CT, GM, DO, DB, M, VDS, B')
       else solveBubblesTest2('bubble['__[TL]], MM, QS, SS, B, TB, TD, unbounded, CT, GM, DO, DB, M, VDS, B')
       fi .
  eq solveBubblesTest(T, MM, QS, SS, B, TB, TD, CT, GM, DO, DB, M, VDS, B') =
          solveBubblesTest3(T, MM, QS, SS, B, TB, TD, unbounded, CT, GM, DO, DB, M, VDS, B') [owise] .

  op solveBubblesTestBnd : Term Maybe{Module} QidSet SortSet Bool Nat Bound CoverageType GenMode
                           DisplayOption Database Module OpDeclSet Bool -> TestTuple .
  ceq solveBubblesTestBnd('`[_`]_.['token[T], T'], MM, QS, SS, B, TB, TD, CT, GM, DO, DB, M, VDS, B') =
        if N? :: Nat
        then solveBubblesTest2(T', MM, QS, SS, B, TB, TD, N?, CT, GM, DO, DB, M, VDS, B')
        else < undefMod, nil, noCoverageInfo, maybe, nil,
               ('\n '\r 'Error: '\o 'Wrong 'bound 'value.) >
        fi
   if N? := downNat*(T) .
  eq solveBubblesTestBnd(T, MM, QS, SS, B, TB, TD, CT, GM, DO, DB, M, VDS, B') =
     < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o 'Wrong 'bound 'value.) > .

  op solveBubblesTest2 : Term Maybe{Module} QidSet SortSet Bool Nat Bound Bound CoverageType
                         GenMode DisplayOption Database Module OpDeclSet Bool -> TestTuple .
  eq solveBubblesTest2('bubble['__[TL]], MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B')
    =  if metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@RedInPart@) :: ResultPair
       then solveBubblesTestIn(getTerm(metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@RedInPart@)),
                               MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B')
          else if metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@TestGen@) :: ResultPair
               then solveBubblesTest3(getTerm(metaParse(GRAMMAR-TEST,
                                         downQidList('__[TL, ''..Qid]), '@TestGen@)),
                                         MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B')
               else < undefMod, nil, noCoverageInfo, maybe, nil,
                        ('\r 'Warning: '\o printSyntaxError(
                        metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@TestGen@),
                        downQidList('__[TL, ''..Qid])) '\n '\r 'Error: '\o 'no 'parse 'for
                        downQidList('__[TL, ''..Qid]) '\n) >
               fi
          fi .
  eq solveBubblesTest2(T, MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B') =
           < undefMod, nil, noCoverageInfo, maybe, nil,
             ('\n '\r 'Error: '\o 'No 'parse 'for 'command.) > [owise] .

  op solveBubblesTestIn : Term Maybe{Module} QidSet SortSet Bool Nat Bound Bound CoverageType
                          GenMode DisplayOption Database Module OpDeclSet Bool -> TestTuple .
  ceq solveBubblesTestIn('in_:_.[T, T'], MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B')
    = if unitInDb(ME, DB')
      then solveBubblesTest3(T', MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB', getFlatModule(ME, DB'),
                             getVars(ME, DB'), included('META-MODULE, getImports(getTopModule(ME, DB')), DB'))
      else < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o  'It 'is
                                 'not 'possible 'to 'compile eMetaPrettyPrint(ME) '. '\n) >
      fi
    if < DB' ; ME > := evalModExp(parseModExp(T), DB) .
  eq solveBubblesTestIn('in_:_.[T, T'], MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B')
    = < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
      'It 'is 'not 'possible 'to 'compile eMetaPrettyPrint(parseModExp(T)) '. '\n) > [owise] .

  op solveBubblesTest3 : Term Maybe{Module} QidSet SortSet Bool Nat Bound Bound CoverageType
                         GenMode DisplayOption Database Module OpDeclSet Bool -> TestTuple .
  eq solveBubblesTest3('bubble['__[TL]], MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B')
    =  if metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@TestGen@) :: ResultPair
       then solveBubblesTest4(getTerm(metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@TestGen@)),
                               MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B')
          else if metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@Judgment@) :: ResultPair
               then solveBubblesTest5(getTerm(metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@Judgment@)),
                                      getTerm(metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@Judgment@)),
                                      MM, QS, SS, B, TB, TD, CT, GM, DO, DB, M, VDS)
               else < undefMod, nil, noCoverageInfo, maybe, nil,
                      ('\r 'Warning: '\o printSyntaxError(
                        metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@Judgment@), downQidList('__[TL, ''..Qid])) '\n
                      '\r 'Error: '\o 'no 'parse 'for downQidList('__[TL, ''..Qid]) '\n) >
               fi
          fi .
  eq solveBubblesTest3('bubble[T], MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B') =
                  solveBubblesTest5('bubble[T], 'bubble[T], MM, QS, SS, B, TB, TD,
                                    CT, GM, DO, DB, M, VDS) [owise] .
  eq solveBubblesTest3(T, MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B') =
           solveBubblesTest4(T, MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B') [owise] .

  op solveBubblesTest4 : Term Maybe{Module} QidSet SortSet Bool Nat Bound Bound CoverageType
                         GenMode DisplayOption Database Module OpDeclSet Bool -> TestTuple .
  eq solveBubblesTest4('_wrt_.[T, T'], MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B')
    = solveBubblesTest5(T, T', MM, QS, SS, B, TB, TD, CT, GM, DO, DB, M, VDS) .
  ceq solveBubblesTest4('_=>*_.['bubble[T], T'], MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B')
    = solveBubblesTestSrch(T', MM, QS, SS, B, TB, TD, CT, GM, DB, M, VDS, B', zeroOrMore, Q)
   if Q := downQid(T) .
  ceq solveBubblesTest4('_=>+_.['bubble[T], T'], MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B')
    = solveBubblesTestSrch(T', MM, QS, SS, B, TB, TD, CT, GM, DB, M, VDS, B', oneOrMore, Q)
   if Q := downQid(T) .
  ceq solveBubblesTest4('_=>!_.['bubble[T], T'], MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B')
    = solveBubblesTestSrch(T', MM, QS, SS, B, TB, TD, CT, GM, DB, M, VDS, B', final, Q)
   if Q := downQid(T) .
  ceq solveBubblesTest4('_models_.['bubble[T], T'], MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B')
    = solveBubblesTestMC(T', MM, QS, SS, B, TB, TD, CT, DB, M, VDS, B', Q)
   if Q := downQid(T) .
  eq solveBubblesTest4(T, MM, QS, SS, B, TB, TD, BND, CT, GM, DO, DB, M, VDS, B') =
            < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error:
                                              'No 'parse 'for 'the 'command. '\o '\n) > [owise] .

  op solveBubblesTest5 : Term Term Maybe{Module} QidSet SortSet Bool Nat Bound CoverageType
                         GenMode DisplayOption Database Module OpDeclSet -> TestTuple .
  ceq solveBubblesTest5('bubble[T], 'bubble[T'], MM, QS, SS, B, TB, TD, CT, GM, DO, DB, M, VDS) =
          solveBubblesTestFun('bubble[T], 'bubble[T'], MM, QS, B, TB, CT, GM, DO, DB, M, VDS)
   if not sort?(M, T) .
  ceq solveBubblesTest5('bubble[T], 'bubble[T'], MM, QS, SS, B, TB, TD, CT, GM, DO, DB, M, VDS) =
         solveBubblesTestSys('bubble[T], 'bubble[T'], MM, QS, SS, B, TB, CT, TD, GM, DO, DB, M)
   if sort?(M, T) .
  eq solveBubblesTest5(T, T', MM, QS, SS, B, TB, TD, CT, GM, DO, DB, M, VDS) =
       < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
         'No 'parse 'for 'term. '\n) > [owise] .

  op solveBubblesTestFun : Term Term Maybe{Module} QidSet Bool Nat CoverageType GenMode DisplayOption
                           Database Module OpDeclSet -> TestTuple .
  ceq solveBubblesTestFun('bubble[T], 'bubble[T'], MM, QS, B, TB, CT, GM, DO, DB, M, VDS) =
                                                                     < M, LTC, CI, maybe, nil, nil >
   if Q := downQid(T) /\
      Q' := downQid(T') /\
      QS' := if B then QS else extractLabels(M) fi /\
      < LTC, CI > := if GM == narrowing
                     then coverageNarrowing(M, Q, TB, QS', DO, CT)
                     else generateTestCases(M, MM, Q, Q', QS', TB, CT)
                     fi .
  ceq solveBubblesTestFun('bubble[T], 'bubble[T'], MM, QS, B, TB, CT, GM, DO, DB, M, VDS) =
       < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
         'No 'test 'cases 'were 'generated 'for 'the 'given 'operator. '\n) >
   if Q := downQid(T) /\
      Q' := downQid(T') /\
      QS' := if B then QS else extractLabels(M) fi /\
      testGenError == generateTestCases(M, MM, Q, Q', QS', TB, CT) .
  eq solveBubblesTestFun(T, T', MM, QS, B, TB, CT, GM, DO, DB, M, VDS) =
       < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
         'No 'parse 'for 'term. '\n) > [owise] .

 op t : Term -> QidList [ctor] .

  op solveBubblesTestSys : Term Term Maybe{Module} QidSet SortSet Bool Nat CoverageType Bound
                           GenMode DisplayOption Database Module -> TestTuple .
  ceq solveBubblesTestSys('bubble[T], 'bubble[T'], undefMod, QS, SS, B, TB, CT, TD, GM, DO, DB, M) =
                                                                     < M, LTC, CI, maybe, nil, nil >
   if Q := downQid(T) /\
      Q' := downQid(T') /\
      QS' := if B then (QS ; extractLabelsSort*(SS, M)) else extractLabels(M) fi /\
      < LTC, CI > := if GM == narrowing
                     then coverageNarrowing(M, Q, TD, QS', DO, CT)
                     else generateTestCasesSys(M, undefMod, Q, Q', TD, QS', TB, CT)
                     fi .
  ceq solveBubblesTestSys('bubble[T], 'bubble[T'], undefMod, QS, SS, B, TB, CT, TD, GM, DO, DB, M) =
       < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
         'No 'test 'cases 'were 'generated 'for 'the 'given 'operator. '\n) >
   if Q := downQid(T) /\
      Q' := downQid(T') /\
      QS' := if B then (QS ; extractLabelsSort*(SS, M)) else extractLabels(M) fi /\
      testGenError == if GM == narrowing
                      then coverageNarrowing(M, Q, TD, QS', DO, CT)
                      else generateTestCasesSys(M, undefMod, Q, Q', TD, QS', TB, CT)
                      fi .
  ceq solveBubblesTestSys('bubble[T], 'bubble[T'], M', QS, SS, B, TB, CT, TD, GM, DO, DB, M) =
                                                                     < M, LTC, CI, maybe, nil, nil >
   if Q := downQid(T) /\
      QS' := if B then (QS ; extractLabelsSort*(SS, M')) else extractLabels(M') fi /\
      < LTC, CI > := if GM == narrowing
                     then narrConf(M, M', Q, TD, QS')
                     else generateTestConf(M, M', Q, QS', TD, TB, CT)
                     fi .
  ceq solveBubblesTestSys('bubble[T], 'bubble[T'], M', QS, SS, B, TB, CT, TD, GM, DO, DB, M) =
       < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
         'No 'test 'cases 'were 'generated 'for 'the 'given 'operator. '\n) >
   if Q := downQid(T) /\
      QS' := if B then (QS ; extractLabelsSort*(SS, M')) else extractLabels(M') fi /\
      testGenError == if GM == narrowing
                      then narrConf(M, M', Q, TD, QS')
                      else generateTestConf(M, M', Q, QS', TD, TB, CT)
                      fi .
  eq solveBubblesTestSys(T, T', MM, QS, SS, B, TB, CT, TD, GM, DO, DB, M) =
       < undefMod, nil, noCoverageInfo, maybe, nil,
         ('\n '\r 'Error: '\o 'No 'parse 'for 'term. '\n) > [owise] .

  op solveBubblesTestSrch : Term Maybe{Module} QidSet SortSet Bool Nat Bound CoverageType GenMode
                            Database Module OpDeclSet Bool SearchType Sort -> TestTuple .
  eq solveBubblesTestSrch('bubble['__[TL]], MM, QS, SS, B, TB, TD, CT, GM, DB, M, VDS, B', ST, S)
    =  if metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@TestCondition@) :: ResultPair
       then solveBubblesTestCond(getTerm(metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@TestCondition@)),
                                 MM, QS, SS, B, TB, TD, CT, GM, DB, M, VDS, B', ST, S)
          else if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
               then resolveTestSrch(MM, QS, SS, B, TB, TD, CT, GM, M, ST, S,
                                    solveBubbles('bubble['__[TL]], M, B, VDS, DB), nil)
               else < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
                      getMsg(solveBubbles('bubble['__[TL]], M, B, VDS, DB))) >
               fi
          fi .
  ceq solveBubblesTestSrch(T, MM, QS, SS, B, TB, TD, CT, GM, DB, M, VDS, B', ST, S) =
         if T? :: Term
         then resolveTestSrch(MM, QS, SS, B, TB, TD, CT, GM, M, ST, S, T?, nil)
         else < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o getMsg(T?)) >
         fi
   if T? := solveBubbles(T, M, B', VDS, DB) .
  eq solveBubblesTestSrch(T, MM, QS, SS, B, TB, TD, CT, GM, DB, M, VDS, B', ST, S) =
      < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
                              'No 'parse 'for 'term. '\n) > [owise] .

  op solveBubblesTestCond : Term Maybe{Module} QidSet SortSet Bool Nat Bound CoverageType GenMode
                            Database Module OpDeclSet Bool SearchType Sort -> TestTuple .
  ceq solveBubblesTestCond('_s.t._.[T, T'], MM, QS, SS, B, TB, TD, CT, GM, DB, M, VDS, B', ST, S) =
       if T? :: Term
       then if solveBubblesCond(T', M, addInfoConds(M), B', VDS, DB) :: Condition
            then resolveTestSrch(MM, QS, SS, B, TB, TD, CT, GM, M, ST, S, T?, solveBubblesCond(T', M, addInfoConds(M), B', VDS, DB))
            else < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o getMsg(solveBubblesCond(T', M, addInfoConds(M), B', VDS, DB))) >
            fi
       else < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o getMsg(T?)) >
       fi
   if T? := solveBubbles(T, M, B', VDS, DB) .
  eq solveBubblesTestCond(T, MM, QS, SS, B, TB, TD, CT, GM, DB, M, VDS, B', ST, S) =
      < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
                              'No 'parse 'for 'condition. '\n) > [owise] .

  op resolveTestSrch : Maybe{Module} QidSet SortSet Bool Nat Bound CoverageType GenMode
                       Module SearchType Sort Term Condition -> TestTuple .
  ceq resolveTestSrch(MM, QS, SS, B, TB, TD, CT, GM, M, ST, S, T?, C) = < M, LTC, CI, T?, C, nil >
   if QS' := if B then (QS ; extractLabelsSort*(SS, M)) else extractLabels(M) fi /\
      Q := if ST == zeroOrMore
           then '*
           else if ST == oneOrMore
                then '+
                else '!
                fi
           fi /\
      < LTC, CI > := if GM == narrowing
                     then narrInv(M, S, T?, C, TD, Q)
                     else generateTestCasesInv(M, MM, S, ST, TD, T?, C, QS', TB, CT)
                     fi .
  eq resolveTestSrch(MM, QS, SS, B, TB, TD, CT, GM, M, ST, S, T?, C) =
             < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
                              'No 'parse 'for 'term. '\n) > [owise] .

  op solveBubblesTestMC : Term Maybe{Module} QidSet SortSet Bool Nat Bound CoverageType Database
                          Module OpDeclSet Bool Sort -> TestTuple .
  eq solveBubblesTestMC('bubble['__[TL]], MM, QS, SS, B, TB, TD, CT, DB, M, VDS, B', S)
    =  if metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@TestFormula@) :: ResultPair
       then solveBubblesTestFormula(getTerm(metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@TestFormula@)),
                                 MM, QS, SS, B, TB, TD, CT, DB, M, VDS, B', S)
          else if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
               then resolveTestMC(MM, QS, SS, B, TB, TD, CT, M, S,
                                  solveBubbles('bubble['__[TL]], M, B, VDS, DB), 'True.Formula)
               else < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
                      getMsg(solveBubbles('bubble['__[TL]], M, B, VDS, DB))) >
               fi
          fi .
  ceq solveBubblesTestMC(T, MM, QS, SS, B, TB, TD, CT, DB, M, VDS, B', S) =
         if T? :: Term
         then resolveTestMC(MM, QS, SS, B, TB, TD, CT, M, S, T?, 'True.Formula)
         else < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o getMsg(T?)) >
         fi
   if T? := solveBubbles(T, M, B', VDS, DB) .
  eq solveBubblesTestMC(T, MM, QS, SS, B, TB, TD, CT, DB, M, VDS, B', S) =
      < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
                              'No 'parse 'for 'term. '\n) > [owise] .

  op solveBubblesTestFormula : Term Maybe{Module} QidSet SortSet Bool Nat Bound CoverageType Database
                               Module OpDeclSet Bool Sort -> TestTuple .
  ceq solveBubblesTestFormula('_for_.[T, T'], MM, QS, SS, B, TB, TD, CT, DB, M, VDS, B', S) =
       if T? :: Term
       then resolveTestMC(MM, QS, SS, B, TB, TD, CT, M, S, T?, T'')
       else < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o getMsg(T?)) >
       fi
   if T? := solveBubbles(T, M, B', VDS, DB) /\
      T'' := solveBubblesFormula(putFormulas(M), T') .
  eq solveBubblesTestFormula(T, MM, QS, SS, B, TB, TD, CT, DB, M, VDS, B', S) =
      < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
                              'No 'parse 'for 'formula. '\n) > [owise] .

  op solveBubblesFormula : Module Term ~> Term .
  eq solveBubblesFormula(M, 'bubble[TL]) = getTerm(metaParse(M, downQidList(TL), '@Formula@)) .

  op resolveTestMC : Maybe{Module} QidSet SortSet Bool Nat Bound CoverageType
                     Module Sort Term Term -> TestTuple .
  ceq resolveTestMC(MM, QS, SS, B, TB, TD, CT, M, S, T?, T') = < M, LTC, CI, T?, nil, nil >
   if QS' := if B then (QS ; extractLabelsSort*(SS, M)) else extractLabels(M) fi /\
      < LTC, CI > := genTestCasesMC(M, MM, S, TD, T?, T', QS', TB, CT) .
  eq resolveTestMC(MM, QS, SS, B, TB, TD, CT, M, S, T, T') =
          < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
                              'Fin 'parsing. '\n) > [owise] .

  op putFormulas : Module -> Module .
  eq putFormulas(M) = addOps(getOps(upModule('LTL-SYNTAX, false)),
                      addSubsorts(subsort 'Bool < '@Formula@ ., addSorts('@Formula@, M))) .

  op sort? : Module Term -> Bool .
  eq sort?(M, T) = downQid(T) in getSorts(M) .

  op procTestMb : Term ModuleExpression Maybe{Module} QidSet Bool Bound Database -> TestTuple .
  eq procTestMb(T, ME, MM, QS, B, TB, DB)
    = if compiledModule(ME, DB)
      then procTestMb(T, ME, MM, QS, B, TB, DB, getFlatModule(ME, DB),
                      getVars(ME, DB))
      else procTestMb(T, modExp(evalModExp(ME, DB)), MM, QS, B, TB,
                      database(evalModExp(ME, DB)), getFlatModule(modExp(evalModExp(ME, DB)),
                      database(evalModExp(ME, DB))), getVars(modExp(evalModExp(ME, DB)),
                      database(evalModExp(ME, DB))))
      fi .
  eq procTestMb(T, ME, MM, QS, B, TB, DB) =
       < undefMod, nil, noCoverageInfo, maybe, nil,
         '\n '\r 'Error: '\o 'Debugging 'process 'aborted. > [owise] .

  op procTestMb : Term ModuleExpression Maybe{Module} QidSet Bool Nat Database Module
                  OpDeclSet -> TestTuple .
  eq procTestMb(T, ME, MM, QS, B, TB, DB, M, VDS)
    = solveBubblesTestMb(T, MM, QS, B, TB, DB, M, VDS,
               included('META-MODULE, getImports(getTopModule(ME, DB)), DB)) .
  eq procTestMb(T, ME, MM, QS, B, TB, DB, unitError(QIL), VDS) =
                 < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o QIL) > .
  eq procTestMb(T, ME, MM, QS, B, TB, DB, noModule, VDS) =
                 < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o getMsg(DB)) > .

  op solveBubblesTestMb : Term Maybe{Module} QidSet Bool Nat Database Module OpDeclSet Bool
                          -> TestTuple .
  eq solveBubblesTestMb('bubble['__[TL]], MM, QS, B, TB, DB, M, VDS, B')
    =  if metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@RedInPart@) :: ResultPair
       then solveBubblesTestMbIn(getTerm(metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@RedInPart@)),
                               MM, QS, B, TB, DB, M, VDS)
          else if metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@Judgment@) :: ResultPair
               then solveBubblesTestMb2(getTerm(metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@Judgment@)),
                                      MM, QS, B, TB, DB, M)
               else < undefMod, nil, noCoverageInfo, maybe, nil,
                      ('\r 'Warning: '\o printSyntaxError(
                        metaParse(GRAMMAR-TEST, downQidList('__[TL, ''..Qid]), '@Judgment@), downQidList('__[TL, ''..Qid])) '\n
                      '\r 'Error: '\o 'no 'parse 'for downQidList('__[TL, ''..Qid]) '\n) >
               fi
          fi .
  eq solveBubblesTestMb('bubble[T], MM, QS, B, TB, DB, M, VDS, B') =
                                solveBubblesTestMb2('bubble[T], MM, QS, B, TB, DB, M) [owise] .

  op solveBubblesTestMbIn : Term Maybe{Module} QidSet Bool Nat Database Module OpDeclSet
                            -> TestTuple .
  ceq solveBubblesTestMbIn('in_:_.[T, T'], MM, QS, B, TB, DB, M, VDS)
    = if unitInDb(ME, DB')
      then solveBubblesTestMb2(T', MM, QS, B, TB, DB', getFlatModule(ME, DB'))
      else < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o  'It 'is
                                 'not 'possible 'to 'compile eMetaPrettyPrint(ME) '. '\n) >
      fi
    if < DB' ; ME > := evalModExp(parseModExp(T), DB) .
  eq solveBubblesTestMbIn('in_:_.[T, T'], MM, QS, B, TB, DB, M, VDS)
    = < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
      'It 'is 'not 'possible 'to 'compile eMetaPrettyPrint(parseModExp(T)) '. '\n) > [owise] .

  op solveBubblesTestMb2 : Term Maybe{Module} QidSet Bool Nat Database Module -> TestTuple .
  ceq solveBubblesTestMb2('bubble[T], MM, QS, B, TB, DB, M) = < M, LTC, CI, maybe, nil, nil >
   if Q := downQid(T) /\
      QS' := if B then QS else extractLabels(M) fi /\
      < LTC, CI > := generateTestCasesMb(M, MM, Q, QS', TB) .
  ceq solveBubblesTestMb2('bubble[T], MM, QS, B, TB, DB, M) =
       < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
         'No 'test 'cases 'were 'generated 'for 'the 'given 'operator. '\n) >
   if Q := downQid(T) /\
      QS' := if B then QS else extractLabels(M) fi /\
      testGenError == generateTestCasesMb(M, MM, Q, QS', TB) .
  eq solveBubblesTestMb2(T, MM, QS, B, TB, DB, M) =
       < undefMod, nil, noCoverageInfo, maybe, nil, ('\n '\r 'Error: '\o
         'No 'parse 'for 'term. '\n) > [owise] .

  sort DebRelTuple .
  op <_,_> : DebRel? Database -> DebRelTuple .

  op solveBubbleDebRel : Term Term Database -> DebRelTuple .
  ceq solveBubbleDebRel(T1, 'bubble[T2], DB) = < DR, DB' >
   if < DB' ; ME > := evalModExp(parseModExp(T1), DB) /\
      M? := if compiledModule(ME, DB)
            then getFlatModule(ME, DB)
            else getFlatModule(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB)))
            fi /\
      T := getTerm(metaParse(DR-LIST, downQidList(T2), '@DebRelList@)) /\ *** metaParse(DR-LIST, downQidList('__[''asd.Qid,''debugs.Qid,''Nat.Qid]), '@DebRelList@)
      DR := downDebRel(T) .
  eq solveBubbleDebRel(T1, T2, DB) = < errorDR, DB > [owise] .

  op downDebRel : Term -> DebRel? .
  eq downDebRel('mtDR.DebRel) = mtDR .
  eq downDebRel('__[TL]) = downDebRel*(TL) .
  eq downDebRel('_debugs_.['token[T1], 'token[T2]]) = downQid(T1) debugs downQid(T2) .
  eq downDebRel(T) = errorDR [owise] .

  op downDebRel* : TermList -> DebRel? .
  eq downDebRel*(empty) = mtDR .
  eq downDebRel*((T, TL)) = downDebRel(T) ; downDebRel*(TL) .

***(%
\end{verbatim}
}

\end{comment}

{\codesize
\begin{verbatim}
  ...
%)

endfm

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

fmod TEST-INFO is
 pr LIST{TestCase} .

 sort LoopTestAttrSoup LoopTestAttr .
 subsort LoopTestAttr < LoopTestAttrSoup .

 var  LTC LTC' : List{TestCase} .
 var  LTAS : LoopTestAttrSoup .
 var  T T' T'' : Term .
 var  Ty : Type .
 var  QIL : QidList .
 var  Q : Qid .

 op mtTestInfo : -> LoopTestAttrSoup [ctor] .
 op _,_ : LoopTestAttrSoup LoopTestAttrSoup
          -> LoopTestAttrSoup [ctor comm assoc id: mtTestInfo] .

 op okTests :_ : List{TestCase} -> LoopTestAttr [ctor gather(&)] .
 op notNormTests :_ : List{TestCase} -> LoopTestAttr [ctor gather(&)] .
 op userTests :_ : List{TestCase} -> LoopTestAttr [ctor gather(&)] .
 op wrongCMTests :_ : List{TestCase} -> LoopTestAttr [ctor gather(&)] .
 op leastCMTests :_ : List{TestCase} -> LoopTestAttr [ctor gather(&)] .
 op greatCMTests :_ : List{TestCase} -> LoopTestAttr [ctor gather(&)] .
 op greatSpecTests :_ : List{TestCase} -> LoopTestAttr [ctor gather(&)] .
 op wrongSignTests :_ : List{TestCase} -> LoopTestAttr [ctor gather(&)] .
 op sysCoverageTests :_ : List{TestCase} -> LoopTestAttr [ctor gather(&)] .
 op invariantTests :_ : List{TestCase} -> LoopTestAttr [ctor gather(&)] .
 op mcTests :_ : List{TestCase} -> LoopTestAttr [ctor gather(&)] .
 op confTests :_ : List{TestCase} -> LoopTestAttr [ctor gather(&)] .

 op cookTCSoup : List{TestCase} -> LoopTestAttrSoup .
 eq cookTCSoup(LTC) = cookTCSoup(LTC, okTests : nil, notNormTests : nil, userTests : nil,
                                      wrongCMTests : nil, leastCMTests : nil, greatCMTests : nil,
                                      greatSpecTests : nil, wrongSignTests : nil,
                                      sysCoverageTests : nil, invariantTests : nil,
                                      mcTests : nil, confTests : nil) .

 op cookTCSoup : List{TestCase} LoopTestAttrSoup -> LoopTestAttrSoup .
 eq cookTCSoup(nil, LTAS) = LTAS .
 eq cookTCSoup(< T, T', ok > LTC, (okTests : LTC', LTAS)) =
            cookTCSoup(LTC, (okTests : LTC' < T, T', ok >, LTAS)) .
 eq cookTCSoup(< T, T', notNormal > LTC, (notNormTests : LTC', LTAS)) =
            cookTCSoup(LTC, (notNormTests : LTC' < T, T', notNormal >, LTAS)) .
 eq cookTCSoup(< T, T', noInfo > LTC, (userTests : LTC', LTAS)) =
            cookTCSoup(LTC, (userTests : LTC' < T, T', noInfo >, LTAS)) .
 eq cookTCSoup(< T, Ty, noInfo > LTC, (userTests : LTC', LTAS)) =
            cookTCSoup(LTC, (userTests : LTC' < T, Ty, noInfo >, LTAS)) .
 eq cookTCSoup(< T, Ty, userBigger > LTC, (userTests : LTC', LTAS)) =
            cookTCSoup(LTC, (userTests : LTC' < T, Ty, userBigger >, LTAS)) .
 eq cookTCSoup(< T, T', notEqualCM > LTC, (wrongCMTests : LTC', LTAS)) =
            cookTCSoup(LTC, (wrongCMTests : LTC' < T, T', notEqualCM >, LTAS)) .
 eq cookTCSoup(< T, T', lessSortCM > LTC, (leastCMTests : LTC', LTAS)) =
            cookTCSoup(LTC, (leastCMTests : LTC' < T, T', lessSortCM >, LTAS)) .
 eq cookTCSoup(< T, T', greatSortCM > LTC, (greatCMTests : LTC', LTAS)) =
            cookTCSoup(LTC, (greatCMTests : LTC' < T, T', greatSortCM >, LTAS)) .
 eq cookTCSoup(< T, T', greatSortOp > LTC, (greatSpecTests : LTC', LTAS)) =
            cookTCSoup(LTC, (greatSpecTests : LTC' < T, T', greatSortOp >, LTAS)) .
 eq cookTCSoup(< T, T', wrongSign > LTC, (wrongSignTests : LTC', LTAS)) =
            cookTCSoup(LTC, (wrongSignTests : LTC' < T, T', wrongSign >, LTAS)) .
 eq cookTCSoup(< T, T', sysCov > LTC, (sysCoverageTests : LTC', LTAS)) =
            cookTCSoup(LTC, (sysCoverageTests : LTC' < T, T', sysCov >, LTAS)) .
 eq cookTCSoup(< T, T', failureProp > LTC, (invariantTests : LTC', LTAS)) =
            cookTCSoup(LTC, (invariantTests : LTC' < T, T', failureProp >, LTAS)) .
 eq cookTCSoup(< T, T', fulfillProp > LTC, (invariantTests : LTC', LTAS)) =
            cookTCSoup(LTC, (invariantTests : LTC' < T, T', fulfillProp >, LTAS)) .
 eq cookTCSoup(< T, T', uncheckedProp > LTC, (invariantTests : LTC', LTAS)) =
            cookTCSoup(LTC, (invariantTests : LTC' < T, T', uncheckedProp >, LTAS)) .
 eq cookTCSoup(< T, T', failurePropMC > LTC, (mcTests : LTC', LTAS)) =
            cookTCSoup(LTC, (mcTests : LTC' < T, T', failurePropMC >, LTAS)) .
 eq cookTCSoup(< T, T', fulfillPropMC > LTC, (mcTests : LTC', LTAS)) =
            cookTCSoup(LTC, (mcTests : LTC' < T, T', fulfillPropMC >, LTAS)) .
 eq cookTCSoup(< T, T', okConformance > LTC, (confTests : LTC', LTAS)) =
            cookTCSoup(LTC, (confTests : LTC' < T, T', okConformance >, LTAS)) .
 eq cookTCSoup(okConformance LTC, (confTests : LTC', LTAS)) =
            cookTCSoup(LTC, (confTests : LTC' okConformance, LTAS)) .
 eq cookTCSoup(failureConformance(T, QIL, T', T'') LTC, (confTests : LTC', LTAS)) =
            cookTCSoup(LTC, (confTests : LTC' failureConformance(T, QIL, T', T''), LTAS)) .
 eq cookTCSoup(failureConformance(T, QIL, Q) LTC, (confTests : LTC', LTAS)) =
            cookTCSoup(LTC, (confTests : LTC' failureConformance(T, QIL, Q), LTAS)) .
endfm

***(%
\end{verbatim}
}

\end{comment}

The persistent state of Full Maude's system is given by a single object
of class \verb+DatabaseClass+, which maintains the database of the system.
We extend the Full Maude system by defining a subclass of
\verb+DatabaseClass+ inheriting its behavior and adding new
attributes to it:

{\codesize
\begin{verbatim}
%)

 mod DD-DATABASE-HANDLING is
  inc CAFE2MAUDE-DATABASE-HANDLING .
  pr UNIVERSAL-DD-TRANSFORMATIONS .
  pr DD-COMMAND-PROCESSING .
  pr DIVIDE-QUERY-STRATEGY .
  inc DATABASE-HANDLING .
  pr UNIVERSAL-TESTING .
  pr LIST{DDState} .
  pr TREE-PRUNING .
  pr LIST{Answer} .
  pr TEST-INFO .

***(%
\end{verbatim}
}

{\codesize
\begin{verbatim}
%)

  sort DDDatabaseClass .
  subsort DDDatabaseClass < CafeDatabaseClass .

  op DDDatabase : -> DDDatabaseClass [ctor] .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  vars Q Q' : Qid .
  vars QIL QIL' QIL'' QIL1 QIL2 CF : QidList .
  var  ST : DDState .
  var  AtS : AttributeSet .
  vars N N' N'' TB SEED : Nat .
  var  N? : [Nat] .
  vars NL NL' : NatList .
  vars RP RP' : ResultPair .
  vars T T' T'' T''' T1 T2 T3 TN TN' : Term .
  var  T? : [Term] .
  vars MT PAT : Maybe{Term} .
  vars TL TL' : TermList .
  vars M M' : Module .
  var  M? : [Module] .
  vars PT PT' UPT : Tree .
  vars F F' F'' : Forest .
  vars MM MM' MM'' : Maybe{Module} .
  var  S : Sort .
  var  LS : List{DDState} .
  vars B B' SP CSP BFS BFS' FST NARR? : Bool .
  vars QS QS' QS'' FS CFS SS TR : QidSet .
  var  LA : List{Answer} .
  var  A : Answer .
  var  R : Result .
  var  TS : ToolState .
  var  J J' J'' : Judgment .
  var  O : Oid .
  var  DDDC : DDDatabaseClass .
  vars DB DB' : Database .
  var  CNTXT : Context .
  vars ME ME' : ModuleExpression .
  var  ME? : [ModuleExpression] .
  var  CONST : Constant .
  vars BND TD : Bound .
  var  BND? : [Bound] .
  var  STRAT : Strat .
  vars TT TT' CTT CTTW : TreeType .
  var  F? : [Forest] .
  vars SB SB' : Substitution .
  var  SB? : [Substitution] .
  var  Ty : Type .
  var  Attr : AttrSet .
  var  RS : RuleSet .
  var  RL : Rule .
  vars C C' : Condition .
  vars SBS SBS' : Set{Substitution} .
  var  V : Variable .
  vars MST MST' : SearchType .
  vars LTC LTC' LTC1 LTC2 : List{TestCase} .
  var  TC : TestCase .
  var  TSt : TestStatus .
  var  CT : CoverageType .
  var  TyL : TypeList .
  vars LTAS LTAS' : LoopTestAttrSoup .
  vars CI CI' : CoverageInfo .
  var  DO : DisplayOption .
  var  DR DR' : DebRel? .
  var  GM : GenMode .
  vars TermT TermT' : ConsTable .
  vars RSRS RSRS' : RuleStmntRelSet .
  var  SDDIS : SDDInfoSet .
  var  SemTy : SemanticsType .

***(%
\end{verbatim}
}

\end{comment}

The new attributes are:
\begin{itemize}

\item the debugging \texttt{tree}, that initially is empty, and will
be traversed during the debugging process:

{\codesize
\begin{verbatim}
%)

  op tree :_ : Forest -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item the type of tree (\texttt{treeType}) that will be built when debugging
rewrites. It takes the value \texttt{os} when the one-step tree is selected and
\texttt{ms} when the many-steps tree is chosen:

{\codesize
\begin{verbatim}
%)

  op treeType :_ : TreeType -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item the type of tree for wrong answers used in the current session is
kept in order to use it when trees are built on demand:

{\codesize
\begin{verbatim}
%)

  op currentTTW :_ : TreeType -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item the type of tree when debugging missing answers;
it also takes the value \texttt{os} when the one-step tree is selected and
\texttt{ms} when the many-steps tree is chosen:

{\codesize
\begin{verbatim}
%)

  op treeTypeMissing :_ : TreeType -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item the type of tree currently used in the debugging of missing answers is
kept in \texttt{currentTTM} in order to use it when the tree is expanded on
demand:

{\codesize
\begin{verbatim}
%)

  op currentTTM :_ : TreeType -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item the \texttt{current} node of the tree that we are analyzing, represented
by a list of natural numbers:

{\codesize
\begin{verbatim}
%)

  op current :_ : NatList -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item the \texttt{strategy} to traverse the tree. The top-down strategy is
represented by the constant \texttt{td},
whereas divide and query is represented by \texttt{dq}:

{\codesize
\begin{verbatim}
%)

  op strategy :_ : Strat -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item the \texttt{module} where debugging takes place. It has sort
\verb"Maybe{Module}", so its value initially is \verb"undefMod":

{\codesize
\begin{verbatim}
%)

  op module :_ : Maybe{Module} -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item the correct module used to prune the debugging tree
(\texttt{correction}). Since this value is optional, it has also sort
\verb"Maybe{Module}", and its value is initially \verb"undefMod":

{\codesize
\begin{verbatim}
%)

  op correction :_ : Maybe{Module} -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item the \texttt{bound} used in the correct module to search for
terms when debugging wrong rewrites:

{\codesize
\begin{verbatim}
%)

  op bound :_ : Bound -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item the value of the \texttt{select} option, that indicates whether
it is enabled or not:

{\codesize
\begin{verbatim}
%)

  op select :_ : Bool -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item a Boolean value that indicates whether the selection of final sorts is enabled or not:

{\codesize
\begin{verbatim}
%)

  op finalSelect :_ : Bool -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item the attribute \texttt{currentFS} keeps whether the option to delete final
sorts is activated in the current session, in order to use it again when building
trees on demand:

{\codesize
\begin{verbatim}
%)

  op currentFS :_ : Bool -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item the set of labels considered \texttt{suspicious}:

{\codesize
\begin{verbatim}
%)

  op suspicious :_ : QidSet -> Attribute [ctor gather(&)] .

***(%
\end{verbatim}
}

\item the set of labels that has been considered suspicious for the construction
of the current tree (\texttt{currentSuspicious}):

{\codesize
\begin{verbatim}
%)

  op currentSuspicious :_ : QidSet -> Attribute  [ctor gather(&)] .

***(%
\end{verbatim}
}

\item the set of final sorts:

{\codesize
\begin{verbatim}
%)

  op finalSorts :_ : QidSet -> Attribute  [ctor gather(&)] .

***(%
\end{verbatim}
}

\item the set of final sorts specified for the current debugging session are kept
in \texttt{currentFinal} to use them when a tree is expanded on demand:

{\codesize
\begin{verbatim}
%)

  op currentFinal :_ : QidSet -> Attribute  [ctor gather(&)] .

***(%
\end{verbatim}
}

\item the stack of previous states (\texttt{previousStates}), used to restore the
state when the \texttt{undo} command is used:

{\codesize
\begin{verbatim}
%)

  op previousStates :_ : List{DDState} -> Attribute [ctor gather(&)] .

***(%
\end{verbatim}
}

\item the list of \texttt{answers} already provided by the user, used to avoid
asking the same question twice:

{\codesize
\begin{verbatim}
%)

  op answers :_ : List{Answer} -> Attribute [ctor gather(&)] .

***(%
\end{verbatim}
}

\item the \texttt{state} of the tool. It is \texttt{waiting} when the tool needs
information from the user, \texttt{computing} when it is processing that information,
and \texttt{finished} when the debugging process has concluded:

{\codesize
\begin{verbatim}
%)

  sort ToolState .
  ops waiting computing finished : -> ToolState [ctor] .

  op state :_ : ToolState -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item the \texttt{pattern} that must be matched by the terms to be
valid solutions when debugging missing answers:

{\codesize
\begin{verbatim}
%)

  op pattern :_ : Maybe{Term} -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item the \texttt{condition} that must be fulfilled by the terms to be
valid solutions when debugging missing answers:

{\codesize
\begin{verbatim}
%)

  op condition :_ : Condition -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item a Boolean value indicating whether the questions about solutions
are prioritized or not:

{\codesize
\begin{verbatim}
%)

  op solutionsPrioritized :_ : Bool -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item we keep in \texttt{currentSP} the value concerning the prioritization of the
questions about solutions to use it when the tree is expanded on demand:

{\codesize
\begin{verbatim}
%)

  op currentSP :_ : Bool -> Attribute [ctor] .

***(%
\end{verbatim}
}

\item the \texttt{searchType} used for the debugging of missing answers, that can
take the values \texttt{zeroOrMore}, \texttt{oneOrMore}, and \texttt{final}:

{\codesize
\begin{verbatim}
%)

  op searchType :_ : SearchType -> Attribute [ctor] .

***(%
\end{verbatim}
}

\begin{comment}

\item the list of test cases generated in the last session:

{\codesize
\begin{verbatim}
%)

  op tests :_ : LoopTestAttrSoup -> Attribute [ctor gather(&)] .
  op coverageInfo :_ : CoverageInfo -> Attribute [ctor] .
  op testBound :_ : Nat -> Attribute [ctor] .
  op coverageType :_ : CoverageType -> Attribute [ctor] .
  op suspiciousTest :_ : QidSet -> Attribute [ctor gather(&)] .
  op testSelect :_ : Bool -> Attribute [ctor] .
  op correctionTest :_ : Maybe{Module} -> Attribute [ctor] .
  op testDepth :_ : Bound -> Attribute [ctor] .
  op testSorts :_ : QidSet -> Attribute  [ctor gather(&)] .
  op incorrectSeen :_ : Nat -> Attribute [ctor] .
  op genMode :_ : GenMode -> Attribute [ctor] .
  op displayOption :_ : DisplayOption -> Attribute [ctor] .

  op debRel :_ : DebRel -> Attribute [ctor gather(&)] .

  op termsTable :_ : ConsTable -> Attribute [ctor gather(&)] .
  op seed :_ : Nat -> Attribute [ctor gather(&)] .
  op currentFunction :_ : QidList -> Attribute [ctor gather(&)] .

  op semanticsModule :_ : Maybe{Module} -> Attribute [ctor gather(&)] .
  op semanticsModuleTransformed :_ : Maybe{Module} -> Attribute [ctor gather(&)] .
  op sortStatements :_ : SortSet -> Attribute [ctor gather(&)] .
  op ruleStatementRel :_ : RuleStmntRelSet -> Attribute [ctor gather(&)] .
  op statementsInCoverage :_ : NatList -> Attribute [ctor gather(&)] .
  op objectProgram :_ : Maybe{Term} -> Attribute [ctor gather(&)] .

  op intended :_ : SDDInfoSet -> Attribute [ctor gather(&)] .
  op transitivityRules :_ : QidSet -> Attribute [ctor gather(&)] .

  op semanticsType :_ : SemanticsType -> Attribute [ctor gather(&)] .

***(%
\end{verbatim}
}

\end{comment}

\end{itemize}

The initial values of all these attributes are defined with the constant
\texttt{init-state}:

{\codesize
\begin{verbatim}
%)

  op init-state : -> AttributeSet .

  *** Initial values of the attributes (except input and output)
  eq init-state = db : initialDatabase,
                  default : 'CONVERSION, tree : mtForest, treeType : os, currentTTW : os,
                  treeTypeMissing : os, currentTTM : os, current : nil, strategy : dq,
                  module : undefMod, correction : undefMod, bound : 42, select : false,
                  finalSelect : false, currentFS : false, suspicious : none,
                  currentSuspicious : none, finalSorts : none, currentFinal : none,
                  previousStates : nil, answers : nil, state : waiting, pattern : maybe,
                  condition : nil, solutionsPrioritized : false, currentSP : false,
                  searchType : final, tests : mtTestInfo, coverageInfo : noCoverageInfo,
                  testBound : 400, coverageType : global, suspiciousTest : none,
                  testSelect : false, correctionTest : undefMod, testDepth : 15,
                  testSorts : none, incorrectSeen : 0, genMode : complete,
                  displayOption : small, debRel : mtDR, termsTable : empty, seed : 17,
                  currentFunction : nil, semanticsModule : undefMod,
                  semanticsModuleTransformed : undefMod, sortStatements : none,
                  ruleStatementRel : mtRSR, statementsInCoverage : nil,
                  objectProgram : maybe, intended : mtSDDIS, semanticsType : bs,
                  transitivityRules : none .

***(%
\end{verbatim}
}

The behavior of the debugger commands is described by means of rewrite rules that change
the state of these attributes. Below we show some of the most interesting rules.

%  -----------------------------------------------------------------------------------------
%  ----------------------------------------- DEBUG -----------------------------------------
%  -----------------------------------------------------------------------------------------

The rule \texttt{debug} starts the debugging process for wrong answers. It receives a
term that will be processed with the function \texttt{procDebug} explained above. If
there is no error (that is, the returned list of quoted identifiers is \texttt{nil}),
the tree, the module, and the set of suspicious labels are updated with the appropriate
information, while the answers given by the user so far and the previous states are
reset. However, if the command was incorrect, the error is shown and the state is set
to \texttt{finished}:

{\codesize
\begin{verbatim}
%)

  crl [debug] :
      < O : DDDC | db : DB, input : ('debug_.[T]), output : nil,
                   default : ME, tree : F, module : MM, correction : MM',
                   previousStates : LS, answers : LA, state : TS,
                   treeType : TT, currentTTW : CTTW, bound : BND, select : B,
                   suspicious : QS, currentSuspicious : QS', AtS >
   => if QIL == nil then
      < O : DDDC | db : DB, input : nilTermList, output : nil, default : ME,
                   tree : F', module : MM'', correction : MM',
                   previousStates : nil, answers : nil, state : computing,
                   treeType : TT, currentTTW : TT, bound : BND, select : B,
                   suspicious : QS, currentSuspicious : QS'', AtS >
      else
      < O : DDDC | db : DB, input : nilTermList, output : QIL, default : ME,
                   tree : mtForest, module : MM, correction : MM',
                   previousStates : nil, answers : nil, state : finished,
                   treeType : TT, currentTTW : CTTW, bound : BND, select : B,
                   suspicious : QS, currentSuspicious : QS', AtS >
      fi
   if < F', MM'', QS'', QIL > := procDebug(T, MM', B, QS, TT, BND, ME, DB) .

***(%
\end{verbatim}
}

The rule \texttt{missing} is in charge of parsing the initial command for
the debugging of missing
answers. If the parsing is correct, that is, if the error message
obtained with the function \texttt{procMissing}---a function analogous to
\verb"procDebug"---is \texttt{nil},
the tuple provides the new debugging tree, the current
module, the search type, the pattern, the search condition, and the suspicious labels.
All these values are kept in the appropriate attributes in order to reuse them later
if trees on demand are built. If the parsing fails, the attributes are
not updated and the command is discarded:

{\codesize
\begin{verbatim}
%)


  crl [missing] :
      < O : DDDC | db : DB, input : ('missing_.[T]), output : nil,
                   default : ME, tree : F, module : MM, correction : MM',
                   previousStates : LS, answers : LA, state : TS, treeType : TT,
                   currentTTW : CTTW, bound : BND, treeTypeMissing : TT',
                   currentTTM : CTT,
                   select : B, suspicious : QS, currentSuspicious : QS', condition : C,
                   pattern : MT, searchType : MST, solutionsPrioritized : SP,
                   currentSP : CSP, finalSorts : FS, currentFinal : CFS,
                   finalSelect : BFS, currentFS : BFS', AtS >
   => if QIL == nil then
      < O : DDDC | db : DB, input : nilTermList, output : nil, default : ME,
                   tree : F?, module : MM'', correction : MM', previousStates : nil,
                   answers : nil, state : computing, treeType : TT, currentTTW : TT,
                   bound : BND,
                   treeTypeMissing : TT', currentTTM : TT', select : B, suspicious : QS,
                   currentSuspicious : QS'', condition : C', pattern : PAT,
                   searchType : MST', solutionsPrioritized : SP, currentSP : SP,
                   finalSorts : FS, currentFinal : FS, finalSelect : BFS,
                   currentFS : BFS, AtS >
      else
      < O : DDDC | db : DB, input : nilTermList, output : QIL, default : ME, tree : F,
                   module : MM, correction : MM', previousStates : LS, answers : nil,
                   state : finished, treeType : TT, currentTTW : CTTW, bound : BND,
                   treeTypeMissing : TT', currentTTM : CTT,
                   select : B, suspicious : QS, currentSuspicious : QS', condition : C,
                   pattern : MT, searchType : MST, solutionsPrioritized : SP,
                   currentSP : CSP, finalSorts : FS, currentFinal : CFS, finalSelect : BFS,
                   currentFS : BFS', AtS >
      fi
   if < F?, MM'', MST', PAT, C', QS'', QIL > :=
                        procMissing(T, ME, MM', TT, TT', B, QS, BFS, FS, SP, BND, DB) .

***(%
\end{verbatim}
}

%  ----------------------------------------------------------------------------------
%  --------------------------------- TEST CASES -------------------------------------
%  ----------------------------------------------------------------------------------

{\codesize
\begin{comment}
%)

  crl [test] :
      < O : DDDC | db : DB, input : ('test_.[T]), output : nil, default : ME, module : MM,
                   correctionTest : MM', tests : LTAS, coverageInfo : CI, testBound : TB,
                   coverageType : CT, suspiciousTest : QS, testSelect : B, testSorts : SS,
                   incorrectSeen : N, testDepth : TD, pattern : MT, condition : C,
                   genMode : GM, displayOption : DO, AtS >
   => if QIL == nil then
      < O : DDDC | db : DB, input : nilTermList, output : (printNumTests(MM'', LTC, CI')),
                   default : ME, module : MM'', correctionTest : MM', tests : cookTCSoup(LTC),
                   coverageInfo : CI', testBound : TB, coverageType : CT, suspiciousTest : QS,
                   testSelect : B, incorrectSeen : 0, testSorts : SS, testDepth : TD,
                   pattern : PAT, condition : C', genMode : GM, displayOption : DO, AtS >
      else
      < O : DDDC | db : DB, input : nilTermList, output : QIL, default : ME,
                   module : MM, correctionTest : MM', tests : LTAS, coverageInfo : CI,
                   testBound : TB, coverageType : CT, suspiciousTest : QS,
                   testSelect : B, incorrectSeen : 0, testSorts : SS, testDepth : TD,
                   pattern : MT, condition : C, genMode : GM, displayOption : DO, AtS >
      fi
   if < MM'', LTC, CI', PAT, C', QIL > := procTest(T, ME, MM', QS, SS, B, TB, TD, CT,
                                                   GM, DO, DB) .

***(%
\end{verbatim}
}

%  ----------------------------------------------------------------------------------
%  ------------------------------- TEST CASES MB ------------------------------------
%  ----------------------------------------------------------------------------------

{\codesize
\begin{comment}
%)

  crl [test-sort] :
      < O : DDDC | db : DB, input : ('test-sort_.[T]), output : nil,
                   default : ME, module : MM, correctionTest : MM', tests : LTAS,
                   coverageInfo : CI, testBound : TB, suspiciousTest : QS,
                   testSelect : B, incorrectSeen : N, pattern : MT, condition : C, AtS >
   => if QIL == nil then
      < O : DDDC | db : DB, input : nilTermList, output : (printNumTests(MM'', LTC, CI')),
                   default : ME, module : MM'', correctionTest : MM', tests : cookTCSoup(LTC),
                   coverageInfo : CI', testBound : TB, suspiciousTest : QS, testSelect : B,
                   incorrectSeen : 0, pattern : PAT, condition : C', AtS >
      else
      < O : DDDC | db : DB, input : nilTermList, output : QIL,
                   default : ME, module : MM, correctionTest : MM', tests : LTAS,
                   coverageInfo : CI, testBound : TB, suspiciousTest : QS, testSelect : B,
                   incorrectSeen : 0, pattern : MT, condition : C, AtS >
      fi
   if < MM'', LTC, CI', PAT, C', QIL > := procTestMb(T, ME, MM', QS, B, TB, DB) .

***(%
\end{verbatim}
}

%  -----------------------------------------------------------------------------------------
%  --------------------------------- CORRECTION MODULE -------------------------------------
%  -----------------------------------------------------------------------------------------

The selection/deselection of the correct module is handled by the following rules:

\begin{itemize}
\item If a correct module expression is introduced,
\verb"correct-module" keeps the associated module if it exists, and shows an error
message otherwise.

{\codesize
\begin{verbatim}
%)

  crl [correct-module] :
      < O : DDDC | db : DB, input : ('correct`module_.[T]), output : nil, correction : MM, AtS >
   => if M? :: Module
      then < O : DDDC | db : DB, input : nilTermList, output : ('\n add-spaceR(printME(ME)) '\b
                                                        'selected 'as 'correct 'module. '\o '\n),
                        correction : M?, AtS >
      else < O : DDDC | db : DB, input : nilTermList, output : ('\n '\r 'Error: '\o getMsg(M?)),
                        correction : MM, AtS >
      fi
   if ME := parseModExp(T) /\
      M? := if compiledModule(ME, DB)
            then getFlatModule(ME, DB)
            else getFlatModule(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB)))
            fi .

***(%
\end{verbatim}
}

\item \verb"correct-module-error" deals with the error when a wrong module
expression is introduced:

{\codesize
\begin{verbatim}
%)

  crl [correct-module-error] :
      < O : DDDC | input : ('correct`module_.[T]), output : nil, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'Wrong
                                                  'module 'expression. '\n), AtS >
   if ME? := parseModExp(T) /\
      not (ME? :: ModuleExpression) .

***(%
\end{verbatim}
}

\item The rule \verb"delete-correct-module" sets the value of the correct module
to \verb"undefMod":

{\codesize
\begin{verbatim}
%)

  rl [delete-correct-module] :
     < O : DDDC | input : ('delete`correct`module`..@Command@), output : nil,
                  correction : MM, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'Correct 'module 'deleted. '\o '\n),
                  correction : undefMod, AtS > .

***(%
\end{verbatim}
}

\end{itemize}

%  -----------------------------------------------------------------------------------------
%  -------------------------------------- STRATEGY -----------------------------------------
%  -----------------------------------------------------------------------------------------

The rule \verb"top-down-strategy" fixes the value of the navigation strategy to
\verb"td", and changes the state to \verb"computing" if the debugging has not finished
to show the appropriate question:

{\codesize
\begin{verbatim}
%)

  rl [top-down-strategy] :
     < O : DDDC | input : ('top-down`strategy`..@Command@), output : nil,
                  strategy : STRAT, state : TS, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'Top-down 'strategy
                                                 'selected. '\o '\n),
                  strategy : td, state : if TS == finished then TS
                                                           else computing fi, AtS > .

***(%
\end{verbatim}
}

Analogously, when the divide and query strategy is selected the following rule
handles the command:

{\codesize
\begin{verbatim}
%)

  rl [divide-query-strategy] :
     < O : DDDC | input : ('divide-query`strategy`..@Command@), output : nil,
                  strategy : STRAT, state : TS, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'Divide '& 'Query 'strategy
                                                 'selected. '\o '\n ),
                  strategy : dq, state : if TS == finished then finished
                                                           else computing fi, AtS > .

***(%
\end{verbatim}
}

Finally, the single-stepping strategy is selected with the rule:

{\codesize
\begin{verbatim}
%)

  rl [single-stepping-strategy] :
     < O : DDDC | input : ('single-stepping`strategy`..@Command@), output : nil,
                  strategy : STRAT, state : TS, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'Single-stepping 'strategy
                                                 'selected. '\o '\n ),
                  strategy : ss, state : if TS == finished then finished
                                                           else computing fi, AtS > .

***(%
\end{verbatim}
}

\begin{comment}

%  -----------------------------------------------------------------------------------------
%  -------------------------------------- TREE TYPE ----------------------------------------
%  -----------------------------------------------------------------------------------------

The following rules are in charge of changing the type of tree used to compute
the debugging tree:

{\codesize
\begin{verbatim}
%)

  rl [one-step-tree] :
     < O : DDDC | input : ('one-step`tree`..@Command@), output : nil, treeType : TT, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'One-step 'tree 'selected 'when
                                                 'debugging 'wrong 'answers. '\o '\n),
                  treeType : os, AtS > .

  rl [many-steps-tree] :
     < O : DDDC | input : ('many-steps`tree`..@Command@), output : nil, treeType : TT, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'Many-steps 'tree 'selected 'when
                                                 'debugging 'wrong 'answers. '\o '\n),
                  treeType : ms, AtS > .

  rl [one-step-tree-missing] :
     < O : DDDC | input : ('one-step`missing`tree`..@Command@), output : nil,
                  treeTypeMissing : TT, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'One-step 'tree 'selected 'when
                                                 'debugging 'missing 'answers. '\o '\n),
                  treeTypeMissing : os, AtS > .

  rl [many-steps-tree-missing] :
     < O : DDDC | input : ('many-steps`missing`tree`..@Command@), output : nil,
                  treeTypeMissing : TT, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'Many-steps 'tree 'selected 'when
                                                 'debugging 'missing 'answers. '\o '\n),
                  treeTypeMissing : ms, AtS > .

***(%
\end{verbatim}
}

%  -----------------------------------------------------------------------------------------
%  --------------------------------------- BOUND -------------------------------------------
%  -----------------------------------------------------------------------------------------

The rule \verb"set-bound" changes the bound used when searching in the correct
module if it is a valid bound, and shows an error message in other case:

{\codesize
\begin{verbatim}
%)

  crl [set-bound] :
      < O : DDDC | input : ('set`bound_.['token[T]]), output : nil, bound : BND, AtS >
   => if BND? :: Bound then
      < O : DDDC | input : nilTermList, output : ('\n '\b 'Bound 'fixed. '\o '\n),
                   bound : BND?, AtS >
      else
      < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'Wrong 'bound. '\n),
                   bound : BND, AtS >
      fi
   if BND? := downBound(T) .

***(%
\end{verbatim}
}

\end{comment}

%  -----------------------------------------------------------------------------------------
%  ---------------------------------- TEST BOUND -------------------------------------------
%  -----------------------------------------------------------------------------------------

\begin{comment}

{\codesize
\begin{verbatim}
%)

  crl [set-test-bound] :
      < O : DDDC | input : ('set`test`bound_.['token[T]]), output : nil, testBound : TB, AtS >
   => if N? :: Nat then
      < O : DDDC | input : nilTermList, output : ('\n '\b 'Bound 'for 'tests 'fixed. '\o '\n),
                   testBound : N?, AtS >
      else
      < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'Wrong 'bound. '\n),
                   testBound : TB, AtS >
      fi
   if N? := downNat*(T) .

***(%
\end{verbatim}
}

\end{comment}

%  -----------------------------------------------------------------------------------------
%  ---------------------------------- TEST DEPTH -------------------------------------------
%  -----------------------------------------------------------------------------------------

\begin{comment}

{\codesize
\begin{verbatim}
%)

  crl [set-test-depth] :
      < O : DDDC | input : ('set`test`depth_.['token[T]]), output : nil, testDepth : BND,
                   AtS >
   => if BND? :: Bound then
      < O : DDDC | input : nilTermList, output : ('\n '\b 'Bound 'for 'checking 'against 'the
                                                  'correct 'module 'fixed. '\o '\n),
                   testDepth : BND?, AtS >
      else
      < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'Wrong 'bound. '\n),
                   testDepth : BND, AtS >
      fi
   if BND? := downBound(T) .

***(%
\end{verbatim}
}

\end{comment}

%  -----------------------------------------------------------------------------------------
%  ----------------------------------- SHOW TREE -------------------------------------------
%  -----------------------------------------------------------------------------------------

\begin{comment}

{\codesize
\begin{verbatim}
%)

  rl [show-tree] :
      < O : DDDC | input : 'show`tree`..@Command@, tree : F, module : M,
                   output : nil, AtS >
   => < O : DDDC | input : nilTermList, tree : F, module : M,
                   output : eMetaPrettyPrint(0, F, M), AtS > .

  rl [show-latex-tree] :
      < O : DDDC | input : 'show`latex`tree`..@Command@, tree : F, module : M,
                   output : nil, AtS >
   => < O : DDDC | input : nilTermList, tree : F, module : M,
                   output : eMetaPrettyLatex(0, F, M, true), AtS > .

***(%
\end{verbatim}
}

\end{comment}

%  -----------------------------------------------------------------------------------------
%  ----------------------------------- NARROWING -------------------------------------------
%  -----------------------------------------------------------------------------------------

\begin{comment}

{\codesize
\begin{verbatim}
%)

  rl [narrowing-on] :
      < O : DDDC | input : ('narrowing`on`..@Command@), genMode : GM,
                   output : nil, AtS >
   => < O : DDDC | input : nilTermList, genMode : narrowing,
                   output : ('\n '\b 'Narrowing 'activated. '\o '\n), AtS > .

  rl [narrowing-off] :
      < O : DDDC | input : ('narrowing`off`..@Command@), genMode : GM,
                   output : nil, AtS >
   => < O : DDDC | input : nilTermList, genMode : complete,
                   output : ('\n '\b 'Narrowing 'deactivated. '\o '\n), AtS > .

  rl [display-simple] :
      < O : DDDC | input : 'display`simple`set`..@Command@, displayOption : DO,
                   output : nil, AtS >
   => < O : DDDC | input : nilTermList, displayOption : simple,
                   output : ('\n '\b 'Simple 'test 'cases 'selected. '\o '\n), AtS > .

  rl [display-small] :
      < O : DDDC | input : 'display`small`set`..@Command@, displayOption : DO,
                   output : nil, AtS >
   => < O : DDDC | input : nilTermList, displayOption : small,
                   output : ('\n '\b 'Small 'set 'of 'test 'cases 'selected. '\o '\n), AtS > .



***(%
\end{verbatim}
}

\end{comment}

%  -----------------------------------------------------------------------------------------
%  ----------------------------------- TREE TRAVERSAL --------------------------------------
%  -----------------------------------------------------------------------------------------


In the top-down strategy, when the user introduces the identifier of a wrong question,
the debugger updates the list of answers and the previous states, and changes the
current tree by the appropriate child of the root:

{\codesize
\begin{verbatim}
%)

  crl [top-down-traversal-no] :
      < O : DDDC | input : ('_:`no`.['token[T]]), strategy : td, tree : PT,
                   previousStates : LS, answers : LA, state : waiting, AtS >
   => < O : DDDC | input : nilTermList, strategy : td, tree : PT',
                   previousStates : LS < nil, PT, td >,
                   answers : LA getAnswer(PT', wrong), state : computing, AtS >
   if UPT := removeUnknownChildren(PT) /\
      N := downNat*(T) /\
      N > 0 /\
      N <= size(getForest(UPT, nil)) /\
      PT' := getSubTree(UPT, sd(N, 1)) .

***(%
\end{verbatim}
}

\noindent where the function \texttt{getAnswer}
constructs an answer given the current node and the answer given by the user.

\begin{comment}

{\codesize
\begin{verbatim}
%)

  crl [top-down-traversal-yes] :
      < O : DDDC | input : ('_:`yes`.['token[T]]), strategy : td, tree : PT,
                   previousStates : LS, answers : LA, state : waiting, AtS >
   => < O : DDDC | input : nilTermList, strategy : td, tree : PT',
                   previousStates : LS < nil, PT, td >,
                   answers : LA getAnswer(PT', right), state : computing, AtS >
   if N := downNat*(T) /\
      N > 0 /\
      N <= sizeNotUnknown(getForest(PT, nil)) /\
      PT' := removeChild(PT, N) .

  crl [top-down-traversal-unknown] :
      < O : DDDC | input : ('_:`don't`know`.['token[T]]), strategy : td, tree : PT,
                   previousStates : LS, answers : LA, state : waiting, AtS >
   => < O : DDDC | input : nilTermList, strategy : td, tree : PT',
                   previousStates : LS < nil, PT, td >,
                   answers : LA getAnswer(PT', unknown), state : computing, AtS >
   if N := downNat*(T) /\
      N > 0 /\
      N <= sizeNotUnknown(getForest(PT, nil)) /\
      PT' := setUnknown(PT, sd(N, 1)) .

  crl [top-down-traversal-trust] :
      < O : DDDC | input : ('_:`trust`.['token[T]]), strategy : td, tree : PT,
                   previousStates : LS, answers : LA, state : waiting, AtS >
   => < O : DDDC | input : nilTermList, strategy : td, tree : PT',
                   previousStates : LS < nil, PT, td >,
                   answers : LA getAnswer(PT', right), state : computing, AtS >
   if UPT := removeUnknownChildren(PT) /\
      N := downNat*(T) /\
      N > 0 /\
      N <= size(getForest(UPT, nil)) /\
      Q := getLabel(UPT, sd(N, 1)) /\
      PT' := prune(PT, Q) .

  crl [top-down-traversal-trust-no-label] :
      < O : DDDC | input : ('_:`trust`.['token[T]]), output : nil, strategy : td,
                   tree : PT, state : waiting, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'The 'selected
                                                  'question 'has 'not 'got 'an
                                                  'associated 'statement 'and
                                                  'cannot 'be 'trusted. '\n),
                   strategy : td, tree : PT, state : waiting, AtS >
   if UPT := removeUnknownChildren(PT) /\
      N := downNat*(T) /\
      N > 0 /\
      N <= size(getForest(UPT, nil)) /\
      not (getLabel(UPT, sd(N, 1))) :: Qid .

  crl [top-down-traversal-final] :
      < O : DDDC | input : ('_:`its`sort`is`final`.['token[T]]), output : nil,
                   strategy : td, tree : PT, previousStates : LS,
                   answers : LA, state : waiting, module : M, AtS >
   => < O : DDDC | input : nilTermList,  output : ('\n '\b 'Terms 'of 'sort '\o Ty
                                                   '\b 'are 'final. '\o '\n),
                   strategy : td, tree : PT', previousStates : LS < nil, PT, td >,
                   answers : LA getAnswer(PT', right), state : computing, module : M, AtS >
   if N := downNat*(T) /\
      N > 0 /\
      UPT := removeUnknownChildren(PT) /\
      N <= size(getForest(UPT, nil)) /\
      finalQuestion?(getContents(UPT, sd(N, 1))) /\
      T' := getFirstTerm(getSubTree(UPT, sd(N, 1))) /\
      Ty := getType(metaReduce(M, T')) /\
      PT' := pruneFinalSort(M, Ty, PT) .

  crl [top-down-traversal-final-no-final-inference] :
      < O : DDDC | input : ('_:`its`sort`is`final`.['token[T]]), output : nil, strategy : td,
                   tree : PT, state : waiting, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'The 'selected
                                                  'question 'is 'not 'associated
                                                  'with 'a 'final 'inference. '\n),
                   strategy : td, tree : PT, state : waiting, AtS >
   if N := downNat*(T) /\
      N > 0 /\
      UPT := removeUnknownChildren(PT) /\
      N <= size(getForest(UPT, nil)) /\
      not finalQuestion?(getContents(PT, sd(N, 1))) .

  crl [top-down-traversal-error-nat] :
      < O : DDDC | input : (Q['token[T]]), output : nil, strategy : td,
                   state : waiting, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'The 'argument 'is
                                                  'not 'a 'natural 'number. '\n),
                   strategy : td, state : waiting, AtS >
   if (Q == '_:`yes`. or-else
       Q == '_:`no`. or-else
       Q == '_:`trust`. or-else
       Q == '_:`don't`know`. or-else
       Q == '_:`its`sort`is`final`.) /\
      not (downNat*(T) :: Nat) .

  crl [top-down-traversal-error-index] :
      < O : DDDC | input : (Q['token[T]]), output : nil, strategy : td, tree : PT,
                   state : waiting, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'The 'question 'selected
                                                  'is 'not 'available. '\n), strategy : td,
                   tree : PT, state : waiting, AtS >
   if (Q == '_:`yes`. or-else
       Q == '_:`no`. or-else
       Q == '_:`trust`. or-else
       Q == '_:`don't`know`. or-else
       Q == '_:`its`sort`is`final`.) /\
       N := downNat*(T) /\
       N > sizeNotUnknown(getForest(PT, nil)) or-else N == 0 .

  rl [top-down-traversal-all-yes] :
     < O : DDDC | input : ('all`:`yes`..@Command@), strategy : td, tree : PT,
                  module : M, previousStates : LS, answers : LA, state : waiting, AtS >
  => < O : DDDC | input : nilTermList, strategy : td, tree : removeChildrenNotUnknown(PT),
                  module : M, previousStates : LS < nil, PT, td >,
                  answers : LA getAnswer(PT, wrong), state : computing, AtS > .

  crl [top-down-traversal-wrong] :
      < O : DDDC | input : ('_:_is`wrong`.['token[T'],'token[T]]),
                   strategy : td, tree : PT, currentSuspicious : QS, currentTTW : TT,
                   bound : BND, module : M, correction : MM, previousStates : LS,
                   answers : LA, state : waiting, AtS >
   => < O : DDDC | input : nilTermList, strategy : td, tree : PT',
                   currentSuspicious : QS, currentTTW : TT, bound : BND,
                   module : M, correction : MM, previousStates : LS < nil, PT, td >,
                   answers : LA getAnswer(PT', wrong), state : computing, AtS >
   if *** We check the values introduced are numbers
      N := downNat*(T) /\
      N' := downNat*(T') /\
      *** We check the question selected exists
      N' <= size(getForest(PT, nil)) /\
      N' > 0 /\
      N'' := sd(N', 1) /\
      *** We check the question selected has a set as result of the inference
      setInference?(getContents(PT, N'')) /\
      *** We check the term selected exists
      N <= numTermsInRootSet(getSubTree(PT, N'')) /\
      N > 0 /\
      *** We obtain the terms of the wrong inference
      T1 := getFirstTerm(getSubTree(PT, N'')) /\
      T2 := getWrongTerm(getSubTree(PT, N''), N) /\
      *** We create the new tree
      PT' := createRewTree(labeling(M), MM, T1, T2, QS, TT, BND) .

  crl [top-down-wrong-error-no-set-inference] :
      < O : DDDC | input : ('_:_is`wrong`.['token[T'],'token[T]]),
                   output : nil, tree : PT, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'This 'option 'is
                                                  'not 'available 'for 'this 'question. '\n),
                   tree : PT, AtS >
   if N := downNat*(T') /\
      N <= size(getForest(PT, nil)) /\
      N > 0 /\
      not setInference?(getContents(PT, N)) .

***(%
\end{verbatim}
}

While using the top-down strategy, if the user introduces a command indicating
that a term in one of the questions is reachable but it is not a solution, the
rule \texttt{top-down-traversal-sol} processes it and updates the tree if the
arguments are correct. First, it parses the introduced arguments with the
function \verb"downNat*" to check that they are natural numbers
and then checks that the question referred by the first argument exists. In this
case, it checks that the question is related to an inference of a set of solutions
with \verb"solutionsInference?" and that the index introduced as second argument
corresponds with one of these solutions by using the auxiliary function
\texttt{numTermsInRootSet}, that computes the number of terms in the inference in
the root of the tree given as argument. If all the conditions hold, a new tree
is computed with \verb"conditionForest":

{\codesize
\begin{verbatim}
%)

  crl [top-down-traversal-sol] :
      < O : DDDC | input : ('_:_is`not`a`solution`.['token[T'],'token[T]]),
                   strategy : td, tree : PT, currentSuspicious : QS, treeType : TT,
                   bound : BND, module : M, correction : MM, previousStates : LS,
                   answers : LA, condition : C, pattern : PAT, state : waiting, AtS >
   => < O : DDDC | input : nilTermList, strategy : td,
                   tree : tree(sol(T2, PAT, C, true, true, true), 1 + getOffspring*(F), F),
                   currentSuspicious : QS, treeType : TT, bound : BND,
                   module : M, correction : MM, previousStates : LS < nil, PT, td >,
                   answers : LA getAnswer(PT, wrong),
                   condition : C, pattern : PAT, state : computing, AtS >
   if *** We check the values introduced are numbers
      N := downNat*(T) /\
      N' := downNat*(T') /\
      *** We check the question selected exists
      N' <= size(getForest(PT, nil)) /\
      N' > 0 /\
      N'' := sd(N', 1) /\
      *** We check the question selected has a set of solutions as result of the inference
      solutionsInference?(getContents(PT, N'')) /\
      *** We check the term selected exists
      N <= numTermsInRootSet(getSubTree(PT, N'')) /\
      N > 0 /\
      *** We obtain the term that is not a solution
      T2 := getWrongTerm(getSubTree(PT, N''), N) /\
      *** We create the new tree
      F := conditionForest(substituteDD(M, C, metaMatch(M, PAT, T2, C, 0)),
                                        M, deleteSuspicious(M, QS), MM, QS, BND, TT) .

  crl [top-down-traversal-sol-error-set-solutions] :
      < O : DDDC | input : ('_:_is`not`a`solution`.['token[T'],'token[T]]),
                   output : nil, strategy : td, tree : PT, state : waiting, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'The 'set 'is 'not
                                                  'related 'to 'solutions. '\n),
                   strategy : td, tree : PT, state : computing, AtS >
   if *** We check the values introduced are numbers
      N := downNat*(T) /\
      N' := downNat*(T') /\
      *** We check the question selected exists
      N' <= size(getForest(PT, nil)) /\
      N' > 0 /\
      N'' := sd(N', 1) /\
      *** We check the question selected has not a set of solutions as result of the inference
      not solutionsInference?(getContents(PT, N'')) .

  crl [top-down-error-nat1] :
      < O : DDDC | input : (Q['token[T'],'token[T]]),
                   output : nil, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'The 'first
                                                  'argument 'is 'not 'a 'natural
                                                  'number. '\n), AtS >
   if (Q == '_:_is`wrong`. or-else
       Q == '_:_is`not`a`solution`.) /\
      not (downNat*(T) :: Nat) .

  crl [top-down-error-nat2] :
      < O : DDDC | input : (Q['token[T'],'token[T]]),
                   output : nil, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'The 'second
                                                  'argument 'is 'not 'a 'natural
                                                  'number. '\n), AtS >
   if (Q == '_:_is`wrong`. or-else
       Q == '_:_is`not`a`solution`.) /\
      not (downNat*(T') :: Nat) .

  crl [top-down-error-out-bound-question] :
      < O : DDDC | input : (Q['token[T'],'token[T]]),
                   output : nil, tree : PT, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'The 'selected
                                                  'question 'does 'not 'exist. '\n),
                   tree : PT, AtS >
   if (Q == '_:_is`wrong`. or-else
       Q == '_:_is`not`a`solution`.) /\
      N := downNat*(T') /\
      N > size(getForest(PT, nil)) or-else N == 0 .

  crl [top-down-error-out-bounds-term] :
      < O : DDDC | input : (Q['token[T'],'token[T]]),
                   output : nil, tree : PT, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'The 'term 'selected
                                                  'does 'not 'exist. '\n),
                   tree : PT, AtS >
   if (Q == '_:_is`wrong`. or-else
       Q == '_:_is`not`a`solution`.) /\
      N := downNat*(T) /\
      N' := downNat*(T') /\
      N' <= size(getForest(PT, nil)) /\
      N' > 0 /\
      N'' := sd(N', 1) /\
      setInference?(getContents(PT, N'')) /\
      N > numTermsInRootSet(getSubTree(PT, N'')) or-else N == 0 .

  crl [command-unexpected] :
       < O : DDDC | input : CONST, output : nil, strategy : td, state : waiting, AtS >
    => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o
                                                   'Top-down 'strategy 'selected. '\n),
                    strategy : td, state : computing, AtS >
    if CONST == 'yes`..@Command@ or-else
       CONST == 'no`..@Command@ or-else
       CONST == 'trust`..@Command@ or-else
       CONST == 'its`sort`is`final`..@Command@ .

  rl [command-unexpected-dont-know] :
     < O : DDDC | input : 'don't`know`..@Command@, output : nil, strategy : td,
                  state : waiting, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o
                                                 'The 'strategy 'cannot 'continue. '\n
                                                 'Use 'the 'command 'undo 'and 'try
                                                 'to 'select 'another 'wrong 'question
                                                 'or 'try 'to 'answer 'one 'of 'the
                                                 'current 'questions. '\n),
                    strategy : td, state : computing, AtS > .

  crl [command-unexpected] :
       < O : DDDC | input : (Q[TL]), output : nil, strategy : td, state : waiting, AtS >
    => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o
                                                   'Top-down 'strategy 'selected. '\n),
                    strategy : td, state : computing, AtS >
    if Q == '_is`wrong`. or-else
       Q == '_is`not`a`solution`. .

  ----------------------------------------- D&C -------------------------------------------

  crl [divide-query-traversal] :
      < O : DDDC | input : ('yes`..@Command@), strategy : dq, tree : PT,
                   current : NL, previousStates : LS, state : waiting,
                   answers : LA, AtS >
   => < O : DDDC | input : nilTermList, strategy : dq, tree : PT', current : NL,
                   previousStates : LS < NL, PT, dq >, state : computing,
                   answers : LA getAnswer(getSubTree(PT, NL), right), AtS >
  if PT' := deleteSubTree(PT, NL) .

  crl [divide-query-traversal] :
      < O : DDDC | input : ('no`..@Command@), strategy : dq, tree : PT, current : NL,
                   previousStates : LS, answers : LA, state : waiting, AtS >
   => < O : DDDC | input : nilTermList, strategy : dq, tree : PT', current : NL,
                   previousStates : LS < NL, PT, dq >, answers : LA getAnswer(PT', wrong),
                   state : computing, AtS >
   if PT' := getSubTree(PT, NL) .

***(%
\end{verbatim}
}

\end{comment}

%  ***********************************
%  ****** Only Missing answers *******
%  ***********************************

The rule \verb"missing-wrong" is used when, while debugging missing answers
with the divide and query strategy, the user points out that
a certain term is not reachable. The
rule checks that the current question is related to an inference of a
set of terms with \verb"setInference?" and that the selected question
points to one of these terms, and then creates the debugging tree
for wrong answers with \texttt{createRewTree}:

{\codesize
\begin{verbatim}
%)

  crl [missing-wrong] :
      < O : DDDC | input : ('_is`wrong`.['token[T]]), strategy : dq, tree : PT,
                   current : NL, previousStates : LS, answers : LA, state : waiting,
                   currentSuspicious : QS, bound : BND, module : M, correction : MM,
                   currentTTW : TT, AtS >
   => < O : DDDC | input : nilTermList, strategy : dq, tree : PT',
                   current : NL, previousStates : LS < NL, PT, dq >,
                   answers : LA getAnswer(getSubTree(PT, NL), wrong),
                   state : computing, currentSuspicious : QS, bound : BND,
                   module : M, correction : MM, currentTTW : TT, AtS >
   if N := downNat*(T) /\
      setInference?(getContents(PT, NL)) /\
      N > 0 /\
      N <= numTermsInRootSet(getSubTree(PT, NL)) /\
      T1 := getFirstTerm(getSubTree(PT, NL)) /\
      T2 := getWrongTerm(getSubTree(PT, NL), N) /\
      PT' := createRewTree(labeling(M), MM, T1, T2, QS, TT, BND) .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  crl [missing-wrong] :
      < O : DDDC | input : ('_is`wrong`.['token[T]]), output : nil, strategy : dq, tree : PT,
                   current : NL, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'The 'term 'does
                                                  'not 'exist. '\n), strategy : dq, tree : PT,
                   current : NL, AtS >
   if N := downNat*(T) /\
      setInference?(getContents(PT, NL)) /\
      N > numTermsInRootSet(getSubTree(PT, NL)) or-else N == 0 .

  crl [missing-wrong-error-nat] :
      < O : DDDC | input : ('_is`wrong`.['token[T]]), output : nil, strategy : dq, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'The 'argument 'is
                                                  'not 'a 'natural 'number. '\n),
                   strategy : dq, AtS >
   if not (downNat*(T) :: Nat) .

  crl [missing-wrong-error-answer] :
      < O : DDDC | input : ('_is`wrong`.['token[T]]), output : nil, tree : PT,
                   current : NL, strategy : dq, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'This 'answer 'cannot
                                                  'be 'given 'here. '\n), tree : PT,
                   current : NL, strategy : dq, AtS >
   if not setInference?(getContents(PT, NL)) .

  op setInference? : Judgment -> Bool .
  eq setInference?(T =>1 {TL}) = true .
  eq setInference?(T =>q[Q] {TL}) = true .
  eq setInference?(T ~>[BND] {TL} s.t. PAT & C [FST]) = true .
  eq setInference?(J) = false [owise] .

  op getWrongTerm : Tree Nat -> Term .
  eq getWrongTerm(tree(T =>1 {TL}, N, F), N') = getTerm(TL, N') .
  eq getWrongTerm(tree(T ~>[BND] {TL} s.t. PAT & C [FST], N, F), N') = getTerm(TL, N') .
  eq getWrongTerm(tree(T =>q[Q] {TL}, N, F), N') = getTerm(TL, N') .

  op numTermsInRootSet : Tree ~> Nat .
  eq numTermsInRootSet(tree(T =>1 {TL}, N, F)) = size(TL) .
  eq numTermsInRootSet(tree(T =>q[Q] {TL}, N, F)) = size(TL) .
  eq numTermsInRootSet(tree(T ~>[BND] {TL} s.t. PAT & C [FST], N, F)) = size(TL) .

  op getTerm : TermList Nat -> Term .
  eq getTerm((T, TL), 1) = T .
  eq getTerm((T, TL), s(s(N))) = getTerm(TL, s(N)) .

***(%
\end{verbatim}
}

\end{comment}

When the divide and query strategy is selected and the user decides to trust a
statement, the current subtree is deleted and the resulting tree is pruned in order
to delete the nodes associated with the trusted statement:

{\codesize
\begin{verbatim}
%)

  crl [divide-query-traversal] :
      < O : DDDC | input : ('trust`..@Command@), strategy : dq, tree : PT,
                   current : NL, previousStates : LS, answers : LA,
                   state : waiting, AtS >
   => < O : DDDC | input : nilTermList, strategy : dq, tree : PT', current : NL,
                   previousStates : LS < NL, PT, dq >,
                   answers : LA getAnswer(getSubTree(PT, NL), right),
                   state : computing, AtS >
  if Q := getLabel(PT, NL) /\
     PT' := prune(deleteSubTree(PT, NL), Q) .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  crl [trust-error] :
      < O : DDDC | input : ('trust`..@Command@), output : nil, strategy : dq,
                   tree : PT, current : NL, state : waiting, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'This 'answer 'is
                                                  'not 'valid 'for 'this 'question. '\n),
                   strategy : dq, tree : PT, current : NL, state : waiting, AtS >
  if not (getLabel(PT, NL) :: Qid) .

***(%
\end{verbatim}
}

\end{comment}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  crl [divide-query-traversal] :
      < O : DDDC | input : ('don't`know`..@Command@), strategy : dq, tree : PT,
                   current : NL, previousStates : LS, answers : LA,
                   state : waiting, AtS >
   => < O : DDDC | input : nilTermList, strategy : dq, tree : PT', current : NL,
                   previousStates : LS < NL, PT, dq >,
                   answers : LA getAnswer(getSubTree(PT, NL), unknown),
                   state : computing, AtS >
  if PT' := setUnknown(PT, NL) .

  crl [command-unexpected] :
       < O : DDDC | input : CONST, output : nil, strategy : dq, state : waiting, AtS >
    => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'Divide 'and
                                                   'query 'strategy 'selected. '\n),
                    strategy : dq, state : computing, AtS >
    if CONST == 'all`:`yes`..@Command@ .

 crl [command-unexpected] :
       < O : DDDC | input : (Q[TL]), output : nil, strategy : dq, state : waiting, AtS >
    => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'Divide 'and
                                                   'query 'strategy 'selected. '\n),
                    strategy : dq, state : computing, AtS >
    if Q == '_:`no`. or-else
       Q == '_:`yes`. or-else
       Q == '_:`don't`know`. or-else
       Q == '_:`trust`. or-else
       Q == '_:`its`sort`is`final`. or-else
       Q == '_:_is`wrong`. or-else
       Q == '_:_is`not`a`solution`. .

  ----------------------------------------- SS -------------------------------------------

  crl [single-stepping-yes] :
      < O : DDDC | input : ('yes`..@Command@), strategy : ss, tree : PT,
                   current : NL, previousStates : LS, state : waiting,
                   answers : LA, AtS >
   => < O : DDDC | input : nilTermList, strategy : ss, tree : PT', current : nil,
                   previousStates : LS < NL, PT, ss >, state : computing,
                   answers : LA getAnswer(getFirstPostorder(PT), right), AtS >
  if PT' := deleteFirstPostorder(PT) .

  crl [single-stepping-no] :
      < O : DDDC | input : ('no`..@Command@), strategy : ss, tree : PT,
                   current : NL, previousStates : LS, state : waiting,
                   answers : LA, AtS >
   => < O : DDDC | input : nilTermList, strategy : ss, tree : PT', current : nil,
                   previousStates : LS < NL, PT, ss >, state : computing,
                   answers : LA getAnswer(getFirstPostorder(PT), wrong), AtS >
  if PT' := getFirstPostorder(PT) .

  crl [single-stepping-command-unexpected-constant] :
       < O : DDDC | input : CONST, output : nil, strategy : ss, state : waiting, AtS >
    => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'Single
                                                   'stepping 'strategy 'selected. '\n),
                    strategy : ss, state : computing, AtS >
    if CONST == 'all`:`yes`..@Command@ or-else
       CONST == 'trust`..@Command@ or-else
       CONST == 'its`sort`is`final`..@Command@ .

  crl [single-stepping-command-unexpected-with-arguments] :
      < O : DDDC | input : (Q[TL]), output : nil, strategy : ss, state : waiting, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'Single
                                                   'stepping 'strategy 'selected. '\n),
                    strategy : ss, state : computing, AtS >
   if Q == '_:`no`. or-else
      Q == '_:`yes`. or-else
      Q == '_:`don't`know`. or-else
      Q == '_:`trust`. or-else
      Q == '_:`its`sort`is`final`. or-else
      Q == '_:_is`wrong`. or-else
      Q == '_:_is`not`a`solution`. or-else
      Q == '_is`wrong`. or-else
      Q == '_:`yes`. or-else
      Q == '_:`no`. or-else
      Q == '_:`trust`. or-else
      Q == '_:`don't`know`. or-else
      Q == '_:`its`sort`is`final`. .


  op deleteFirstPostorder : Tree -> Forest .
  eq deleteFirstPostorder(tree(J, N, PT F)) = tree(J, sd(N, 1), deleteFirstPostorder(PT) F) .
  eq deleteFirstPostorder(tree(J, 1, mtForest)) = mtForest .

  op getFirstPostorder : Tree -> Tree .
  eq getFirstPostorder(tree(J, N, PT F)) = getFirstPostorder(PT) .
  eq getFirstPostorder(tree(J, 1, mtForest)) = tree(J, 1, mtForest) .

  -----------------------------------------------------------------------------------------
  ---------------------------------------- UNDO -------------------------------------------
  -----------------------------------------------------------------------------------------

  rl [undo-top-down] :
     < O : DDDC | input : ('undo`..@Command@), output : nil, strategy : STRAT, tree : PT,
                  module : M, previousStates : LS < nil, PT', td >, answers : LA A,
                  state : TS, AtS >
  => < O : DDDC | input : nilTermList, output : printOffspring(PT', M),
                  strategy : td, tree : PT', module : M, previousStates : LS,
                  answers : LA, state : waiting, AtS > .

  rl [undo-divide-query] :
     < O : DDDC | input : ('undo`..@Command@), output : nil, strategy : STRAT, tree : PT,
                  current : NL, module : M, previousStates : LS < NL', PT', dq >,
                  answers : LA A, state : TS, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n printNode(PT', NL', M)),
                  strategy : dq, tree : PT', current : NL', module : M,
                  previousStates : LS, answers : LA, state : waiting, AtS > .

  rl [undo-single-stepping] :
     < O : DDDC | input : ('undo`..@Command@), output : nil, strategy : STRAT, tree : PT,
                  current : NL, module : M, previousStates : LS < NL', PT', ss >,
                  answers : LA A, state : TS, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n printFirstPreorder(PT', M)),
                  strategy : ss, tree : PT', current : NL', module : M,
                  previousStates : LS, answers : LA, state : waiting, AtS > .

  rl [undo-error] :
     < O : DDDC | input : ('undo`..@Command@), output : nil, previousStates : nil, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'Cannot 'undo.),
                  previousStates : nil, AtS > .

  -----------------------------------------------------------------------------------------
  ------------------------------------- NEXT QUESTION -------------------------------------
  -----------------------------------------------------------------------------------------

  crl [expand] :
      < O : DDDC | tree : PT, module : M, state : computing, bound : BND,
                   correction : MM, currentSuspicious : QS, AtS >
   => < O : DDDC | tree : PT', module : M, state : computing, bound : BND,
                   correction : MM, currentSuspicious : QS, AtS >
   if anotherTreeNeeded?(PT) /\
      PT' := expand(M, MM, PT, QS, BND) .

  crl [top-down] :
      < O : DDDC | output : nil, strategy : td, tree : PT, module : M,
                   state : computing, intended : SDDIS, AtS >
   => < O : DDDC | if hasOffspring?(PT, nil)
                   then output : printOffspring(PT, M), state : waiting
                   else output : printRoot(PT, M, SDDIS), state : finished
                   fi, tree : PT, strategy : td, module : M,
                   intended : SDDIS, AtS >
   if not anotherTreeNeeded?(PT) /\
      not allChildUnknown(PT) .

  crl [top-down-all-unknown] :
      < O : DDDC | output : nil, strategy : td, tree : PT, state : computing, AtS >
   => < O : DDDC | output : ('\n '\r 'Error: '\o 'The 'information 'introduced 'is 'not
                             'enough 'to 'find 'the 'error. '\n), strategy : td, tree : PT,
                   state : waiting, AtS >
   if allChildUnknown(PT) .

  crl [divide-query] :
      < O : DDDC | output : nil, strategy : dq, tree : PT, current : NL, module : M,
                   state : computing, answers : LA, intended : SDDIS, AtS >
   => < O : DDDC | if not debugFinished?(PT')
                   then output : printNode(PT', NL', M), state : waiting, tree : PT'
                   else output : printRoot(getResult(PT'), M, SDDIS), state : finished,
                        tree : PT
                   fi, current : NL', strategy : dq, module : M, answers : LA,
                   intended : SDDIS, AtS >
   if not anotherTreeNeeded?(PT) /\
      not sol?(PT) /\
      < PT', NL' > := nextTreeDQ(PT, searchBestNode(PT), LA) .

  crl [single-stepping] :
      < O : DDDC | output : nil, strategy : ss, tree : PT, module : M,
                   state : computing, intended : SDDIS, AtS >
   => < O : DDDC | if hasOffspring?(PT, nil)
                   then output : printFirstPreorder(PT, M), state : waiting
                   else output : printRoot(PT, M, SDDIS), state : finished
                   fi, tree : PT, strategy : ss, module : M,
                   intended : SDDIS, AtS >
   if not anotherTreeNeeded?(PT) /\
      not allChildUnknown(PT) .

***(%
\end{verbatim}
}

\end{comment}

When the debugging of missing answers reaches a node that is frozen (i.e., it is
built with the operator \texttt{sol} and its fifth argument is \texttt{false}),
the debugger builds the associated tree. If the condition holds for the current
term (the third argument is \texttt{true}), a tree for wrong answers is built with
\texttt{conditionForest}:


{\codesize
\begin{verbatim}
%)

  crl [sol-true] :
      < O : DDDC | tree : tree(sol(T, T', C, true, false, true), N, F), module : M,
                   correction : MM, state : computing, currentSuspicious : QS, bound : BND,
                   currentTTW : TT, currentFinal : FS, currentFS : BFS, AtS >
   => < O : DDDC | tree : tree(sol(T, T', C, true, true, true), 1 + getOffspring*(F'), F'),
                   module : M, correction : MM, state : computing, currentSuspicious : QS,
                   bound : BND, currentTTW : TT, currentFinal : FS, currentFS : BFS, AtS >
   if F' := conditionForest(substituteDD(M, C, metaMatch(M, T', T, C, 0)), M,
                            deleteSuspicious(M, QS), MM, QS, BND, TT) .

***(%
\end{verbatim}
}

\noindent while if the condition does not hold a tree for missing answers is
computed by using the function \verb"buildConditionForestMissingAux":

{\codesize
\begin{verbatim}
%)

  crl [sol-false] :
      < O : DDDC | tree : tree(sol(T, T', C, false, false, true), N, F), module : M,
                   correction : MM, state : computing, currentSuspicious : QS, bound : BND,
                   currentTTW : TT, currentTTM : TT', searchType : MST, currentSP : SP,
                   currentFinal : FS, currentFS : BFS, AtS >
   => < O : DDDC | tree : tree(sol(T, T', C, false, true, true), 1 + getOffspring*(F'), F'),
                   module : M, correction : MM, state : computing, currentSuspicious : QS,
                   bound : BND, currentTTW : TT, currentTTM : TT', searchType : MST,
                   currentSP : SP, currentFinal : FS, currentFS : BFS, AtS >
   if M' := deleteSuspicious(M, QS) /\
      F' := cleanTree*(M, BFS, FS, createForest(M, M', MM, T,
                                        getTerm(metaReduce(M, T)), QS, strat?(M))
            first(buildConditionForestMissingAux(M, M', MM, QS, FS, T, T, BND, MST, TT,
                                TT', SP, T' := T /\ C, strat?(M),
                                allSubs(M, T, T' := T, 0, mtSSB), 2, getNumConds(C) + 1))) .

***(%
\end{verbatim}
}

\begin{comment}

%  -----------------------------------------------------------------------------------------
%  -------------------------------------- NO TREE ------------------------------------------
%  -----------------------------------------------------------------------------------------


{\codesize
\begin{verbatim}
%)

  rl [no-tree] :
     < O : DDDC | tree : mtForest, state : computing, AtS >
  => < O : DDDC | tree : mtForest, state : waiting, AtS > .

    crl [no-tree-error] :
       < O : DDDC | input : CONST, output : nil, tree : mtForest, state : waiting, AtS >
    => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o
                                                   'The 'debugging 'process 'has 'not
                                                   'started 'yet '\n),
                    tree : mtForest, state : waiting, AtS >
    if CONST == 'yes`..@Command@ or-else
       CONST == 'no`..@Command@ or-else
       CONST == 'all`:`yes`..@Command@ or-else
       CONST == 'don't`know`..@Command@ or-else
       CONST == 'trust`..@Command@ or-else
       CONST == 'its`sort`is`final`..@Command@ .

 crl [no-tree-error] :
       < O : DDDC | input : (Q[TL]), output : nil, tree : mtForest, state : waiting, AtS >
    => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o
                                                   'The 'debugging 'process 'has 'not
                                                   'started 'yet '\n),
                    tree : mtForest, state : waiting, AtS >
    if Q == '_:`no`. or-else
       Q == '_:`yes`. or-else
       Q == '_:`trust`. or-else
       Q == '_:`its`sort`is`final`. or-else
       Q == '_:`don't`know`. or-else
       Q == '_is`wrong`. or-else
       Q == '_is`not`a`solution`. or-else
       Q == '_:_is`wrong`. or-else
       Q == '_:_is`not`a`solution`. .

***(%
\end{verbatim}
}

\end{comment}

%  -----------------------------------------------------------------------------------------
%  ---------------------------------- NOT WANTED RESULT ------------------------------------
%  -----------------------------------------------------------------------------------------

When a question related to a set of reachable solutions is presented to the
user, he can point that one of these terms is not a solution, although it is
reachable. In this case, the rule \verb"no-result" checks that the question
was really related to an inference of reachable solutions with
\verb"solutionsInference?" and that the term selected by the user exists,
and then computes the tree of wrong answers for the fulfillment of the
condition with \texttt{conditionForest}:

{\codesize
\begin{verbatim}
%)

  crl [no-result] :
      < O : DDDC | input : ('_is`not`a`solution`.['token[T]]), strategy : dq,
                   tree : PT, current : NL, module : M, correction : MM, treeType : TT,
                   bound : BND, currentSuspicious : QS, state : waiting,
                   condition : C, pattern : PAT, previousStates : LS,
                   answers : LA, AtS >
   => < O : DDDC | input : nilTermList, strategy : dq, current : NL,
                   tree : tree(sol(T2, PAT, C, true, true, true), 1 + getOffspring*(F), F),
                   module : M, correction : MM, treeType : TT, bound : BND,
                   currentSuspicious : QS, state : computing, condition : C,
                   pattern : PAT, previousStates : LS < NL, PT, dq >,
                   answers : LA getAnswer(PT, wrong), AtS >
   if N := downNat*(T) /\
      solutionsInference?(getContents(PT, NL)) /\
      N > 0 /\
      N <= numTermsInRootSet(getSubTree(PT, NL)) /\
      T2 := getWrongTerm(getSubTree(PT, NL), N) /\
      F := conditionForest(substituteDD(M, C, metaMatch(M, PAT, T2, C, 0)),
                                       M, deleteSuspicious(M, QS), MM, QS, BND, TT) .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  crl [no-result-wrong] :
      < O : DDDC | input : ('_is`not`a`solution`.['token[T]]), output : nil, strategy : dq,
                   tree : PT, current : NL, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'The 'term 'does
                                                  'not 'exist. '\n), strategy : dq, tree : PT,
                   current : NL, AtS >
   if N := downNat*(T) /\
      solutionsInference?(getContents(PT, NL)) /\
      N > numTermsInRootSet(getSubTree(PT, NL)) or-else N == 0 .

  crl [no-result-error-nat] :
      < O : DDDC | input : ('_is`not`a`solution`.['token[T]]), output : nil, strategy : dq, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'The 'argument 'is
                                                  'not 'a 'natural 'number. '\n),
                   strategy : dq, AtS >
   if not (downNat*(T) :: Nat) .

  crl [no-result-error-answer] :
      < O : DDDC | input : ('_is`not`a`solution`.['token[T]]), output : nil, tree : PT,
                   current : NL, strategy : dq, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'The 'set 'is 'not
                                                  'related 'to 'solutions. '\n), tree : PT,
                   current : NL, strategy : dq, AtS >
   if not solutionsInference?(getContents(PT, NL)) .

  op solutionsInference? : Judgment -> Bool .
  eq solutionsInference?(T ~>[BND] {TL} s.t. PAT & C [true]) = true .
  eq solutionsInference?(J) = false [owise] .

***(%
\end{verbatim}
}

%  -----------------------------------------------------------------------------------------
%  ------------------------------------- SORT FINAL ----------------------------------------
%  -----------------------------------------------------------------------------------------

\end{comment}

In the divide and query strategy,
when the user introduces that the sort of a certain term is final on the fly
the rule \verb"sort-final" is applied. It checks that the question is related to
final terms with the function \verb"finalQuestion?"
and then prunes all the tree with the function \verb"pruneFinalSort":

{\codesize
\begin{verbatim}
%)

  crl [sort-final] :
      < O : DDDC | input : ('its`sort`is`final`..@Command@), output : nil,
                   tree : PT, current : NL, module : M, state : waiting, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\b 'Terms 'of 'sort '\o Ty
                                                  '\b 'are 'final. '\o '\n),
                   tree : PT', current : NL, module : M, state : computing, AtS >
   if finalQuestion?(getContents(PT, NL)) /\
      T := getFirstTerm(getSubTree(PT, NL)) /\
      Ty := getType(metaReduce(M, T)) /\
      PT' := pruneFinalSort(M, Ty, PT) .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  crl [sort-final] :
      < O : DDDC | input : ('its`sort`is`final`..@Command@), output : nil,
                   tree : PT, current : NL, state : waiting, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'Answer 'not
                                                  'allowed. '\n),
                   tree : PT, current : NL, state : computing, AtS >
   if J := getContents(PT, NL) /\
      not finalQuestion?(J) .

  -----------------------------------------------------------------------------------------
  ------------------------------------ SELECT ON/OFF  -------------------------------------
  -----------------------------------------------------------------------------------------

***(%
\end{verbatim}
}

\end{comment}

When the user decides to switch the select mode on to use a subset of the labeled
statements as suspicious, the \texttt{select} attribute is set to \texttt{true}:

{\codesize
\begin{verbatim}
%)

  rl [select] :
     < O : DDDC | input : ('set`debug`select`on`..@Command@), select : B,
                  output : nil, AtS >
  => < O : DDDC | input : nilTermList, select : true,
                  output : ('\n '\b 'Debug 'select 'is 'on. '\o '\n), AtS > .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  rl [deselect] :
     < O : DDDC | input : ('set`debug`select`off`..@Command@), output : nil,
                  select : B, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'Debug 'select 'is 'off. '\o '\n),
                  select : false, AtS > .

***(%
\end{verbatim}
}

The final selection mode is switched on and off with the rules \verb"final-on"
and \verb"final-off" respectively, that update the \texttt{finalSelect} attribute:

%  -----------------------------------------------------------------------------------------
%  ------------------------------- SELECT FINAL ON/OFF  ------------------------------------
%  -----------------------------------------------------------------------------------------

{\codesize
\begin{verbatim}
%)

  rl [final-on] :
     < O : DDDC | input : ('set`final`select`on`..@Command@), output : nil,
                  finalSelect : B, AtS >
  => < O : DDDC | input : nilTermList, finalSelect : true,
                  output : ('\n '\b 'Final 'select 'is 'on. '\o '\n), AtS > .

  rl [final-off] :
     < O : DDDC | input : ('set`final`select`off`..@Command@), output : nil,
                  finalSelect : B, AtS >
  => < O : DDDC | input : nilTermList, finalSelect : false,
                  output : ('\n '\b 'Final 'select 'is 'off. '\o '\n), AtS > .

***(%
\end{verbatim}
}

\end{comment}

%  -----------------------------------------------------------------------------------------
%  ---------------------------------- SOLUTIONS PRIORITIZED  -------------------------------
%  -----------------------------------------------------------------------------------------

The rules \verb"solution-expanded-on" and \verb"solution-expanded-off" are used
to select and deselect, respectively, if the solutions are expanded:

{\codesize
\begin{verbatim}
%)

  rl [solution-expanded-on] :
     < O : DDDC | input : ('solutions`prioritized`on`..@Command@),
                  solutionsPrioritized : B, output : nil, AtS >
  => < O : DDDC | input : nilTermList, solutionsPrioritized : true,
                  output : ('\n '\b 'Solutions 'are 'prioritized. '\o '\n), AtS > .

  rl [solution-expanded-off] :
     < O : DDDC | input : ('solutions`prioritized`off`..@Command@),
                  solutionsPrioritized : B, output : nil, AtS >
  => < O : DDDC | input : nilTermList, solutionsPrioritized : false,
                  output : ('\n '\b 'Solutions 'are 'not 'prioritized. '\o '\n), AtS > .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  -----------------------------------------------------------------------------------------
  ----------------------------------- SHOW SUSPICIOUS -------------------------------------
  -----------------------------------------------------------------------------------------

  rl [show-suspicious] :
      < O : DDDC | input : 'show`suspicious`labels`..@Command@, suspicious : QS,
                   output : nil,  AtS >
   => < O : DDDC | input : nilTermList, suspicious : QS,
                   output : ('\n '\b 'Suspicious 'labels: '\o set2list(QS) '\n) , AtS > .

  -----------------------------------------------------------------------------------------
  ----------------------------------- SELECT/DESELECT -------------------------------------
  -----------------------------------------------------------------------------------------

  rl [select] :
      < O : DDDC | input : ('debug-select_.['neTokenList[T]]), output : nil,
                   suspicious : QS, select : B, AtS >
   => < O : DDDC | input : nilTermList, output : (advisory-select(B)
                                                  includeMsg(list2set(downQidList(T)))),
                   suspicious : (QS ; list2set(downQidList(T))), select : B, AtS > .

  rl [deselect] :
      < O : DDDC | input : ('debug-deselect_.['neTokenList[T]]), output : nil,
                   suspicious : QS, select : B, AtS >
   => < O : DDDC | input : nilTermList, output : (advisory-select(B)
                                                  excludeMsg(list2set(downQidList(T)))),
                   suspicious : (QS \ list2set(downQidList(T))),
                   select : B, AtS > .

  crl [include] :
      < O : DDDC | db : DB, input : ('debug-include_.[T]), output : nil, select : B,
                   suspicious : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList,
                   output : (advisory-select(B) QIL includeMsg(QS')),
                   select : B, suspicious : (QS ; QS'), AtS >
   if < QS' : QIL > := procInclude(T, DB) .

  crl [exclude] :
      < O : DDDC | db : DB, input : ('debug-exclude_.[T]), output : nil, select : B,
                   suspicious : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList, output : (advisory-select(B) QIL
                                                           excludeMsg(QS')),
                   select : B,  suspicious : (QS \ QS'), AtS >
   if < QS' : QIL > := procInclude(T, DB) .

  crl [include-eqs] :
      < O : DDDC | db : DB, input : ('debug-include-eqs_.[T]), output : nil, select : B,
                   suspicious : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList,
                   output : (advisory-select(B) QIL includeMsg(QS')),
                   select : B, suspicious : (QS ; QS'), AtS >
   if < QS' : QIL > := procIncludeEqs(T, DB) .

  crl [exclude-eqs] :
      < O : DDDC | db : DB, input : ('debug-exclude-eqs_.[T]), output : nil, select : B,
                   suspicious : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList, output : (advisory-select(B) QIL
                                                           excludeMsg(QS')),
                   select : B,  suspicious : (QS \ QS'), AtS >
   if < QS' : QIL > := procIncludeEqs(T, DB) .

  crl [include-mbs] :
      < O : DDDC | db : DB, input : ('debug-include-mbs_.[T]), output : nil, select : B,
                   suspicious : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList,
                   output : (advisory-select(B) QIL includeMsg(QS')),
                   select : B, suspicious : (QS ; QS'), AtS >
   if < QS' : QIL > := procIncludeMbs(T, DB) .

  crl [exclude-mbs] :
      < O : DDDC | db : DB, input : ('debug-exclude-mbs_.[T]), output : nil, select : B,
                   suspicious : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList, output : (advisory-select(B) QIL
                                                           excludeMsg(QS')),
                   select : B,  suspicious : (QS \ QS'), AtS >
   if < QS' : QIL > := procIncludeMbs(T, DB) .

  crl [include-rls] :
      < O : DDDC | db : DB, input : ('debug-include-rls_.[T]), output : nil, select : B,
                   suspicious : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList,
                   output : (advisory-select(B) QIL includeMsg(QS')),
                   select : B, suspicious : (QS ; QS'), AtS >
   if < QS' : QIL > := procIncludeRls(T, DB) .

  crl [exclude-rls] :
      < O : DDDC | db : DB, input : ('debug-exclude-rls_.[T]), output : nil, select : B,
                   suspicious : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList, output : (advisory-select(B) QIL
                                                           excludeMsg(QS')),
                   select : B,  suspicious : (QS \ QS'), AtS >
   if < QS' : QIL > := procIncludeRls(T, DB) .

  op includeMsg : QidSet -> QidList .
  eq includeMsg(none) = '\n '\b 'No 'labels 'have 'been 'added. '\o '\n .
  eq includeMsg(QS) = '\n '\b 'Labels '\o set2list(QS) '\b 'are 'now 'suspicious. '\o '\n [owise] .

  op excludeMsg : QidSet -> QidList .
  eq excludeMsg(none) = '\n '\b 'No 'labels 'have 'been 'trusted. '\o '\n .
  eq excludeMsg(QS) = '\n '\b 'Labels '\o set2list(QS) '\b 'have 'been 'trusted. '\o '\n [owise] .

***(%
\end{verbatim}
}

%  -----------------------------------------------------------------------------------------
%  --------------------------------- SELECTING FINAL SORTS ---------------------------------
%  -----------------------------------------------------------------------------------------

Final sorts are introduced with the rule \verb"select-final", that uses an auxiliary
function \texttt{procFinals} to generate the list of new sorts and
an error message, that must be \verb"nil" when the sorts are correct. These sorts
are added to the former final sorts in the attribute \verb"finalSorts",
and an advisory message is generated with \verb"advisory-final" if the final mode
is switched off:

{\codesize
\begin{verbatim}
%)

  crl [select-final] :
      < O : DDDC | input : ('final`select_.[T]), output : nil,
                   finalSelect : B, finalSorts : QS, AtS >
   => < O : DDDC | input : nilTermList, finalSelect : B,
                   output : (advisory-final(B) includeMsgFinal(QS')),
                   finalSorts : (QS ; QS'), AtS >
   if < QS' : nil > := procFinals(T) .

  crl [deselect-final] :
      < O : DDDC | input : ('final`deselect_.[T]), output : nil,
                   finalSelect : B, finalSorts : QS, AtS >
   => < O : DDDC | input : nilTermList, finalSelect : B,
                   output : (advisory-final(B) excludeMsgFinal(QS')),
                   finalSorts : (QS \ QS'), AtS >
   if < QS' : nil > := procFinals(T) .

  crl [select-final-error] :
      < O : DDDC | input : ('final`select_.[T]), output : nil, finalSelect : B, AtS >
   => < O : DDDC | input : nilTermList, output : (advisory-final(B) QIL),
                   finalSelect : B, AtS >
   if < QS : QIL > := procFinals(T) /\
      QIL =/= nil .

  crl [deselect-final-error] :
      < O : DDDC | input : ('final`deselect_.[T]), output : nil,
                   finalSelect : B, AtS >
   => < O : DDDC | input : nilTermList, output : (advisory-final(B) QIL),
                   finalSelect : B, AtS >
   if < QS : QIL > := procFinals(T) /\
      QIL =/= nil .

  op includeMsgFinal : QidSet -> QidList .
  eq includeMsgFinal(none) = '\n '\b 'No 'sorts 'have 'been 'added. '\o '\n .
  eq includeMsgFinal(QS) = '\n '\b 'Sorts '\o printQidSet(QS) '\b
                           'are 'now 'final. '\o '\n [owise] .

  op excludeMsgFinal : QidSet -> QidList .
  eq excludeMsgFinal(none) = '\n '\b 'No 'sorts 'have 'been 'removed. '\o '\n .
  eq excludeMsgFinal(QS) = '\n '\b 'Sorts '\o printQidSet(QS) '\b  'are 'not
                           'final. '\o '\n [owise] .

  op printQidSet : QidSet -> QidList .
  eq printQidSet(none) = nil .
  eq printQidSet(Q ; QS) = add-space(eMetaPrettyPrint(Q)) printQidSet(QS) .

  -----------------------------------------------------------------------------------------
  ---------------------------------------- START ------------------------------------------
  -----------------------------------------------------------------------------------------

  rl [start] :
      < O : DDDC | input : 'start`..@Command@, output : nil,  AtS >
   => < O : DDDC | input : nilTermList,
                   output : ('\n '\b 'The 'tool 'state 'has 'been 'reset. '\o '\n),
                   init-state > .

  -----------------------------------------------------------------------------------------
  -------------------------------------- FINISHED -----------------------------------------
  -----------------------------------------------------------------------------------------

  crl [command-unexpected-finished] :
       < O : DDDC | input : CONST, output : nil, state : finished, AtS >
    => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o
                                                   'Debugging 'process 'finished. '\n),
                    state : finished, AtS >
    if CONST == 'yes`..@Command@ or-else
       CONST == 'no`..@Command@ or-else
       CONST == 'all`:`yes`..@Command@ or-else
       CONST == 'unknown`..@Command@ or-else
       CONST == 'trust`..@Command@ or-else
       CONST == 'its`sort`is`final`..@Command@ .

 crl [command-unexpected-finished] :
       < O : DDDC | input : (Q[TL]), output : nil, state : finished, AtS >
    => < O : DDDC | input : nilTermList, output : ('\n '\r 'Invalid 'command: '\o
                                                   'Debugging 'process 'finished. '\n),
                    state : finished, AtS >
    if Q == '_:`no`. or-else
       Q == '_:`yes`. or-else
       Q == '_:`trust`. or-else
       Q == '_:`its`sort`is`final`. or-else
       Q == '_is`wrong`. or-else
       Q == '_is`not`a`solution`. or-else
       Q == '_:_is`wrong`. or-else
       Q == '_:_is`not`a`solution`. .

  -----------------------------------------------------------------------------------------
  ------------------------------------- SHOW TESTS ----------------------------------------
  -----------------------------------------------------------------------------------------

  crl [show-correct] :
      < O : DDDC | input : ('show`correct`..@Command@), output : nil, module : M,
                   tests : (okTests : LTC, LTAS), AtS >
   => < O : DDDC | input : nilTermList, output : (incorrectMsg printTests(M, LTC)),
                   module : M, tests : (okTests : LTC, LTAS), AtS >
   if LTC =/= nil .

  rl [show-correct-error1] :
     < O : DDDC | input : ('show`correct`..@Command@), output : nil,
                  tests : (okTests : nil, LTAS), AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'There 'are 'not 'test 'cases
                                                 'correct 'with 'respect 'to 'the 'correct 'module. '\n),
                  tests : (okTests : nil, LTAS), AtS > .

  rl [show-correct-error2] :
     < O : DDDC | input : ('show`correct`..@Command@), output : nil, module : undefMod, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'No 'module 'selected. '\n),
                  module : undefMod, AtS > .

  rl [show-correct-error3] :
     < O : DDDC | input : ('show`correct`..@Command@), output : nil,
                  tests : mtTestInfo, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'No 'test 'cases
                                                 'generated. '\n),
                  tests : mtTestInfo, AtS > .

  crl [show-incorrect] :
      < O : DDDC | input : ('show`incorrect`..@Command@), output : nil, module : M,
                   tests : (wrongCMTests : LTC, LTAS), AtS >
   => < O : DDDC | input : nilTermList, output : (incorrectMsg printTests(M, LTC)),
                   module : M, tests : (wrongCMTests : LTC, LTAS), AtS >
   if LTC =/= nil .

  rl [show-incorrect-error1] :
     < O : DDDC | input : ('show`incorrect`..@Command@), output : nil,
                  tests : (wrongCMTests : nil, LTAS), AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'There 'are 'not 'test 'cases
                                                 'incorrect 'with 'respect 'to 'the 'correct 'module. '\n),
                  tests : (wrongCMTests : nil, LTAS), AtS > .

  rl [show-incorrect-error2] :
     < O : DDDC | input : ('show`incorrect`..@Command@), output : nil, module : undefMod, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'No 'module 'selected. '\n),
                  module : undefMod, AtS > .

  rl [show-incorrect-error3] :
     < O : DDDC | input : ('show`incorrect`..@Command@), output : nil,
                  tests : mtTestInfo, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'No 'test 'cases
                                                 'generated. '\n),
                  tests : mtTestInfo, AtS > .

  crl [show-N-incorrect] :
      < O : DDDC | input : ('show_incorrect`.['token[T]]), output : nil, module : M,
                   tests : (wrongCMTests : LTC, LTAS), incorrectSeen : N, AtS >
   => < O : DDDC | input : nilTermList, output : (incorrectMsg printTests(M, LTC', N')),
                   module : M, tests : (wrongCMTests : LTC, LTAS),
                   incorrectSeen : (N + N'), AtS >
   if LTC =/= nil /\
      N' := downNat*(T) /\
      LTC' := skip(LTC, N) .

  crl [show-N-incorrect-error1] :
      < O : DDDC | input : ('show_incorrect`.['token[T]]), output : nil, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'Natural
                                                  'number 'expected. '\n),
                   AtS >
   if N? := downNat*(T) /\
      not N? :: Nat .

  rl [show-N-incorrect-error2] :
     < O : DDDC | input : ('show_incorrect`.['token[T]]), output : nil,
                  tests : (wrongCMTests : nil, LTAS), AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'No 'incorrect 'test
                                                 'cases 'generated. '\n),
                  tests : (wrongCMTests : nil, LTAS), AtS > .

  crl [next-N-incorrect] :
      < O : DDDC | input : ('next_incorrect`.['token[T]]), output : nil, module : M,
                   tests : (wrongCMTests : LTC, LTAS), incorrectSeen : N, AtS >
   => < O : DDDC | input : nilTermList, output : (incorrectMsg printTests(M, LTC', s(N), N')),
                   module : M, tests : (wrongCMTests : LTC, LTAS),
                   incorrectSeen : (N + N'), AtS >
   if LTC =/= nil /\
      N' := downNat*(T) /\
      LTC' := skip(LTC, N) .

  crl [next-N-incorrect-error1] :
      < O : DDDC | input : ('next_incorrect`.['token[T]]), output : nil, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'Natural
                                                  'number 'expected. '\n), AtS >
   if N? := downNat*(T) /\
      not N? :: Nat .

  rl [next-N-incorrect-error2] :
     < O : DDDC | input : ('next_incorrect`.['token[T]]), output : nil,
                  tests : (wrongCMTests : nil, LTAS), AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'No 'incorrect 'test
                                                 'cases 'generated. '\n),
                  tests : (wrongCMTests : nil, LTAS), AtS > .

  crl [show-not-normal] :
      < O : DDDC | input : ('show`not`normal`..@Command@), output : nil, module : M,
                   tests : (notNormTests : LTC, LTAS), AtS >
   => < O : DDDC | input : nilTermList, output : (notNormMsg printTests(M, LTC)),
                   module : M, tests : (notNormTests : LTC, LTAS), AtS >
   if LTC =/= nil .

  rl [show-not-normal-error1] :
     < O : DDDC | input : ('show`not`normal`..@Command@), output : nil,
                  tests : (notNormTests : nil, LTAS), AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'There 'are 'not 'test 'cases
                                                 'incorrect 'with 'respect 'to 'the 'correct 'module. '\n),
                  tests : (notNormTests : nil, LTAS), AtS > .

  rl [show-not-normal-error2] :
     < O : DDDC | input : ('show`not`normal`..@Command@), output : nil, module : undefMod, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'No 'module 'selected. '\n),
                  module : undefMod, AtS > .

  rl [show-not-normal-error3] :
     < O : DDDC | input : ('show`not`normal`..@Command@), output : nil,
                  tests : mtTestInfo, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'No 'test 'cases
                                                 'generated. '\n),
                  tests : mtTestInfo, AtS > .

  -----------------------------------------------------------------------------------------
  ---------------------------------- CHOOSE SEMANTICS -------------------------------------
  -----------------------------------------------------------------------------------------

  rl [big-step-semantics] :
     < O : DDDC | input : ('big-step`semantics`..@Command@), output : nil, semanticsType : SemTy, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'Big-step 'semantics
                                                 'selected '\o '\n), semanticsType : bs, AtS > .

  rl [small-step-semantics] :
     < O : DDDC | input : ('small-step`semantics`..@Command@), output : nil, semanticsType : SemTy, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'Small-step 'semantics
                                                 'selected '\o '\n), semanticsType : ss, AtS > .

  -----------------------------------------------------------------------------------------
  ---------------------------------- COVERAGE STRATEGY ------------------------------------
  -----------------------------------------------------------------------------------------

  rl [global-coverage] :
     < O : DDDC | input : ('global`coverage`..@Command@), output : nil, coverageType : CT, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'Global 'Branch 'Coverage
                                                 'selected '\o '\n), coverageType : global, AtS > .

  rl [function-coverage] :
     < O : DDDC | input : ('function`coverage`..@Command@), output : nil, coverageType : CT, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'Function 'Coverage 'selected
                                                 '\o '\n), coverageType : function, AtS > .

  rl [system-coverage] :
     < O : DDDC | input : ('system`coverage`..@Command@), output : nil, coverageType : CT, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'System 'Coverage 'selected
                                                 '\o '\n), coverageType : system, AtS > .

  -----------------------------------------------------------------------------------------
  ---------------------------------- INVOKING DEBUGGER ------------------------------------
  -----------------------------------------------------------------------------------------

  crl [invoke-debuger-not-nf] :
      < O : DDDC | input : ('invoke`debugger`with`normal`form_.['token[T]]), output : nil,
                   tests : (notNormTests : LTC, LTAS), module : M, correction : MM, tree : F,
                   select : B, suspicious : QS, currentSuspicious : QS',
                   state : TS, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\b 'Declarative 'debugging 'of
                                                  'normal 'forms 'started. '\o '\n),
                   tests : (notNormTests : LTC, LTAS), module : M, correction : MM, tree : F',
                   select : B, suspicious : QS, currentSuspicious : QS'',
                   state : computing, AtS >
   if N := downNat*(T) /\
      N' := testListSize(LTC) /\
      N <= N' /\
      < T1, T2, TSt > := getNth(LTC, N) /\
      QS'' := if B then QS else extractLabels(M) fi /\
      F' := createMissingTree(M, MM, T1, T2, QS'') .

  crl [invoke-debuger-not-nf-error-not-nat] :
      < O : DDDC | input : ('invoke`debugger`with`normal`form_.['token[T]]), output : nil,
                   AtS >
   => < O : DDDC | input : nilTermList, output : ('\r 'Error: '\o '\n '\b 'The 'argument 'must 'be
                                                  'a 'natural 'number '\o '\n), AtS >
   if not downNat*(T) :: Nat .

  crl [invoke-debuger-not-nf-no-elem] :
      < O : DDDC | input : ('invoke`debugger`with`test`case_.['token[T]]), output : nil,
                   tests : (notNormTests : LTC, LTAS), AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o '\b 'There 'is 'not 'a 'test 'case 'with
                                                  'that 'index '\o '\n),
                   tests : (notNormTests : LTC, LTAS), AtS >
   if N := downNat*(T) /\
      N' := testListSize(LTC) /\
      N > N' .

  rl [invoke-debuger-not-nf-no-tests] :
     < O : DDDC | input : ('invoke`debugger`with`test`case_.['token[T]]), output : nil,
                  tests : mtTestInfo, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o '\b 'No 'test 'cases. '\o '\n),
                  tests : mtTestInfo, AtS > .

  crl [invoke-debuger-wrong] :
      < O : DDDC | input : ('invoke`debugger`with`incorrect`test`case_.['token[T]]), output : nil,
                   tests : (wrongCMTests : LTC, LTAS), module : M, correction : MM, tree : F,
                   select : B, suspicious : QS, currentSuspicious : QS',
                   state : TS, AtS >
   => < O : DDDC | input : nilTermList, output : QIL, tests : (wrongCMTests : LTC, LTAS), module : M,
                   correction : MM, tree : F', select : B, suspicious : QS,
                   currentSuspicious : QS'', state : computing, AtS >
   if N := downNat*(T) /\
      N' := testListSize(LTC) /\
      N <= N' /\
      < T1, T2, TSt > := getNth(LTC, N, notEqualCM) /\
      QS'' := if B then QS else extractLabels(M) fi /\
      F' := createTree(M, MM, T1, T2, QS'') /\
      QIL := ('\n '\b 'Declarative 'debugging 'of 'wrong 'answers 'started. '\o '\n) .

  crl [invoke-debuger-wrong-error-not-nat] :
      < O : DDDC | input : ('invoke`debugger`with`incorrect`test`case_.['token[T]]), output : nil,
                   AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o '\b 'The 'argument 'must
                                                  'be 'a 'natural 'number '\o '\n), AtS >
   if not downNat*(T) :: Nat .

  crl [invoke-debuger-wrong-no-elem] :
      < O : DDDC | input : ('invoke`debugger`with`incorrect`test`case_.['token[T]]), output : nil,
                   tests : (wrongCMTests : LTC, LTAS), AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o '\b 'There 'is 'not 'a 'test
                                                  'case 'with 'that 'index '\o '\n),
                   tests : (wrongCMTests : LTC, LTAS), AtS >
   if N := downNat*(T) /\
      N' := testListSize(LTC) /\
      N > N' .

  rl [invoke-debuger-wrong-no-tests] :
     < O : DDDC | input : ('invoke`debugger`with`incorrect`test`case_.['token[T]]), output : nil,
                  tests : mtTestInfo, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o '\b 'No 'test 'cases. '\o '\n),
                  tests : mtTestInfo, AtS > .

  crl [invoke-debuger-user-red] :
      < O : DDDC | input : ('invoke`debugger`with`user`test`case_.['token[T]]), output : nil,
                   tests : (userTests : LTC, LTAS), module : M, correction : MM, tree : F,
                   select : B, suspicious : QS, currentSuspicious : QS',
                   state : TS, AtS >
   => < O : DDDC | input : nilTermList, output : QIL, tests : (userTests : LTC, LTAS),
                   module : M, correction : MM, tree : F', select : B, suspicious : QS,
                   currentSuspicious : QS'', state : computing, AtS >
   if N := downNat*(T) /\
      N' := testListSize(LTC) /\
      N <= N' /\
      < T1, T2, TSt > := getNth(LTC, N) /\
      QS'' := if B then QS else extractLabels(M) fi /\
      B' := normalForm?(M, T2) /\
      F' := if B'
            then createTree(M, MM, T1, T2, QS'')
            else createMissingTree(M, MM, T1, T2, QS'')
            fi /\
      QIL := if B'
             then ('\n '\b 'Declarative 'debugging 'of 'wrong 'answers 'started. '\o '\n)
             else ('\n '\b 'Declarative 'debugging 'of 'normal 'forms 'started. '\o '\n)
             fi .

  crl [invoke-debuger-user-mb] :
      < O : DDDC | input : ('invoke`debugger`with`user`test`case_.['token[T]]), output : nil,
                   tests : (userTests : LTC, LTAS), module : M, correction : MM, tree : F,
                   select : B, suspicious : QS, currentSuspicious : QS',
                   state : TS, AtS >
   => < O : DDDC | input : nilTermList, output : QIL, tests : (userTests : LTC, LTAS),
                   module : M, correction : MM, tree : F', select : B, suspicious : QS,
                   currentSuspicious : QS'', state : computing, AtS >
   if N := downNat*(T) /\
      N' := testListSize(LTC) /\
      N <= N' /\
      < T1, Ty, TSt > := getNth(LTC, N) /\
      QS'' := if B then QS else extractLabels(M) fi /\
      F' := if TSt == noInfo
            then createTree(M, MM, T1, Ty, QS'')
            else createMissingTreeMb(M, MM, T1, Ty, QS'')
            fi /\
      QIL := if TSt == noInfo
             then ('\n '\b 'Declarative 'debugging 'of 'wrong 'answers 'started. '\o '\n)
             else ('\n '\b 'Declarative 'debugging 'of 'normal 'forms 'started. '\o '\n)
             fi .

  crl [invoke-debuger-wrong-user-not-nat] :
      < O : DDDC | input : ('invoke`debugger`with`user`test`case_.['token[T]]), output : nil,
                   AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o '\b 'The 'argument 'must 'be
                                                  'a 'natural 'number '\o '\n), AtS >
   if not downNat*(T) :: Nat .

  crl [invoke-debuger-user-no-elem] :
      < O : DDDC | input : ('invoke`debugger`with`user`test`case_.['token[T]]), output : nil,
                   tests : (userTests : LTC, LTAS), AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o '\b 'There 'is 'not 'a 'test
                                                  'case 'with 'that 'index '\o '\n),
                   tests : (userTests : LTC, LTAS), AtS >
   if N := downNat*(T) /\
      N' := testListSize(LTC) /\
      N > N' .

  rl [invoke-debuger-user-no-tests] :
     < O : DDDC | input : ('invoke`debugger`with`user`test`case_.['token[T]]), output : nil,
                  tests : mtTestInfo, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o '\b 'No 'test 'cases. '\o '\n),
                  tests : mtTestInfo, AtS > .

  crl [invoke-debuger-invariant] :
      < O : DDDC | input : ('invoke`debugger`with`invariant_.['token[T]]), output : nil,
                   tests : (invariantTests : LTC, LTAS), module : M, correction : MM, tree : F,
                   select : B, currentSuspicious : QS, state : TS,
                   pattern : PAT, condition : C, solutionsPrioritized : SP,
                   currentTTW : CTTW, currentFS : BFS, currentTTM : CTT,
                   currentFinal : CFS, bound : BND, AtS >
   => < O : DDDC | input : nilTermList, output : QIL, tests : (invariantTests : LTC, LTAS),
                   module : M, correction : MM, tree : F', select : B,
                   currentSuspicious : QS', state : computing, pattern : PAT,
                   condition : C, solutionsPrioritized : SP, currentTTW : CTTW,
                   currentFS : BFS, currentTTM : CTT, currentFinal : CFS,
                   bound : BND, AtS >
   if N := downNat*(T) /\
      N' := testListSize(LTC) /\
      N <= N' /\
      < T1, T2, failureProp > := getNth(LTC, N) /\
      QS' := if B then QS else extractLabels(M) fi /\
      F' := createMissingTree(M, MM, T1, PAT, C, BND, 2, zeroOrMore, CTTW, CTT, QS', BFS, CFS, false, SP) /\
      QIL := ('\n '\b 'Declarative 'debugging 'started. '\o '\n) .

  crl [invoke-debuger-invariant-not-nat] :
      < O : DDDC | input : ('invoke`debugger`with`invariant_.['token[T]]), output : nil,
                   AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o '\b 'The 'argument 'must 'be
                                                  'a 'natural 'number '\o '\n), AtS >
   if not downNat*(T) :: Nat .

  crl [invoke-debuger-invariant-no-elem] :
      < O : DDDC | input : ('invoke`debugger`with`invariant_.['token[T]]), output : nil,
                   tests : (invariantTests : LTC, LTAS), AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o '\b 'There 'is 'not 'a 'test
                                                  'case 'with 'that 'index '\o '\n),
                   tests : (invariantTests : LTC, LTAS), AtS >
   if N := downNat*(T) /\
      N' := testListSize(LTC) /\
      N > N' .

  rl [invoke-debuger-invariant-no-tests] :
     < O : DDDC | input : ('invoke`debugger`with`invariant_.['token[T]]), output : nil,
                  tests : mtTestInfo, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o '\b 'No 'test 'cases. '\o '\n),
                  tests : mtTestInfo, AtS > .

  -----------------------------------------------------------------------------------------
  ------------------------------------ TEST SELECT ----------------------------------------
  -----------------------------------------------------------------------------------------

  rl [select-test-on] :
     < O : DDDC | input : ('set`test`select`on`..@Command@), testSelect : B,
                  output : nil, AtS >
  => < O : DDDC | input : nilTermList, testSelect : true,
                  output : ('\n '\b 'Select 'is 'on 'for 'test
                            'generation. '\o '\n), AtS > .

  rl [select-test-off] :
     < O : DDDC | input : ('set`test`select`off`..@Command@), testSelect : B,
                  output : nil, AtS >
  => < O : DDDC | input : nilTermList, testSelect : false,
                  output : ('\n '\b 'Select 'is 'off 'for 'test
                            'generation. '\o '\n), AtS > .

  -----------------------------------------------------------------------------------------
  --------------------------------- TEST SELECT/DESELECT ----------------------------------
  -----------------------------------------------------------------------------------------

  rl [select-test] :
      < O : DDDC | input : ('test-select_.['neTokenList[T]]), output : nil,
                   suspiciousTest : QS, testSelect : B, AtS >
   => < O : DDDC | input : nilTermList, output : (advisory-test-select(B)
                                                  includeMsgTest(list2set(downQidList(T)))),
                   suspiciousTest : (QS ; list2set(downQidList(T))), testSelect : B, AtS > .

  rl [deselect-test] :
      < O : DDDC | input : ('test-deselect_.['neTokenList[T]]), output : nil,
                   suspiciousTest : QS, testSelect : B, AtS >
   => < O : DDDC | input : nilTermList, output : (advisory-test-select(B)
                                                  excludeMsgTest(list2set(downQidList(T)))),
                   suspiciousTest : (QS \ list2set(downQidList(T))),
                   testSelect : B, AtS > .

  crl [test-include] :
      < O : DDDC | db : DB, input : ('test-include_.[T]), output : nil, testSelect : B,
                   suspiciousTest : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList,
                   output : (advisory-test-select(B) QIL includeMsgTest(QS')),
                   testSelect : B, suspiciousTest : (QS ; QS'), AtS >
   if < QS' : QIL > := procInclude(T, DB) .

  crl [test-exclude] :
      < O : DDDC | db : DB, input : ('test-exclude_.[T]), output : nil, testSelect : B,
                   suspiciousTest : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList, output : (advisory-test-select(B) QIL
                                                           excludeMsgTest(QS')),
                   testSelect : B,  suspiciousTest : (QS \ QS'), AtS >
   if < QS' : QIL > := procInclude(T, DB) .

  crl [test-include-eqs] :
      < O : DDDC | db : DB, input : ('test-include-eqs_.[T]), output : nil, testSelect : B,
                   suspiciousTest : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList,
                   output : (advisory-select(B) QIL includeMsgTest(QS')),
                   testSelect : B, suspiciousTest : (QS ; QS'), AtS >
   if < QS' : QIL > := procIncludeEqs(T, DB) .

  crl [test-exclude-eqs] :
      < O : DDDC | db : DB, input : ('test-exclude-eqs_.[T]), output : nil, testSelect : B,
                   suspiciousTest : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList, output : (advisory-select(B) QIL
                                                           excludeMsgTest(QS')),
                   testSelect : B,  suspiciousTest : (QS \ QS'), AtS >
   if < QS' : QIL > := procIncludeEqs(T, DB) .

  crl [test-include-mbs] :
      < O : DDDC | db : DB, input : ('test-include-mbs_.[T]), output : nil, testSelect : B,
                   suspiciousTest : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList,
                   output : (advisory-select(B) QIL includeMsgTest(QS')),
                   testSelect : B, suspiciousTest : (QS ; QS'), AtS >
   if < QS' : QIL > := procIncludeMbs(T, DB) .

  crl [test-exclude-mbs] :
      < O : DDDC | db : DB, input : ('test-exclude-mbs_.[T]), output : nil, testSelect : B,
                   suspiciousTest : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList, output : (advisory-select(B) QIL
                                                           excludeMsgTest(QS')),
                   testSelect : B,  suspiciousTest : (QS \ QS'), AtS >
   if < QS' : QIL > := procIncludeMbs(T, DB) .

  crl [test-include-rls] :
      < O : DDDC | db : DB, input : ('test-include-rls_.[T]), output : nil, testSelect : B,
                   suspiciousTest : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList,
                   output : (advisory-select(B) QIL includeMsgTest(QS')),
                   testSelect : B, suspiciousTest : (QS ; QS'), AtS >
   if < QS' : QIL > := procIncludeRls(T, DB) .

  crl [test-exclude-rls] :
      < O : DDDC | db : DB, input : ('test-exclude-rls_.[T]), output : nil, testSelect : B,
                   suspiciousTest : QS, AtS >
   => < O : DDDC | db : DB, input : nilTermList, output : (advisory-select(B) QIL
                                                           excludeMsgTest(QS')),
                   testSelect : B,  suspiciousTest : (QS \ QS'), AtS >
   if < QS' : QIL > := procIncludeRls(T, DB) .

  op includeMsgTest : QidSet -> QidList .
  eq includeMsgTest(none) = '\n '\b 'No 'labels 'have 'been 'added 'to 'the 'coverage. '\o '\n .
  eq includeMsgTest(QS) = '\n '\b 'Labels '\o set2list(QS) '\b 'have 'been 'added
                          'to 'the 'coverage. '\o '\n [owise] .

  op excludeMsgTest : QidSet -> QidList .
  eq excludeMsgTest(none) = '\n '\b 'No 'labels 'have 'been 'excluded 'from 'the 'coverage. '\o '\n .
  eq excludeMsgTest(QS) = '\n '\b 'Labels '\o set2list(QS) '\b 'have 'been 'excluded
                          'from 'the 'coverage. '\o '\n [owise] .

  -----------------------------------------------------------------------------------------
  ------------------------------ TEST FINAL SELECT/DESELECT -------------------------------
  -----------------------------------------------------------------------------------------

  crl [test-select-final] :
      < O : DDDC | input : ('sort`test`select_.[T]), output : nil,
                   testSelect : B, testSorts : QS, AtS >
   => < O : DDDC | input : nilTermList, testSelect : B,
                   output : (advisory-test-select(B) includeMsgSortTest(QS')),
                   testSorts : (QS ; QS'), AtS >
   if < QS' : nil > := procFinals(T) .

  crl [test-deselect-final] :
      < O : DDDC | input : ('sort`test`deselect_.[T]), output : nil,
                   testSelect : B, testSorts : QS, AtS >
   => < O : DDDC | input : nilTermList, testSelect : B,
                   output : (advisory-test-select(B) excludeMsgSortTest(QS')),
                   testSorts : (QS \ QS'), AtS >
   if < QS' : nil > := procFinals(T) .

  crl [test-select-final-error] :
      < O : DDDC | input : ('sort`test`select_.[T]), output : nil, testSelect : B, AtS >
   => < O : DDDC | input : nilTermList, output : (advisory-test-select(B) QIL),
                   testSelect : B, AtS >
   if < QS : QIL > := procFinals(T) /\
      QIL =/= nil .

  crl [test-deselect-final-error] :
      < O : DDDC | input : ('sort`test`deselect_.[T]), output : nil,
                   testSelect : B, AtS >
   => < O : DDDC | input : nilTermList, output : (advisory-test-select(B) QIL),
                   testSelect : B, AtS >
   if < QS : QIL > := procFinals(T) /\
      QIL =/= nil .

  op includeMsgSortTest : QidSet -> QidList .
  eq includeMsgSortTest(none) = '\n '\b 'No 'sorts 'have 'been 'added. '\o '\n .
  eq includeMsgSortTest(QS) = '\n '\b 'Sorts '\o printQidSet(QS) '\b
                              'will 'not 'be 'tested. '\o '\n [owise] .

  op excludeMsgSortTest : QidSet -> QidList .
  eq excludeMsgSortTest(none) = '\n '\b 'No 'sorts 'have 'been 'removed. '\o '\n .
  eq excludeMsgSortTest(QS) = '\n '\b 'Sorts '\o printQidSet(QS) '\b  'will 'be
                              'tested. '\o '\n [owise] .

  -----------------------------------------------------------------------------------------
  ------------------------------- TESTING CORRECT MODULE ----------------------------------
  -----------------------------------------------------------------------------------------

  crl [correct-test-module] :
      < O : DDDC | db : DB, input : ('correct`test`module_.[T]), output : nil,
                   correctionTest : MM, AtS >
   => if M? :: Module
      then < O : DDDC | db : DB, input : nilTermList, output : ('\n add-spaceR(printME(ME)) '\b
                                                        'selected 'as 'correct 'module
                                                        'for 'testing. '\o '\n),
                        correctionTest : M?, AtS >
      else < O : DDDC | db : DB, input : nilTermList, output : ('\n '\r 'Error: '\o getMsg(M?)),
                        correctionTest : MM, AtS >
      fi
   if ME := parseModExp(T) /\
      M? := if compiledModule(ME, DB)
            then getFlatModule(ME, DB)
            else getFlatModule(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB)))
            fi .

  crl [correct-test-module-error] :
      < O : DDDC | input : ('correct`test`module_.[T]), output : nil, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'Wrong
                                                  'module 'expression. '\n), AtS >
   if ME? := parseModExp(T) /\
      not (ME? :: ModuleExpression) .

  rl [delete-correct-test-module] :
     < O : DDDC | input : ('delete`correct`test`module`..@Command@), output : nil,
                  correctionTest : MM, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'Correct 'module 'for 'testing
                                                 'deleted. '\o '\n),
                  correctionTest : undefMod, AtS > .

  -----------------------------------------------------------------------------------------
  ---------------------------- UNIVERSAL DEBUGGING RELATION -------------------------------
  -----------------------------------------------------------------------------------------

   crl [deb-rel] :
       < O : DDDC | db : DB, input : ('debugging`relation`module_._enddr[T1, T2]), debRel : DR,
                    output : nil, AtS >
    => < O : DDDC | db : DB', input : nilTermList, debRel : DR',
                    output : ('\n '\b 'Correct 'module '\o '\n), AtS >
    if < DR', DB' > := solveBubbleDebRel(T1, T2, DB) /\
       DR' : DebRel .

   crl [deb-rel-error] :
       < O : DDDC | db : DB, input : ('debugging`relation`module_._enddr[T1, T2]), debRel : DR,
                    output : nil, AtS >
    => < O : DDDC | db : DB, input : nilTermList, debRel : DR,
                    output : ('\n '\r 'Error: '\b 'Wrong 'debugging
                              'relation. '\o '\n), AtS >
    if < errorDR, DB' > := solveBubbleDebRel(T1, T2, DB) .

  -----------------------------------------------------------------------------------------
  ---------------------------------- SEMANTICS TESTING ------------------------------------
  -----------------------------------------------------------------------------------------

   crl [semantics-mod] :
       < O : DDDC | db : DB, input : ('semantics`module_.[T]), semanticsModule : MM,
                    output : nil, AtS >
    => < O : DDDC | db : DB, input : nilTermList, semanticsModule : M?,
                    output : ('\n '\b 'Module '\o ME '\b 'selected 'for 'semantics
                              'testing. '\o '\n), AtS >
    if ME := parseModExp(T) /\
       M? := if compiledModule(ME, DB)
             then getFlatModule(ME, DB)
             else getFlatModule(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB)))
             fi .

  crl [semantics-mod-error] :
      < O : DDDC | input : ('semantics`module_.[T]), output : nil, AtS >
   => < O : DDDC | input : nilTermList, output : ('\n '\r 'Error: '\o 'Wrong
                                                  'module 'expression. '\n), AtS >
   if ME? := parseModExp(T) /\
      not (ME? :: ModuleExpression) .

  crl [semantics-sort] :
      < O : DDDC | input : ('set-sort-statements_.['token[T]]), semanticsModule : M,
                   semanticsModuleTransformed : MM, sortStatements : SS, output : nil,
                   ruleStatementRel : RSRS, AtS >
   => < O : DDDC | input : nilTermList, semanticsModule : M, semanticsModuleTransformed : M',
                   sortStatements : Q, ruleStatementRel : RSRS',
                   output : ('\n '\b 'Sort '\o Q '\b 'selected 'as 'sort 'of
                             'statements. '\o '\n), AtS >
   if Q := downQid(T) /\
      hasSort?(M, Q) /\
      M' := index(M, Q) /\
      RSRS' := computeRSR(M') .

  crl [semantics-sort-error1] :
      < O : DDDC | input : ('set-sort-statements_.['token[T]]), semanticsModule : M,
                   output : nil, AtS >
   => < O : DDDC | input : nilTermList, semanticsModule : M,
                   output : ('\n '\r 'Error: '\o '\b 'The 'module 'does 'not 'contain 'the
                             'sort Q '. '\o '\n), AtS >
   if Q := downQid(T) /\
      not hasSort?(M, Q) .

  rl [semantics-sort-error2] :
      < O : DDDC | input : ('set-sort-statements_.[T]), semanticsModule : undefMod,
                   output : nil, AtS >
   => < O : DDDC | input : nilTermList, semanticsModule : undefMod,
                   output : ('\n '\r 'Error: '\o '\b 'The 'module 'is 'not 'declared.
                             '\o '\n), AtS > .

  rl [show-applied-statements] :
     < O : DDDC | input : ('show-applied-statements`..@Command@), semanticsModuleTransformed : M,
                  ruleStatementRel : RSRS, output : nil, AtS >
  => < O : DDDC | input : nilTermList, semanticsModuleTransformed : M,
                  ruleStatementRel : RSRS,
                  output : printRuleStmntRelSet(M, RSRS), AtS > .

  rl [show-semantics-rules] :
     < O : DDDC | input : ('show-semantics-rules`..@Command@), semanticsModuleTransformed : M,
                  output : nil, AtS >
  => < O : DDDC | input : nilTermList, semanticsModuleTransformed : M,
                  output : printSemanticsRules(M), AtS > .

  rl [show-semantics-rules-error] :
     < O : DDDC | input : ('show-semantics-rules`..@Command@), semanticsModuleTransformed : M,
                  output : nil, AtS >
  => < O : DDDC | input : nilTermList, semanticsModuleTransformed : undefMod,
                  output : ('\n '\r 'Error: '\o '\b 'More 'parameters 'required.
                            '\o '\n), AtS > .

  crl [rule-no-statements] :
      < O : DDDC | input : ('rule_is`not`associated`to`any`statement`.['token[T]]),
                   ruleStatementRel : RSRS, output : nil, AtS >
   => < O : DDDC | input : nilTermList, ruleStatementRel : RSRS',
                   output : ('\n '\b 'The 'mapping 'for  'rule '\o Q '\b
                             'has 'been 'updated. '\o '\n), AtS >
   if Q := downQid(T) /\
      RSRS' := updateRSRS(RSRS, Q, empty) .

  crl [rule-statements] :
      < O : DDDC | input : ('rule_is`associated`to_.['token[T], 'neTokenList[T']]),
                   ruleStatementRel : RSRS, output : nil, AtS >
   => < O : DDDC | input : nilTermList, ruleStatementRel : RSRS',
                   output : ('\n '\b 'The 'mapping 'for  'rule '\o Q '\b
                             'has 'been 'updated. '\o '\n), AtS >
   if Q := downQid(T) /\
      QIL := downQidList(T') /\
      TL := putSortNat(QIL) /\
      RSRS' := updateRSRS(RSRS, Q, TL) .

  crl [object-program] :
      < O : DDDC | db : DB, input : ('object`program_.['bubble['__[TL]]]),
                   semanticsModuleTransformed : M, objectProgram : MT,
                   statementsInCoverage : NL, sortStatements : S, output : nil, AtS >
   => < O : DDDC | db : DB, input : nilTermList, semanticsModuleTransformed : M,
                   objectProgram : T', statementsInCoverage : NL', sortStatements : S,
                   output : ('\n '\b 'Object 'program 'introduced. '\o '\n), AtS >
   if ME := getName(M) /\
      QIL := downQidList('__[TL]) /\
      T := getTerm(metaParse(M, QIL, anyType)) /\
      T' := fst(index(M, S, reduce(M, T))) /\
      NL' := getCoverage(T') .

  crl [object-program] :
      < O : DDDC | db : DB, input : ('object`program_.['bubble[T]]),
                   semanticsModuleTransformed : M, objectProgram : MT,
                   statementsInCoverage : NL, sortStatements : S, output : nil, AtS >
   => < O : DDDC | db : DB, input : nilTermList, semanticsModuleTransformed : M,
                   objectProgram : T'', statementsInCoverage : NL', sortStatements : S,
                   output : ('\n '\b 'Object 'program 'introduced. '\o '\n), AtS >
   if ME := getName(M) /\
      QIL := downQid(T) /\
      T' := getTerm(metaParse(M, QIL, anyType)) /\
      T'' := fst(index(M, S, reduce(M, T'))) /\
      NL' := getCoverage(T') .

  rl [object-program-error1] :
     < O : DDDC | input : ('object`program_.[T]),
                  semanticsModuleTransformed : undefMod, output : nil, AtS >
  => < O : DDDC | input : nilTermList, semanticsModuleTransformed : undefMod,
                  output : ('\n '\r 'Error: '\o '\b 'The 'module 'is 'not 'declared.
                            '\o '\n), AtS > .

  rl [object-program-error2] :
     < O : DDDC | input : ('object`program_.[T]),
                  sortStatements : none, output : nil, AtS >
  => < O : DDDC | input : nilTermList, sortStatements : none,
                  output : ('\n '\r 'Error: '\o '\b 'The 'sort 'of 'statements
                            'is 'not 'declared. '\o '\n), AtS > .

  *** Error cuando hay de todo pero no hacer parse

  rl [show-object-program] :
     < O : DDDC | input : ('show`object`program`..@Command@),
                  semanticsModuleTransformed : M, objectProgram : T, output : nil, AtS >
  => < O : DDDC | input : nilTermList, objectProgram : T,
                  semanticsModuleTransformed : M,
                  output : ('\n metaPrettyPrint(M, T) '\n), AtS > .

  rl [show-object-program-error1] :
     < O : DDDC | input : ('show`object`program`..@Command@),
                  objectProgram : maybe, output : nil, AtS >
  => < O : DDDC | input : nilTermList, objectProgram : maybe,
                  output : ('\n '\r 'Error: '\o '\b 'The 'object 'program
                            'has 'not 'been 'introduced 'yet. '\o '\n), AtS > .

  rl [show-object-program-error2] :
     < O : DDDC | input : ('show`object`program`..@Command@),
                  semanticsModuleTransformed : undefMod, output : nil, AtS >
  => < O : DDDC | input : nilTermList, semanticsModuleTransformed : undefMod,
                  output : ('\n '\r 'Error: '\o '\b 'The 'module
                            'has 'not 'been 'selected 'yet. '\o '\n), AtS > .

  crl [customize-coverage] :
      < O : DDDC | input : ('statements`in`coverage_.['neTokenList[T]]),
                   statementsInCoverage : NL, output : nil, AtS >
   => < O : DDDC | input : nilTermList, statementsInCoverage : NL',
                   output : ('\n '\b 'The 'required 'coverage
                             'has 'been 'updated. '\o '\n), AtS >
   if QIL := downQidList(T) /\
      NL' := qidList2NatList(QIL) .

  crl [customize-coverage-error] :
      < O : DDDC | input : ('statements`in`coverage_.['neTokenList[T]]),
                   output : nil, AtS >
   => < O : DDDC | input : nilTermList,
                   output : ('\n '\r 'Error: '\o '\b 'Use 'natural 'numbers.
                             '\o '\n), AtS >
   if QIL := downQidList(T) /\
      not qidList2NatList(QIL) :: NatList .

  -----------------------------------------------------------------------------------------
  ------------------------------- DEBUGGING USING SEMANTICS -------------------------------
  -----------------------------------------------------------------------------------------

  crl [debug-big-step-semantics] :
      < O : DDDC | db : DB, input : ('debug-big-step-semantics_=>_.['bubble[T], 'bubble[T']]),
                   output : nil, default : ME, tree : F, module : MM, correction : MM',
                   previousStates : LS, answers : LA, state : TS, treeType : TT,
                   currentTTW : CTTW, bound : BND, select : B, suspicious : QS,
                   currentSuspicious : QS', intended : SDDIS, strategy : STRAT, AtS >
   => < O : DDDC | db : DB', input : nilTermList, output : nil, default : ME, tree : PT',
                   module : M, correction : MM', previousStates : nil, answers : nil,
                   state : computing, treeType : TT, currentTTW : TT, bound : BND, select : B,
                   suspicious : QS, currentSuspicious : QS'', intended : SDDIS,
                   strategy : ss, AtS >
   if DB' := if compiledModule(ME, DB)
             then DB
             else database(evalModExp(ME, DB))
             fi /\
      M := getFlatModule(ME, DB') /\
      QIL1 := getQIL(T) /\
      QIL2 := getQIL(T') /\
      T1 := getTerm(metaParse(M, QIL1, anyType)) /\
      T2 := getTerm(metaParse(M, QIL2, anyType)) /\
      TN := normal(M, T1) /\
      TN' := normal(M, T2) /\
      QS'' := if B then QS else extractLabels(M) fi /\
      PT := createRewTree(labeling(M), MM', TN, TN', QS'', TT, BND) /\
      PT' := keep-intended(M, reduceSubtermsBigStep(M, PT), SDDIS) .

  crl [debug-small-step-semantics] :
      < O : DDDC | db : DB, input : ('debug-small-step-semantics_=>_.['bubble[T], 'bubble[T']]),
                   output : nil, default : ME, tree : F, module : MM, correction : MM',
                   previousStates : LS, answers : LA, state : TS, treeType : TT,
                   currentTTW : CTTW, bound : BND, select : B, suspicious : QS,
                   currentSuspicious : QS', intended : SDDIS, strategy : STRAT,
                   transitivityRules : TR, AtS >
   => < O : DDDC | db : DB', input : nilTermList, output : nil, default : ME, tree : PT',
                   module : M, correction : MM', previousStates : nil, answers : nil,
                   state : computing, treeType : TT, currentTTW : TT, bound : BND, select : B,
                   suspicious : QS, currentSuspicious : QS'', intended : SDDIS,
                   strategy : STRAT, transitivityRules : TR, AtS >
   if DB' := if compiledModule(ME, DB)
             then DB
             else database(evalModExp(ME, DB))
             fi /\
      M := getFlatModule(ME, DB') /\
      QIL1 := getQIL(T) /\
      QIL2 := getQIL(T') /\
      T1 := getTerm(metaParse(M, QIL1, anyType)) /\
      T2 := getTerm(metaParse(M, QIL2, anyType)) /\
      TN := normal(M, T1) /\
      TN' := normal(M, T2) /\
      QS'' := if B then QS else extractLabels(M) fi /\
      PT := createRewTree(labeling(M), MM', TN, TN', QS'', TT, BND) /\
      *** PT' := smallStepTransformation(M, PT, SDDIS, TR) .
      PT' := sstrans(M, MM', QS'', TT, BND, PT, SDDIS, TR) .

  crl [introduce-intended] :
      < O : DDDC | db : DB, input : ('intended`semantics_.['token[T]]),
                   output : nil, default : ME, intended : SDDIS, AtS >
   => < O : DDDC | db : DB', input : nilTermList, output : QIL,
                   default : ME, intended : SDDIS sdd(Q, maybe), AtS >
   if DB' := if compiledModule(ME, DB)
             then DB
             else database(evalModExp(ME, DB))
             fi /\
      M := getFlatModule(ME, DB') /\
      Q := downQid(T) /\
      ruleExists(M, Q) /\
      QIL := '\n '\b 'The 'rule '\o Q '\b 'has 'been
             'added 'to 'the 'intended 'semantics. '\o '\n .

  crl [introduce-intended-error-label] :
      < O : DDDC | db : DB, input : ('intended`semantics_.['token[T]]),
                   output : nil, default : ME, AtS >
   => < O : DDDC | db : DB, input : nilTermList, output : QIL,
                   default : ME, AtS >
   if DB' := if compiledModule(ME, DB)
             then DB
             else database(evalModExp(ME, DB))
             fi /\
      M := getFlatModule(ME, DB') /\
      Q := downQid(T) /\
      not ruleExists(M, Q) /\
      QIL := '\n '\b 'The 'rule '\o Q '\b 'does 'not 'exist. '\o '\n .

  crl [introduce-intended-culprit] :
      < O : DDDC | db : DB, input : ('intended`semantics_culprit_.['token[T],'bubble[T']]),
                   output : nil, default : ME, intended : SDDIS, AtS >
   => < O : DDDC | db : DB', input : nilTermList, output : QIL,
                   default : ME, intended : SDDIS sdd(Q, T2), AtS >
   if DB' := if compiledModule(ME, DB)
             then DB
             else database(evalModExp(ME, DB))
             fi /\
      M := getFlatModule(ME, DB') /\
      Q := downQid(T) /\
      ruleExists(M, Q) /\
      QIL2 := getQIL(T') /\
      T2 := getTerm(metaParse(M, QIL2, anyType)) /\
      QIL := '\n '\b 'The 'rule '\o Q '\b 'has 'been
             'added 'to 'the 'intended 'semantics. '\o
             '\n '\b 'If 'buggy '`, ' 'the '\o metaPrettyPrint(M, T2) '\b
             'in 'the 'lefthand 'side 'will 'be 'pointed 'out 'as 'erroneous.
             '\o '\n .

  crl [introduce-intended-culprit-error-label] :
      < O : DDDC | db : DB, input : ('intended`semantics_culprit_.['token[T], T']),
                   output : nil, default : ME, AtS >
   => < O : DDDC | db : DB', input : nilTermList, output : QIL,
                   default : ME, AtS >
   if DB' := if compiledModule(ME, DB)
             then DB
             else database(evalModExp(ME, DB))
             fi /\
      M := getFlatModule(ME, DB') /\
      Q := downQid(T) /\
      not ruleExists(M, Q) /\
      QIL := '\n '\b 'The 'rule '\o Q '\b 'does 'not 'exist. '\o '\n .

  crl [introduce-intended-culprit-error-term-parsing] :
      < O : DDDC | db : DB, input : ('intended`semantics_culprit_.['token[T],'bubble[T']]),
                   output : nil, default : ME, AtS >
   => < O : DDDC | db : DB', input : nilTermList, output : QIL,
                   default : ME, AtS >
   if DB' := if compiledModule(ME, DB)
             then DB
             else database(evalModExp(ME, DB))
             fi /\
      M := getFlatModule(ME, DB') /\
      QIL2 := getQIL(T') /\
      not (metaParse(M, QIL2, anyType) :: ResultPair) /\
      QIL := ('\n '\r 'Error: '\o '\b 'No 'parse 'for 'the 'second 'term. '\o '\n) .

  rl [initialize-intended] :
     < O : DDDC | input : ('initialize`intended`semantics`..@Command@),
                  output : nil, intended : SDDIS, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'The 'intended 'semantics 'is 'now
                                                 'empty. '\o '\n), intended : mtSDDIS, AtS > .

  rl [initialize-transitivity-rules] :
     < O : DDDC | input : ('initialize`transitivity`rules`..@Command@),
                  output : nil, transitivityRules : QS, AtS >
  => < O : DDDC | input : nilTermList, output : ('\n '\b 'The 'set 'of 'transitivity
                              'rules 'is 'now 'empty. '\o '\n),
                  transitivityRules : none, AtS > .

  crl [add-transitivity-rules] :
      < O : DDDC | input : ('transitivity`rules_.['neTokenList[T]]), output : nil,
                   transitivityRules : QS, AtS >
   => < O : DDDC | input : nilTermList, output : QIL,
                   transitivityRules : (QS ; list2set(downQidList(T))), AtS >
   if QIL := '\n '\b 'The 'rules '\o downQidList(T) '\b 'have 'been 'introduced
             'as 'rules 'for 'transitivity. '\o '\n .

  -----------------------------------------------------------------------------------------
  ---------------------------------- SPECIAL FEATURES -------------------------------------
  -----------------------------------------------------------------------------------------

  rl [yeah] :
     < O : DDDC | input : ('yeah!`..@Command@), AtS >
  => < O : DDDC | input : ('yes`..@Command@), AtS > .

  rl [never] :
     < O : DDDC | input : ('never!`..@Command@), AtS >
  => < O : DDDC | input : ('no`..@Command@), AtS > .

  rl [who-knows] :
     < O : DDDC | input : ('who`knows`..@Command@), AtS >
  => < O : DDDC | input : ('don't`know`..@Command@), AtS > .

  -----------------------------------------------------------------------------------------
  --------------------------------- AUXILIARY FUNCTIONS -----------------------------------
  -----------------------------------------------------------------------------------------

  op removeChild : Tree Nat ~> Tree .
  op removeChild* : Forest Nat ~> Forest .

  ceq removeChild(tree(J, N, F), N') = tree(J, s(N''), F')
   if F' := removeChild*(F, N') /\
      N'' := getOffspring*(F') .

  eq removeChild*(tree(unknown, N, F) F', N') = tree(unknown, N, F) removeChild*(F', N') .
  eq removeChild*(PT F, 1) = F [owise] .
  eq removeChild*(PT F, s(s(N))) = PT removeChild*(F, s(N)) [owise] .

  op debugFinished? : Tree -> Bool .
  eq debugFinished?(tree(J, 1, F)) = true .
  eq debugFinished?(tree(T =>+ T', 2, PT)) = not hasOffspring?(PT, nil) .
  eq debugFinished?(tree('root@#$% : T -> T', 2, PT)) = not hasOffspring?(PT, nil) .
  eq debugFinished?(tree('root@#$% : T : S, 2, PT)) = not hasOffspring?(PT, nil) .
  eq debugFinished?(tree(T =>1 {TL}, 1, mtForest)) = true .
  eq debugFinished?(PT) = false [owise] .

  op expand : Module Maybe{Module} Tree QidSet Bound -> Forest .

  ceq expand(M, MM, tree(T =>+ T', N, PT PT'), QS, BND) =
                     tree(T =>+ T', getOffspring*(F F') + 1, F F')
   if F := expand(M, MM, PT, QS, BND) /\
      F' := expand(M, MM, PT', QS, BND) .
  eq expand(M, MM, tree(T =>f T', 1, mtForest), QS, BND) =
                     manyStepsTree2(M, deleteSuspicious(M, QS), MM, T, T', QS, BND) .
  eq expand(M, MM, PT, QS, BND) = PT [owise] .

  op getResult : Tree -> Tree .
  eq getResult(tree(J, 2, PT)) = PT .
  eq getResult(PT) = PT [owise] .

  op nextTreeDQ : Tree NatList List{Answer} -> ForestColor .
  eq nextTreeDQ(PT, nil, LA) = < PT, nil > .
  ceq nextTreeDQ(PT, NL, LA) = nextTreeDQ(PT', NL', LA)
   if NL =/= nil /\
      tree(J, N, F) := getSubTree(PT, NL) /\
      unknown?(J, LA) /\
      PT' := setUnknown(PT, NL) /\
      NL' := searchBestNode(PT') .
  ceq nextTreeDQ(PT, NL, LA) = nextTreeDQ(PT', NL', LA)
   if NL =/= nil /\
      tree(J, N, F) := getSubTree(PT, NL) /\
      right?(J, LA) /\
      PT' := deleteSubTree(PT, NL) /\
      NL' := searchBestNode(PT') .
  eq nextTreeDQ(PT, NL, LA) = < PT, NL > [owise] .

  op anotherTreeNeeded? : Tree -> Bool .
  eq anotherTreeNeeded?(tree(T =>+ T', N, PT PT')) = frozen?(PT) or-else frozen?(PT') .
  eq anotherTreeNeeded?(tree(sol(T, T', C, B, false, true), N, F)) = true .
  eq anotherTreeNeeded?(PT) = false [owise] .

  op frozen? : Tree -> Bool .
  eq frozen?(tree(T =>f T', N, F)) = true .
  eq frozen?(PT) = false [owise] .

  op getAnswer : Tree Result -> Answer .
  eq getAnswer(tree(Q : T -> T', N, F), R) = < T, T', R > .
  eq getAnswer(tree(Q : T : S, N, F), R) = < T, S, R > .
  eq getAnswer(tree(Q : T =>1 T', N, F), R) = < T, T', R > .
  eq getAnswer(tree(T =>+ T', N, F), R) = < T, T', R > .
  eq getAnswer(tree(T =>1 {TL}, N, F), R) = < T, TL, R > .
  eq getAnswer(tree(T ~>[BND] {TL} s.t. PAT & C [FST], N, F), R) = < T, TL, R > .

  op unknown? : Judgment List{Answer} -> Bool .
  eq unknown?(J, nil) = false .
  eq unknown?(Q : T -> T', < T, T', unknown > LA) = true .
  eq unknown?(Q : T =>1 T', < T, T', unknown > LA) = true .
  eq unknown?(T =>+ T', < T, T', unknown > LA) = true .
  eq unknown?(Q : T : S, < T, S, unknown > LA) = true .
  eq unknown?(T ~>[BND] {TL} s.t. PAT & C [FST], < T, TL, unknown > LA) = true .
  eq unknown?(T =>1 {TL}, < T, TL, unknown > LA) = true .
  eq unknown?(J, A LA) = unknown?(J, LA) [owise] .

  op allChildUnknown : Tree -> Bool .
  eq allChildUnknown(tree(J, N, F)) = F =/= mtForest and-then allChildUnknown*(F) .

  op allChildUnknown* : Forest -> Bool .
  eq allChildUnknown*(mtForest) = true .
  eq allChildUnknown*(tree(unknown, N, F) F') = allChildUnknown*(F') .
  eq allChildUnknown*(PT F) = false [owise] .

  op removeChildrenNotUnknown : Tree -> Tree .
  ceq removeChildrenNotUnknown(tree(J, N, F)) = tree(J, s(N'), F')
   if F' := removeChildrenNotUnknown*(F) /\
      N' := getOffspring*(F') .

  op removeChildrenNotUnknown* : Forest -> Forest .
  eq removeChildrenNotUnknown*(mtForest) = mtForest .
  eq removeChildrenNotUnknown*(tree(unknown, N, F) F') = tree(unknown, N, F)
                                                         removeChildrenNotUnknown*(F') .
  eq removeChildrenNotUnknown*(PT F) = removeChildrenNotUnknown*(F) [owise] .

  op right? : Judgment List{Answer} -> Bool .
  eq right?(J, nil) = false .
  eq right?(Q : T -> T', < T, T', right > LA) = true .
  eq right?(Q : T =>1 T', < T, T', right > LA) = true .
  eq right?(T =>+ T', < T, T', right > LA) = true .
  eq right?(Q : T : S, < T, S, right > LA) = true .
  eq right?(T ~>[BND] {TL} s.t. PAT & C [FST], < T, TL, right > LA) = true .
  eq right?(T =>1 {TL}, < T, TL, right > LA) = true .
  eq right?(J, A LA) = right?(J, LA) [owise] .

  op sol? : Tree -> Bool .
  eq sol?(tree(sol(T, T', C, B, false, FST), N, F)) = true .
  eq sol?(PT) = false [owise] .

  op finalQuestion? : Judgment -> Bool .
  eq finalQuestion?(T =>1 {empty}) = true .
  eq finalQuestion?(J) = false [owise] .

  op downBound : Term -> [Bound] .
  ceq downBound(T) = N
   if N := downNat*(T) .
  ceq downBound(T) = unbounded
   if 'unbounded := downQid(T) .

  op sizeNotUnknown : Forest -> Nat .
  eq sizeNotUnknown(mtForest) = 0 .
  eq sizeNotUnknown(tree(unknown, N, F) F') = sizeNotUnknown(F') .
  eq sizeNotUnknown(PT F) = s(sizeNotUnknown(F)) .

  op getNth : List{TestCase} Nat ~> TestCase .
  eq getNth(TC LTC, 1) = TC .
  eq getNth(TC LTC, s(s(N))) = getNth(LTC, s(N)) .

  op getNth : List{TestCase} Nat TestStatus ~> TestCase .
  eq getNth(< T, T', TSt > LTC, 1, TSt) = < T, T', TSt > .
  eq getNth(< T, T', TSt > LTC, s(s(N)), TSt) = getNth(LTC, s(N), TSt) .
  eq getNth(TC LTC, N) = getNth(LTC, N) [owise] .

  op hasSort? : Module Sort -> Bool .
  ceq hasSort?(M, S) = true
   if S ; SS := getSorts(M) .
  eq hasSort?(M, S) = false [owise] .

  op putSortNat : QidList -> TermList .
  eq putSortNat(nil) = empty .
  eq putSortNat(Q QIL) = qid(string(Q) + ":Nat"), putSortNat(QIL) .

  op qidList2NatList : QidList -> NatList .
  eq qidList2NatList(nil) = nil .
  eq qidList2NatList(Q QIL) = rat(string(Q), 10) qidList2NatList(QIL) .

  op getCoverage : Term -> NatList .
  eq getCoverage(V) = nil .
  eq getCoverage(CONST) = nil .
  eq getCoverage('stmntIndx[T, T']) = getCoverage(T) downTerm(T', 0) .
  eq getCoverage(Q[TL]) = getCoverage*(TL) [owise] .

  op getCoverage* : TermList -> NatList .
  eq getCoverage*(empty) = nil .
  eq getCoverage*((T, TL)) = getCoverage(T) getCoverage*(TL) .

  op getQIL : Term -> QidList .
  eq getQIL('__[TL]) = downQidList(TL) .
  eq getQIL(T) = downQidList(T) [owise] .

  op ruleExists : Module Qid -> Bool .
  eq ruleExists(M, Q) = ruleExists(getRls(M), Q) .

  op ruleExists : RuleSet Qid -> Bool .
  eq ruleExists(rl T => T' [label(Q) Attr] . RS, Q) = true .
  eq ruleExists(crl T => T' if C [label(Q) Attr] . RS, Q) = true .
  eq ruleExists(RS, Q) = false [owise] .


  op getLHS : Module Qid ~> Term .
  eq getLHS(M, Q) = getLHS(getRls(M), Q) .

  op getLHS : RuleSet Qid ~> Term .
  eq getLHS(rl T => T' [label(Q) Attr] . RS, Q) = T .
  eq getLHS(crl T => T' if C [label(Q) Attr] . RS, Q) = T .

  -----------------------------------------------------------------------------------------
  ----------------------------------- CONNECTION C++ --------------------------------------
  -----------------------------------------------------------------------------------------

  crl [isabel-test] :
      < O : DDDC | db : DB, input : ('isabel-test_.['token[T]]), output : nil,
                   default : ME, testBound : TB, termsTable : TermT, seed : SEED,
                   currentFunction : CF, AtS >
   => < O : DDDC | db : DB, input : nilTermList, output : QIL, default : ME,
                   testBound : TB, termsTable : TermT', seed : SEED,
                   currentFunction : Q, AtS >
   if Q := downQid(T) /\
      M := if compiledModule(ME, DB)
           then getFlatModule(ME, DB)
           else getFlatModule(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB)))
           fi /\
      << QIL, TermT' >> := generateIsabelTestCases(M, Q, TB, SEED) .

  crl [isabel-next] :
      < O : DDDC | db : DB, input : ('isabel-next`..@Command@), output : nil,
                   default : ME, testBound : TB, termsTable : TermT, seed : SEED,
                   currentFunction : Q, AtS >
   => < O : DDDC | db : DB, input : nilTermList, output : QIL, default : ME,
                   testBound : TB, termsTable : TermT', seed : SEED,
                   currentFunction : Q, AtS >
   if M := if compiledModule(ME, DB)
           then getFlatModule(ME, DB)
           else getFlatModule(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB)))
           fi /\
      << QIL, TermT' >> := generateIsabelTestCases(M, Q, TB, SEED, TermT) .

***(%
\end{verbatim}
}

\end{comment}

{\codesize
\begin{verbatim}
  ...

%)

 endm

***(%
\end{verbatim}
}

The module \texttt{DD} manages the introduction of data by the user and the
output of the debugger's answers. Full Maude uses the input/output
facility provided by the \texttt{LOOP-MODE} module \cite[Chapter 17]{maude-book},
that consists of an operator \verb"[_,_,_]"
with an input stream (the first argument), an output stream (the third
argument), and a state (given by its second argument):

{\codesize
\begin{verbatim}
%)

 mod DD is
  inc DD-DATABASE-HANDLING .
  inc LOOP-PRE-PROCESSING .
  inc META-DD-SIGN .
  inc LOOP-MODE .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  var  QI : Qid .
  vars QIL QIL' QIL'' : QidList .
  var  Atts : AttributeSet .
  var  N : Nat .
  var  DB : Database .
  vars RP RP' : ResultPair .
  var  O : Oid .
  var  DDDC : DDDatabaseClass .
  var  X@Database : DatabaseClass .

***(%
\end{verbatim}
}

\end{comment}

{\codesize
\begin{verbatim}
%)

  op o : -> Oid .

  --- State for LOOP mode:
  subsort Object < State .
  op init-debug : -> System .

  rl [init] :
     init-debug
  => [nil, < o : DDDatabase | input : nilTermList, output : nil,
                              initCafeAttS, init-state >, dd-banner] .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  -----------------------------------------------------------------------------------------
  ---------------------------------------- IN ---------------------------------------------
  -----------------------------------------------------------------------------------------

  eq ['debug 'select QIL, S:State, QIL'] = ['debug-select QIL, S:State, QIL'] .
  eq ['debug 'deselect QIL, S:State, QIL'] = ['debug-deselect QIL, S:State, QIL'] .
  eq ['debug 'include 'eqs QIL, S:State, QIL'] = ['debug-include-eqs QIL, S:State, QIL'] .
  eq ['debug 'exclude 'eqs QIL, S:State, QIL'] = ['debug-exclude-eqs QIL, S:State, QIL'] .
  eq ['debug 'include 'mbs QIL, S:State, QIL'] = ['debug-include-mbs QIL, S:State, QIL'] .
  eq ['debug 'exclude 'mbs QIL, S:State, QIL'] = ['debug-exclude-mbs QIL, S:State, QIL'] .
  eq ['debug 'include 'rls QIL, S:State, QIL'] = ['debug-include-rls QIL, S:State, QIL'] .
  eq ['debug 'exclude 'rls QIL, S:State, QIL'] = ['debug-exclude-rls QIL, S:State, QIL'] .
  eq ['debug 'include QIL, S:State, QIL'] = ['debug-include QIL, S:State, QIL'] [owise] .
  eq ['debug 'exclude QIL, S:State, QIL'] = ['debug-exclude QIL, S:State, QIL'] [owise] .
  eq ['test 'select QIL, S:State, QIL'] = ['test-select QIL, S:State, QIL'] .
  eq ['test 'deselect QIL, S:State, QIL'] = ['test-deselect QIL, S:State, QIL'] .
  eq ['test 'include 'eqs QIL, S:State, QIL'] = ['test-include-eqs QIL, S:State, QIL'] .
  eq ['test 'exclude 'eqs QIL, S:State, QIL'] = ['test-exclude-eqs QIL, S:State, QIL'] .
  eq ['test 'include 'mbs QIL, S:State, QIL'] = ['test-include-mbs QIL, S:State, QIL'] .
  eq ['test 'exclude 'mbs QIL, S:State, QIL'] = ['test-exclude-mbs QIL, S:State, QIL'] .
  eq ['test 'include 'rls QIL, S:State, QIL'] = ['test-include-rls QIL, S:State, QIL'] .
  eq ['test 'exclude 'rls QIL, S:State, QIL'] = ['test-exclude-rls QIL, S:State, QIL'] .
  eq ['test 'sort QIL, S:State, QIL'] = ['test-sort QIL, S:State, QIL'] .
  eq ['test 'include QIL, S:State, QIL'] = ['test-include QIL, S:State, QIL'] [owise] .
  eq ['test 'exclude QIL, S:State, QIL'] = ['test-exclude QIL, S:State, QIL'] [owise] .
  eq ['all ': 'yes '. QIL, S:State, QIL'] = ['all`:`yes`. QIL, S:State, QIL'] .
  eq ['set 'sort 'statements QIL, S:State, QIL'] = ['set-sort-statements QIL, S:State, QIL'] .
  eq ['show 'applied 'statements QIL, S:State, QIL'] = ['show-applied-statements QIL, S:State, QIL'] .
  eq ['show 'semantics 'rules QIL, S:State, QIL'] = ['show-semantics-rules QIL, S:State, QIL'] .
  eq ['debug 'big 'step 'semantics QIL, S:State, QIL'] = ['debug-big-step-semantics QIL, S:State, QIL'] .
  eq ['debug 'small 'step 'semantics QIL, S:State, QIL'] = ['debug-small-step-semantics QIL, S:State, QIL'] .

***(%
\end{verbatim}
}

\end{comment}

The rule \texttt{in} below parses the data introduced by the user, that
appears in the first argument of the loop, in the module \texttt{DD-GRAMMAR}
and introduces it in the \texttt{input} attribute if it is correctly built:

{\codesize
\begin{verbatim}
%)

  crl [in] :
      [QIL, < O : X@Database | input : nilTermList, Atts >, QIL']
   => [nil,
       < O : X@Database | input : getTerm(metaParse(DD-GRAMMAR, QIL, '@Input@)), Atts >,
       QIL']
   if QIL =/= nil /\
      metaParse(DD-GRAMMAR, QIL, '@Input@) : ResultPair .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

  crl [in] :
      [QIL, < O : X@Database | output : nil, Atts >, QIL']
   => [nil,
       < O : X@Database | output : ('\r 'Warning: '\o
                 printSyntaxError(metaParse(DD-GRAMMAR, QIL, '@Input@), QIL)
                 '\n
                 '\r 'Error: '\o 'No 'parse 'for 'input. '\n), Atts >,
       QIL']
   if QIL =/= nil /\
      noParse(N) := metaParse(DD-GRAMMAR, QIL, '@Input@)  .

  crl [in] :
      [QIL, < O : X@Database | output : nil, Atts >, QIL']
   => [nil,
       < O : X@Database | output :  ('\r 'Error: '\o 'Ambiguous 'input. '\n), Atts >,
       QIL']
    if QIL =/= nil /\
       ambiguity(RP, RP') := metaParse(DD-GRAMMAR, QIL, '@Input@)  .

***(%
\end{verbatim}
}

\end{comment}

The rule \texttt{out} is in charge of printing the messages from the debugger
by moving the data in the \texttt{output} attribute to the third component
of the loop:

{\codesize
\begin{verbatim}
%)

  rl [out] :
     [QIL, < O : X@Database | output : (QI QIL'), Atts >, QIL'']
  => [QIL, < O : X@Database | output : nil, Atts >, (QIL'' QI QIL')] .
 endm

***(%
\end{verbatim}
}

The command \texttt{loop init-debug} initializes the state of the loop:

{\codesize
\begin{verbatim}
%)

loop init-debug .

***(%
\end{verbatim}
}

\begin{comment}

{\codesize
\begin{verbatim}
%)

set print conceal on .
print conceal mod_is_sorts_._____endm .
print conceal fmod_is_sorts_.____endfm .
print conceal db .
print conceal answers`:_ .
print conceal previousStates`:_ .
print conceal tests`:_ .
print conceal termsTable`:_ .

set show advisories off .
set show loop stats off .
set show loop timing off .

***(%
\end{verbatim}
}

\end{comment}
%)