load predefined_core.maude
load parameter_config.maude
load citp_aux.maude
load cimpg_defs.maude
load module_parsing.maude


***(%

The module \verb"CafePARSER" is in charge of parsing complete modules and views:

{\codesize
\begin{verbatim}
%)

load search_predicate.maude

mod CafePARSER is
  inc CafeDECL-PARSING .
  pr DATABASE-HANDLING .
  pr SEARCH_PREDICATE .
  pr PARAMETER-CONFIG .
  pr CITP-AUX .

***(%
\end{verbatim}
}

It builds a new term of sort \verb"CafeParseResult" returning the updated database and
a list of quoted identifiers reporting the errors found during the parsing process:

{\codesize
\begin{verbatim}
%)

  op <_,_> : Database QidList -> CafeParseResult [ctor] .
  op <_,_,_,_> : Database SortMap TheorySortMap QidList -> CafeParseResult [ctor] .

***(%
\end{verbatim}
}

% We also define other constructor for \verb"CafeParseResult", that will be
% used in open-close environments. Since these environments do not change the
% database, it is composed of a list of quoted identifiers pointing out the
% errors found during the parsing, and another list showing the results of the
% reduction commands:

{\codesize
\begin{comment}
%)

  op <_|_|_|_> : Database ScoreInfoMap QidList QidList -> CafeParseResult [ctor] .

***(%
\end{comment}
}

{\codesize
\begin{comment}
%)

  vars U3 U4 U5 TM TM' FM FM' PU PU' U U' U'' M M' M'' M''' M1 M2 M3 : Module .
  vars STR STR' S S' S'' S''' St St' St'' St''' : String .
  vars T T' T'' T''' T1 T2 T3 T4 T5 T6 T7 TP TI : Term .
  vars TL TL' TL'' PL PL' TLR TL1 TL2 TL3 : TermList .
  vars PrL PrL' PrL'' PrL1 PrL2 : ProofTreeList .
  vars SIS SIS' SIS1 SIS2 : ScoreInfoSet .
  vars TSM TSM' HSM HSM' : TheorySortMap .
  vars QIL QIL' QIL'' QILR : QidList .
  var  T? : [Term] .
  vars V V' : Variable .
  vars C C' : Constant .
  vars DB DB' : Database .
  *** TN: TheoryName
  vars F Q Q' Q'' QI QI' TN ID CMD : Qid .
  *** TS: TheorySort
  var  TS : Sort .
  vars CafeM CafeM' : CafeModule .
  var  VDS : OpDeclSet .
  vars PDR PDR' : ParseDeclResult .
  vars Ty Ty1 Ty2 : Type .
  vars N N' N'' INDENT : Nat .
  **** PSM: Principal Sort Map
  vars PSM PSM' SM SM' : SortMap .
  vars QS QS' : QidSet .
  vars MACS MACS' : Macros .
  var  H : Header .
  var  I : Import .
  vars IL IL' : ImportList .
  var  Srt : Sort .
  vars SS SS' : SortSet .
  var  SSDS : SubsortDeclSet .
  vars ODS ODS' : OpDeclSet .
  var  OD : OpDecl .
  var  MAS : MembAxSet .
  vars EqS EqS' : EquationSet .
  var  RS : RuleSet .
  var  M? : [Module] .
  vars DB'' DB3 : Database .
  vars AtS AtS' : AttrSet .
  vars CND COND : Condition .
  vars ST ST' ST'' : SharingTable .
  vars G G' G'' : Goal .
  var  TyL : TypeList .
  vars Eq Eq' : Equation .
  vars P P' P'' : ProofTree .
  vars B B' CURR PRVN : Bool .
  var  SR : SearchRes .
  vars NL NL' : NatList .
  vars PO PO' PO'' : ProofOrder .
  vars SIM SIM' : ScoreInfoMap .
  vars CS CS' : ConsSub .
  var  ML : MList .
  vars MLb MLb' : MacroLabel .
  vars TrS TrS' : TermSet .
  var  SB : Substitution .
  var  SISP : SISPair .
  var  IPL : ImpPairList .
  vars ME ME' : ModuleExpression .
  var  RenS : RenamingSet .
  var  ParamL : ParameterList .
  vars MNS MNS' MNS'' MNS3 MNS4 MNS5 MNS6 : Set{ModuleName} .
  vars VES VES' VES'' VES3 : Set{ViewExp} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .

***(%
\end{comment}
}

The constants \verb"errModName" and \texttt{paramThWarn} will report specific
errors:

{\codesize
\begin{verbatim}
%)

  op errModName : -> QidList .
  eq errModName = '\n '\r 'ERROR: '\o 'The 'module 'name 'is 'not 'a
                  'valid 'identifier. .

  op paramThWarn : -> QidList .
  eq paramThWarn = '\n '\r 'Warning: '\o 'Parameterized 'theories 'are 'not 'allowed
                   'in 'Maude. '\n 'The 'module 'was 'introduced 'with '\g 'tight '\o
                   'semantics. '\n .

***(%
\end{verbatim}
}

The function in charge of parsing modules is \verb"procCafeMod". It receives as
arguments the term to be parsed and the current Full Maude database. It just duplicates
the term to be parsed and calls to \verb"procCafeMod2":

{\codesize
\begin{verbatim}
%)

  op procCafeMod : Term SortMap TheorySortMap TheorySortMap Database -> CafeParseResult .
  eq procCafeMod(T, PSM, HSM, TSM, DB) = procCafeMod2(T, T, PSM, HSM, TSM, DB) .

***(%
\end{verbatim}
}

The function \verb"procCafeMod2" distinguishes between modules with loose and
tight semantics. Modules with tight semantics, will be translated as Maude modules,
and hence we just use the function \verb"procCafeMod3", propagating the parameters
if required. Note that we use an empty module, \verb"emptyFModule", indicating that
it has tight semantics:

{\codesize
\begin{verbatim}
%)

  op procCafeMod2 : Term Term SortMap TheorySortMap TheorySortMap Database
                    -> CafeParseResult .
  eq procCafeMod2(T, 'cmod!_`{_`}['CafeToken[T'], T''], PSM, HSM, TSM, DB) =
                      procCafeMod3(T, 'CafeToken[T'], empty, T'',
                                   emptyFModule, PSM, HSM, TSM, DB) .
  eq procCafeMod2(T, 'cmod!_`{_`}['_`(_`)[T', T''], T3], PSM, HSM, TSM, DB) =
                      procCafeMod3(T, T', T'', T3, emptyFModule, PSM, HSM, TSM, DB) .
  ceq procCafeMod2(T, 'cmod!_`{_`}['_`[_`]['CafeToken[T'], 'CafeToken[TP]], T3], PSM,
                   HSM, TSM, DB) =
                 procCafeMod3(T, 'CafeToken[T'], empty, T3, emptyFModule, PSM', HSM, TSM, DB)
   if QI := downQid(T') /\
      QI' := downQid(TP) /\
      PSM' := add2PrincipalMap(QI, QI', PSM) .
  ceq procCafeMod2(T, 'cmod!_`{_`}['_`{_|_`}['CafeToken[T'], T'', 'CafeToken[TP]], T3],
                   PSM, HSM, TSM, DB) =
                      procCafeMod3(T, 'CafeToken[T'], T'', T3, emptyFModule, PSM', HSM, TSM, DB)
   if QI := downQid(T') /\
      QI' := downQid(TP) /\
      PSM' := add2PrincipalMap(QI, QI', PSM) .

  op add2PrincipalMap : Qid Qid SortMap -> SortMap .
  eq add2PrincipalMap(QI, QI', (QI |-> Q, PSM)) = QI |-> QI', PSM .
  eq add2PrincipalMap(QI, QI', PSM) = QI |-> QI', PSM [owise] .

***(%
\end{verbatim}
}

When parsing modules with loose semantics first introduce them as a theory but,
in order to accept a wider range of CafeOBJ modules, we also introduce it into the
database as a module, adding the suffix \verb"-MODCAFE" to its name.
Note that we do not allow parameterized theories, so we use the \verb"paramThWarn"
message when they are used.
%
Also note that we use an empty module or theory depending of the semantics we
want to use:

{\codesize
\begin{verbatim}
%)

  ceq procCafeMod2(T, 'cmod*_`{_`}['CafeToken[T'], T''], PSM, HSM, TSM, DB) =
        if QIL == nil
        then procCafeMod3(T, T3, empty, T'', emptyFModule, PSM', HSM', TSM, DB')
        else < DB', PSM', HSM', QIL >
        fi
   if < DB', PSM', HSM', QIL > := procCafeMod3(T, 'CafeToken[T'], empty, addBool(T''),
                                         emptyFTheory, PSM, HSM, TSM, DB) /\
      QI := downQid(T') /\
      QI' := qid(string(QI) + "-MODCAFE") /\
      T3 := 'CafeToken[upTerm(QI')] .
  ceq procCafeMod2(T, 'cmod*_`{_`}['_`[_`]['CafeToken[T'], 'CafeToken[TP]], T''], PSM,
                   HSM, TSM, DB) =
        if QIL == nil
        then procCafeMod3(T, T3, empty, T'', emptyFModule, PSM', HSM', TSM, DB')
        else < DB', PSM', HSM', QIL >
        fi
   if QI := downQid(T') /\
      Q := downQid(TP) /\
      QI' := qid(string(QI) + "-MODCAFE") /\
      T3 := 'CafeToken[upTerm(QI')] /\
      PSM' := add2PrincipalMap(QI, Q, PSM) /\
      < DB', PSM', HSM', QIL > := procCafeMod3(T, 'CafeToken[T'], empty, addBool(T''),
                                         emptyFTheory, PSM', HSM, TSM, DB) .
  ceq procCafeMod2(T, 'cmod*_`{_`}['_`{_|_`}['CafeToken[T'], T'','CafeToken[TP]], T3],
                   PSM, HSM, TSM, DB) =
        if QIL == nil
        then < DB', PSM', HSM', paramThWarn >
        else < DB', PSM', HSM', QIL >
        fi
   if QI := downQid(T') /\
      Q := downQid(TP) /\
      PSM' := add2PrincipalMap(QI, Q, PSM) /\
      < DB', PSM', HSM', QIL > := procCafeMod3(T, 'CafeToken[T'], T'', addBool(T3),
                                         emptyFModule, PSM', HSM, TSM, DB) .

 op addBool : Term -> Term .
 eq addBool(T) = if addsBool?(T)
                 then T
                 else '__['inc`(_`)['token[''BOOL.Qid]], T]
                 fi .

 op addsBool? : Term -> Bool .
 eq addsBool?('__[TL]) = addsBool?*(TL) .
 eq addsBool?('pr`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?('protecting`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?('inc`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?('including`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?('ex`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?('extending`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?('us`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?('using`(_`)[Q[''BOOL.Qid]]) = true .
 eq addsBool?(T) = false [owise] .

 op addsBool?* : TermList -> Bool .
 eq addsBool?*((T, TL)) = addsBool?(T) or addsBool?*(TL) .
 eq addsBool?*(empty) = false .

***(%
\end{verbatim}
}

In other case an error is returned:

{\codesize
\begin{verbatim}
%)

***  eq procCafeMod2(T, Q[T', T''], DB) = < DB, errModName > [owise] .

***(%
\end{verbatim}
}

The function \verb"procCafeMod3" deals with parameterized modules. If the current
modules is not parameterized we just set the name of the module and apply the
\texttt{procCafeMod4} function:

{\codesize
\begin{verbatim}
%)

  op procCafeMod3 : Term Term Term Term Module SortMap TheorySortMap TheorySortMap
                    Database -> CafeParseResult .
  ceq procCafeMod3(T, 'CafeToken[T'], empty, T'', U, PSM, HSM, TSM, DB) =
         procCafeMod4(T, T'', setName(U, QI), setName(U, QI), none, PSM, HSM, TSM, DB)
   if QI := downQid(T') .

***(%
\end{verbatim}
}

When the module is parameterized we set the name of the module and then parse
the parameters to introduce them into the current module.
We use the \texttt{parseParList} function from Full Maude, which returns a
parameter list from a term.

{\codesize
\begin{verbatim}
%)

  ceq procCafeMod3(T, 'CafeToken[T'], PL, T'', U, PSM, HSM, TSM, DB) =
         procCafeMod4(T, T3, setPars(setName(U, QI), parseParList(PL')),
                      setName(U, QI), none, PSM, HSM, TSM, DB)
   if PL =/= empty /\
      PL' := cafeParam2maudeParam(PL) /\
      QI := downQid(T') /\
      QIL := cafeParamNames(PL) /\
      SM := cafeTheoryMap(PL) /\
      TSM' := restrictTheorySortMap(TSM, SM) /\
      T3 := paramSortsMap(T'', TSM', QIL) .

  op restrictTheorySortMap : TheorySortMap SortMap -> TheorySortMap .
  eq restrictTheorySortMap((Q -> SS, TSM), (Q' |-> Q, SM)) =
                                       (Q' -> SS), restrictTheorySortMap(TSM, SM) .
  eq restrictTheorySortMap(TSM, SM) = empty [owise] .

  op cafeTheoryMap : Term -> SortMap .
  eq cafeTheoryMap('_::_['CafeToken[T], 'token[T']]) = downQid(T) |-> downQid(T') .
  ceq cafeTheoryMap('_`,_[T, T']) = SM, SM'
   if SM := cafeTheoryMap(T) /\
      SM' := cafeTheoryMap(T') .

***(%
\end{verbatim}
}

In other case an error is returned:

{\codesize
\begin{verbatim}
%)

  eq procCafeMod3(T, T', PL, T'', U, PSM, HSM, TSM, DB) = < DB, PSM, HSM, errModName > [owise] .

***(%
\end{verbatim}
}

The auxiliary functions required to deal with parameters are:
\begin{itemize}
\item
\verb"cafeParam2maudeParam", which translates the parameter declaration to Maude syntax:

{\codesize
\begin{verbatim}
%)

  op cafeParam2maudeParam : Term -> Term .
  eq cafeParam2maudeParam('_::_['CafeToken[T], T']) = '_::_['token[T], T'] .
  ceq cafeParam2maudeParam('_`,_[T, T']) = '_`,_[T'', T3]
   if T'' := cafeParam2maudeParam(T) /\
      T3 := cafeParam2maudeParam(T') .

***(%
\end{verbatim}
}

\item
\verb"cafeParamNames", which extracts the name of the parameters:

{\codesize
\begin{verbatim}
%)

  op cafeParamNames : Term -> QidList .
  eq cafeParamNames('_::_['CafeToken[T], T']) = downQid(T) .
  ceq cafeParamNames('_`,_[T, T']) = QIL QIL'
   if QIL := cafeParamNames(T) /\
      QIL' := cafeParamNames(T') .

***(%
\end{verbatim}
}

\item
\verb"paramSortsMap", which transforms the qualified sorts in CafeOBJ syntax into
qualified sorts in Maude syntax. It renames constants (which includes the
metarepresentation of variables) by using the names of the parameters obtained with
\texttt{cafeParamNames}. If the function is a composed term, it applies
\texttt{paramSortsMap*}:

{\codesize
\begin{verbatim}
%)

  op paramSortsMap : Term TheorySortMap QidList -> Term .
  eq paramSortsMap(Q[TL], TSM, QIL) = Q[paramSortsMap*(TL, TSM, QIL)] .

***(%
\end{verbatim}
}

Variables are not modified:

{\codesize
\begin{verbatim}
%)

  eq paramSortsMap(V, TSM, QIL) = V .

***(%
\end{verbatim}
}

For constants, we distinguish whether they stand for a constant (including sorts)
or for a variable. When they stand for a constant, (i.e., the String \verb@":"@ cannot
be found) we split the term looking for the \verb@"."@ String, which is used in CafeOBJ
to qualify sorts, and built it again by using the \verb@"$"@ used by Maude:

{\codesize
\begin{verbatim}
%)

  ceq paramSortsMap(C, TSM, QIL) = upTerm(QI)
   if Q := downQid(C) /\
      St := string(Q) /\
      find(St, ":", 0) == notFound /\
      N := find(St, ".", 0) /\
      St' := substr(St, 0, N) /\
      St'' := substr(St, N + 1, length(St)) /\
      Q' := qid(St'') /\
      Q' in QIL /\
      QI := qid(St'' + "$" + St') .

  ceq paramSortsMap(C, (TN -> (TS ; SS), TSM), QIL) = upTerm(QI)
   if TS := downQid(C) /\
      St := string(TS) /\
      QI := qid(string(TN) + "$" + St) .

  ceq paramSortsMap(C, TSM, QIL) = upTerm(QI)
   if Q := downQid(C) /\
      St := string(Q) /\
      find(St, ":", 0) == notFound /\
      N := find(St, ".", 0) /\
      St' := substr(St, 0, N) /\
      St'' := substr(St, N + 1, length(St)) /\
      Q' := qid(St'') /\
      Q'' := paramSortsMap(upTerm(Q'), TSM, QIL) /\
      QI := qid(St' + "." + string(Q'')) [owise] .

***(%
\end{verbatim}
}

When the constant stands for a variable, we proceed in a similar way but taking into
account that the name of the variable must be placed first in both cases:

{\codesize
\begin{verbatim}
%)

  ceq paramSortsMap(C, TSM, QIL) = upTerm(QI)
   if Q := downQid(C) /\
      St := string(Q) /\
      N := find(St, ":", 0) /\
      N' := find(St, ".", 0) /\
      St' := substr(St, 0, N + 1) /\
      St'' := substr(St, N + 1, _-_(N', N + 1)) /\
      St''' := substr(St, N' + 1, length(St)) /\
      Q' := qid(St''') /\
      Q' in QIL /\
      QI := qid(St' + St''' + "$" + St'') .

  ceq paramSortsMap(C, (TN -> (TS ; SS), TSM), QIL) = upTerm(QI)
   if Q := downQid(C) /\
      St := string(Q) /\
      N := find(St, ":", 0) /\
      St' := substr(St, 0, N + 1) /\
      St'' := substr(St, N + 1, length(St)) /\
      TS := qid(St'') /\
      QI := qid(St' + string(TN) + "$" + St'') .

***(%
\end{verbatim}
}

In other case, the constant is not modified:

{\codesize
\begin{verbatim}
%)

  eq paramSortsMap(C, TSM, QIL) = C [owise] .

***(%
\end{verbatim}
}

\item
\verb"paramSortsMap*", which just traverses the list, applying
\texttt{paramSortsMap} to each element:

{\codesize
\begin{verbatim}
%)

  op paramSortsMap* : TermList TheorySortMap QidList -> TermList .
  eq paramSortsMap*(empty, TSM, QIL) = empty .
  eq paramSortsMap*((T, TL), TSM, QIL) = paramSortsMap(T, TSM, QIL),
                                         paramSortsMap*(TL, TSM, QIL) .

***(%
\end{verbatim}
}

\item
\verb"_in_", which looks for a quoted identifier in a list:

{\codesize
\begin{verbatim}
%)

  op _in_ : Qid QidList -> Bool .
  eq Q in nil = false .
  eq Q in Q QIL = true .
  eq Q in QIL = false [owise] .

***(%
\end{verbatim}
}

\end{itemize}

The function \verb"procCafeMod4" traverses the module, applying the function
\verb"parseCafeDecl" shown above to each statement:

{\codesize
\begin{verbatim}
%)

  op procCafeMod4 : Term Term Module Module OpDeclSet SortMap TheorySortMap TheorySortMap
                    Database -> CafeParseResult .
  ceq procCafeMod4(T, '__[T', T''], PU, U, VDS, PSM, HSM, TSM, DB) =
        if QIL == nil
        then procCafeMod4(T, T'', preModule(PDR), unit(PDR), vars(PDR), PSM, HSM', TSM, DB')
        else < DB, PSM, HSM', QIL >
        fi
   if < PDR, QIL, SS, DB' > := parseCafeDecl(T', PU, U, VDS, PSM, TSM, DB) /\
      HSM' := addHiddenSort(HSM, getName(U), SS) .

  op addHiddenSort : TheorySortMap Qid SortSet -> TheorySortMap .
  eq addHiddenSort((Q -> SS, HSM), Q, SS') = (Q -> (SS ; SS'), HSM) .
  eq addHiddenSort(HSM, Q, SS) = Q -> SS, HSM [owise] .

***(%
\end{verbatim}
}

When only one statement remains it is parsed and the module is evaluated by means
of the \verb"evalPreModule" function:

{\codesize
\begin{verbatim}
%)

  ceq procCafeMod4(T, F[TL], PU, U, VDS, PSM, HSM, TSM, DB) = < DB3, PSM, HSM', nil >
   if F =/= '__ /\
      < PDR, nil, SS, DB' > := parseCafeDecl(F[TL], PU, U, VDS, PSM, TSM, DB) /\
      DB'' := evalPreModule(predefinedCafeEqual(preModule(PDR)),
                            predefinedCafeEqual(unit(PDR)),
                            vars(PDR), insTermModule(getName(U), T, DB')) /\
      DB3 := updateDatabase4cafe(getName(U), DB'') /\
      HSM' := addHiddenSort(HSM, getName(U), SS) .

  ceq procCafeMod4(T, C, PU, U, VDS, PSM, HSM, TSM, DB) = < DB3, PSM, HSM', nil >
   if < PDR, nil, SS, DB' > := parseCafeDecl(C, PU, U, VDS, PSM, TSM, DB) /\
      DB'' := evalPreModule(predefinedCafeEqual(preModule(PDR)),
                            predefinedCafeEqual(unit(PDR)),
                            vars(PDR), insTermModule(getName(U), T, DB')) /\
      DB3 := updateDatabase4cafe(getName(U), DB'') /\
      HSM' := addHiddenSort(HSM, getName(U), SS) .

  ceq procCafeMod4(T, F[TL], PU, U, VDS, PSM, HSM, TSM, DB) = < DB, PSM, HSM', QIL >
   if F =/= '__ /\
      < PDR, QIL, SS, DB' > := parseCafeDecl(F[TL], PU, U, VDS, PSM, TSM, DB) /\
      QIL =/= nil /\
      HSM' := addHiddenSort(HSM, getName(U), SS) .

  op nonexecInLabel : Module -> Module .
  eq nonexecInLabel(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm) =
       fmod H is IL sorts SS . SSDS ODS MAS nonexecInLabel(EqS) endfm .
  eq nonexecInLabel(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm) =
       mod H is IL sorts SS . SSDS ODS MAS nonexecInLabel(EqS) RS endm .
  eq nonexecInLabel(fth H is IL sorts SS . SSDS ODS MAS EqS endfth) =
       fth H is IL sorts SS . SSDS ODS MAS nonexecInLabel(EqS) endfth .
  eq nonexecInLabel(th H is IL sorts SS . SSDS ODS MAS EqS RS endth) =
       th H is IL sorts SS . SSDS ODS MAS nonexecInLabel(EqS) RS endth .
  eq nonexecInLabel(M?) = M? [owise] .

  op nonexecInLabel : EquationSet -> EquationSet .
  eq nonexecInLabel((none).EquationSet) = none .
  eq nonexecInLabel(eq T = T' [AtS] . EqS) = eq T = T' [nonexecInLabel(AtS)] .
                                             nonexecInLabel(EqS) .
  eq nonexecInLabel(ceq T = T' if COND [AtS] . EqS) =
             ceq T = T' if COND [nonexecInLabel(AtS)] . nonexecInLabel(EqS) .

  op nonexecInLabel : AttrSet -> AttrSet .
  eq nonexecInLabel(label('cafe-label-:nonexec) AtS) = nonexec AtS .
  ceq nonexecInLabel(label(Q) AtS) = label(Q') nonexec AtS
   if STR := string(Q) /\
      N := find(STR, "-:nonexec", 0) /\
      STR' := substr(STR, 0, N) + substr(STR, N + 9, length(STR)) /\
      Q' := qid(STR') .
  ceq nonexecInLabel(label(Q) AtS) = label(Q') nonexec AtS
   if STR := string(Q) /\
      N := find(STR, "cafe-label-:nonexec-", 0) /\
      STR' := substr(STR, 0, N) + substr(STR, N + 20, length(STR)) /\
      Q' := qid(STR') .
  eq nonexecInLabel(AtS) = AtS [owise] .

  op updateDatabase4cafe : ModuleExpression Database -> Database .
  ceq updateDatabase4cafe(ME, DB) = DB'
   if DB' := updateDatabase4cafeAux(ME, DB) .
  eq updateDatabase4cafe(ME, DB) = DB [owise] .

  op filterPredefEqs : EquationSet -> EquationSet .
  eq filterPredefEqs(eq T = T' [AtS metadata("built-in in CafeOBJ")] . EqS) =
                                        filterPredefEqs(EqS) .
  eq filterPredefEqs(ceq T = T' if CND [AtS metadata("built-in in CafeOBJ")] . EqS) =
                                        filterPredefEqs(EqS) .
  eq filterPredefEqs(EqS) = EqS [owise] .

  op isSystem : Module -> Bool .
  eq isSystem(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm) = true .
  eq isSystem(th H is IL sorts SS . SSDS ODS MAS EqS RS endth) = true .
  eq isSystem(M) = false [owise] .

  op updateDatabase4cafeAux : ModuleExpression Database -> Database .
  ceq updateDatabase4cafeAux(ME, DB) =
             db(< ME ; T ; nonexecInLabel(addEqual&SearchEqs(U')) ;
                  nonexecInLabel(addEqual&SearchEqs(U'')) ; U3 ;
                  VDS ; MNS ; VES > MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)
   if db(< ME ; T ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS', VIS, VES', MNS'',
           MNS3, MNS4, QIL) := DB /\
      U5 := getFlatModule(modExp(evalModExp(ME, DB)),
                 database(evalModExp(ME, DB))) .
  eq updateDatabase4cafeAux(ME, DB) = DB [owise] .

  op addEqual&SearchEqs : Module -> Module .
  ceq addEqual&SearchEqs(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm) =
                         fmod H is IL sorts SS . SSDS ODS MAS (EqS EqS') endfm
   if EqS' := createEqsFromSorts(SS) createEqsFromImports(IL) .
  ceq addEqual&SearchEqs(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm) =
                         mod H is IL sorts SS . SSDS ODS MAS (EqS EqS') RS endm
   if EqS' := createEqsFromSorts(SS) createEqsFromImports(IL) .
  ceq addEqual&SearchEqs(fth H is IL sorts SS . SSDS ODS MAS EqS endfth) =
                         fth H is IL sorts SS . SSDS ODS MAS (EqS EqS') endfth
   if EqS' := createEqsFromSorts(SS) createEqsFromImports(IL) .
  ceq addEqual&SearchEqs(th H is IL sorts SS . SSDS ODS MAS EqS RS endth) =
                         th H is IL sorts SS . SSDS ODS MAS (EqS EqS') RS endth
   if EqS' := createEqsFromSorts(SS) createEqsFromImports(IL) .

  op predefinedCafeEqual : Module -> Module .
  ceq predefinedCafeEqual(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm) =
                          fmod H is IL' sorts SS . SSDS ODS MAS EqS endfm
   if IL' := (IL protecting 'EQL .) .
  ceq predefinedCafeEqual(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm) =
                          mod H is IL' sorts SS . SSDS ODS MAS EqS RS endm
   if IL' := (IL protecting 'EQL . protecting 'RWL .) .
  ceq predefinedCafeEqual(fth H is IL sorts SS . SSDS ODS MAS EqS endfth) =
                          fth H is IL' sorts SS . SSDS ODS MAS EqS endfth
   if IL' := (IL protecting 'EQL .) .
  ceq predefinedCafeEqual(th H is IL sorts SS . SSDS ODS MAS EqS RS endth) =
                          th H is IL' sorts SS . SSDS ODS MAS EqS RS endth
   if IL' := (IL protecting 'EQL . protecting 'RWL .) .
  eq predefinedCafeEqual(M?) = M? [owise] .

  op createEqsFromSorts : SortSet -> EquationSet .
  eq createEqsFromSorts(none) = none .
  ceq createEqsFromSorts(Srt ; SS) = eq '_=_[V, V] = 'true.Bool [metadata("built-in in CafeOBJ")] .
                                     createEqsFromSorts(SS)
   if V := qid("V:" + string(Srt)) /\
      V' := qid("V':" + string(Srt)) .

  op createEqsFromImports : ImportList -> EquationSet .
  eq createEqsFromImports(nil) = none .
  eq createEqsFromImports(I IL) = createEqsFromImport(I) createEqsFromImports(IL) .

  op createEqsFromImport : Import -> EquationSet .
  eq createEqsFromImport(protecting ME .) = createEqsFromME(ME) .
  eq createEqsFromImport(extending ME .) = createEqsFromME(ME) .
  eq createEqsFromImport(including ME .) = createEqsFromME(ME) .

  op createEqsFromME : ModuleExpression -> EquationSet .
  eq createEqsFromME(Q) = getEqs4Predefined(Q) .
  eq createEqsFromME(ME + ME') = createEqsFromME(ME) createEqsFromME(ME') .
  eq createEqsFromME(ME * (RenS)) = createEqsFromME(ME) .
  eq createEqsFromME(ME{ParamL}) = createEqsFromME(ME) .

  vars V1 V2 V3 : Variable .

  op getEqs4Predefined : Qid -> EquationSet .
  ceq getEqs4Predefined('NAT) =
                eq '_=_[V1, V1] = 'true.Bool [metadata("built-in in CafeOBJ")] .
                eq '_=_[V2, V2] = 'true.Bool [metadata("built-in in CafeOBJ")] .
                eq '_=_[V3, V3] = 'true.Bool [metadata("built-in in CafeOBJ")] .
   if V1 := 'V:Zero /\
      V2 := 'V:NzNat /\
      V3 := 'V:Nat .
  eq getEqs4Predefined(Q) = none [owise] .

***(%
\end{verbatim}
}

The function \verb"procCafeView" is in charge of processing views. It just
translates the view and introduces it into the database:

{\codesize
\begin{verbatim}
%)

  op procCafeView : Term SortMap Database -> CafeParseResult .
  ceq procCafeView('cview_from_to_`{`}[T, 'token[T'], 'token[T'']], PSM, DB) =
           procCafeView('cview_from_to_`{_`}[T, 'token[T'], 'token[T''], T3], PSM, DB)
   if Q := downQid(T') /\
      Q' := downQid(T'') /\
      (Q' |-> QI, PSM') := PSM /\
      M := getFlatModule(Q, DB) /\
      'Bool ; Srt := getSorts(M) /\
      QI =/= Srt /\
      T3 := 'sort_->_.['CafeToken[upTerm(Srt)], 'CafeToken[upTerm(QI)]] .
  ceq procCafeView(T, PSM, DB) = < DB', nil >
   if T' := view2view(T) /\
      DB' := procView(T', DB) [owise] .

***(%
\end{verbatim}
}

\noindent
where the auxiliary functions behave as follows:
\begin{itemize}
\item
\verb"view2view" translates the term to Maude syntax, and then applies
the \verb"maps2maps" function shown above to the body:

{\codesize
\begin{verbatim}
%)

  op view2view : Term -> Term .
  eq view2view('cview_from_to_`{_`}[T, T', T'', T3]) =
        'view_from_to_is_endv[token2token(T), T', T'', maps2maps(T3)] .
  eq view2view('cview_from_to_`{`}[T, T', T'']) =
        'view_from_to_is_endv[token2token(T), T', T'', 'none.ViewDeclSet] .

***(%
\end{verbatim}
}

\item
\verb"token2token" translates a CafeOBJ token into a Maude token:

{\codesize
\begin{verbatim}
%)

  op token2token : Term -> Term .
  eq token2token('CafeToken[T]) = 'token[T] .
  eq token2token(T) = T [owise] .

***(%
\end{verbatim}
}
\end{itemize}

{\codesize
\begin{comment}
%)

  op openCloseModNameUp : -> Constant .
  eq openCloseModNameUp = ''OPEN_CLOSE.Qid .

  op openCloseModName : -> Qid .
  eq openCloseModName = 'OPEN_CLOSE .

  op procOpenCloseEnv : Term Term SortMap TheorySortMap TheorySortMap Database
                        ScoreInfoMap -> CafeParseResult .

  *** This equation is used when an id is used to identify the proof being carried in the
  *** open-close environment, and hence it is required to update the map.
  ceq procOpenCloseEnv(T, T', PSM, HSM, TSM, DB, SIM) = < DB' | SIM' | QIL | QIL' >
   if (TI, TL') := getIds(T') /\
      ID := downQid(TI) /\
      T1 := 'CafeToken[openCloseModNameUp] /\
      T2 := '__['inc`(_`)[cleanOpenCloseName(T)], T'] /\
      < DB', PSM', HSM', QIL > := procCafeMod('cmod!_`{_`}[T1, T2], PSM, HSM, TSM, DB) /\
      M := nonexecInLabel(getFlatModule(openCloseModName, DB')) /\
      M' := nonexecInLabel(getTopModule(openCloseModName, DB')) /\
      TLR := getRedTerms(M, T', T2) /\
      TL := getRedThCommands(T') /\
      SIM' := addSIM(SIM, ID, $ M, M', TLR $) /\
      QIL' := processRedThCommands(M, PSM, HSM, TSM, DB', TL, T2, mtPT, 'foo:Foo,
                                   mtMacros, finished, SIM') .

  *** This equation is used when no id is used to identify the proof
  ceq procOpenCloseEnv(T, T', PSM, HSM, TSM, DB, SIM) = < DB' | SIM | QIL | QIL' >
   if getIds(T') == empty /\
      T1 := 'CafeToken[openCloseModNameUp] /\
      T2 := '__['inc`(_`)[cleanOpenCloseName(T)], T'] /\
      < DB', PSM', HSM', QIL > := procCafeMod('cmod!_`{_`}[T1, T2], PSM, HSM, TSM, DB) /\
      M := nonexecInLabel(getFlatModule(openCloseModName, DB')) /\
      TL := getRedThCommands(T') /\
      QIL' := processRedThCommands(M, PSM, HSM, TSM, DB', TL, T2, mtPT, 'foo:Foo,
                                   mtMacros, finished, SIM) .

  eq procOpenCloseEnv(T, T', PSM, HSM, TSM, DB, SIM) =
                         < DB | SIM | nil | 'Environment 'not 'parsed. > [owise] .

  op cleanOpenCloseName : Term -> Term .
  eq cleanOpenCloseName('`(_`)[T]) = T .
  eq cleanOpenCloseName(T) = T [owise] .

  op getIds : Term -> TermList .
  eq getIds('__[T, T']) = getId(T), getIds(T') .
  eq getIds(T) = getId(T) [owise] .

  op getId : Term -> TermList .
  eq getId(':id`(_`)['CafeToken[T]]) = T .
  eq getId(T) = empty [owise] .

  op getRedTerms : Module Term Term -> TermList .
  eq getRedTerms(M, '__[T, T'], T1) = getRedTerm(M, T, T1), getRedTerms(M, T', T1) .
  eq getRedTerms(M, T, T1) = getRedTerm(M, T, T1) [owise] .

  op getRedTerm : Module Term Term -> TermList .
  ceq getRedTerm(M, 'red_.['CafeBubble[T]], T') = T1
   if ODS := parseModule4Vars(T') /\
      QIL := downQidList(T) /\
      ODS' := opDeclSetFromQidList(QIL) /\
      T'' := renameOnTheFly(T, ODS ODS') /\
      T1 := getTerm(metaParse(M, downQidList(T''), anyType)) .
  eq getRedTerm(M, T, T') = empty [owise] .

  op getRedThCommands : Term -> TermList .
  eq getRedThCommands('__[T, T']) = getRedThCommand(T), getRedThCommands(T') .
  eq getRedThCommands(T) = getRedThCommand(T) [owise] .

  op getRedThCommand : Term -> TermList .
  eq getRedThCommand('reduce_.['CafeBubble[T]]) = 'red_.['bubble[T]] .
  eq getRedThCommand('red_.['CafeBubble[T]]) = 'red_.['bubble[T]] .
  eq getRedThCommand(':goal`{_`}[T]) = ':goal`{_`}[T] .
  eq getRedThCommand(':ind`on`(_`)['CafeToken[T]]) = ':ind`on`(_`)[T] .
  eq getRedThCommand(':apply`(_`)['neCafeTokenList[T]]) = ':apply`(_`)[T] .
  eq getRedThCommand(':sel`(_`)['CafeToken[T]]) = ':sel`(_`)[T] .
  eq getRedThCommand(':postpone`..@CafeInductiveComm@) = ':postpone`..@CafeInductiveComm@ .
  eq getRedThCommand(':imp`[_`].['CafeToken[T]]) = ':imp`[_`].[T] .
  eq getRedThCommand(':imp`[_`]by`{_`}['CafeToken[T], 'neCafeTokenList[T']]) =
                                                    ':imp`[_`]by`{_`}[T, T'] .
  eq getRedThCommand(':id`(_`)['CafeToken[T]]) = empty .
  eq getRedThCommand(':proof`(_`)['CafeToken[T]]) = ':proof`(_`)[T] .
  eq getRedThCommand(':infer`(_`)['CafeToken[T]]) = ':infer`(_`)[T] .
  eq getRedThCommand(':def_=`:ctf`{_`}['CafeToken[T], T']) =
                                                   ':def_=`:ctf`{_`}[T, T'] .
  eq getRedThCommand(':def_=`:ctf`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:ctf`[_`][T, T'] .
  eq getRedThCommand(':def_=`:cvss`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:cvss`[_`][T, T'] .
  eq getRedThCommand(':def_=`:cvvs`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:cvvs`[_`][T, T'] .
  eq getRedThCommand(':def_=`:cvsv`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:cvsv`[_`][T, T'] .
  eq getRedThCommand(':def_=`:cevss`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:cevss`[_`][T, T'] .
  eq getRedThCommand(':def_=`:cvs`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:cvs`[_`][T, T'] .
  eq getRedThCommand(':def_=`:csv`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:csv`[_`][T, T'] .
  eq getRedThCommand(':def_=`:csvs`[_`]['CafeToken[T], 'CafeBubble[T']]) =
                                                   ':def_=`:csvs`[_`][T, T'] .
  eq getRedThCommand(':show`proof.@CafeInductiveComm@) = ':show`proof.@CafeInductiveComm@ .
  eq getRedThCommand(':desc`proof.@CafeInductiveComm@) = ':desc`proof.@CafeInductiveComm@ .
  eq getRedThCommand(':desc`..@CafeInductiveComm@) = ':desc`..@CafeInductiveComm@ .
  eq getRedThCommand(T) = empty [owise] .

  op processRedThCommands : Module SortMap TheorySortMap TheorySortMap Database
                            TermList Term ProofTree Variable Macros ProofOrder
                            ScoreInfoMap -> QidList .
  eq processRedThCommands(M, PSM, HSM, TSM, DB, empty, T, P, V, MACS, PO, SIM) = nil .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':goal`{_`}[T], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P', V, MACS, PO', SIM)
   if [P', PO', QIL] := evalGoalCommand(M, T, T1, PSM, HSM, TSM, DB, PO) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':ind`on`(_`)[T], TL), T1, P, V,
                           MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, T', MACS, PO,SIM)
   if T' := downTerm(T) /\
      T' :: Variable /\
      QIL := '\n 'Induction 'set 'on metaPrettyPrint(M, T', po) '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':apply`(_`)[T], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, (':apply`(_`)['__[T3, TL']], TL),
                                    T1, P', V, MACS, PO', SIM)
   if '__[T2, T3, TL'] := T /\
      TL' =/= empty /\
      Q := downQid(T2) /\
      [P', PO', QIL] := evalApply(M, Q, P, V, MACS, PO) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':apply`(_`)[T], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, (':apply`(_`)[T3], TL),
                                    T1, P', V, MACS, PO', SIM)
   if '__[T2, T3] := T /\
      Q := downQid(T2) /\
      [P', PO', QIL] := evalApply(M, Q, P, V, MACS, PO) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':apply`(_`)[T], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P', V, MACS, PO', SIM)
   if Q := downQid(T) /\
      [P', PO', QIL] := evalApply(M, Q, P, V, MACS, PO) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':sel`(_`)[T], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P', V, MACS, PO', SIM)
   if Q := downQid(T) /\
      NL := qid2natlist(Q) /\
      P' := selectGoal(P, NL) /\
      PO' := selectGoal(PO, NL) /\
      QIL := '\n 'Sentence Q 'selected. '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':postpone`..@CafeInductiveComm@, TL),
                           T1, P, V, MACS, NL y PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P', V, MACS, PO', SIM)
   if PO' := PO y NL /\
      P' := selectGoal(P, fst(PO')) /\
      QIL := '\n 'Sentence printIndex(NL) 'postponed. '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':imp`[_`].[T], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P', V, MACS, PO, SIM)
   if Q := downQid(T) /\
      [P', B] := applyImp(P, Q) /\
      QIL := if B
             then '\n 'New 'goal 'generated: printCurrent(P')
             else '\n 'Command 'failed. '\n
             fi .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':imp`[_`]by`{_`}[T, T'], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P', V, MACS, PO, SIM)
   if Q := downQid(T) /\
      SB := procImpSub(getMod(P, fst(PO)), T') /\
      [P', B] := applyImp(P, Q, SB) /\
      QIL := if B
             then '\n 'New 'goal 'generated: printCurrent(P')
             else '\n 'Command 'failed. '\n
             fi .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:ctf`{_`}[T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - Eq #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - Eq # := parseEqMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':ctf ' '`{ ' printEq(M', Eq) ' '`} '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:ctf`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':ctf ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:cvss`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 . cvss #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      subsortSingleBinaryOpConstraints(M', T2) /\
      QIL := '\n Q 'defined 'as ':cvss ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:cvvs`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 . cvvs #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':cvvs ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:cvsv`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 . cvsv #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':cvsv ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:cevss`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 . cevss #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':cevss ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:cvs`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 . cvs #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      subsortUnaryBinaryOpConstraints(M', T2) /\
      QIL := '\n Q 'defined 'as ':cvs ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:csv`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 . csv #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      subsortUnaryBinaryOpConstraints(M', T2) /\
      QIL := '\n Q 'defined 'as ':csv ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                          (':def_=`:csvs`[_`][T, T'], TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,
                                          MACS # M', Q - T2 . csvs #, PO, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      subsortUnaryBinaryOpConstraints(M', T2) /\
      QIL := '\n Q 'defined 'as ':csvs ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                           (':show`proof.@CafeInductiveComm@, TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V, MACS, PO, SIM)
   if QIL := '\n 'Current 'goals: printGoals(P) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                           (':desc`proof.@CafeInductiveComm@, TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V, MACS, PO, SIM)
   if QIL := '\n 'Current 'proof: printProofTree(P) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB,
                           (':desc`..@CafeInductiveComm@, TL), T1, P, V, MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V, MACS, PO, SIM)
   if QIL := '\n 'Current 'goal: printCurrent(P) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, ('red_.['bubble[T]], TL), T1, P, V,
                           MACS, PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V, MACS, PO, SIM)
   if QIL := evalRedCommand(M, T, T1) .
  eq processRedThCommands(M, PSM, HSM, TSM, DB, (':id`(_`)[T], TL), T1, P, V, MACS,
                          PO, SIM) =
           processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V, MACS, PO, SIM) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':proof`(_`)[T], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V, MACS, PO, SIM)
   if Q := downQid(T) /\
      QIL := inferProof(M, Q, SIM[Q], mtMacros) .
  ceq processRedThCommands(M, PSM, HSM, TSM, DB, (':infer`(_`)[T], TL), T1, P, V, MACS,
                           PO, SIM) =
           QIL processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V, MACS, PO, SIM)
   if Q := downQid(T) /\
      QIL := inferWithGoalProof(M, Q, SIM[Q], mtMacros) .
  eq processRedThCommands(M, PSM, HSM, TSM, DB, (T, TL), T1, P, V, MACS, PO, SIM) =
           '\n 'Error 'in 'command.
           processRedThCommands(M, PSM, HSM, TSM, DB, TL, T1, P, V,MACS, PO, SIM) [owise] .

  *** Module.
  *** Term to be reduced.
  *** Module in term representation, including vars
  op evalRedCommand : Module Term Term -> QidList .
  ceq evalRedCommand(M, T, T') = evalRedCommand(M, T'')
   if ODS := parseModule4Vars(T') /\
      QIL := downQidList(T) /\
      ODS' := opDeclSetFromQidList(QIL) /\
      T'' := renameOnTheFly(T, ODS ODS') .

  op evalRedCommand : Module Term -> QidList .
  ceq evalRedCommand(M, T) = QIL
   if T1 := getTerm(metaParse(M, downQidList(T), anyType)) /\
      T' := getTerm(metaReduce(M, T1)) /\
      T'' := addComments(T') /\
      QIL := evalRedCommandFinal(M, T'', T1) .
***(
  ceq evalRedCommand(M, T) = QIL
   if T1 := getTerm(metaParse(M, downQidList(T), anyType)) /\
      T'' := addComments(T1) /\
      QIL := evalRedCommandFinal(M, T'', T1) .
      *** TODO: Simplify if same argument
)

  op evalRedCommandFinal : Module Term Term -> QidList .
  ceq evalRedCommandFinal(M, T, T1) = QIL '\n QIL'
   if | T', QIL, ST | := changeSearch(M, T, mtST) /\
      {T'', Ty} := metaReduce(M, T') /\
      QIL' := printRedRes(M, T1, T'', Ty) .
***(
  ceq evalRedCommandFinal(M, T, T1) = QIL '\n QIL'
   if | T', QIL | := myRed(M, T) /\
      QIL' := printRedRes(M, T1, T', type(M, T')) .
)

  sort GoalRes .
  op [_,_,_] : ProofTree ProofOrder QidList -> GoalRes [ctor] .

  op evalGoalCommand : Module Term Term SortMap TheorySortMap TheorySortMap Database
                       ProofOrder -> GoalRes .
  ceq evalGoalCommand(M, T, T2, PSM, HSM, TSM, DB, PO) = [P, (nil).NatList, QIL']
   if T1 := 'CafeToken[openCloseModNameUp] /\
      < DB', PSM', HSM', QIL > := procCafeMod('cmod!_`{_`}[T1, addEqs(T2, T)], PSM, HSM, TSM, DB) /\
      M' := nonexecInLabel(getFlatModule(openCloseModName, DB')) /\
      P := getNew(M, getEqs(M), getEqs(M')) /\
      QIL' := 'New 'goal 'introduced: '\n printGoals(P) '\n .
  eq evalGoalCommand(M, T, T1, PSM, HSM, TSM, DB, PO) =
                       [mtPT, finished, '\n 'Error 'processing 'goal. '\n] [owise] .

  op evalApply : Module Qid ProofTree Variable Macros ProofOrder -> GoalRes .
  ceq evalApply(M, 'si, P, V, MACS, PO) = [P', PO', QIL]
   if [P', PO'] := applyInduction(P, V, PO) /\
      QIL := '\n 'Induction 'applied 'on metaPrettyPrint(M, V, po) ':
             '\n 'New 'goal: printGoals(P') '\n .
  ceq evalApply(M, 'tc, P, V, MACS, PO) = [P', PO', QIL]
   if [P', PO'] := applyTC(P, PO) /\
      QIL := '\n 'Theorem 'of 'constants 'applied.
             '\n 'New 'goal: printGoals(P') '\n .
  ceq evalApply(M, 'rd, P, V, MACS, PO) = [P'', PO', QIL]
   if [P', B] := applyRed(P) /\
      PO' := if B
             then pop(PO)
             else PO
             fi /\
      B' := PO' == finished /\
      P'' := if B and (not B')
             then selectGoal(P', fst(PO'))
             else P'
             fi /\
      QIL := '\n '\n 'Reduction 'applied.
             'The 'goal 'was if B then nil else 'not fi 'discarded
             if B and (not B')
             then '\n 'Next 'goal 'is '\! printIndex(fst(PO')) '\o
             else if B'
                  then '\n '\! 'PROOF 'FINISHED! '\o '\n
                  else nil
                  fi
             fi .
  ceq evalApply(M, 'rd-, P, V, MACS, PO) = [P'', PO', QIL]
   if [P', B] := applyRed(P) /\
      PO' := if B
             then pop(PO)
             else PO
             fi /\
      B' := PO' == finished /\
      P'' := if B and (not B')
             then selectGoal(P', fst(PO'))
             else P'
             fi /\
      QIL := '\n '\n 'Reduction 'applied.
             'The 'goal 'was if B then nil else 'not fi 'discarded
             if B and (not B')
             then '\n 'Next 'goal 'is '\! printIndex(fst(PO')) '\o
             else if B'
                  then '\n '\! 'PROOF 'FINISHED! '\o '\n
                  else nil
                  fi
             fi .
  ceq evalApply(M, Q, P, V, # M', Q - Eq # MACS, PO) = [P', PO', QIL]
   if P' := applyEquationMacro(P, Q, Eq) /\
      PO' := indProofOrder(fst(PO), 2) y pop(PO) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .
  ceq evalApply(M, Q, P, V, # M', Q - T # MACS, PO) = [P', PO', QIL]
   if Ty := getType(metaReduce(M', T)) /\
      [P', PO'] := applyTermMacro(P, PO, Q, T, Ty) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .
  ceq evalApply(M, Q, P, V, # M', Q - T . cvss # MACS, PO) = [P', PO', QIL]
   if Ty := getType(metaReduce(M', T)) /\
      [P', PO'] := applyTermMacro(P, PO, Q, T, cvss, Ty) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .
  ceq evalApply(M, Q, P, V, # M', Q - T . cvs # MACS, PO) = [P', PO', QIL]
   if Ty := getType(metaReduce(M', T)) /\
      [P', PO'] := applyTermMacro(P, PO, Q, T, cvs, Ty) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .
  ceq evalApply(M, Q, P, V, # M', Q - T . csv # MACS, PO) = [P', PO', QIL]
   if Ty := getType(metaReduce(M', T)) /\
      [P', PO'] := applyTermMacro(P, PO, Q, T, csv, Ty) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .
  ceq evalApply(M, Q, P, V, # M', Q - T . csvs # MACS, PO) = [P', PO', QIL]
   if Ty := getType(metaReduce(M', T)) /\
      [P', PO'] := applyTermMacro(P, PO, Q, T, csvs, Ty) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .

  op getCtors : Module Sort -> OpDeclSet .
  eq getCtors(M, Srt) = getCtors(M, getOps(M), Srt) .

  op getCtors : Module OpDeclSet Sort -> OpDeclSet .
  eq getCtors(M, op Q : TyL -> Srt [ctor AtS] . ODS, Srt) = op Q : TyL -> Srt [ctor AtS] .
                                                            getCtors(M, ODS, Srt) .
  ceq getCtors(M, op Q : TyL -> Ty [ctor AtS] . ODS, Srt) = op Q : TyL -> Ty [ctor AtS] .
                                                            getCtors(M, ODS, Srt)
   if Ty =/= 'Universal /\
      sameKind(M, Ty, Srt) /\
      sortLeq(M, Ty, Srt) .
  eq getCtors(M, ODS, Srt) = none [owise] .

  op getExactCtors : Module Sort -> OpDeclSet .
  eq getExactCtors(M, Srt) = getExactCtors(M, getOps(M), Srt) .

  op getExactCtors : Module OpDeclSet Sort -> OpDeclSet .
  eq getExactCtors(M, op Q : TyL -> Srt [ctor AtS] . ODS, Srt) = op Q : TyL -> Srt [ctor AtS] .
                                                            getExactCtors(M, ODS, Srt) .
  eq getExactCtors(M, ODS, Srt) = none [owise] .

  op buildTermsCtors : OpDeclSet String -> TermList .
  eq buildTermsCtors(none, STR) = empty .
  ceq buildTermsCtors(OD ODS, STR) = (T, TL)
   if T := buildTermCtor(OD, STR) /\
      TL := buildTermsCtors(ODS, STR) .

  op buildTermCtor : OpDecl String -> Term .
  ceq buildTermCtor(op Q : nil -> Srt [AtS] ., STR) = C
   if C := qid(string(Q) + "." + string(Srt)) .
  ceq buildTermCtor(op Q : TyL -> Srt [AtS] ., STR) = Q[TL]
   if TL := buildArgs(TyL, empty, STR) [owise] .

  op procImpSub : Module Term ~> Substitution .
  eq procImpSub(M, '__[TL]) = $procImpSub(getOps(M), TL) .

  op $procImpSub : OpDeclSet TermList ~> Substitution .
  eq $procImpSub(ODS, empty) = none .
  ceq $procImpSub(ODS, (T, ''<-.Qid, T', '';.Qid, TL)) = V <- C ; $procImpSub(ODS, TL)
   if V := downQid(T) /\
      Q := downQid(T') /\
      op Q : nil -> Ty [AtS] . ODS' := ODS /\
      C := qid(string(Q) + "." + string(Ty)) .
  ceq $procImpSub(ODS, (T, ''<-.Qid, T', '';.Qid, TL)) = V <- C ; $procImpSub(ODS, TL)
   if V := downQid(T) /\
      C := downQid(T') .
  ceq $procImpSub(ODS, (T, ''<-.Qid, T', ''`(.Qid, TL, ''`).Qid,  '';.Qid, TL')) =
                                                      V <- Q[TL''] ; $procImpSub(ODS, TL')
   if V := downQid(T) /\
      Q := downQid(T') /\
      TL'' := parseSubList(ODS, TL) .

  op parseSubList : OpDeclSet TermList ~> TermList .
  eq parseSubList(ODS, empty) = empty .
  eq parseSubList(ODS, (''`,.Qid, TL)) = parseSubList(ODS, TL) .
  ceq parseSubList(ODS, (T, TL)) = C, parseSubList(ODS, TL)
   if Q := downQid(T) /\
      op Q : nil -> Ty [AtS] . ODS' := ODS /\
      C := qid(string(Q) + "." + string(Ty)) .
  ceq parseSubList(ODS, (T, TL)) = C, parseSubList(ODS, TL)
   if C := downQid(T) .
  ceq parseSubList(ODS, (T, ''`(.Qid, TL, ''`).Qid, TL')) = Q[TL''], parseSubList(ODS, TL')
   if Q := downQid(T) /\
      TL'' := parseSubList(ODS, TL) .

  ************************************************************************************
  ********************************* APPLY TERM MACRO *********************************
  ************************************************************************************

  op applyTermMacro : ProofTree ProofOrder Qid Term Type -> IndResPair .
  eq applyTermMacro(P, PO, Q, T, Ty) = $applyTermMacro(P, PO, Q, T, Ty) .

  op $applyTermMacro : ProofTree ProofOrder Qid Term Type -> IndResPair .
  eq $applyTermMacro(mtPT, PO, Q, T, Ty) = [mtPT, finished] .
  ceq $applyTermMacro(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, PO, Q, T, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if [ PrL', PO' ] := $applyTermMacro*(PrL, PO, Q, T, Ty) .
  ceq $applyTermMacro(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO, Q, T, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if ODS := getCtors(M, Ty) /\
      TL := ordTrueFalse(buildTermsCtors(ODS, "CS")) /\
      ML := createModules(M, T, TL) /\
      PrL' := createCTFTerm(ML, NL, Q, EqS) /\
      PO' := indProofOrder(fst(PO), size(TL)) y pop(PO) .

  op applyTermMacro : ProofTree ProofOrder Qid Term MacroLabel Type -> IndResPair .
  eq applyTermMacro(P, PO, Q, T, MLb, Ty) = $applyTermMacro(P, PO, Q, T, MLb, Ty) .
  ceq $applyTermMacro(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, PO, Q, T, MLb, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if [ PrL', PO' ] := $applyTermMacro*(PrL, PO, Q, T, MLb, Ty) .
  *** Case selection cvss: value (eq1) + seq seq (eq2)
  ceq $applyTermMacro(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO, Q, T, cvss, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if TL := buildVSS(M, Ty, "VSS" + natlist2string(NL)) /\
      ML := createModules(M, T, TL) /\
      PrL' := createCTFTerm(ML, NL, Q, EqS) /\
      PO' := indProofOrder(fst(PO), size(TL)) y pop(PO) .
  *** Case selection cvs: empty (eq1) + value seq (eq2)
  ceq $applyTermMacro(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO, Q, T, cvs, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if TL := buildEVS(M, Ty, "EVS" + natlist2string(NL)) /\
      TL' := joinConstantsEVS(TL, "EVS" + natlist2string(NL), 0) /\
      ML := createModules(M, T, TL') /\
      PrL' := createCTFTerm(ML, NL, Q, EqS) /\
      PO' := indProofOrder(fst(PO), size(TL')) y pop(PO) .
  *** Case selection csv: empty (eq1) + seq value (eq2)
  ceq $applyTermMacro(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO, Q, T, csv, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if TL := buildESV(M, Ty, "ESV" + natlist2string(NL)) /\
      TL' := joinConstantsESV(TL, "ESV" + natlist2string(NL), 0) /\
      ML := createModules(M, T, TL') /\
      PrL' := createCTFTerm(ML, NL, Q, EqS) /\
      PO' := indProofOrder(fst(PO), size(TL')) y pop(PO) .
  *** Case selection csvs: empty (eq1) + seq value seq (eq2)
  ceq $applyTermMacro(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO, Q, T, csvs, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if TL := buildSVS(M, Ty, "ESVS" + natlist2string(NL)) /\
      TL' := joinConstantsESV(TL, "ESVS" + natlist2string(NL), 0) /\
      ML := createModules(M, T, TL') /\
      PrL' := createCTFTerm(ML, NL, Q, EqS) /\
      PO' := indProofOrder(fst(PO), size(TL')) y pop(PO) .

  op joinConstantsEVS : TermList String Nat -> TermList .
  ceq joinConstantsEVS((TL, Q[C, T'], TL', Q[C', T'], TL''), St, N) =
                                            joinConstantsEVS((TL, Q[T'', T'], TL''), St, s(N))
   if Ty := getType(C) /\
      Ty := getType(C') /\
      T'' := qid(substr(string(Ty), 0, 1) + string(N, 10) + St + string(Ty) + "." + string(Ty)) .
  eq joinConstantsEVS(TL, St, N) = TL [owise] .

  op joinConstantsESV : TermList String Nat -> TermList .
  ceq joinConstantsESV((TL, Q[T', C], TL', Q[T', C'], TL''), St, N) =
                                            joinConstantsESV((TL, Q[T', T''], TL''), St, s(N))
   if Ty := getType(C) /\
      Ty := getType(C') /\
      T'' := qid(substr(string(Ty), 0, 1) + string(N, 10) + St + string(Ty) + "." + string(Ty)) .
  eq joinConstantsESV(TL, St, N) = TL [owise] .

  op buildVSS : Module Type String -> TermList .
  ceq buildVSS(M, Ty, St) = TL', TL
   if ODS := getExactCtors(M, Ty) /\
      TL := buildTermsCtors(ODS, "VSS") /\
      SS := lesserSorts(M, Ty) /\
      TL' := buildTermsOrFreshConst(M, SS, St + "Sub") .

  op buildEVS : Module Type String -> TermList .
  ceq buildEVS(M, Ty, St) = combineEVS(TL, TL')
   if ODS := getExactCtors(M, Ty) /\
      TL := buildTermsCtors(ODS, St) /\
      SS := lesserSorts(M, Ty) /\
      TL' := buildTermsOrFreshConst(M, SS, St + "Sub") .

  op combineEVS : TermList TermList ~> TermList .
  eq combineEVS((C, T), TL) = C, putTogetherEVS(T, TL) .
  eq combineEVS((T, C), TL) = C, putTogetherEVS(T, TL) .

  op buildESV : Module Type String -> TermList .
  ceq buildESV(M, Ty, St) = combineESV(TL, TL')
   if ODS := getExactCtors(M, Ty) /\
      TL := buildTermsCtors(ODS, St) /\
      SS := lesserSorts(M, Ty) /\
      TL' := buildTermsOrFreshConst(M, SS, St + "Sub") .

  op combineESV : TermList TermList ~> TermList .
  eq combineESV((C, T), TL) = C, putTogetherESV(T, TL) .
  eq combineESV((T, C), TL) = C, putTogetherESV(T, TL) .

  op buildSVS : Module Type String -> TermList .
  ceq buildSVS(M, Ty, St) = combineSVS(TL, TL'', TL')
   if ODS := getExactCtors(M, Ty) /\
      TL := buildTermsCtors(ODS, St + "L") /\
      TL' := buildTermsCtors(ODS, St + "R") /\
      SS := lesserSorts(M, Ty) /\
      TL'' := buildTermsOrFreshConst(M, SS, St + "Sub") .

  op combineSVS : TermList TermList TermList ~> TermList .
  eq combineSVS(TL, (C, T), TL') = C, putTogetherESV(T, TL) .
  eq combineSVS(TL, (T, C), TL') = C, putTogetherESV(T, TL) .

  op putTogetherEVS : Term TermList -> TermList .
  eq putTogetherEVS(T, empty) = empty .
  eq putTogetherEVS(Q[T, T'], (T1, TL)) = Q[T1, T'], putTogetherEVS(Q[T, T'], TL) .

  op putTogetherESV : Term TermList -> TermList .
  eq putTogetherESV(T, empty) = empty .
  eq putTogetherESV(Q[T, T'], (T1, TL)) = Q[T, T1], putTogetherESV(Q[T, T'], TL) .

  op putTogetherSVS : TermList Term TermList -> TermList .
  eq putTogetherSVS(empty, T, empty) = empty .
  eq putTogetherSVS((T1, TL), Q[T, T'], (T2, TL')) = Q[T1, T, T2],
                                                     putTogetherSVS(TL, Q[T, T'], TL') .

  op buildTermsOrFreshConst : Module SortSet String -> TermList .
  eq buildTermsOrFreshConst(M, none, St) = empty .
  ceq buildTermsOrFreshConst(M, Srt ; SS, St) = TL, buildTermsOrFreshConst(M, SS, St)
   if ODS := getExactCtors(M, Srt) /\
      ODS =/= none /\
      TL := buildTermsCtors(ODS, St) .
  ceq buildTermsOrFreshConst(M, Srt ; SS, St) = T, buildTermsOrFreshConst(M, SS, St)
   if getExactCtors(M, Srt) == none /\
      T := qid(St + string(Srt) + "." + string(Srt)) .



  op $applyTermMacro : ProofTree ProofOrder Qid Term MacroLabel Type -> IndResPair .
  eq $applyTermMacro(mtPT, PO, Q, T, MLb, Ty) = [mtPT, finished] .

  op $applyTermMacro* : ProofTreeList ProofOrder Qid Term Type -> IndResPair .
  eq $applyTermMacro*(mtPT, PO, Q, T, Ty) = [mtPT, finished] .
  ceq $applyTermMacro*(| M', G, PrL, N | PrL', PO, Q, T, Ty) = [PrL1 PrL2, PO' y PO'']
   if [PrL1, PO'] := $applyTermMacro(| M', G, PrL, N |, PO, Q, T, Ty) /\
      [PrL2, PO''] := $applyTermMacro*(PrL', PO, Q, T, Ty) .

  op $applyTermMacro* : ProofTreeList ProofOrder Qid Term MacroLabel Type -> IndResPair .
  eq $applyTermMacro*(mtPT, PO, Q, T, MLb, Ty) = [mtPT, finished] .
  ceq $applyTermMacro*(| M', G, PrL, N | PrL', PO, Q, T, MLb, Ty) = [PrL1 PrL2, PO' y PO'']
   if [PrL1, PO'] := $applyTermMacro(| M', G, PrL, N |, PO, Q, T, MLb, Ty) /\
      [PrL2, PO''] := $applyTermMacro*(PrL', PO, Q, T, MLb, Ty) .

  sort MList .
  subsort Module < MList .

  op mtML : -> MList [ctor] .
  op _._ : MList MList -> MList [ctor assoc id: mtML] .

  op ordTrueFalse : TermList -> TermList .
  eq ordTrueFalse(('false.Bool, 'true.Bool)) = 'true.Bool, 'false.Bool .
  eq ordTrueFalse(TL) = TL [owise] .

  op createModules : Module Term TermList -> MList .
  eq createModules(M, T, empty) = mtML .
  ceq createModules(M, T, ('true.Bool, TL)) = addHyp(M, Eq) . createModules(M, T, TL)
   if '_=_[T1, T2] := T /\
      Eq := eq T1 = T2 [metadata("CTF-true")] . .
  ceq createModules(M, T, (T', TL)) = addHyp(addCons(M, T'), Eq) . createModules(M, T, TL)
   if STR := createName(T') /\
      Eq := eq T = T' [metadata(STR)] . [owise] .

  op createName : Term -> String .
  eq createName(C) = "CTF-" + string(getName(C)) .
  eq createName(V) = "CTF-" + string(getName(V)) .
  eq createName(Q[TL]) = "CTF-" + string(Q) .

  op createCTFTerm : MList NatList Qid EquationSet -> ProofTreeList .
  eq createCTFTerm(ML, NL, Q, EqS) = $createCTFTerm(ML, NL, Q, EqS, 1) .

  op $createCTFTerm : MList NatList Qid EquationSet Nat -> ProofTreeList .
  eq $createCTFTerm(mtML, NL, Q, EqS, N) = mtPT .
  eq $createCTFTerm(M . ML, NL, Q, EqS, N) = | M, [NL N, Q, EqS, N == 1, false], mtPT, 1 |
                                             $createCTFTerm(ML, NL, Q, EqS, s(N)) .

  ************************************************************************************
  ************************************ TERM MACRO ************************************
  ************************************************************************************

  op parseTermMacro : ProofTree Qid Term -> Macros .
  eq parseTermMacro(mtPT, Q, T) = mtMacros .
  eq parseTermMacro(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, Q, T) =
          parseTermMacro*(PrL, Q, T) .
  eq parseTermMacro(| M, [NL, CMD, EqS, true, PRVN], PrL, N' |, Q, T) =
          parseTermMacro(M, Q, T) .

  op parseTermMacro* : ProofTreeList Qid Term -> Macros .
  eq parseTermMacro*(mtPT, Q, T) = mtMacros .
  eq parseTermMacro*(| M', G, PrL, N | PrL', Q, T) = parseTermMacro(| M', G, PrL, N |, Q, T)
                                                     parseTermMacro*(PrL', Q, T) .

  op parseTermMacro : Module Qid Term -> Macros .
  ceq parseTermMacro(M, Q, '__[TL, ''..Qid]) = if T? :: Term
                                          then # M, Q - T? #
                                          else parseTermMacro(M, Q, '__[TL])
                                          fi
   if T? := getTerm(metaParse(M, downQidList('__[TL, '.]), anyType)) .
  ceq parseTermMacro(M, Q, T) = if T? :: Term
                                then # M, Q - T? #
                                else mtMacros
                                fi
   if T? := getTerm(metaParse(M, downQidList(T), anyType)) [owise] .

  ************************************************************************************
  ****************************** SIMULTANEOUS INDUCTION ******************************
  ************************************************************************************

  sort IndResPair .
  op [_,_] : ProofTreeList ProofOrder -> IndResPair [ctor] .

  op applyInduction : ProofTree Variable ProofOrder -> IndResPair .
  eq applyInduction(mtPT, V, PO) = [mtPT, finished] .
  ceq applyInduction(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, V, PO) =
                          [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if [PrL', PO'] := applyInduction*(PrL, V, PO) .
  ceq applyInduction(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, V, PO) =
                          [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if ODS := getCtors(M, getType(V)) /\
      TL := buildTermsCtors(ODS, "") /\
      Ty := getType(V) /\
      PO' := indProofOrder(fst(PO), size(TL)) y pop(PO) /\
      PrL' := subGoal*(M, [NL, CMD, EqS, true, PRVN], V, Ty, TL, NL, 1) .

  op applyInduction* : ProofTreeList Variable ProofOrder -> IndResPair .
  eq applyInduction*(mtPT, V, PO) = [mtPT, finished] .
  ceq applyInduction*(| M', G, PrL, N | PrL', V, PO) = [P' P'', PO' y PO'']
   if [P', PO'] := applyInduction(| M', G, PrL, N |, V, PO) /\
      [P'', PO''] := applyInduction*(PrL', V, PO) .

  op subGoal* : Module Goal Variable Type TermList NatList Nat -> ProofTreeList .
  eq subGoal*(M, G, V, Ty, empty, NL, N) = mtPT .
  eq subGoal*(M, G, V, Ty, (T, TL), NL, N) = subGoal(M, getEq(G), V, Ty, T, NL, N)
                                             subGoal*(M, G, V, Ty, TL, NL, s(N)) .

  op subGoal : Module EquationSet Variable Type Term NatList Nat -> ProofTree .
  ceq subGoal(M, EqS, V, Ty, T, NL, N) =
            | addCons(M', T), [NL N, 'SI, makeSub(EqS, V, T), N == 1, false], mtPT, 1 |
   if TL := getConstsOfSort(M, T, Ty) /\
      EqS' := createHI(EqS, V, TL) /\
      M' := addHyp(M, EqS') .

  op getConstsOfSort : Module Term Type -> TermList .
  eq getConstsOfSort(M, Q[TL], Ty) = getConstsOfSort*(M, TL, Ty) .
  eq getConstsOfSort(M, T, Ty) = empty [owise] .

  op $getConstsOfSort : Module Term Type -> TermList .
  eq $getConstsOfSort(M, Q[TL], Ty) = getConstsOfSort*(M, TL, Ty) .
  ceq $getConstsOfSort(M, C, Ty) = C
   if Ty' := getType(C) /\
      sameKind(M, Ty', Ty) /\
      sortLeq(M, Ty', Ty) .
  eq $getConstsOfSort(M, T, Ty) = empty [owise] .

  op getConstsOfSort* : Module TermList Type -> TermList .
  eq getConstsOfSort*(M, empty, Ty) = empty .
  eq getConstsOfSort*(M, (T, TL), Ty) = $getConstsOfSort(M, T, Ty),
                                        getConstsOfSort*(M, TL, Ty) .

  *** We make sure not to add constant constructors by skipping them at first.
  op addCons : Module Term -> Module .
  ceq addCons(M, C) = M
   if Q := getName(C) /\
      Ty := getType(C) /\
      op Q : TyL -> Ty [AtS] . ODS := getOps(M) .
  eq addCons(M, T) = $addCons(M, T) [owise] .

  op $addCons : Module Term -> Module .
  eq $addCons(M, V) = M .
  ceq $addCons(M, C) = M
   if definedConst(M, C) .
  ceq $addCons(M, C) = addOp(M, OD)
   if not definedConst(M, C) /\
      OD := op getName(C) : nil -> getType(C) [metadata("generated-si")] . .
  eq $addCons(M, Q[TL]) = $addCons*(M, TL) .

  op $addCons* : Module TermList -> Module .
  eq $addCons*(M, empty) = M .
  eq $addCons*(M, (T, TL)) = $addCons*($addCons(M, T), TL) .

  op definedConst : Module Constant -> Bool .
  ceq definedConst(M, C) = true
   if Q := getName(C) /\
      Ty := getType(C) /\
      op Q : TyL -> Ty [AtS] . ODS := getOps(M) .
  eq definedConst(M, C) = false [owise] .

  op makeSub : EquationSet Variable Term -> EquationSet .
  eq makeSub(none, V, T) = none .
  eq makeSub(eq T = T' [AtS] . EqS, V, T1) =
         eq subTerm(T, V, T1) = subTerm(T', V, T1) [AtS] .
         makeSub(EqS, V, T1) .
  eq makeSub(ceq T = T' if COND [AtS] . EqS, V, T1) =
         ceq subTerm(T, V, T1) = subTerm(T', V, T1) if subCond(COND, V, T1) [AtS] .
         makeSub(EqS, V, T1) .

  op createHI : EquationSet Variable TermList -> EquationSet .
  eq createHI(none, V, TL) = none .
  eq createHI(Eq EqS, V, TL) = $createHI(Eq, V, TL)
                               createHI(EqS, V, TL) .

  op $createHI : Equation Variable TermList -> EquationSet .
  eq $createHI(Eq, V, empty) = none .
  eq $createHI(eq T = T' [AtS] ., V, (T1, TL)) =
        eq subTerm(T, V, T1) = subTerm(T', V, T1) [metadata("HI") AtS] .
        $createHI(eq T = T' [AtS] ., V, TL) .
  eq $createHI(ceq T = T' if COND [AtS] ., V, (T1, TL)) =
         ceq subTerm(T, V, T1) = subTerm(T', V, T1)
          if subCond(COND, V, T1) [metadata("HI") AtS] .
        $createHI(ceq T = T' if COND [AtS] ., V, TL) .

  op subTerm : Term Variable Term -> Term .
  eq subTerm(Q[TL], V, T) = Q[subTermList(TL, V, T)] .
  eq subTerm(V, V, T) = T .
  eq subTerm(T, V, T') = T [owise] .

  op subTermList : TermList Variable Term -> TermList .
  eq subTermList(empty, V, T) = empty .
  eq subTermList((T, TL), V, T') = subTerm(T, V, T'), subTermList(TL, V, T') .

  op subCond : Condition Variable Term -> Condition .
  eq subCond(nil, V, T) = nil .
  eq subCond(T = T' /\ COND, V, T1) = subTerm(T, V, T1) = subTerm(T', V, T1) /\
                                      subCond(COND, V, T1) .
  eq subCond(T : Srt /\ COND, V, T1) = subTerm(T, V, T1) : Srt /\
                                       subCond(COND, V, T1) .
  eq subCond(T := T' /\ COND, V, T1) = subTerm(T, V, T1) := subTerm(T', V, T1) /\
                                       subCond(COND, V, T1) .
  eq subCond(T => T' /\ COND, V, T1) = subTerm(T, V, T1) => subTerm(T', V, T1) /\
                                       subCond(COND, V, T1) .

  op buildArgs : TypeList TermList String -> TermList .
  eq buildArgs(nil, TL, STR) = empty .
  ceq buildArgs(Ty TyL, TL, STR) = (C, TL')
   if C := buildArg(Ty, TL, STR) /\
      TL' := buildArgs(TyL, (C, TL), STR) .

  op buildArg : Type TermList String -> TermList .
  ceq buildArg(Ty, (TL, C, TL'), St) = $buildArg(Ty, (TL, TL'), St, 0)
   if STR := string(Ty) /\
      C := qid(substr(STR, 0, 1) +  "#" + St + STR + "." + STR) .
  ceq buildArg(Ty, TL, St) = C
   if STR := string(Ty) /\
      C := qid(substr(STR, 0, 1) + "#" + St + STR + "." + STR) [owise] .

  op $buildArg : Type TermList String Nat -> TermList .
  ceq $buildArg(Ty, (TL, C, TL'), St, N) = $buildArg(Ty, (TL, TL'), St, s(N))
   if STR := string(Ty) /\
      C := qid(substr(STR, 0, 1) + string(N, 10) + "#" + St + STR + "." + STR) .
  ceq $buildArg(Ty, TL, St, N) = C
   if STR := string(Ty) /\
      C := qid(substr(STR, 0, 1) + string(N, 10) + "#" + St + STR + "." + STR) [owise] .

  op indProofOrder : NatList Nat -> ProofOrder .
  eq indProofOrder(NL, s(N)) = indProofOrder(NL, N) y NL s(N) .
  eq indProofOrder(NL, 0) = finished .

  sort Vars2ConsPair .
  op [_,_] : Equation Module -> Vars2ConsPair [ctor] .
  op [_,_] : TermList Module -> Vars2ConsPair [ctor] .
  op [_,_] : Condition Module -> Vars2ConsPair [ctor] .

  ***********************************************************************************
  ***************************** APPLY IMPLIES SUBSTITUTION **************************
  ***********************************************************************************

  op applyImp : ProofTree Qid Substitution -> ProofBool .
  eq applyImp(mtPT, Q, SB) = [mtPT, false] .
  ceq applyImp(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, Q, SB) =
                           [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, B]
   if [PrL', B] := applyImp*(PrL, Q, SB) .
  ceq applyImp(| M, [NL, CMD, Eq, true, PRVN], mtPT, N' |, Q, SB) = [PrL', B]
   if [PrL', B] := applyImp(M, Eq, Q, NL, SB) .

  op applyImp* : ProofTreeList Qid Substitution -> ProofBool .
  eq applyImp*(mtPT, Q, SB) = [mtPT, false] .
  ceq applyImp*(| M', G, PrL, N | PrL', Q, SB) = [PrL1 PrL2, B or B']
   if [PrL1, B] := applyImp(| M', G, PrL, N |, Q, SB) /\
      [PrL2, B'] := applyImp*(PrL', Q, SB) .

  op applyImp : Module Equation Qid NatList Substitution -> ProofBool .
  ceq applyImp(M, Eq, Q, NL, SB) = [| M, [NL, 'imp, Eq', true, false], mtPT, 1 |, true]
   if eq T = 'true.Bool [label(Q) AtS] . EqS := getEqs(M) /\
      ODS := getOps(M) /\
      Eq' := impEq(M, Eq, substitute(T, SB)) .
  eq applyImp(M, Eq, Q, N, SB) = [mtPT, false] [owise] .

  op substitute : Term Substitution -> Term .
  eq substitute(Q[TL], SB) = Q[substitute*(TL, SB)] .
  eq substitute(C, SB) = C .
  eq substitute(V, V <- T ; SB) = T .
  eq substitute(T, SB) = T [owise] .

  op substitute* : TermList Substitution -> TermList .
  eq substitute*(empty, SB) = empty .
  eq substitute*((T, TL), SB) = substitute(T, SB), substitute*(TL, SB) .

  ***********************************************************************************
  ********************************** APPLY IMPLIES **********************************
  ***********************************************************************************

  op applyImp : ProofTree Qid -> ProofBool .
  eq applyImp(mtPT, Q) = [mtPT, false] .
  ceq applyImp(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, Q) =
                           [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, B]
   if [PrL', B] := $applyImp*(PrL, Q) .
  ceq applyImp(| M, [NL, CMD, Eq, true, PRVN], mtPT, N' |, Q) = [PrL', B]
   if [PrL', B] := applyImp(M, Eq, Q, NL) .

  op $applyImp* : ProofTreeList Qid -> ProofBool .
  eq $applyImp*(mtPT, Q) = [mtPT, false] .
  ceq $applyImp*(| M', G, PrL, N | PrL', Q) = [PrL1 PrL2, B or B']
   if [PrL1, B] := applyImp(| M', G, PrL, N |, Q) /\
      [PrL2, B'] := $applyImp*(PrL', Q) .

  op applyImp : Module Equation Qid NatList -> ProofBool .
  ceq applyImp(M, Eq, Q, NL) = [| M, [NL, 'imp, Eq', true, false], mtPT, 1 |, true]
   if eq T = 'true.Bool [label(Q) AtS] . EqS := getEqs(M) /\
      Eq' := impEq(M, Eq, T) .
  eq applyImp(M, EqS, Q, N) = [mtPT, false] [owise] .

  op impEq : Module Equation Term -> Equation .
  ceq impEq(M, eq T = 'true.Bool [AtS] ., T') = eq '_implies_[T1, T] = 'true.Bool [AtS] .
   if T1 := getTerm(metaReduce(M, T')) .
  ceq impEq(M, eq T = T' [AtS] ., T'') = eq '_implies_[T1, '_=_[T', T]] =
                                        'true.Bool [AtS] .
   if T1 := getTerm(metaReduce(M, T'')) [owise] .


  ************************************************************************************
  ******************************* THEOREM OF CONSTANTS *******************************
  ************************************************************************************

  op applyTC : ProofTree ProofOrder -> IndResPair .
  eq applyTC(P, PO) = $applyTC(P, PO) .

  op $applyTC : ProofTree ProofOrder -> IndResPair .
  eq $applyTC(mtPT, PO) = [mtPT, finished] .
  ceq $applyTC(| M', [NL, CMD, EqS, false, PRVN], PrL, N' |, PO) =
                         [| M', [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if [PrL', PO'] := $applyTC*(PrL, PO) .
  ceq $applyTC(| M', [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO) =
                         [| M', [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if PrL' := vars2cons*(EqS, M', NL, 1) /\
      PO' := indProofOrder(fst(PO), sizeEQS(EqS)) y pop(PO) .

  op $applyTC* : ProofTreeList ProofOrder -> IndResPair .
  eq $applyTC*(mtPT, PO) = [mtPT, finished] .
  ceq $applyTC*(| M', G, PrL, N | PrL', PO) = [P PrL'', PO' y PO'']
   if [P, PO'] := $applyTC(| M', G, PrL, N |, PO) /\
      [PrL'', PO''] := $applyTC*(PrL', PO) .

  op vars2cons* : EquationSet Module NatList Nat -> ProofTreeList .
  eq vars2cons*(none, M, NL, N) = mtPT .
  ceq vars2cons*(Eq EqS, M, NL, N) = | M', [NL N, 'TC, Eq', N == 1, false], mtPT, 1 |
                                     vars2cons*(EqS, M, NL, s(N))
   if [Eq', M'] := vars2cons(Eq, M) .

  op vars2cons : Equation Module -> Vars2ConsPair .
  ceq vars2cons(eq T = T' [AtS] ., M) = [eq T1 = T2 [AtS] ., M'']
   if [T1, M'] := vars2cons(T, M) /\
      [T2, M''] := vars2cons(T', M') .
  ceq vars2cons(ceq T = T' if COND [AtS] ., M) =
               [ceq T1 = T2 if CND [AtS] ., M''']
   if [T1, M'] := vars2cons(T, M) /\
      [T2, M''] := vars2cons(T', M') /\
      [CND, M'''] := vars2cons*(COND, M) .

  op vars2cons* : TermList Module -> Vars2ConsPair .
  eq vars2cons*(empty, M) = [empty, M] .
  ceq vars2cons*((T, TL), M) = [(T', TL'), M'']
   if [T', M'] := vars2cons(T, M) /\
      [TL', M''] := vars2cons*(TL, M') .

  op vars2cons : Term Module -> Vars2ConsPair .
  eq vars2cons(C, M) = [C, M] .
  ceq vars2cons(V, M) = [C, M']
   if STR := string(getType(V)) /\
      C := qid(string(getName(V)) + "@" + STR + "." + STR) /\
      OD := op getName(C) : nil -> getType(V) [metadata("tc")] . /\
      M' := addOp(M, OD) .
  ceq vars2cons(Q[TL], M) = [Q[TL'], M']
   if [TL', M'] := vars2cons*(TL, M) .

  op vars2cons* : Condition Module -> Vars2ConsPair .
  eq vars2cons*((nil).Condition, M) = [(nil).Condition, M] .
  ceq vars2cons*(T = T' /\ COND, M) = [T1 = T2 /\ CND, M''']
   if [T1, M'] := vars2cons(T, M) /\
      [T2, M''] := vars2cons(T', M') /\
      [CND, M'''] := vars2cons*(COND, M'') .
  ceq vars2cons*(T : Srt /\ COND, M) = [T1 : Srt /\ CND, M'']
   if [T1, M'] := vars2cons(T, M) /\
      [CND, M''] := vars2cons*(COND, M') .
  ceq vars2cons*(T := T' /\ COND, M) = [T1 := T2 /\ CND, M''']
   if [T1, M'] := vars2cons(T, M) /\
      [T2, M''] := vars2cons(T', M') /\
      [CND, M'''] := vars2cons*(COND, M'') .
  ceq vars2cons*(T => T' /\ COND, M) = [T1 => T2 /\ CND, M''']
   if [T1, M'] := vars2cons(T, M) /\
      [T2, M''] := vars2cons(T', M') /\
      [CND, M'''] := vars2cons*(COND, M'') .

  op sizeEQS : EquationSet -> Nat .
  eq sizeEQS(none) = 0 .
  eq sizeEQS(Eq EqS) = s(sizeEQS(EqS)) .

  ***********************************************************************************
  *********************************** SELECT GOAL ***********************************
  ***********************************************************************************

  op selectGoal : ProofTree NatList -> ProofTree .
  eq selectGoal(mtPT, NL) = mtPT .
  ceq selectGoal(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |, NL') =
                            | M, [NL, CMD, EqS, NL == NL', PRVN], PrL', N' |
   if PrL' := selectGoal*(PrL, NL') .

  op selectGoal* : ProofTreeList NatList -> ProofTreeList .
  eq selectGoal*(mtPT, NL) = mtPT .
  eq selectGoal*(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' | PrL', NL') =
       selectGoal(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |, NL') selectGoal*(PrL', NL') .

  op qid2natlist : Qid -> NatList .
  eq qid2natlist(Q) = str2natlist(string(Q)) .

  op str2natlist : String -> NatList .
  ceq str2natlist(S) = rat(substr(S, 0, N), 10) str2natlist(substr(S, N + 1, length(S)))
   if N := find(S, "-", 0) .
  eq str2natlist(S) = rat(S, 10) [owise] .

  op selectGoal : ProofOrder NatList -> ProofOrder .
  eq selectGoal(PO y NL y PO', NL) = NL y PO y PO' .
  eq selectGoal(PO, NL) = PO [owise] .

  op addOp : Module OpDecl -> Module .
  eq addOp(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm, OD) =
             fmod H is IL sorts SS . SSDS ODS OD MAS EqS endfm .
  eq addOp(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm, OD) =
             mod H is IL sorts SS . SSDS ODS OD MAS EqS RS endm .
  eq addOp(fth H is IL sorts SS . SSDS ODS MAS EqS endfth, OD) =
             fth H is IL sorts SS . SSDS ODS OD MAS EqS endfth .
  eq addOp(th H is IL sorts SS . SSDS ODS MAS EqS RS endth, OD) =
             th H is IL sorts SS . SSDS ODS OD MAS EqS RS endth .

  op addEqs : Term Term -> Term .
  eq addEqs('__[T1, T2], T) = '__[T1, addEqs(T2, T)] .
  eq addEqs(T, T') = '__[T, T'] [owise] .

  ************************************************************************************
  *********************************** GET NEW GOAL ***********************************
  ************************************************************************************

  op getNew : Module EquationSet EquationSet ~> ProofTree .
  eq getNew(M, Eq EqS, Eq EqS') = getNew(M, EqS, EqS') .
  ceq getNew(M, none, EqS) = setToGoal(M, EqS)
   if EqS =/= none .

  op setToGoal : Module EquationSet -> ProofTree .
  eq setToGoal(M, EqS) = | M, [nil, 'root, EqS, true, false], mtPT, 1 | .

  ************************************************************************************
  *********************************** REDUCE COMMAND *********************************
  ************************************************************************************

  sort ProofBool .
  op [_,_] : ProofTreeList Bool -> ProofBool [ctor] .

  op applyRed : ProofTree -> ProofBool .
  ceq applyRed(| M, [NL, CMD, EqS, true, PRVN], PrL, N' |) =
               [| M, [NL, CMD, EqS', not B, B], PrL, N' |, B]
   if [EqS', B] := reduceAll(M, EqS) .
  ceq applyRed(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |) =
                         [| M, [NL, CMD, EqS, false, PRVN], PrL', N' |, B]
   if [PrL', B] := applyRed*(PrL) .

  sort EquationReduction .
  op [_,_] : EquationSet Bool -> EquationReduction [ctor] .

  op reduceAll : Module EquationSet -> EquationReduction .
  eq reduceAll(M, none) = [none, true] .
  ceq reduceAll(M, eq T = T' [AtS] . EqS) = [Eq EqS', B and B']
   if T1 := getTerm(metaReduce(M, T)) /\
      T2 := getTerm(metaReduce(M, T')) /\
      B := T1 == T2 /\
      Eq := if B then eq T = T' [AtS] .
                 else eq T1 = T2 [AtS] .
                 fi /\
      [EqS', B'] := reduceAll(M, EqS) .

  op applyRed* : ProofTreeList -> ProofBool .
  eq applyRed*(mtPT) = [mtPT, false] .
  ceq applyRed*(| M, G, PrL, N' | PrL') = [P PrL'', B or B']
   if [P, B] := applyRed(| M, G, PrL, N' |) /\
      [PrL'', B'] := applyRed*(PrL') .

  op applyRed- : ProofTree -> ProofBool .
  ceq applyRed-(| M, [NL, CMD, eq T = T' [AtS] ., true, PRVN], PrL, N' |) =
               [| M, [NL, CMD, eq T = T' [AtS] ., not B, B], PrL, N' |, B]
   if T1 := getTerm(metaReduce(M, T)) /\
      T2 := getTerm(metaReduce(M, T')) /\
      B := T1 == T2 .
  ceq applyRed-(| M, [NL, CMD, Eq, false, PRVN], PrL, N' |) =
                         [| M, [NL, CMD, Eq, false, PRVN], PrL', N' |, B]
   if [PrL', B] := applyRed-*(PrL) .

  op applyRed-* : ProofTreeList -> ProofBool .
  eq applyRed-*(mtPT) = [mtPT, false] .
  ceq applyRed-*(| M, G, PrL, N' | PrL') = [P PrL'', B or B']
   if [P, B] := applyRed-(| M, G, PrL, N' |) /\
      [PrL'', B'] := applyRed-*(PrL') .

  **************************************************************************************
  *********************************** PRINT CURRENT ************************************
  **************************************************************************************

  op printCurrent : ProofTree -> QidList .
  eq printCurrent(mtPT) = nil .
  eq printCurrent(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |) =
                                   '\n CMD ' printEqS(M, EqS, ' ) '\n .
  eq printCurrent(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |) = printCurrent*(PrL) [owise] .

  op printCurrent* : ProofTreeList -> QidList .
  eq printCurrent*(mtPT) = nil .
  eq printCurrent*(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' | PrL') =
         printCurrent(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |) printCurrent*(PrL') .

  ************************************************************************************
  *********************************** PRINT PROOF ************************************
  ************************************************************************************

  op printProofTree : ProofTree -> QidList .
  eq printProofTree(P) = $printProofTree(P, 0) .

  op $printProofTree : ProofTree Nat -> QidList .
  eq $printProofTree(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N |, N') =
                               printPremises(M, N')
                               '\n printTab(N') printIndex(NL)
                               if PRVN then '* else nil fi
                               if CURR then '> else nil fi
                               CMD '
                               printEqS(M, EqS, printTab(N'))
                               $printProofTree*(PrL, s(N')) .

  op $printProofTree* : ProofTreeList Nat -> QidList .
  eq $printProofTree*(mtPT, N) = nil .
  eq $printProofTree*(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N | PrL', N') =
                       $printProofTree(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N |, N')
                       $printProofTree*(PrL', N') .

  op printTab : Nat -> QidList .
  eq printTab(0) = nil .
  eq printTab(s(N)) = '\t printTab(N) .

  ***********************************************************************************
  ********************************* PRINT PREMISES **********************************
  ***********************************************************************************

  op printPremises : Module Nat -> QidList .
  eq printPremises(M, N) = printPremises(M, getEqs(M), N) .

  op printPremises : Module EquationSet Nat -> QidList .
  ceq printPremises(M, eq T = T' [metadata(S) AtS] . EqS, N) =
        '\n printTab(N) '-- 'Assumption:
        '\n printTab(N) printEq(M, eq T = T' [metadata(S) AtS] .)
        printPremises(M, EqS, N)
   if S == "generated-si" or
      S == "HI" or
      find(S, "CTF", 0) =/= notFound .
  eq printPremises(M, EqS, N) = nil [owise] .

  *************************************************************************************
  *********************************** PRINT LEAVES ************************************
  *************************************************************************************

  op printGoals : ProofTree -> QidList .
  eq printGoals(mtPT) = nil .
  eq printGoals(| M, [NL, CMD, EqS, CURR, PRVN], mtPT, N' |) =
                                   '\n printIndex(NL)
                                   if PRVN then '* else nil fi
                                   if CURR then '> else nil fi
                                   CMD '
                                   printEqS(M, EqS, ') .
  eq printGoals(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |) = printGoals*(PrL) [owise] .

  op printGoals* : ProofTreeList -> QidList .
  eq printGoals*(mtPT) = nil .
  eq printGoals*(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' | PrL') =
         printGoals(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |) printGoals*(PrL') .

  op printIndex : NatList -> QidList .
  eq printIndex(nil) = nil .
  eq printIndex(NL) = qid(natlist2string(NL)) .

  op natlist2string : NatList -> String .
  eq natlist2string(nil) = "" .
  eq natlist2string(N) = string(N, 10) + "." .
  eq natlist2string(N NL) = string(N, 10) + "-" + natlist2string(NL) [owise] .

  op printEqS : Module EquationSet QidList -> QidList .
  eq printEqS(M, none, QIL) = nil .
  eq printEqS(M, Eq EqS, QIL) = printEq(M, Eq) '\n QIL printEqS(M, EqS, QIL) .

  op printEq : Module EquationSet -> QidList .
  eq printEq(M, eq T = T' [label(Q) nonexec] .) = 'eq ' '`[ Q ':nonexec '`] ':
                                                      metaPrettyPrint(M, T, po) ' '=
                                                      metaPrettyPrint(M, T', po) '. .
  eq printEq(M, eq T = T' [label(Q)] .) = 'eq ' '`[ Q '`] ':
                                              metaPrettyPrint(M, T, po) ' '=
                                              metaPrettyPrint(M, T', po) '. .
  eq printEq(M, eq T = T' [nonexec] .) = 'eq ' '`[ ':nonexec '`] ':
                                             metaPrettyPrint(M, T, po) ' '=
                                             metaPrettyPrint(M, T', po) '. .
  eq printEq(M, eq T = T' [metadata(S) AtS] .) = printEq(M, eq T = T' [AtS] .) .
  eq printEq(M, eq T = T' [none] .) = 'eq metaPrettyPrint(M, T, po) ' '=
                                          metaPrettyPrint(M, T', po) '. .
  eq printEq(M, ceq T = T' if COND [label(Q) nonexec] .) =
                    'ceq ' '`[ Q ':nonexec '`] ': metaPrettyPrint(M, T, po) ' '=
                                                 metaPrettyPrint(M, T', po) '. .
  eq printEq(M, ceq T = T' if COND [label(Q)] .) =
                    'ceq ' '`[ Q '`] ': metaPrettyPrint(M, T, po) ' '=
                                        metaPrettyPrint(M, T', po) '. .
  eq printEq(M, ceq T = T' if COND [nonexec] .) =
                    'ceq ' '`[ ':nonexec '`] ': metaPrettyPrint(M, T, po) ' '=
                                                metaPrettyPrint(M, T', po) '. .

  ************************************************************************************
  *********************************** INFER PROOF ************************************
  ************************************************************************************

  op inferProof : Module Qid ScoreInfoSet Macros -> QidList .
  ceq inferProof(M, Q, SIS, MACS) = printProof(M, Q, Q', TL, QIL)
   if Q' := getNameProofScore(SIS) /\
      TL := inferGoal(SIS) /\
      EqS := goalEqS(TL, Q, 0) /\
      P := | M, [nil, 'root, EqS, true, false], mtPT, 1 | /\
      QIL := developProof(P, nil, SIS, MACS) [print "Generate proof without goal"] .
  eq inferProof(M, Q, SIS, MACS) = '\n '\! '\r 'Error 'while
                                   'generating 'proof '\o '\n [owise] .

  op inferWithGoalProof : Module Qid ScoreInfoSet Macros -> QidList .
  ceq inferWithGoalProof(M, Q, SIS, MACS) = printProof(M, Q, Q', TL, QIL)
   if Q' := getNameProofScore(SIS) /\
      (V, TL) := getGoal(SIS) /\
      EqS := goalEqS(TL, Q, 0) /\
      P := | M, [nil, 'root, EqS, true, false], mtPT, 1 | /\
      [P', PO] := applyInduction(P, V, nil) /\
      QIL := '\t ':ind 'on ' '`( metaPrettyPrint(M, V, po) '`) '\n '\n
             '\t ':apply '`( 'si '`) '\n '\n
             developProof(P', PO, noScoreInfo, MACS) [print "Induction " V " Terms\n" TL] .
  eq inferWithGoalProof(M, Q, SIS, MACS) = '\n '\! '\r 'Error 'while
                                   'generating 'proof '\o '\n [print owise] .

  op getGoal : ScoreInfoSet -> TermList .
  ceq getGoal($ M, M', (T, TL)$ SIS) = V, $getGoal($ M, M', (T, TL)$ SIS)
   if V := getVars(T) .

  op $getGoal : ScoreInfoSet -> TermList .
  eq $getGoal(noScoreInfo) = empty .
  eq $getGoal($ M, M', empty $ SIS) = $getGoal(SIS) .
  eq $getGoal($ M, M', (T, TL)$ SIS) = getGoal(T),
                                       $getGoal($ M, M', TL $ SIS) .

  op getGoal : Term -> Term .
  eq getGoal(V) = V .
  eq getGoal(C) = qid(string(getName(C)) + ":" + string(getType(C))) .
  eq getGoal(Q[TL]) = Q[getGoal*(TL)] .

  op getGoal* : TermList -> TermList .
  eq getGoal*(empty) = empty .
  eq getGoal*((T, TL)) = getGoal(T), getGoal*(TL) .

  op goalEqS : TermList Qid Nat -> EquationSet .
  eq goalEqS(empty, Q, N) = none .
  ceq goalEqS((T, TL), Q, N) = eq T = 'true.Bool [label(Q') nonexec] .
                               goalEqS(TL, Q, s(N))
   if Q' := if N == 0
            then Q
            else qid(string(Q) + string(N, 10))
            fi .

  op developProof : ProofTree ProofOrder ScoreInfoSet Macros -> QidList .
  eq developProof(P, finished, SIS, MACS) = nil .
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS)
   if eq T = 'true.Bool [AtS] . EqS := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      V := indRequired(SIS, M, T) /\
      [P', PO'] := applyInduction(P, V, NL y PO) /\
      QIL := '\t ':ind 'on ' '`( metaPrettyPrint(M, V, po) '`) '\n '\n
             '\t ':apply '`( 'si '`) '\n '\n [print "Induction"] .
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS)
   if eq T = 'true.Bool [AtS] . EqS := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      (tcRequired(T) or EqS =/= none) /\
      [P', PO'] := applyTC(P, NL y PO) /\
      QIL := '\t ':apply '`( 'tc '`) '\n '\n [print "Theorem of constants"] .
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P'', PO', SIS2, MACS)
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      [true, SIS2] := redRequired(SIS, M, T) /\
      [P', B] := applyRed(P) /\
      PO' := if B
             then PO
             else NL y PO
             fi /\
      B' := PO' == finished /\
      P'' := if B and (not B')
             then selectGoal(P', fst(PO'))
             else P'
             fi /\
      QIL := '\t ':apply ' '`( 'rd '`) '\n '\n [print "Red\n"] .

  -----------------------------------------------------------------------------------
  ---                          developProof -> csv                                ---
  -----------------------------------------------------------------------------------
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS')
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      [false, SIS] := redRequired(SIS, M, T) /\
      T1 := cesvRequired(SIS, M, T) /\
      Ty := getType(metaNormalize(M, T1)) /\
      | MACS', Q | := addNewMac(MACS, M, T1, csv) /\
      [P', PO'] := applyTermMacro(P, NL y PO, Q, T1, csv, Ty) /\
      QIL := printCESV(M, Q, T1) [print NL " Termino csv: " T1 "\n"] .

  -----------------------------------------------------------------------------------
  ---                          developProof -> cvs                                ---
  -----------------------------------------------------------------------------------
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS')
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      [false, SIS] := redRequired(SIS, M, T) /\
      cesvRequired(SIS, M, T) == empty /\
      T1 := cevsRequired(SIS, M, T) /\
      Ty := getType(metaNormalize(M, T1)) /\
      | MACS', Q | := addNewMac(MACS, M, T1, cvs) /\
      [P', PO'] := applyTermMacro(P, NL y PO, Q, T1, cvs, Ty) /\
      QIL := printCEVS(M, Q, T1) [print NL " Termino cvs: " T1 "\n"] .

  -----------------------------------------------------------------------------------
  ---                          developProof -> csvs                                ---
  -----------------------------------------------------------------------------------
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS')
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      [false, SIS] := redRequired(SIS, M, T) /\
      cesvRequired(SIS, M, T) == empty /\
      cevsRequired(SIS, M, T) == empty /\
      T1 := csvsRequired(SIS, M, T) /\
      Ty := getType(metaNormalize(M, T1)) /\
      | MACS', Q | := addNewMac(MACS, M, T1, cvs) /\
      [P', PO'] := applyTermMacro(P, NL y PO, Q, T1, cvs, Ty) /\
      QIL := printCEVS(M, Q, T1) [print NL " Termino csvs: " T1 "\n"] .

  -----------------------------------------------------------------------------------
  ---                       developProof -> ctfTerm                               ---
  -----------------------------------------------------------------------------------
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS')
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      [false, SIS] := redRequired(SIS, M, T) /\
      cesvRequired(SIS, M, T) == empty /\
      cevsRequired(SIS, M, T) == empty /\
      csvsRequired(SIS, M, T) == empty /\
      T1 := ctfTermRequired(SIS, M, T) /\
      Ty := getType(metaNormalize(M, T1)) /\
      | MACS', Q | := addNewMac(MACS, M, T1) /\
      [P', PO'] := applyTermMacro(P, NL y PO, Q, T1, Ty) /\
      QIL := printCtfTermComm(M, Q, T1) [print NL " Term case split " T1] .

  -----------------------------------------------------------------------------------
  ---                          developProof -> ctf                                ---
  -----------------------------------------------------------------------------------
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS')
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      [false, SIS] := redRequired(SIS, M, T) /\
      cesvRequired(SIS, M, T) == empty /\
      cevsRequired(SIS, M, T) == empty /\
      csvsRequired(SIS, M, T) == empty /\
      ctfTermRequired(SIS, M, T) == empty /\
      Eq := ctfRequired(SIS, M, T) /\
      | MACS', Q | := addNewMac(MACS, M, Eq) /\
      P' := applyEquationMacro(P, Q, Eq) /\
      PO' := indProofOrder(NL, 2) y PO /\
      QIL := printCtfComm(M, Q, Eq) [print NL " Case split by " Eq] .

  -----------------------------------------------------------------------------------
  ---                          developProof -> imp                                ---
  -----------------------------------------------------------------------------------
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', NL y PO, SIS, MACS)
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      [false, SIS] := redRequired(SIS, M, T) /\
      cesvRequired(SIS, M, T) == empty /\
      cevsRequired(SIS, M, T) == empty /\
      csvsRequired(SIS, M, T) == empty /\
      ctfTermRequired(SIS, M, T) == empty /\
      ctfRequired(SIS, M, T) == none /\
      | Q, SB | := impRequired(SIS, M, T) /\
      [P', B] := if SB == none
                 then applyImp(P, Q)
                 else applyImp(P, Q, SB)
                 fi /\
      B' := P == P' /\
      QIL := if SB == none
             then '\t ':imp ' '`[ Q '`] ' '. '\n '\n
             else '\t ':imp ' '`[ Q '`] ' 'by ' '`{ printSub(SB) '`} '\n '\n
             fi [print "Imp"] .
  eq developProof(P, NL y PO, SIS, MACS) = inferNewProof(P, NL y PO, SIS, MACS)
                           [owise print "Try reduction and implication for " NL] .

  -------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------
  ---                               inferNewProof                                   ---
  ---                                                                               ---
  --- This function tries to generate proofs that are not given by the proof        ---
  --- scores. It first tries to infer "forgotten" nodes, that is, those proof       ---
  --- scores that are implicitly required because of the rest of scores (e.g. in    ---
  --- case splitting the rest of cases are given).                                  ---
  ---                                                                               ---
  -------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------

  -------------------------------------------------------------------------------------
  ---                        inferNewProof -> red                                   ---
  --- We take into account that induction and TC are forced in the previous step.   ---
  -------------------------------------------------------------------------------------
  op inferNewProof : ProofTree ProofOrder ScoreInfoSet Macros -> QidList .
  ceq inferNewProof(P, NL y PO, SIS, MACS) = QIL developProof(P'', PO, SIS, MACS)
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      redForgotten(M, T) /\
      [P', true] := applyRed(P) /\
      B' := PO == finished /\
      P'' := if not B'
             then selectGoal(P', fst(PO))
             else P'
             fi /\
      QIL := '\t '*** 'The 'corresponding 'proof 'score 'was 'not 'present. '\n
             '\t ':apply ' '`( 'rd '`) '\n '\n [print "Red forgotten\n"] .
  ceq inferNewProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO, SIS, MACS)
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      not redForgotten(M, T) /\
      TL := getHypotheses(M) /\
      [IPL, true] := tryImplication(M, T, TL) /\
      QIL := printImpCom(IPL) /\
      B := PO == finished /\
      P' := if not B
            then selectGoal(P, fst(PO))
            else P
            fi [print "Imp forgotten\n"] .
  eq inferNewProof(P, NL y PO, SIS, MACS) =
                 createNewProof(P, NL y PO, SIS, MACS, backtrackLevels) [owise print "Infer proof for " NL] .

  ---------------------------------------------------------------------------------------
  ---                                createNewProof                                   ---
  --- The last argument indicates the maximum depth available when trying.            ---
  --- It returns either a proof or nil when the proof is not possible.                ---
  ---------------------------------------------------------------------------------------
  op createNewProof : ProofTree ProofOrder ScoreInfoSet Macros Nat -> QidList .
  eq createNewProof(P, PO, SIS, MACS, 0) = nil .
  eq createNewProof(P, finished, SIS, MACS, N) = nil .
  -------------------------------------------------------------------------------------
  ---                                reduction                                      ---
  -------------------------------------------------------------------------------------
  ceq createNewProof(P, NL y PO, SIS, MACS, s(N)) = QIL''
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      redForgotten(M, T) /\
      [P', true] := applyRed(P) /\
      B' := PO == finished /\
      P'' := if not B'
             then selectGoal(P', fst(PO))
             else P'
             fi /\
      QIL   := '\t '*** 'The 'corresponding 'proof 'score 'was 'not 'present. '\n
               '\t ':apply ' '`( 'rd '`) '\n '\n /\
      QIL'  := createNewProof(P'', PO, SIS, MACS, s(N)) /\
      QIL'' := if B' or QIL' =/= nil
               then QIL QIL'
               else nil
               fi [print "Red created\n"] .
  -------------------------------------------------------------------------------------
  ---                                implication                                    ---
  -------------------------------------------------------------------------------------
  ceq createNewProof(P, NL y PO, SIS, MACS, s(N)) = QIL''
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      not redForgotten(M, T) /\
      TL := getHypotheses(M) /\
      [IPL, true] := tryImplication(M, T, TL) /\
      QIL := printImpCom(IPL) /\
      B := PO == finished /\
      P' := if not B
             then selectGoal(P, fst(PO))
             else P
             fi /\
      QIL'  := createNewProof(P', PO, SIS, MACS, s(N)) /\
      QIL'' := if B or QIL' =/= nil
               then QIL QIL'
               else nil
               fi .
  ----------------------------------------------------------------------------------------
  ---                                case-splitting                                    ---
  ----------------------------------------------------------------------------------------
  ceq createNewProof(P, NL y PO, SIS, MACS, s(N)) =
            QIL
            if PO =/= finished
            then developProof(selectGoal(P, fst(PO)), PO, SIS, MACS')
            else nil
            fi
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      not redForgotten(M, T) /\
      TL := getHypotheses(M) /\
      [IPL, false] := tryImplication(M, T, TL) /\
      [QIL, MACS', true] := tryCaseSplitting([M, T, s(N)], MACS, nil,
                                             "Goal " + natlist2stringNoDot(NL), 1, NL)
        [print "Inference correct "] .

  op natlist2stringNoDot : NatList -> String .
  eq natlist2stringNoDot(nil) = "" .
  eq natlist2stringNoDot(N) = string(N, 10) .
  eq natlist2stringNoDot(N NL) = string(N, 10) + "-" + natlist2stringNoDot(NL) [owise] .

  ceq createNewProof(P, NL y PO, SIS, MACS, s(N)) =
            if PO =/= finished
            then QIL '\t ':postpone '. '\n '\n
                 developProof(selectGoal(P, fst(PO)), PO, SIS, MACS)
            else QIL '\t ':postpone '. '\n '\n
            fi
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      not redForgotten(M, T) /\
      TL := getHypotheses(M) /\
      [IPL, false] := tryImplication(M, T, TL) /\
      [QIL, MACS', false] := tryCaseSplitting([M, T, s(N)], MACS, nil, "Goal 1", 1, NL)
        [owise print "Inference failure " NL] .

  eq createNewProof(P, NL y PO, SIS, MACS, N) =
            if PO =/= finished
            then '\t ':postpone '. '\n '\n
                 developProof(selectGoal(P, fst(PO)), PO, SIS, MACS)
            else '\t ':postpone '. '\n '\n
            fi [owise print "Final postpone " NL] .

  *** Goal to prove
  *** Current SIS
  *** Success QidList
  *** Failure QidList
  *** Indentation
  op tryCaseSplitting : IT Macros QidList String Nat NatList -> IR .
  ceq tryCaseSplitting([M, T, N], MACS, QILR, S, INDENT, NL) = [QILR QIL, MACS, true]
   if redForgotten(M, T) /\
      QIL := indent(INDENT) '*** qid(S) 'Success 'by 'reduction '\n
             indent(INDENT) ':apply ' '`( 'rd '`) '\n '\n .
  ceq tryCaseSplitting([M, T, N], MACS, QILR, S, INDENT, NL) = [QILR QIL, MACS, true]
   if not redForgotten(M, T) /\
      TL := getHypotheses(M) /\
      [IPL, true] := tryImplication(M, T, TL) /\
      QIL := printImpCom(IPL, S, INDENT) .
  ceq tryCaseSplitting([M, T, 0], MACS, QILR, S, INDENT, NL) = [QILR QIL, MACS, false]
   if not redForgotten(M, T) /\
      TL := getHypotheses(M) /\
      [IPL, false] := tryImplication(M, T, TL) /\
      QIL := indent(INDENT) '*** qid(S) 'cannot 'be 'discharged.
                            'Maximum 'depth 'reached. '\n '\n [print "Max depth"] .
  ceq tryCaseSplitting([M, T, s(N)], MACS, QILR, S, INDENT, NL) =
                 $tryCaseSplitting([M, T, s(N)], MACS, QILR, TPS, TPS'', S, INDENT, 1, NL)
   if not redForgotten(M, T) /\
      [IPL, false] := tryImplication(M, T, getHypotheses(M)) /\
      TrS := getEqualityTerms(M, T) /\
      TrS' := getEqTermsWithImps(M, T) /\
      TPS := processEqualityTerm*(M, TrS) /\
      TPS' := processEqualityTerm*(M, TrS' - TrS) /\
      TPS'' := (TPS' - TPS) [print "TPS " TPS "\nTPS' " TPS'' "\ninit-term " T] .

*** For testing purposes, inv9 - rec2
  op prior : TrialPairSet -> TrialPairSet .
  eq prior(['_=_['dc['S#Sys.Sys],'_`,_['pbps1@PBPSeq.PBPSeq,'<_`,_>['p1@Packet.Packet,'b1@Bit.Bit]]],ctf] TPS) =
      ['_=_['dc['S#Sys.Sys],'_`,_['pbps1@PBPSeq.PBPSeq,'<_`,_>['p1@Packet.Packet,'b1@Bit.Bit]]],ctf]
      prior(TPS) .
  eq prior(['_=_['sb['S#Sys.Sys],'b2@Bit.Bit],ctf] TPS) =
                  ['_=_['sb['S#Sys.Sys],'b2@Bit.Bit],ctf] prior(TPS) .
  eq prior(['_=_['p2s['S#Sys.Sys],'p2@Packet.Packet],ctf] TPS) =
                  ['_=_['p2s['S#Sys.Sys],'p2@Packet.Packet],ctf] prior(TPS) .
  eq prior(['pbps2@PBPSeq.PBPSeq,cesv] TPS) = ['pbps2@PBPSeq.PBPSeq,cesv] prior(TPS) .

  eq prior(TPS) = mtTPS [owise] .

***( For testing purposes, inv8 - rec2
  op prior : TrialPairSet -> TrialPairSet .
  eq prior(['dc['S#Sys.Sys],cevs] TPS) = ['dc['S#Sys.Sys],cevs] .
  eq prior(['_=_['rb['S#Sys.Sys],'B#EVS1-1.SubBit.Bit],ctf] TPS) = ['_=_['rb['S#Sys.Sys],'B#EVS1-1.SubBit.Bit],ctf] .
  eq prior(['_=_['ac['S#Sys.Sys],'_`,_['bs1@BSeq.BSeq,'b1@Bit.Bit,'b2@Bit.Bit,'bs2@BSeq.BSeq]],ctf] TPS) =  ['_=_['ac['S#Sys.Sys],'_`,_['bs1@BSeq.BSeq,'b1@Bit.Bit,'b2@Bit.Bit,'bs2@BSeq.BSeq]],ctf] .

  eq prior(['_=_['B#EVS1-1.SubBit.Bit,'b1@Bit.Bit],ctf] TPS) = ['_=_['b1@Bit.Bit,'B#EVS1-1.SubBit.Bit],ctf] .
  eq prior(TPS) = mtTPS [owise] .
)

***( For testing purposes, inv1 - rec1
  op prior1 : TrialPairSet TrialPairSet -> TrialPairSet .
  op prior2 : TrialPairSet -> TrialPairSet .
  eq prior1(['ac['S#Sys.Sys],cevs] TPS, TPS') = ['ac['S#Sys.Sys],cevs] .
  eq prior1(['_=_['sb['S#Sys.Sys],'B0EVS1-1.Bit.Bit],ctf] TPS, TPS') =
                             ['_=_['sb['S#Sys.Sys],'B0EVS1-1.Bit.Bit],ctf] .
  eq prior2(['_=_['rb['S#Sys.Sys],'B0EVS1-1.Bit.Bit],ctf] TPS) =
                             ['_=_['rb['S#Sys.Sys],'B0EVS1-1.Bit.Bit],ctf] .
***  eq prior1(['_=_['mksq['p2s['S#Sys.Sys]],'psr['S#Sys.Sys]],ctf] TPS, TPS') =
***                             ['_=_['mksq['p2s['S#Sys.Sys]],'psr['S#Sys.Sys]],ctf] .
  eq prior1(TPS, ['_=_['rb['S#Sys.Sys],'B0EVS1-1.Bit.Bit],ctf] TPS') = mtTPS .
  eq prior1(TPS, TPS') = TPS [owise] .
  eq prior2(TPS) = TPS [owise] .
)

***( For testing purposes, inv9 - rec1
  op prior : TrialPairSet TrialPairSet -> TrialPairSet .
  op prior : TrialPairSet -> TrialPairSet .
  eq prior(['ac['S#Sys.Sys],cevs] TPS, TPS') = ['ac['S#Sys.Sys],cevs] .
  eq prior(['_=_['sb['S#Sys.Sys],'B0EVS1-1.Bit.Bit],ctf] TPS, TPS') =
                                         ['_=_['sb['S#Sys.Sys],'B0EVS1-1.Bit.Bit],ctf] .
  eq prior(['_=_['dc['S#Sys.Sys],'_`,_['pbps1@PBPSeq.PBPSeq,'<_`,_>['p1@Packet.Packet,'b1@Bit.Bit],'<_`,_>['p2@Packet.Packet,
    'b2@Bit.Bit],'pbps2@PBPSeq.PBPSeq]],ctf] TPS, TPS') =
                                         ['_=_['dc['S#Sys.Sys],'_`,_['pbps1@PBPSeq.PBPSeq,'<_`,_>['p1@Packet.Packet,'b1@Bit.Bit],'<_`,_>['p2@Packet.Packet,
    'b2@Bit.Bit],'pbps2@PBPSeq.PBPSeq]],ctf] .
  eq prior(TPS, ['_=_['sb['S#Sys.Sys],'b1@Bit.Bit],ctf] TPS') = mtTPS .
  eq prior(['_=_['p2s['S#Sys.Sys],'p1@Packet.Packet],ctf] TPS) = ['_=_['p2s['S#Sys.Sys],'p1@Packet.Packet],ctf] .
  eq prior(['_=_['sb['S#Sys.Sys],'b1@Bit.Bit],ctf] TPS) = ['_=_['sb['S#Sys.Sys],'b1@Bit.Bit],ctf] .

  eq prior(TPS) = TPS [owise] .
  eq prior(TPS, TPS') = TPS [owise] .
)


  var  MACS'' : Macros .
  var  IT : IT .
  var  ITL : ITL .
  vars TPS TPS' TPS'' : TrialPairSet .
  var  TPair : TrialPair .
  var  CTXT : Context .
  var  IR : IR .

  eq TPair TPair = TPair .

  op _-_ : TermSet TermSet -> TermSet .
  eq (T | TrS) - (T | TrS') = TrS - TrS' .
  eq TrS - TrS' = TrS [owise] .

  op _-_ : TrialPairSet TrialPairSet -> TrialPairSet .
  eq (TPair TPS) - (TPair TPS') = TPS - TPS' .
  eq TPS - TPS' = TPS [owise] .

  op $tryCaseSplitting : IT Macros QidList TrialPairSet TrialPairSet String Nat Nat NatList
                         -> IR .
  eq $tryCaseSplitting([M, T, 0], MACS, QILR, TPS, TPS', S, INDENT, N', NL) =
                                                 [QILR, MACS, false] [print "Maximum depth"] .
  eq $tryCaseSplitting([M, T, N], MACS, QILR, mtTPS, mtTPS, S, INDENT, N', NL) =
                                                 [QILR, MACS, false] [print "No more cs available"] .
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, ([T', ctf] TPS), TPS', S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', TPS, TPS', S, INDENT, s(N'), NL)
             fi
   if not hasCEVS(TPS) /\
      Eq := getEq(T') /\
      | MACS', Q | := addNewMac(MACS, M, Eq) /\
      M' := createCTFmodTrue(M, Eq) /\
      M'' := createCTFmodFalse(M, Eq) /\
      QIL := printCtfComm(M, Q, Eq, INDENT) /\
      [QIL', MACS'', B] := tryCaseSplitting*([M', T, N] [M'', T, N],
                                              MACS', S, s(INDENT), 1, NL) /\
      QIL'' := indent(INDENT)
               if B
               then '*** qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '*** qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting true-false 1 applied " Eq " - " B] .
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, ([T', term] TPS), TPS', S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', TPS, TPS', S, INDENT, s(N'), NL)
             fi
   if not hasCEVS(TPS) /\
      | MACS', Q | := addNewMac(MACS, M, T') /\
      Ty := getType(metaReduce(M, T')) /\
      ODS := getCtors(M, Ty) /\
      TL := ordTrueFalse(buildTermsCtors(ODS, "CS" + natlist2string(NL s(N')))) /\
      TL =/= empty /\
      ML := createModules(M, T', TL) /\
      ITL := createITL(ML, T, N) /\
      QIL := printCtfTermComm(M, Q, T', INDENT) /\
      [QIL', MACS'', B] := tryCaseSplitting*(ITL, MACS', S, s(INDENT), 1, NL) /\
      EqS := getEqs(M) /\
      QIL'' := indent(INDENT)
               if B
               then '*** qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '*** qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting term applied " T' " - " B " " TPS " - " TPS'] .
  ***********
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, mtTPS, ([T', ctf] TPS), S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', mtTPS, TPS, S, INDENT, s(N'), NL)
             fi
   if not hasCEVS(TPS) /\
      Eq := getEq(T') /\
      | MACS', Q | := addNewMac(MACS, M, Eq) /\
      M' := createCTFmodTrue(M, Eq) /\
      M'' := createCTFmodFalse(M, Eq) /\
      QIL := printCtfComm(M, Q, Eq, INDENT) /\
      [QIL', MACS'', B] := tryCaseSplitting*([M', T, N] [M'', T, N],
                                              MACS', S, s(INDENT), 1, NL) /\
      EqS := getEqs(M') /\
      QIL'' := indent(INDENT)
               if B
               then '*** qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '*** qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting true-false 2 applied " Eq " - " B " - " TPS] .
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, mtTPS, ([T', term] TPS), S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', mtTPS, TPS, S, INDENT, s(N'), NL)
             fi
   if not hasCEVS(TPS) /\
      | MACS', Q | := addNewMac(MACS, M, T') /\
      Ty := getType(metaReduce(M, T')) /\
      ODS := getCtors(M, Ty) /\
      TL := ordTrueFalse(buildTermsCtors(ODS, "CS" + natlist2string(NL s(N')))) /\
      TL =/= empty /\
      ML := createModules(M, T', TL) /\
      ITL := createITL(ML, T, N) /\
      QIL := printCtfTermComm(M, Q, T', INDENT) /\
      [QIL', MACS'', B] := tryCaseSplitting*(ITL, MACS', S, s(INDENT), 1, NL) /\
      EqS := getEqs(M) /\
      QIL'' := indent(INDENT)
               if B
               then '*** qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '*** qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting term applied " T' " - " B] .
  ****************** CEVS *************
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, ([T', cevs] TPS), TPS', S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', TPS, TPS', S, INDENT, s(N'), NL)
             fi
   if | MACS', Q | := addNewMac(MACS, M, T') /\
      Ty := getType(metaNormalize(M, T')) /\
      TL := buildEVS(M, Ty, "EVS" + natlist2string(NL)) /\
      TL' := joinConstantsEVS(TL, "EVS" + natlist2string(NL), 0) /\
      ML := createModules(M, T', TL') /\
      ITL := createITL(ML, T, N) /\
      QIL := printCEVS(M, Q, T') /\
      [QIL', MACS'', B] := tryCaseSplitting*(ITL, MACS', S, s(INDENT), 1, NL) /\
      ODS := getOps(M) /\
      EqS := getEqs(M) /\
      QIL'' := indent(INDENT)
               if B
               then '*** qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '*** qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting cevs term applied " T' " - " B " - " TL'] .
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, mtTPS, ([T', cevs] TPS'), S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', mtTPS, TPS', S, INDENT, s(N'), NL)
             fi
   if | MACS', Q | := addNewMac(MACS, M, T') /\
      Ty := getType(metaNormalize(M, T')) /\
      TL := buildEVS(M, Ty, "EVS" + natlist2string(NL)) /\
      TL' := joinConstantsEVS(TL, "EVS" + natlist2string(NL), 0) /\
      ML := createModules(M, T', TL') /\
      ITL := createITL(ML, T, N) /\
      QIL := printCEVS(M, Q, T') /\
      [QIL', MACS'', B] := tryCaseSplitting*(ITL, MACS', S, s(INDENT), 1, NL) /\
      QIL'' := indent(INDENT)
               if B
               then '*** qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '*** qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting cevs term applied " T' " - " B] .
  *** CESV
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, ([T', cesv] TPS), TPS', S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', TPS, TPS', S, INDENT, s(N'), NL)
             fi
   if | MACS', Q | := addNewMac(MACS, M, T') /\
      Ty := getType(metaNormalize(M, T')) /\
      TL := buildESV(M, Ty, "ESV" + natlist2string(NL)) /\
      TL' := joinConstantsEVS(TL, "ESV" + natlist2string(NL), 0) /\
      ML := createModules(M, T', TL') /\
      ITL := createITL(ML, T, N) /\
      QIL := printCEVS(M, Q, T') /\
      [QIL', MACS'', B] := tryCaseSplitting*(ITL, MACS', S, s(INDENT), 1, NL) /\
      ODS := getOps(M) /\
      EqS := getEqs(M) /\
      QIL'' := indent(INDENT)
               if B
               then '*** qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '*** qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting cevs term applied " T' " - " B " - " TL'] .
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, mtTPS, ([T', cesv] TPS'), S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', mtTPS, TPS', S, INDENT, s(N'), NL)
             fi
   if | MACS', Q | := addNewMac(MACS, M, T') /\
      Ty := getType(metaNormalize(M, T')) /\
      TL := buildESV(M, Ty, "ESV" + natlist2string(NL)) /\
      TL' := joinConstantsESV(TL, "ESV" + natlist2string(NL), 0) /\
      ML := createModules(M, T', TL') /\
      ITL := createITL(ML, T, N) /\
      QIL := printCEVS(M, Q, T') /\
      [QIL', MACS'', B] := tryCaseSplitting*(ITL, MACS', S, s(INDENT), 1, NL) /\
      QIL'' := indent(INDENT)
               if B
               then '*** qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '*** qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting cevs term applied " T' " - " B] .

  op hasCEVS : TrialPairSet -> Bool .
  eq hasCEVS([T, cevs] TPS) = true .
  eq hasCEVS(TPS) = false [owise] .

  op createITL : MList Term Nat -> ITL .
  eq createITL(mtML, T, N) = nilITL .
  eq createITL(M . ML, T, N) = [M, T, N] createITL(ML, T, N) .

  op getEq : Term ~> Equation .
  eq getEq('_=_[T, 'false.Bool]) = getEq(T) .
  eq getEq('_=_[T, T']) = eq T = T' [none] . .

  op tryCaseSplitting* : ITL Macros String Nat Nat NatList -> IR .
  ceq tryCaseSplitting*(IT ITL, MACS, S, INDENT, N, NL) = [QIL QIL', MACS'', B and B']
   if [QIL, MACS', B] := tryCaseSplitting(IT, MACS, nil, S + "-" + string(N, 10), INDENT, NL N) /\
      [QIL', MACS'', B'] := tryCaseSplitting*(ITL, MACS', S, INDENT, s(N), NL) .
  eq tryCaseSplitting*(nilITL, MACS, S, INDENT, N, NL) = [nil, MACS, true] .

  sorts TrialType TrialPair TrialPairSet .
  subsort TrialPair < TrialPairSet .

  ops ctf term cevs cesv : -> TrialType [ctor] .

  op [_,_] : Term TrialType -> TrialPair [ctor] .

  op mtTPS : -> TrialPairSet [ctor] .
  op __ : TrialPairSet TrialPairSet -> TrialPairSet [ctor comm assoc id: mtTPS] .
  eq TPair TPair TPS = TPair TPS [metadata "idempotency"] .

  op processEqualityTerm : Module Term -> TrialPairSet .
  ceq processEqualityTerm(M, T) = mtTPS
   if hasVars(T) .
  ceq processEqualityTerm(M, '_=_[T, T']) = mtTPS
   if subterm(T, T') .
  ceq processEqualityTerm(M, Q[TL]) = processEqualityTerm*(M, tl2ts(TL))
   if containsBoolOps*(TL) . *** [print "Equality Bools " Q "(" TL ")"] .
  eq processEqualityTerm(M, '_=_[T, T]) = mtTPS .
  *** Built-in strategies for sequences: built sequences with same top constructor
  ceq processEqualityTerm(M, '_=_[T, T']) = seqEqualities(M, T, T')
   if sameSeqCtor(M, T, T') /\
      sameSize(T, T') . *** [print "s&s " T " = " T'] .
  *** Built-in strategies for sequences: seq = seq, elem*, seq
  ceq processEqualityTerm(M, '_=_[T, T']) = seqEqConst2Seq(M, T, T')
   if not subterm(T, T') /\
      const2seq(M, T, T') [print "c&ses 1 " T " = " T'] .
  *** Built-in strategies for sequences: seq, elem*, seq = seq
  ceq processEqualityTerm(M, '_=_[T, T']) = seqEqConst2Seq(M, T', T)
   if not subterm(T', T) /\
      const2seq(M, T', T) [print "c&ses 2 " T " = " T'] .
  *** Built-in strategies for sequences: elem^n, seq = seq,elem^n,seq
  ceq processEqualityTerm(M, '_=_[T, T']) = es&ses(M, T, T')
   if es&sesCheck(M, T, T') [print "es&ses " T " = " T'] .
  *** Built-in strategies for sequences: seq,elem^n, seq = elem^n,seq
  ceq processEqualityTerm(M, '_=_[T, T']) = es&ses(M, T', T)
   if es&sesCheck(M, T', T) [print "es&ses " T' " = " T] .
  *** Built-in strategies for sequences: elem^n, seq = seq,elem^n,seq
  ceq processEqualityTerm(M, '_=_[T, T']) = se&ses(M, T', T)
   if se&sesCheck(M, T', T) [print "se&ses " T " = " T'] .
  *** Built-in strategies for sequences: elem^n, seq = elem^n,seq
  ceq processEqualityTerm(M, '_=_[T, T']) = es&es(M, T, T')
   if es&esCheck(M, T, T') [print "es&es " T " = " T'] .
  *** Unary sequence, no constructors
  ceq processEqualityTerm(M, '_=_[T, T']) = ['_=_[T, T'], ctf]
   if T =/= T' /\
      unarySeqCheck(M, T, T') [print "Unary " T " = " T'] .
  *** Built-in strategies for sequences: seq, elem, elem, seq, elem = seq,elem
  ceq processEqualityTerm(M, '_=_[T, T']) = seese&se(T, T')
   if seese&seCheck(M, T, T') [print "seese&se " T " = " T'] .
  *** Default
  ceq processEqualityTerm(M, '_=_[T, T']) = ['_=_[T, T'], ctf]
   if T =/= T' /\
      not sees&seCheck(M, T, T') /\
      sameSeqCtor(M, T, T') /\
      not sameSize(T, T') /\
      not se&sesCheck(M, T, T') /\
      not es&sesCheck(M, T, T') /\
      not es&sesCheck(M, T', T) /\
      not es&esCheck(M, T, T') /\
      not seese&seCheck(M, T, T') /\
      not es&esCheck(M, T', T) [print "Default seq " T " = " T'] .
  *** seq1, elem1, elem2, seq2 = seq3, elem3 -> seq3 = seq1, elem1
  ceq processEqualityTerm(M, '_=_[T, T']) = sees&se(M, T, T')
   if sees&seCheck(M, T, T') [print "sees&se " T " = " T'] .
  *** Default
  ceq processEqualityTerm(M, '_=_[T, T']) = ['_=_[T, T'], ctf]
   if T =/= T' /\
      not subterm(T, T') /\
      Q[T1] := T /\
      isFreshCons(M, T1) /\
      Q'[TL'] := T' /\
      not seqCtor(getOps(M), Q) /\
      seqCtor(getOps(M), Q') /\ *** Both sequences, one of the is a function
      anyTC(M, TL') /\
      not es&sesCheck(M, T, T') /\
      not es&sesCheck(M, T', T) /\
      not se&sesCheck(M, T, T') /\
      not es&esCheck(M, T, T') /\
      not seese&seCheck(M, T, T') /\
      not es&esCheck(M, T', T) [print "es&es 2 " T " = " T'] .
  eq processEqualityTerm(M, T) = $processEqualityTerm(M, T) [owise] . *** print "Eq terms owise " T] .

  op subterm : Term Term -> Bool .
  eq subterm(T, Q[TL, T, TL']) = true .
  eq subterm(T, T') = false [owise] .

  op anyTC : Module TermList -> Bool .
  eq anyTC(M, empty) = false .
  eq anyTC(M, (Q[TL], TL')) = false .
  eq anyTC(M, (V, TL)) = false .
  eq anyTC(M, (C, TL)) = fromTC(getOps(M), C) or-else anyTC(M, TL) .

  op fromTC : OpDeclSet Constant -> Bool .
  ceq fromTC(op Q : nil -> Ty [metadata("tc")] . ODS, C) = true
   if Q := getName(C) /\
      Ty := getType(C) .
  eq fromTC(ODS, C) = false [owise] .

  op $processEqualityTerm : Module Term -> TrialPairSet .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = mtTPS
   if allCtor(M, T1) /\
      allCtor(M, T2) . *** [print "Eqt 1" T1] . *** [print "Equality term 1 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = if isCevs(M, T2)
                                              then [T2, cevs]
                                              else [T2, term] *** ['_=_[T2, T1], ctf]
                                              fi
   if allCtor(M, T1) /\
      isFreshCons(M, T2) . *** [print "Equality term 2 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = if isCevs(M, T1)
                                              then [T1, cevs]
                                              else [T1, term]
                                              fi
   if isFreshCons(M, T1) /\
      allCtor(M, T2) . *** [print "Equality term 3 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = ['_=_[T1, T2], ctf] *** cevs?
   if isFreshCons(M, T1) /\
      isFreshCons(M, T2) . *** [print "Equality term 4 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) =  $processEqualityTerm(M, T1)
   if not (allCtor(M, T1) or isFreshCons(M, T1)) /\
      allCtor(M, T2) . *** [print "Equality term 5 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = ['_=_[T1, T2], ctf]
                                              $processEqualityTerm(M, T1)
   if not (allCtor(M, T1) or isFreshCons(M, T1)) /\
      isFreshCons(M, T2) . *** [print "Equality term 6 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = $processEqualityTerm(M, T2)
   if allCtor(M, T1) /\
      not (allCtor(M, T2) or isFreshCons(M, T2)) . *** [print "Equality term 7 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = mtTPS
   if isFreshCons(M, T1) /\
      hasVars(T2) /\
      not (allCtor(M, T2) or isFreshCons(M, T2)) .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = ['_=_[T1, T2], ctf] *** ['_=_[T2, T1], ctf]
                                              $processEqualityTerm(M, T2)
   if isFreshCons(M, T1) /\
      not hasVars(T2) /\
      not (allCtor(M, T2) or isFreshCons(M, T2)) . *** [print "Equality term 8 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = ['_=_[T1, T2], ctf] *** !!! Seq
                                              processEqualityTerm*(M, T1 | T2)
   if not (allCtor(M, T1) or isFreshCons(M, T1)) /\
      not (allCtor(M, T2) or isFreshCons(M, T2)) /\
      noneCtor(M, T1) /\ noneCtor(M, T2) . *** [print "Equality term 9 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = processEqualityTerm*(M, T1 | T2)
   if not (allCtor(M, T1) or isFreshCons(M, T1)) /\
      not (allCtor(M, T2) or isFreshCons(M, T2)) /\
      not (noneCtor(M, T1) and noneCtor(M, T2)) . *** [print "Equality term 10 " T1 " = " T2] .
  ceq $processEqualityTerm(M, Q[T, T']) = processEqualityTerm*(M, T | T')
   if (Q == '_or_) or (Q == '_and_) or (Q == '_xor_) .
  eq $processEqualityTerm(M, 'not_[T]) = $processEqualityTerm(M, T) .
  eq $processEqualityTerm(M, 'if_then_else_fi[T, TL]) = $processEqualityTerm(M, T) .
  ceq $processEqualityTerm(M, T) = $processEqualityTerm(M, T1)
   if T1 := reduce(M, T) /\
      T =/= T1 .
  ceq $processEqualityTerm(M, T) = mtTPS
   if allCtor(M, T) . *** [print "Equality term 12 " T] .
  eq $processEqualityTerm(M, T) = $$processEqualityTerm(M, T, getEqs(M)) [owise] . *** print "Equality term 13 " T] .

  op $$processEqualityTerm : Module Term EquationSet -> TrialPairSet .
  ceq $$processEqualityTerm(M, T, EqS) = if TPS == mtTPS
                                         then decomposeTerm(M, T)
                                         else TPS
                                         fi
   if TPS := processEq*(M, T, EqS) .

  op sameSeqCtor : Module Term Term -> Bool .
  eq sameSeqCtor(M, Q[TL], Q[TL']) = seqCtor(getOps(M), Q) .
  eq sameSeqCtor(M, T, T') = false [owise] .

  op seqCtor : OpDeclSet Qid -> Bool .
  eq seqCtor(op Q : TyL -> Ty [ctor assoc AtS] . ODS, Q) = true .
  eq seqCtor(ODS, Q) = false [owise] .

  op const2seq : Module Term Term -> Bool .
  ceq const2seq(M, C, Q[T, TL]) = true
   if seqCtor(getOps(M), Q) /\
      hasId(getOps(M), Q) /\
      isCevs(M, C) /\
      isCevs(M, T) .
  eq const2seq(M, T, T') = false [owise] .

  op hasId : OpDeclSet Qid -> Bool .
  eq hasId(op Q : TyL -> Ty [id(T) AtS] . ODS, Q) = true .
  eq hasId(ODS, Q) = false [owise] .

  op unarySeqCheck : Module Term Term -> Bool .
  ceq unarySeqCheck(M, Q[TL], Q'[TL']) = (not isCtor(getOps(M), Q)) and-then
                                         (not isCtor(getOps(M), Q')) and-then
                                         isCevs(Ty, getSubsorts(M), getOps(M))
   if Ty := getType(metaReduce(M, Q[TL])) /\
      Ty := getType(metaReduce(M, Q'[TL'])) .

  op seqEqConst2Seq : Module Term Term ~> TrialPairSet .
  eq seqEqConst2Seq(M, C, Q[T, TL]) = [T, cevs] . *** ['_=_[C, TL], ctf] . *** If the first fails the second makes no sense

  op sees&seCheck : Module Term Term -> Bool .
  ceq sees&seCheck(M, T, T') = true
   if sameSeqCtor(M, T, T') /\
      Q[T1, T2, T3, T4] := T /\
      Q[T5, T6] := T' /\
      isCevs(M, T1) /\
      isCevs(M, T4) /\
      isCevs(M, T5) /\
      not isCevs(M, T2) /\
      not isCevs(M, T3) /\
      not isCevs(M, T6) /\
      T5 =/= T1 .
  eq sees&seCheck(M, T, T') = false [owise] .

  op seese&se : Term Term ~> TrialPairSet .
  eq seese&se(Q[T1, T2, T3, T4, T5], Q[T6, T7]) = ['_=_[T6, Q[T1, T2, T3, T4]], ctf] .

  op seese&seCheck : Module Term Term -> Bool .
  ceq seese&seCheck(M, T, T') = true
   if sameSeqCtor(M, T, T') /\
      Q[T1, T2, T3, T4, T5] := T /\
      Q[T6, T7] := T' /\
      isCevs(M, T1) /\
      isCevs(M, T4) /\
      isCevs(M, T6) /\
      not isCevs(M, T2) /\
      not isCevs(M, T3) /\
      not isCevs(M, T5) /\
      not isCevs(M, T7)  .
  eq seese&seCheck(M, T, T') = false [owise] .

  op sees&se : Module Term Term -> TrialPairSet .
  ceq sees&se(M, Q[T1, T2, T3, T4], Q[T5, T6]) = [T4, cesv]
   if eq '_=_[T5, Q[T1, T2]] = 'false.Bool [AtS] . EqS := getEqs(M) .
  eq sees&se(M, Q[T1, T2, T3, T4], Q[T5, T6]) = ['_=_[T5, Q[T1, T2]], ctf] [owise] .

  op es&sesCheck : Module Term Term -> Bool .
  eq es&sesCheck(M, T, Q[T', TL]) =
                             es&sesSize(M, T, Q[T', TL]) and-then
                             es&sesTypes(M, T, Q[T', TL]) and-then
                             sameSeqCtor(M, T, Q[T', TL]) and-then
                             isCevs(M, T') .

  op se&sesCheck : Module Term Term -> Bool .
  eq se&sesCheck(M, T, Q[TL, T']) =
                             es&sesSize(M, T, Q[TL, T']) and-then
                             se&sesTypes(M, T, Q[TL, T']) and-then
                             sameSeqCtor(M, T, Q[TL, T']) and-then
                             isCevs(M, T') .

  op es&esCheck : Module Term Term -> Bool .
  eq es&esCheck(M, T, T') = sameSeqCtor(M, T, T') and-then
                            not sameSize(T, T') and-then
                            not es&sesCheck(M, T, T') and-then
                            firstIsElem(M, T) and-then
                            firstIsElem(M, T') .

  op firstIsElem : Module Term -> Bool .
  eq firstIsElem(M, Q[T, TL]) = not isCevs(M, T) .
  eq firstIsElem(M, T) = false [owise] .

  op es&sesSize : Module Term Term -> Bool .
  eq es&sesSize(M, Q[TL], Q[TL']) = (size(TL) + 1) == size(TL') .
  eq es&sesSize(M, T, T') = false [owise] .

  op es&sesTypes : Module Term Term -> Bool .
  eq es&sesTypes(M, Q[TL], Q[T', TL']) = es&sesTypes*(M, TL, TL') .

  op se&sesTypes : Module Term Term -> Bool .
  eq se&sesTypes(M, Q[TL], Q[TL', T']) = es&sesTypes*(M, TL, TL') .

  op es&sesTypes* : Module TermList TermList -> Bool .
  eq es&sesTypes*(M, (T, TL), (T', TL')) =
                              getType(metaReduce(M, T)) == getType(metaReduce(M, T')) and
                              es&sesTypes*(M, TL, TL') .
  eq es&sesTypes*(M, empty, empty) = true .
  eq es&sesTypes*(M, TL, TL') = false [owise] .

  op es&ses : Module Term Term ~> TrialPairSet .
  eq es&ses(M, Q[TL], Q[T', TL']) = [T', cevs] . *** $processEqualityTerm(M, '_=_[Q[TL], Q[TL']]) .

  op se&ses : Module Term Term ~> TrialPairSet .
  eq se&ses(M, Q[TL], Q[TL', T']) = [T', cevs] . *** $processEqualityTerm(M, '_=_[Q[TL], Q[TL']]) .


  op es&es : Module Term Term ~> TrialPairSet .
  ceq es&es(M, Q[T, TL], Q[T', TL']) = processEqualityTerm*(M, TrS) *** ['_=_[Q[TL], Q[TL']], ctf]
   if T1 := reduce(M, '_=_[T, T']) /\
      TrS := getEqualityTerms(M, T1) .

  *** TODO: With different sizes it would be possible to make different equalities.
  op sameSize : Term Term -> Bool [comm] .
  eq sameSize(Q[TL], Q[TL']) = size(TL) == size(TL') .
  eq sameSize(Q[TL], C) = false .
  eq sameSize(Q[TL], V) = true .
  eq sameSize(T, T') = true [owise] .

  op seqEqualities : Module Term Term ~> TrialPairSet .
  eq seqEqualities(M, Q[TL], Q[TL']) = seqEqualities*(M, TL, TL') .

  op seqEqualities* : Module TermList TermList ~> TrialPairSet .
  eq seqEqualities*(M, empty, empty) = mtTPS .
  eq seqEqualities*(M, (T, TL), (T', TL')) = processEqualityTerm(M, '_=_[T, T'])
                                             seqEqualities*(M, TL, TL') [print "Sequence inference " T " = " T'] .

  op divideEqSeq : Module Term Term ~> TrialPairSet .
  eq divideEqSeq(M, Q[TL], Q[TL']) = divideEqSeq*(M, TL, TL') .

  op divideEqSeq* : Module TermList TermList ~> TrialPairSet .
  eq divideEqSeq*(M, empty, empty) = mtTPS .
  eq divideEqSeq*(M, (T, TL), (T', TL')) = processEqualityTerm(M, '_=_[T, T'])
                                           divideEqSeq*(M, TL, TL') .

  op decomposeTerm : Module Term -> TrialPairSet .
  eq decomposeTerm(M, V) = mtTPS .
  eq decomposeTerm(M, C) = if allCtor(M, C) or isFreshCons(M, C)
                           then mtTPS
                           else if isCevs(M, C)
                                then [C, cevs] *** [C, term] *** Adrian
                                else [C, term]
                                fi
                           fi .
  eq decomposeTerm(M, Q[TL]) = if allCtor(M, Q[TL]) or Q == 'if_then_else_fi
                               then mtTPS
                               else decomposeTerm*(M, TL)
                                    if isCtor(getOps(M), Q)
                                    then mtTPS
                                    else if isCevs(M, Q[TL])
                                         then [Q[TL], cevs] *** [Q[TL], term] *** Adrian
                                         else [Q[TL], term]
                                         fi
                                    fi
                               fi .

  op decomposeTerm* : Module TermList -> TrialPairSet .
  eq decomposeTerm*(M, empty) = mtTPS .
  eq decomposeTerm*(M, (T, TL)) = decomposeTerm(M, T) decomposeTerm*(M, TL) .

  op isCevs : Module Term -> Bool .
  eq isCevs(M, V) = false .
  ceq isCevs(M, C) = (not isCtor(getOps(M), getName(C))) and
                     isCevs(Ty, getSubsorts(M), getOps(M))
   if Ty := getType(metaReduce(M, C)) .
  ceq isCevs(M, Q[TL]) = allConstants(TL) and isCevs(Ty, getSubsorts(M), getOps(M))
   if Ty := getType(metaReduce(M, Q[TL])) .

  op allConstants : TermList -> Bool .
  eq allConstants(empty) = true .
  eq allConstants((C, TL)) = allConstants(TL) .
  eq allConstants(TL) = false [owise] .

  op isCevs : Type SubsortDeclSet OpDeclSet -> Bool .
  eq isCevs(Ty, subsort Ty' < Ty . SSDS, ODS) = isCevs(Ty, ODS) .
  eq isCevs(Ty, SSDS, ODS) = false [owise] .

  op isCevs : Type OpDeclSet -> Bool .
  eq isCevs(Ty, op Q : TyL -> Ty [ctor assoc id(T) AtS] . ODS) = true .
  eq isCevs(Ty, ODS) = false [owise] .

  op isCtor : OpDeclSet Qid -> Bool .
  eq isCtor(op Q : TyL -> Ty [ctor AtS] . ODS, Q) = true .
  eq isCtor(ODS, Q) = false [owise] .

  op containsBoolOps : Term -> Bool .
  eq containsBoolOps(V) = false .
  eq containsBoolOps(C) = false .
  ceq containsBoolOps(Q[TL]) = true
   if (Q == '_or_) or (Q == '_and_) or (Q == '_xor_) or (Q == 'if_then_else_fi) .
  eq containsBoolOps(Q[TL]) = containsBoolOps*(TL) [owise] .

  op containsBoolOps* : TermList -> Bool .
  eq containsBoolOps*(empty) = false .
  eq containsBoolOps*((T, TL)) = containsBoolOps(T) or-else containsBoolOps*(TL) .

  op processEq* : Module Term EquationSet -> TrialPairSet .
  eq processEq*(M, T, EqS) = processEq*(M, T, EqS, mtTPS) .

  op processEq* : Module Term EquationSet TrialPairSet -> TrialPairSet .
  ceq processEq*(M, T, Eq EqS, TPS) = processEq*(M, T, EqS, TPS TPS')
   if ceq T1 = T2 if COND [AtS] . := Eq /\
      TPS' := processEq(M, T, Eq, 0) /\
      TPS' =/= mtTPS .
  eq processEq*(M, T, EqS, TPS) = if TPS == mtTPS
                                  then decomposeTerm(M, T)
                                  else TPS
                                  fi [owise] .


  op processEq : Module Term Equation Nat -> TrialPairSet .
  ceq processEq(M, T, ceq T1 = T2 if COND [AtS] ., N) = mtTPS
   if metaXmatch(M, T1, T, nil, 0, unbounded, N) == noMatch .
  ceq processEq(M, T, Eq, N) = processCond(M, COND, SB)
                               processEq(M, T, Eq, s(N))
   if ceq T1 = T2 if COND [AtS] . := Eq /\
      {SB, CTXT} := metaXmatch(M, T1, T, nil, 0, unbounded, N) /\
      checkCond(M, COND, SB) .
  ceq processEq(M, T, Eq, N) = processEq(M, T, Eq, s(N))
   if ceq T1 = T2 if COND [AtS] . := Eq /\
      {SB, CTXT} := metaXmatch(M, T1, T, nil, 0, unbounded, N) /\
      not checkCond(M, COND, SB) .

  *** We assume only equalities are possible, since we are using CafeOBJ modules
  op checkCond : Module Condition Substitution -> Bool .
  eq checkCond(M, nil, SB) = true .
  ceq checkCond(M, T = T' /\ COND, SB) = ((T1 == T2) or
                                          (not allCtor(M, T1)) or
                                          (not allCtor(M, T2))) and-then
                                         checkCond(M, COND, SB)
   if T1 := substitute(T, SB) /\
      T2 := substitute(T', SB) .

  op processCond : Module Condition Substitution -> TrialPairSet .
  eq processCond(M, nil, SB) = mtTPS .
  ceq processCond(M, T = T' /\ COND, SB) =
                             processEqualityTerm(M, '_=_[T1, T2])
                             processCond(M, COND, SB)
   if T1 := substitute(T, SB) /\
      T2 := substitute(T', SB) .

  op processEqualityTerm* : Module TermSet -> TrialPairSet .
  eq processEqualityTerm*(M, emptyTermSet) = mtTPS .
  eq processEqualityTerm*(M, T | TrS) = processEqualityTerm(M, T)
                                        processEqualityTerm*(M, TrS) .

  op allCtor : Module Term -> Bool .
  eq allCtor(M, T) = allCtor(getOps(M), T) .

  op allCtor : OpDeclSet Term -> Bool .
  eq allCtor(ODS, V) = false .
  ceq allCtor(op Q : nil -> Ty [ctor AtS] . ODS, C) = true
   if Q := getName(C) .
  eq allCtor(op Q : TyL -> Ty [ctor AtS] . ODS, Q[TL]) =
            allCtor*(op Q : TyL -> Ty [ctor AtS] . ODS, TL) .
  eq allCtor(ODS, T) = false [owise] .

  op allCtor* : OpDeclSet TermList -> Bool .
  eq allCtor*(ODS, empty) = true .
  eq allCtor*(ODS, (T, TL)) = allCtor(ODS, T) and allCtor*(ODS, TL) .

  op noneCtor : Module Term -> Bool .
  eq noneCtor(M, T) = noneCtor(getOps(M), T) .

  op noneCtor : OpDeclSet Term -> Bool .
  eq noneCtor(ODS, V) = false .
  ceq noneCtor(op Q : nil -> Ty [ctor AtS] . ODS, C) = false
   if Q := getName(C) .
  ceq noneCtor(op Q : nil -> Ty [AtS] . ODS, C) = true
   if Q := getName(C) [owise] .
  eq noneCtor(op Q : TyL -> Ty [ctor AtS] . ODS, Q[TL]) = false .
  eq noneCtor(op Q : TyL -> Ty [AtS] . ODS, Q[TL]) =
            noneCtor*(op Q : TyL -> Ty [ctor AtS] . ODS, TL) [owise] .

  op noneCtor* : OpDeclSet TermList -> Bool .
  eq noneCtor*(ODS, empty) = true .
  eq noneCtor*(ODS, (T, TL)) = noneCtor(ODS, T) and noneCtor*(ODS, TL) .

  op tl2ts : TermList -> TermSet .
  eq tl2ts(empty) = emptyTermSet .
  eq tl2ts((T, TL)) = T | tl2ts(TL) .

  *** Inference tuple
  sort IT ITL .
  subsort IT < ITL .

  op [_,_,_] : Module Term Nat -> IT [ctor] .

  op nilITL : -> IT [ctor] .
  op __ : ITL ITL -> ITL [ctor assoc id: nilITL] .

  sort IR .
  *** Command list
  *** Updated ScoreInfoSet
  *** Successful or not
  op [_,_,_] : QidList Macros Bool -> IR [ctor] .

  op indent : Nat -> QidList .
  eq indent(0) = nil .
  eq indent(s(N)) = '\t indent(N) .

***(%
\end{verbatim}
}

\noindent
and \verb"sizeTL" just computes the size of a list of terms:

{\codesize
\begin{verbatim}
%)

  op sizeTL : TermList -> Nat .
  eq sizeTL(empty) = 0 .
  eq sizeTL((T, TL)) = s(sizeTL(TL)) .

  ---------------------------------------------------------------------------------------
  ---                              getEqTermsWithImps                                 ---
  ---------------------------------------------------------------------------------------

  op getEqTermsWithImps : Module Term -> TermSet .
  ceq getEqTermsWithImps(M, T) = getEqTermsWithImps*(M, T, TL)
   if TL := getHypotheses(M) .

  op getEqTermsWithImps* : Module Term TermList -> TermSet .
  eq getEqTermsWithImps*(M, T, empty) = emptyTermSet .
  ceq getEqTermsWithImps*(M, Q[TL], (Q[TL'], TL'')) =
               getEqualityTerms(M, reduce(M, '_implies_[substitute(Q[TL'], SB), Q[TL]]), Q[TL]) |
               getEqTermsWithImps*(M, Q[TL], TL'')
   if SB := basicSB*(TL', TL) . *** [print "Implication with " Q "(" TL' ") - " SB] .
  ceq getEqTermsWithImps*(M, T, (T', TL)) = getEqTermWithImpsInst(M, T, TSPS) |
                                            getEqTermsWithImps*(M, T, TL)
   if numVars(T') <= numInstVars /\
      TSPS := allIns(M, [T', none, getLabel(M, T')]) .
  ceq getEqTermsWithImps*(M, T, (T', TL)) = getEqualityTerms(M, T1, T) |
                                            getEqTermsWithImps*(M, T, TL)
   if T1 := reduce(M, '_implies_[T', T]) [owise] . *** print "Implication owise with " T' " - " T1] .

  op getEqTermWithImpsInst : Module Term TermSubPairSet -> TermSet .
  eq getEqTermWithImpsInst(M, T, mtTSPS) = emptyTermSet .
  ceq getEqTermWithImpsInst(M, T, [T', SB, Q] TSPS) = getEqualityTerms(M, T1, T) |
                                                      getEqTermWithImpsInst(M, T, TSPS)
   if T1 := reduce(M, '_implies_[T', T]) .

  ---------------------------------------------------------------------------------------
  ---                               getEqualityTerms                                  ---
  ---------------------------------------------------------------------------------------

  op getEqualityTerms : Module Term -> TermSet .
  ceq getEqualityTerms(M, T) = getEqualityTerms(M, T', T)
   if T' := reduce(M, T) .

  op getEqualityTerms : Module Term Term -> TermSet .
  ceq getEqualityTerms(M, '_=_[T1, T2], T) = reorder(M, '_=_[T1, T2], T)
   if not containsBoolOps('_=_[T1, T2]) .
  ceq getEqualityTerms(M, Q[TL], T) = getEqualityTerms*(M, TL, T)
   if Q =/= 'if_then_else_fi /\
      containsBoolOps(Q[TL]) .
  eq getEqualityTerms(M, 'not_[T], T') = T .
  eq getEqualityTerms(M, 'if_then_else_fi[T, T', T''], T1) = getEqualityTerms(M, T, T1) .
  eq getEqualityTerms(M, 'true.Bool, T) = emptyTermSet .
  eq getEqualityTerms(M, 'false.Bool, T) = emptyTermSet .
  eq getEqualityTerms(M, T, T') = '_=_[T, 'true.Bool] [owise] .

  op getEqualityTerms* : Module TermList Term -> TermSet .
  eq getEqualityTerms*(M, empty, T) = emptyTermSet .
  eq getEqualityTerms*(M, (T, TL), T') = getEqualityTerms(M, T, T') |
                                         getEqualityTerms*(M, TL, T') .

  op reorder : Module Term Term -> Term .
  eq reorder(M, '_=_[C, T], Q[TL, C, TL']) = '_=_[T, C] .
  ceq reorder(M, '_=_[Q[TL], C], Q'[TL']) = '_=_[C, Q[TL]]
   if not C in TL' /\
      isCtor(getOps(M), Q) .
  ceq reorder(M, '_=_[C, Q[TL]], T) = '_=_[Q[TL], C]
   if not isCtor(getOps(M), Q) .
  ceq reorder(M, '_=_[C, Q[TL]], T) = '_=_[Q[TL], C]
   if C in TL .
  ***(
  ceq reorder(M, '_=_[T1, T2], T) = '_=_[T2, T1]
   if eq T3 = T4 [AtS] . EqS := getEqs(M) /\
      T1 := reduce(M, T4) .
  )
  ceq reorder(M, '_=_[Q[TL], Q[TL']], T) = '_=_[Q[TL'], Q[TL]]
   if sameSeqCtor(M, Q[TL], Q[TL']) /\
      size(TL') > size(TL) .
  eq reorder(M, T, T') = T [owise] .

  op _in_ : Term TermList -> Bool .
  eq T in (TL, T, TL') = true .
  eq T in TL = false [owise] .

  ---------------------------------------------------------------------------------------
  ---                                tryImplication                                   ---
  ---------------------------------------------------------------------------------------

  sort ImpPair ImpPairList ImpTryRes .
  subsort ImpPair < ImpPairList .

  op [_,_,_] : Term Qid Substitution -> ImpPair [ctor] .

  op nilIPL : -> ImpPairList [ctor] .
  op __ : ImpPairList ImpPairList -> ImpPairList [ctor assoc id: nilIPL] .

  op [_,_] : ImpPairList Bool -> ImpTryRes [ctor] .






  var SB? : [Substitution] .
  var SB' : Substitution .
  var TS? : [TermSet] .

  op preSubstitution : Module Term Term ~> SbSet .
  eq preSubstitution(M, T, T') = preSubstitution(M, T, T', 0) .

  op preSubstitution : Module Term Term Nat ~> SbSet .
  ceq preSubstitution(M, T, T', N) = SB +
                                     if SB == none
                                     then mtSBS
                                     else preSubstitution(M, T, T', s(N))
                                     fi
   if TrS := getEquals(reduce(M, '_implies_[T, T'])) /\
      SB := traverseEquals(M, TrS, N, none) .

  op traverseEquals : Module TermSet Nat Substitution ~> Substitution .
  ceq traverseEquals(M, ('_=_[T, T']) | TrS, N, SB) =
                                                traverseEquals(M, TrS, N, SB ; SB?)
   if T1 := substitute(T, SB) /\
      T2 := substitute(T', SB) /\
      hasVars(T1) /\
      not (T1 :: Variable) /\
      not hasVars(T2) /\
      SB? := metaMatch(M, T1, T2, nil, N) /\
      SB? :: Substitution .
  ceq traverseEquals(M, ('_=_[T, T']) | TrS, N, SB) =
                                                traverseEquals(M, TrS, N, SB ; SB?)
   if T1 := substitute(T, SB) /\
      T2 := substitute(T', SB) /\
      hasVars(T2) /\
      not (T2 :: Variable) /\
      not hasVars(T1) /\
      SB? := metaMatch(M, T2, T1, nil, N) /\
      SB? :: Substitution .
  ceq traverseEquals(M, ('_=_[T, T']) | ('_=_[T, T'']) | TrS, N, SB) =
                                                traverseEquals(M, TrS, N, SB ; SB?)
   if T1 := substitute(T'', SB) /\
      T2 := substitute(T', SB) /\
      hasVars(T2) /\
      not (T2 :: Variable) /\
      not hasVars(T1) /\
      SB? := metaMatch(M, T2, T1, nil, N) /\
      SB? :: Substitution .
  eq traverseEquals(M, TrS, N, SB) = SB [owise] .

  op getEquals : Term -> TermSet .
  eq getEquals(C) = emptyTermSet .
  eq getEquals(V) = emptyTermSet .
  eq getEquals('_=_[TL]) = '_=_[TL] .
  eq getEquals(Q[TL]) = getEquals*(TL) [owise] .

  op getEquals* : TermList -> TermSet .
  eq getEquals*(empty) = emptyTermSet .
  eq getEquals*((T, TL)) = getEquals(T) | getEquals*(TL) .








  sort SbSet .
  subsort Substitution < SbSet .

  op mtSBS : -> SbSet .
  op _+_ : SbSet SbSet -> SbSet [ctor assoc comm id: mtSBS] .

  eq (V <- T ; SB) + none = (V <- T ; SB) .

  var SBS : SbSet .


  sorts TermSubPair TermSubPairSet .
  subsort TermSubPair < TermSubPairSet .

  op mtTSPS : -> TermSubPairSet [ctor] .
  op [_,_,_] : Term Substitution Qid -> TermSubPair [ctor] .
  op __ : TermSubPairSet TermSubPairSet -> TermSubPairSet [ctor assoc comm id: mtTSPS] .

  vars TSPS TSPS' : TermSubPairSet .
  var  TSP  : TermSubPair .
  var  IPL' : ImpPairList .
  var  IP : ImpPair .

  op tryImplication : Module Term TermList -> ImpTryRes .
  eq tryImplication(M, T, TL) = tryImplication(M, T, TL, extraImpLevels) .

  op tryImplication : Module Term TermList Nat -> ImpTryRes .
  ceq tryImplication(M, Q[TL], (TL1, Q[TL'], TL2), N) =
                                    if T'' == 'true.Bool
                                    then [IP, true]
                                    else $tryImplication(M, '_implies_[T', Q[TL]],
                                                         (TL1, Q[TL'], TL2),
                                                         (TL1, Q[TL'], TL2), IP, N)
                                    fi
   if SB := basicSB*(TL', TL) /\
      T' := substitute(Q[TL'], SB) /\
      T'' := reduce(M, '_implies_[T', Q[TL]]) /\
      Q' := getLabel(M, Q[TL']) /\
      IP := [T', Q', SB] .

  op $tryImplication : Module Term TermList TermList ImpPair Nat -> ImpTryRes .
  eq $tryImplication(M, T, empty, TL, IP, N) = [nilIPL, false] .
  ceq $tryImplication(M, T, (T', TL), TL', IP, N) = [IP [T'', Q, SB'], true]
   if (SB + SBS) := preSubstitution(M, T', T) /\
      T1 := substitute(T', SB) /\
      numVars(T1) < 3 /\
      [T'', SB', Q] TSPS := allIns(M, [T1, SB, getLabel(M, T')]) /\
      reduce(M, '_implies_[T'', T]) == 'true.Bool .
  ceq $tryImplication(M, T, (T', TL), TL', IP, s(N)) = [IP [T'', Q, SB'], true]
   if (SB + SBS) := preSubstitution(M, T', T) /\
      T1 := substitute(T', SB) /\
      numVars(T1) < 3 /\
      [T'', SB', Q] TSPS := allIns(M, [T1, SB, getLabel(M, T')]) /\
      [IPL, true] := $tryImplication(M, '_implies_[T'', T], TL', TL', IP, N) .
  eq $tryImplication(M, T, (T', TL), TL', IP, N) = $tryImplication(M, T, TL, TL', IP, N) [owise] .

  op allIns : Module TermSubPairSet -> TermSubPairSet [memo] .
  ceq allIns(M, [T, SB, Q] TSPS) = allIns(M, TSPS TSPS')
   if hasVars(T) /\
      TSPS' := allIns([T, SB, Q], getOps(M)) .
  eq allIns(M, TSPS) = TSPS [owise] .

  op allIns : TermSubPair OpDeclSet ~> TermSubPairSet .
  ceq allIns([Q[TL, V, TL'], SB, Q'], op Q'' : nil -> Ty [metadata(S) AtS] . ODS) =
                                        [Q[TL, C, TL'], V <- C ; SB, Q']
                                        allIns([Q[TL, V, TL'], SB, Q'], ODS)
   if not hasVars*(TL) /\
      Ty := getType(V) /\
      (S == "generated-si" or S == "tc") /\
      C := qid(string(Q'') + "." + string(Ty)) .
  eq allIns(TSP, ODS) = mtTSPS [owise] .

  op basicSB* : TermList TermList -> Substitution .
  eq basicSB*(empty, empty) = none .
  eq basicSB*((V, TL), (C, TL')) = V <- C ; basicSB*(TL, TL') .
  eq basicSB*((T, TL), (T', TL')) = basicSB*(TL, TL') [owise] .



  op numVars : Term -> Nat .
  eq numVars(T) = size(getVars(T)) .

  op size : TermSet -> Nat .
  eq size(T | TrS) = s(size(TrS)) .
  eq size(TrS) = 0 [owise] .

  op getLabel : Module Term ~> Qid [memo] .
  eq getLabel(M, T) = getLabel(getEqs(M), T) .

  op getLabel : EquationSet Term ~> Qid [memo] .
  eq getLabel(eq T = 'true.Bool [label(Q) AtS] . EqS, T) = Q .

  *** Term in premise
  *** Term in goal
  *** We assume the first term has vars
  op getImpSubs : Module Term Term -> Substitution [memo] .
  ceq getImpSubs(M, T, T') = getImpSubs(T1, T2)
   if T1 := reduce(M, T) /\
      T2 := reduce(M, T') .

  op getImpSubs : Term Term -> Substitution .
  ceq getImpSubs(Q[TL], T) = getImpSubs*(TL, T)
   if tryMatch(Q[TL], T) == none or
      not (tryMatch(Q[TL], T) :: Substitution) .
  ceq getImpSubs(Q[TL], T) = SB
   if SB := tryMatch(Q[TL], T) /\
      SB =/= none .
  eq getImpSubs(T, T') = none [owise] .

  op getImpSubs* : TermList Term -> Substitution .
  eq getImpSubs*(empty, T) = none .
  eq getImpSubs*((T, TL), T') = getImpSubs(T, T') ; getImpSubs*(TL, T') .

  op tryMatch : Term Term ~> Substitution .
  eq tryMatch(Q[TL], Q[TL']) = tryMatch*(TL, TL') .
  ceq tryMatch(Q[TL], Q'[TL']) = traverseRest(Q[TL], TL')
   if Q =/= Q' .

  op traverseRest : Term TermList ~> Substitution .
  ceq traverseRest(T, (T', TL)) = SB
   if SB := tryMatch(T, T') /\ SB =/= none .
  ceq traverseRest(T, (T', TL)) = traverseRest(T, TL)
   if not (tryMatch(T, T') :: Substitution) or
      tryMatch(T, T') == none .
  eq traverseRest(T, empty) = none .

  op tryMatch* : TermList TermList ~> Substitution .
  eq tryMatch*(empty, empty) = none .
  eq tryMatch*((V, TL), (C, TL')) = V <- C ; tryMatch*(TL, TL') .
  eq tryMatch*((T, TL), (T', TL')) = tryMatch*(TL, TL') [owise] .

  op applyImpSub : Term Substitution -> Term .
  eq applyImpSub(Q[TL], SB) = Q[applyImpSub*(TL, SB)] .
  eq applyImpSub(C, SB) = C .
  eq applyImpSub(V, V <- T ; SB) = T .
  eq applyImpSub(V, SB) = V [owise] .

  op applyImpSub* : TermList Substitution -> TermList .
  eq applyImpSub*((T, TL), SB) = applyImpSub(T, SB), applyImpSub*(TL, SB) .
  eq applyImpSub*(empty, SB) = empty .

  op isFreshCons : Module Term -> Bool .
  ceq isFreshCons(M, C) = true
   if Q := getName(C) /\
      Ty := getType(C) /\
      op Q : nil -> Ty [metadata("generated-si") AtS] . ODS := getOps(M) .
  ceq isFreshCons(M, C) = true
   if Q := getName(C) /\
      Ty := getType(C) /\
      op Q : nil -> Ty [metadata("tc") AtS] . ODS := getOps(M) .
  ceq isFreshCons(M, C) = true
   if Q := getName(C) /\
      Ty := getType(C) /\
      op Q : nil -> Ty [metadata(St) AtS] . ODS := getOps(M) /\
      find(St, "CTF-", 0) =/= notFound .
  eq isFreshCons(M, T) = false [owise] .


  ------------------------------------------------------------------------------------
  ---                                printImpCom                                   ---
  ------------------------------------------------------------------------------------

  *** We assume it reduces the term to true, so the last command is a reduction.
  op printImpCom : ImpPairList -> QidList .
  eq printImpCom(nilIPL) =
             '\t '*** 'The 'corresponding 'proof 'score 'was 'not 'present. '\n
             '\t ':apply ' '`( 'rd '`) '\n '\n .
  eq printImpCom([T, Q, SB] IPL) =
             '\t '*** 'The 'corresponding 'proof 'score 'was 'not 'present. '\n
             if SB == none
             then '\t ':imp ' '`[ Q '`] ' '. '\n '\n
             else '\t ':imp ' '`[ Q '`] ' 'by ' '`{ printSub(SB) '`} '\n '\n
             fi
             printImpCom(IPL) .

  *** We assume it reduces the term to true, so the last command is a reduction.
  op printImpCom : ImpPairList String Nat -> QidList .
  eq printImpCom(IPL, S, INDENT) =
             indent(INDENT) '*** qid(S) 'Success 'by 'implication 'and 'reduction. '\n
             printImpCom(IPL, INDENT) .

  op printImpCom : ImpPairList Nat -> QidList .
  eq printImpCom(nilIPL, INDENT) =
             indent(INDENT) ':apply ' '`( 'rd '`) '\n '\n .
  eq printImpCom([T, Q, SB] IPL, INDENT) =
             if SB == none
             then indent(INDENT) ':imp ' '`[ Q '`] ' '. '\n '\n
             else indent(INDENT) ':imp ' '`[ Q '`] ' 'by ' '`{ printSub(SB) '`} '\n '\n
             fi
             printImpCom(IPL, INDENT) .

  -------------------------------------------------------------------------------------
  ---                                redForgotten                                   ---
  -------------------------------------------------------------------------------------

  op redForgotten : Module Term -> Bool .
  eq redForgotten(M, T) = getTerm(metaReduce(M, T)) == 'true.Bool .

  -------------------------------------------------------------------------------------
  ---                                 indRequired                                   ---
  -------------------------------------------------------------------------------------

  op indRequired : ScoreInfoSet Module Term -> TermList .
  ceq indRequired(SIS, M, T) = V
   if SIS =/= noScoreInfo /\
      TrS := getVars(T) /\
      V := getIndVar(T, TrS, SIS) .
  eq indRequired(SIS, M, T) = empty [owise] .

  -------------------------------------------------------------------------------------
  ---                                 tcRequired                                    ---
  -------------------------------------------------------------------------------------

  op tcRequired : Term -> Bool .
  eq tcRequired(T) = hasVars(T) .

  -------------------------------------------------------------------------------------
  ---                              cevsTermRequired                                 ---
  -------------------------------------------------------------------------------------

  op cevsRequired : ScoreInfoSet Module Term -> TermList .
  ceq cevsRequired(SIS, M, T) = $cevsRequired(SIS1, SIS2, M, T, 2)
   if [SIS1, SIS2] := divideByExecEqs(SIS, 1) .
  op $cevsRequired : ScoreInfoSet ScoreInfoSet Module Term Nat -> TermList .
  ceq $cevsRequired($ M, M', (TL, T, TL') $ SIS, SIS2, M'', T', N) = T5
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      eq T3 = T'' [AtS] . EqS := getEqs(M') /\
      isExec(AtS) /\
      T5 := instantiateVars(M, M'', T3, CS) /\
      isCEVS(M, T'') /\
      not isEquality(T3) /\
      ((T'' =/= 'true.Bool) and (T'' =/= 'false.Bool)) /\
      not eqDefinedFor(M'', T5) /\
      termDefinedInAll(SIS SIS2, M'', T', T5) .
  ceq $cevsRequired($ M, M', (TL, T, TL') $ SIS,
                    $ M1, M2, (TL1, T1, TL2) $ SIS2, M'', T', N) = T5
   if CS := getSub(M, T, M'', T') /\
      CS' := getSub(M1, T1, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      consistentPremises(M2, M'', CS) /\
      *** Case distinction in the same term
      eq T3 = T'' [AtS] . EqS := getEqs(M') /\
      eq T3 = T''' [AtS'] . EqS' := getEqs(M2) /\
      *** Both equations are executable
      isExec(AtS) /\
      isExec(AtS') /\
      T5 := instantiateVars(M, M'', T3, CS) /\
      isCEVS(M1, T''') /\
      not isEquality(T3) /\
      ((T'' =/= 'true.Bool) and (T'' =/= 'false.Bool)) /\
      not eqDefinedFor(M'', T5) /\
      termDefinedInAll(SIS SIS2, M'', T', T5) .
  eq $cevsRequired(SIS1, SIS2, M, T, N) =
      if (SIS2 == noScoreInfo) or
         (ctfTermRequired(SIS1, M, T) =/= empty) or
         (ctfRequired(SIS1, M, T) =/= none)
      then empty
      else $cevsRequired(fst(divideByExecEqs(SIS2, N)),
                         snd(divideByExecEqs(SIS2, N)), M, T, s(N))
      fi [owise] .

  var Ty' : Type .

  op isCEVS : Module Term -> Bool .
  eq isCEVS(M, T) = subsortUnaryBinaryOpConstraints(M, T) and checkTermCEVS(M, T) .
  eq isCEVS(M, T) = false [owise] .

  op checkTermCEVS : Module Term -> Bool .
  ceq checkTermCEVS(M, Q[T, T']) = true
   if op Q : Ty1 Ty2 -> Ty [ctor assoc AtS] . ODS := getOps(M) /\
      Ty' := getType(metaReduce(M, T)) /\
      Ty' =/= Ty1 /\
      sortLeq(M, Ty', Ty1) /\
      getType(metaReduce(M, T')) == Ty2 .
  eq checkTermCEVS(M, T) = false [owise] .

  -------------------------------------------------------------------------------------
  ---                              csvsTermRequired                                 ---
  -------------------------------------------------------------------------------------

  op csvsRequired : ScoreInfoSet Module Term -> TermList .
  ceq csvsRequired(SIS, M, T) = $csvsRequired(SIS1, SIS2, M, T, 2)
   if [SIS1, SIS2] := divideByExecEqs(SIS, 1) .
  op $csvsRequired : ScoreInfoSet ScoreInfoSet Module Term Nat -> TermList .
  ceq $csvsRequired($ M, M', (TL, T, TL') $ SIS, SIS2, M'', T', N) = T5
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      eq T3 = T'' [AtS] . EqS := getEqs(M') /\
      isExec(AtS) /\
      T5 := instantiateVars(M, M'', T3, CS) /\
      isCSVS(M, T'') /\
      not isEquality(T3) /\
      ((T'' =/= 'true.Bool) and (T'' =/= 'false.Bool)) /\
      not eqDefinedFor(M'', T5) /\
      termDefinedInAll(SIS SIS2, M'', T', T5) .
  ceq $csvsRequired($ M, M', (TL, T, TL') $ SIS,
                    $ M1, M2, (TL1, T1, TL2) $ SIS2, M'', T', N) = T5
   if CS := getSub(M, T, M'', T') /\
      CS' := getSub(M1, T1, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      consistentPremises(M2, M'', CS) /\
      *** Case distinction in the same term
      eq T3 = T'' [AtS] . EqS := getEqs(M') /\
      eq T3 = T''' [AtS'] . EqS' := getEqs(M2) /\
      *** Both equations are executable
      isExec(AtS) /\
      isExec(AtS') /\
      T5 := instantiateVars(M, M'', T3, CS) /\
      isCSVS(M1, T''') /\
      not isEquality(T3) /\
      ((T'' =/= 'true.Bool) and (T'' =/= 'false.Bool)) /\
      not eqDefinedFor(M'', T5) /\
      termDefinedInAll(SIS SIS2, M'', T', T5) .
  eq $csvsRequired(SIS1, SIS2, M, T, N) =
      if (SIS2 == noScoreInfo) or
         (ctfTermRequired(SIS1, M, T) =/= empty) or
         (ctfRequired(SIS1, M, T) =/= none)
      then empty
      else $csvsRequired(fst(divideByExecEqs(SIS2, N)),
                         snd(divideByExecEqs(SIS2, N)), M, T, s(N))
      fi [owise] .

  op isCSVS : Module Term -> Bool .
  eq isCSVS(M, T) = subsortUnaryBinaryOpConstraints(M, T) and checkTermCSVS(M, T) .
  eq isCSVS(M, T) = false [owise] .

  op checkTermCSVS : Module Term -> Bool .
  ceq checkTermCSVS(M, Q[T, T', T'']) = true
   if op Q : Ty1 Ty2 -> Ty [ctor assoc AtS] . ODS := getOps(M) /\
      Ty' := getType(metaReduce(M, T')) /\
      Ty' =/= Ty1 /\
      sortLeq(M, Ty', Ty1) /\
      getType(metaReduce(M, T)) == Ty2 /\
      getType(metaReduce(M, T'')) == Ty2 .
  eq checkTermCSVS(M, T) = false [owise] .

  -------------------------------------------------------------------------------------
  ---                              cesvTermRequired                                 ---
  -------------------------------------------------------------------------------------

  op cesvRequired : ScoreInfoSet Module Term -> TermList .
  ceq cesvRequired(SIS, M, T) = $cesvRequired(SIS1, SIS2, M, T, 2)
   if [SIS1, SIS2] := divideByExecEqs(SIS, 1) .

  op $cesvRequired : ScoreInfoSet ScoreInfoSet Module Term Nat -> TermList .
  ceq $cesvRequired($ M, M', (TL, T, TL') $ SIS, SIS2, M'', T', N) = T5
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      eq T3 = T'' [AtS] . EqS := getEqs(M') /\
      isExec(AtS) /\
      T5 := instantiateVars(M, M'', T3, CS) /\
      isCESV(M, T'') /\
      not isEquality(T3) /\
      ((T'' =/= 'true.Bool) and (T'' =/= 'false.Bool)) /\
      not eqDefinedFor(M'', T5) /\
      termDefinedInAll(SIS SIS2, M'', T', T5) .
  ceq $cesvRequired($ M, M', (TL, T, TL') $ SIS,
                    $ M1, M2, (TL1, T1, TL2) $ SIS2, M'', T', N) = T5
   if CS := getSub(M, T, M'', T') /\
      CS' := getSub(M1, T1, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      consistentPremises(M2, M'', CS) /\
      *** Case distinction in the same term
      eq T3 = T'' [AtS] . EqS := getEqs(M') /\
      eq T3 = T''' [AtS'] . EqS' := getEqs(M2) /\
      *** Both equations are executable
      isExec(AtS) /\
      isExec(AtS') /\
      T5 := instantiateVars(M, M'', T3, CS) /\
      isCESV(M1, T''') /\
      not isEquality(T3) /\
      ((T'' =/= 'true.Bool) and (T'' =/= 'false.Bool)) /\
      not eqDefinedFor(M'', T5) /\
      termDefinedInAll(SIS SIS2, M'', T', T5) .
  eq $cesvRequired(SIS1, SIS2, M, T, N) =
      if (SIS2 == noScoreInfo) or
         (ctfTermRequired(SIS1, M, T) =/= empty) or
         (ctfRequired(SIS1, M, T) =/= none)
      then empty
      else $cesvRequired(fst(divideByExecEqs(SIS2, N)),
                         snd(divideByExecEqs(SIS2, N)), M, T, s(N))
      fi [owise] .

  op isCESV : Module Term -> Bool .
  eq isCESV(M, T) = subsortUnaryBinaryOpConstraints(M, T) and checkTermCESV(M, T) .
  eq isCESV(M, T) = false [owise] .

  op checkTermCESV : Module Term -> Bool .
  ceq checkTermCESV(M, Q[T, T']) = true
   if op Q : Ty1 Ty2 -> Ty [ctor assoc AtS] . ODS := getOps(M) /\
      Ty1 == getType(metaReduce(M, T)) /\
      Ty' := getType(metaReduce(M, T')) /\
      Ty' =/= Ty2 /\
      sortLeq(M, Ty', Ty2) .
  eq checkTermCESV(M, T) = false [owise] .

  -------------------------------------------------------------------------------------
  ---                              instantiateVars                                  ---
  -------------------------------------------------------------------------------------

  op instantiateVars : Module Module Term ConsSub -> Term .
  ceq instantiateVars(M, M', T, CS) = T
   if getTerm(metaReduce(M', T)) :: Term .
  ceq instantiateVars(M, M', T, CS) = instantiateVars(EqS, M, M', applyCS(T, CS))
   if EqS := applySubEqs(getEqs(M), CS) [owise] .

  op instantiateVars : EquationSet Module Module Term -> Term .
  ceq instantiateVars(EqS, M, M', T) = T
   if getTerm(metaReduce(M', T)) :: Term .
  ceq instantiateVars(eq T1 = T2 [AtS] . EqS, M, M', T) =
                      instantiateVars(applySubEqs(EqS, CS), M, M', applyCS(T, CS))
   if not (getTerm(metaReduce(M', T)) :: Term) /\
      eq T1 = T3 [AtS'] . EqS' := getEqs(M') /\
      CS := getSub(M, T2, M', T3) .

  op applySubEqs : EquationSet ConsSub -> EquationSet .
  ceq applySubEqs(eq T = T' [AtS] . EqS, CS) = eq applyCS(T, CS) = applyCS(T', CS) [AtS] .
                                               applySubEqs(EqS, CS)
   if isExec(AtS) .
  eq applySubEqs(EqS, CS) = none [owise] .

  ------------------------------------------------------------------------------------
  ---                              ctfTermRequired                                 ---
  ------------------------------------------------------------------------------------

  op ctfTermRequired : ScoreInfoSet Module Term -> TermList .
  ceq ctfTermRequired(SIS, M, T) = $ctfTermRequired(SIS1, SIS2, M, T, 2)
   if [SIS1, SIS2] := divideByExecEqs(SIS, 1) .

  op $ctfTermRequired : ScoreInfoSet ScoreInfoSet Module Term Nat -> TermList .
  ceq $ctfTermRequired($ M, M', (TL, T, TL') $ SIS, SIS2, M'', T', N) = T3
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      eq T1 = T2 [AtS] . EqS := getEqs(M') /\
      isExec(AtS) /\
      ((T2 == 'true.Bool) or (T2 == 'false.Bool)) /\
      not isEquality(T1) /\
      T3 := instantiateVars(M, M'', T1, CS) /\
      T4 := instantiateVars(M, M'', T2, CS) /\
      not eqDefinedFor(M'', T3) /\
      T5 := getTerm(metaReduce(M'', '_=_[T3, T4])) /\
      T5 =/= 'true.Bool /\
      T5 =/= 'false.Bool /\
      termDefinedInAll(SIS SIS2, M'', T', T3) .
  ceq $ctfTermRequired($ M, M', (TL, T, TL') $ SIS, SIS2, M'', T', N) = T5
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      *** Any level
      $ M1, M2, (TL1, T1, TL2) $ SIS1 := SIS SIS2 /\
      CS' := getSub(M1, T1, M'', T') /\
      *** Consistent premises
      consistentPremises(M2, M'', CS') /\
      eq T3 = T'' [AtS] . EqS := getEqs(M') /\
      isExec(AtS) /\
      eq T4 = T''' [AtS'] . EqS' := getEqs(M2) /\
      isExec(AtS') /\
      T5 := instantiateVars(M, M'', T3, CS) /\
      T5 := instantiateVars(M, M'', T4, CS) /\
      T'' =/= T''' /\
      isCtor(M, T'') /\
      isCtor(M1, T''') /\
      not isEquality(T3) /\
      not isEquality(T4) /\
      ((T'' =/= 'true.Bool) and (T'' =/= 'false.Bool)) /\
      ((T''' =/= 'true.Bool) and (T''' =/= 'false.Bool)) /\
      not eqDefinedFor(M'', T5) /\
      termDefinedInAll(SIS SIS2, M'', T', T5) .
  eq $ctfTermRequired(SIS1, SIS2, M, T, N) =
      if (SIS2 == noScoreInfo) or (ctfRequired(SIS1, M, T) =/= none)
      then empty
      else $ctfTermRequired(fst(divideByExecEqs(SIS2, N)),
                            snd(divideByExecEqs(SIS2, N)), M, T, s(N))
      fi [owise] .

  *** Term in the goal and term generated
  op termDefinedInAll : ScoreInfoSet Module Term Term -> Bool .
  ceq termDefinedInAll($ M, M', (TL, T, TL') $ SIS, M'', T', T1) = false
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      not hasTermDefined(M, M', M'', T1, CS) .
  eq termDefinedInAll(SIS, M, T, T1) = true [owise] .

  op hasTermDefined : Module Module Module Term ConsSub -> Bool .
  ceq hasTermDefined(M, M', M'', T, CS) = true
   if eq T1 = T2 [AtS] . EqS := getEqs(M') /\
      T := instantiateVars(M, M'', T1, CS)  .
  eq hasTermDefined(M, M', M'', T, CS) = false [owise] .

  op eqDefinedFor : Module Term -> Bool .
  ceq eqDefinedFor(M, T) = true
   if eq T = T' [AtS] . EqS := getEqs(M) .
  ceq eqDefinedFor(M, T) = true
   if eq '_=_[T, T'] = T'' [AtS] . EqS := getEqs(M) .
  eq eqDefinedFor(M, '_=_[T, T']) = eqDefinedFor(M, T, T') .
  eq eqDefinedFor(M, T) = false [owise] .

  op eqDefinedFor : Module Term Term -> Bool .
  ceq eqDefinedFor(M, T, T') = true
   if eq T = T' [AtS] . EqS := getEqs(M) .
  ceq eqDefinedFor(M, T, T') = true
   if eq '_=_[T, T'] = T'' [AtS] . EqS := getEqs(M) .
  ceq eqDefinedFor(M, T, 'false.Bool) = true
   if eqDefinedFor(M, T, 'true.Bool) .
  eq eqDefinedFor(M, '_=_[T, T'], 'true.Bool) = eqDefinedFor(M, T, T') .
  eq eqDefinedFor(M, T, T') = false [owise] .

  ------------------------------------------------------------------------------------
  ---                                ctfRequired                                   ---
  ------------------------------------------------------------------------------------

  op ctfRequired : ScoreInfoSet Module Term -> EquationSet .
  ceq ctfRequired(SIS, M, T) = $ctfRequired(SIS1, SIS2, M, T, 2)
   if [SIS1, SIS2] := divideByExecEqs(SIS, 1) .

  op $ctfRequired : ScoreInfoSet ScoreInfoSet Module Term Nat -> EquationSet .
  ceq $ctfRequired($ M, M', (TL, T, TL') $ SIS, SIS2, M'', T', N) = eq T5 = T6 [none] .
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremisesEq(M, M', M'', CS) /\
      eq T1 = T2 [AtS] . EqS := getEqs(M') /\
      isExec(AtS) /\
      T3 := instantiateVars(M, M'', T1, CS) /\
      T4 := instantiateVars(M, M'', T2, CS) /\
      not eqDefinedFor(M'', T3, T4) /\
      eq T5 = T6 [none] . := ctfEq(T3, T4) /\
      eqDefinedInAll(SIS SIS2, M'', T', T5, T6) .
  eq $ctfRequired(SIS1, SIS2, M, T, N) =
      if SIS2 == noScoreInfo
      then none
      else $ctfRequired(fst(divideByExecEqs(SIS2, N)),
                        snd(divideByExecEqs(SIS2, N)), M, T, s(N))
      fi [owise] .

  *** Term in the goal and terms for the generated equation
  op eqDefinedInAll : ScoreInfoSet Module Term Term Term -> Bool .
  ceq eqDefinedInAll($ M, M', (TL, T, TL') $ SIS, M'', T', T1, T2) = false
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      not hasEqDefined(M, M', M'', T1, T2, CS) .
  eq eqDefinedInAll(SIS, M, T, T1, T2) = true [owise] .

  op hasEqDefined : Module Module Module Term Term ConsSub -> Bool .
  ceq hasEqDefined(M, M', M'', T, T', CS) = true
   if eq T1 = T2 [AtS] . EqS := getEqs(M') /\
      T := instantiateVars(M, M'', T1, CS) /\
      T' := instantiateVars(M, M'', T2, CS) .
  ceq hasEqDefined(M, M', M'', T, T', CS) = true
   if eq '_=_[T1, T2] = 'false.Bool [AtS] . EqS := getEqs(M') /\
      T := instantiateVars(M, M'', T1, CS) /\
      T' := instantiateVars(M, M'', T2, CS) .
  eq hasEqDefined(M, M', M'', T, T', CS) = false [owise] .

  op ctfEq : Term Term -> Equation .
  eq ctfEq('_=_[T1, T2], 'false.Bool) = eq T1 = T2 [none] . .
  eq ctfEq(T1, T2) = if T2 == 'false.Bool
                     then eq T1 = 'true.Bool [none] .
                     else eq T1 = T2 [none] .
                     fi [owise] .

  op isExec : AttrSet -> Bool .
  eq isExec(nonexec AtS) = false .
  eq isExec(AtS) = true [owise] .

  ------------------------------------------------------------------------------------
  ---                                impRequired                                   ---
  ------------------------------------------------------------------------------------

  sort ImpRequiredPair .
  op noImpRequired : -> ImpRequiredPair [ctor] .
  op |_,_| : Qid Substitution -> ImpRequiredPair [ctor] .

  op impRequired : ScoreInfoSet Module Term -> ImpRequiredPair .
  ceq impRequired($ M, M', (TL, '_implies_[T1, T2], TL') $ SIS, M'', T) = | Q, none |
   if CS := getSub(M, T2, M'', T) /\
      *** Same premises
      samePremises(M, M', M'', CS) /\
      T3 := getTermImplication(M, M'', '_implies_[T1, T2], T, CS) /\
      eq T3 = 'true.Bool [label(Q) AtS] . EqS := getEqs(M'') .
  ceq impRequired($ M, M', (TL, '_implies_[T1, T2], TL') $ SIS, M'', T) = | Q, SB |
   if CS := getSub(M, T2, M'', T) /\
      *** Same premises
      samePremises(M, M', M'', CS) /\
      T3 := getTermImplication(M, M'', '_implies_[T1, T2], T, CS) /\
      eq T4 = 'true.Bool [label(Q) AtS] . EqS := getEqs(M'') /\
      T3 =/= T4 /\
      SB := computeSub(T4, T3) .
  eq impRequired(SIS, M, T) = noImpRequired [owise] .

  op getTermImplication : Module Module Term Term ConsSub -> TermList .
  ceq getTermImplication(M, M', '_implies_[T1, T2], T, CS) = T4
   if impLevels(T) == impLevels(T2) /\
      T3 := applyCS(T1, CS) /\
      T4 := instantiateVars(M, M', T3, CS) .
  ceq getTermImplication(M, M', '_implies_[T1, T2], T, CS) = getTermImplication(M, M', T2, T, CS)
   if impLevels(T2) > impLevels(T) .
  eq getTermImplication(M, M', T, T', CS) = empty [owise] .

  *** Term with variables (premise)
  *** Ground term (term being reduced, once substituted)
  op computeSub : Term Term ~> Substitution .
  eq computeSub(C, C) = none .
  eq computeSub(V, T) = V <- T .
  eq computeSub(Q[TL], Q[TL']) = computeSub*(TL, TL') .

  op computeSub* : TermList TermList ~> Substitution .
  eq computeSub*(empty, empty) = none .
  eq computeSub*((T, TL), (T', TL')) = computeSub(T, T') ; computeSub*(TL, TL') .

  op implies? : Term -> Bool .
  eq implies?('_implies_[TL]) = true .
  eq implies?(T) = false [owise] .

  op impLevels : Term -> Nat .
  eq impLevels('_implies_[T, T']) = s(impLevels(T')) .
  eq impLevels(T) = 0 [owise] .

  ------------------------------------------------------------------------------------
  ---                                redRequired                                   ---
  ------------------------------------------------------------------------------------

  sort RedReqRes .
  op [_,_] : Bool ScoreInfoSet -> RedReqRes [ctor] .

  op redRequired : ScoreInfoSet Module Term -> RedReqRes .
  ceq redRequired($ M, M', (TL, T, TL') $ SIS, M'', T') = [true, SIS2]
   if CS := getSub(M, T, M'', T') /\
      *** Same premises
      samePremises(M, M', M'', CS) /\
      impLevels(T) == impLevels(T') /\
      T1 := applyCS(T, CS) /\
      T2 := getTerm(metaReduce(M, T)) /\
      T3 := getTerm(metaReduce(M'', T')) /\
      T2 == T3 /\
      SIS2 := if (TL == empty) and (TL' == empty)
              then SIS
              else $ M, M', (TL, TL') $ SIS
              fi .
  eq redRequired(SIS, M, T) = [false, SIS] [owise] .

  op isEquality : Term -> Bool .
  eq isEquality('_=_[T1, T2]) = true .
  eq isEquality(T) = false [owise] .

  *** Flat module
  *** Top module
  *** Goal module
  op samePremises : Module Module Module ConsSub -> Bool .
  eq samePremises(M, M', M'', CS) = samePremises(M, getEqs(M'), M'', CS) .

  op samePremises : Module EquationSet Module ConsSub -> Bool .
  ceq samePremises(M, eq T = T' [AtS] . EqS, M', CS) = exactEq(M', T1, T2) and
                                                       samePremises(M, EqS, M', CS)
   if isExec(AtS) /\
      T1 := instantiateVars(M, M', T, CS) /\
      T2 := instantiateVars(M, M', T', CS) .
  eq samePremises(M, EqS, M', CS) = true [owise] .

  op exactEq : Module Term Term -> Bool .
  ceq exactEq(M, T, T') = true
   if eq T = T' [AtS] . EqS := getEqs(M) .
  eq exactEq(M, T, T') = false [owise] .

  *** Flat module
  *** Top module
  *** Goal module
  op consistentPremises : Module Module ConsSub -> Bool .
  eq consistentPremises(M, M', CS) = consistentPremises(getEqs(M), M, M', CS) .

  op consistentPremises : EquationSet Module Module ConsSub -> Bool [memo] .
  ceq consistentPremises(eq T = T' [AtS] . EqS, M, M', CS) = (T3 =/= 'false.Bool) and
                                                             *** exactEq(M', T1, T2) and
                                                             consistentPremises(EqS, M, M', CS)
   if isExec(AtS) /\
      T1 := instantiateVars(M, M', T, CS) /\
      T2 := instantiateVars(M, M', T', CS) /\
      eqDefinedFor(M', T1) /\
      T3 := getTerm(metaReduce(M', '_=_[T1, T2])) .
  ceq consistentPremises(eq T = T' [AtS] . EqS, M, M', CS) = exactEq(M', T1, T2) and
                                                             consistentPremises(EqS, M, M', CS)
   if isExec(AtS) /\
      T1 := instantiateVars(M, M', T, CS) /\
      T2 := instantiateVars(M, M', T', CS) /\
      eqDefinedFor(M', T1) /\
      not (getTerm(metaReduce(M', '_=_[T1, T2])) :: Term) .
  eq consistentPremises(EqS, M, M', CS) = true [owise] .

  *** Flat module
  *** Top module
  *** Goal module
  op consistentPremisesEq : Module Module Module ConsSub -> Bool [memo] .
  eq consistentPremisesEq(M, M', M'', CS) = consistentPremisesEq(getEqs(M'), M, M', M'', CS) .

  op consistentPremisesEq : EquationSet Module Module Module ConsSub -> Bool .
  ceq consistentPremisesEq(eq T = T' [AtS] . EqS, M, M', M'', CS) =
                           ((T3 =/= 'false.Bool) or-else definedForOther(M'', T1, T2)) and
                           *** asd (exactEq(M'', T1, T2) or-else definedForOther(M'', T1, T2)) and
                           consistentPremisesEq(EqS, M, M', M'', CS)
   if isExec(AtS) /\
      T1 := instantiateVars(M, M'', T, CS) /\
      T2 := instantiateVars(M, M'', T', CS) /\
      eqDefinedFor(M'', T1) /\
      T3 := getTerm(metaReduce(M'', '_=_[T1, T2])) .
  ceq consistentPremisesEq(eq T = T' [AtS] . EqS, M, M', M'', CS) =
                               (exactEq(M'', T1, T2) or definedForOther(M'', T1, T2)) and
                               consistentPremisesEq(EqS, M, M', M'', CS)
   if isExec(AtS) /\
      T1 := instantiateVars(M, M'', T, CS) /\
      T2 := instantiateVars(M, M'', T', CS) /\
      eqDefinedFor(M'', T1) /\
      not (getTerm(metaReduce(M'', '_=_[T1, T2])) :: Term) .
  eq consistentPremisesEq(EqS, M, M', M'', CS) = true [owise] .

  op definedForOther : Module Term Term -> Bool .
  eq definedForOther(M, T, T') = definedForOther(M, getEqs(M), T, T') .

  op definedForOther : Module EquationSet Term Term -> Bool .
  ceq definedForOther(M, eq T = T2 [AtS] . EqS, T, T') = true
   if not isCtor(M, T') /\
      not isCtor(M, T2) /\
      T' =/= T2 .
  ceq definedForOther(M, eq '_=_[T, T1] = 'false.Bool [AtS] . EqS, T, T') = true
   if not isCtor(M, T') /\
      T1 =/= T' .
  eq definedForOther(M, EqS, T, T') = false [owise] .

  op getNameProofScore : ScoreInfoSet -> Qid .
  eq getNameProofScore($ M, M', (T, TL)$ SIS) = getNameProofScore(getImports(M')) .

  op getNameProofScore : ImportList -> Qid .
  eq getNameProofScore(including 'BOOL . IL) = getNameProofScore(IL) .
  eq getNameProofScore(protecting 'EQL . IL) = getNameProofScore(IL) .
  eq getNameProofScore(including Q . IL) = cut(Q) [owise] .

  op cut : Qid -> Qid .
  ceq cut(Q) = qid(substr(STR, 0, N))
   if STR := string(Q) /\
      N := find(STR, "-MODCAFE", 0) .
  eq cut(Q) = Q [owise] .

  op renameRepVars : Term -> Term .
  ceq renameRepVars(T) = T
   if TrS := getVars(T) /\
      moreThanOne(T, TrS) == emptyTermSet .
  ceq renameRepVars(T) = renameRepVars(oneSub(T, V, V'))
   if TrS := getVars(T) /\
      V := moreThanOne(T, TrS) /\
      V' := newVar(V, TrS, 0) .

  op renameRepVars* : TermList -> TermList .
  eq renameRepVars*(empty) = empty .
  eq renameRepVars*((T, TL)) = renameRepVars(T), renameRepVars*(TL) .

  op oneSub : Term Variable Variable -> Term .
  eq oneSub(Q[TL], V, V') = Q[oneSub*(TL, V, V')] .
  eq oneSub(V, V, V') = V' .
  eq oneSub(T, V, V') = T [owise] .

  op oneSub* : TermList Variable Variable -> TermList .
  eq oneSub*(empty, V, V') = empty .
  eq oneSub*((TL, T), V, V') = if oneSub(T, V, V') == T
                               then oneSub*(TL, V, V'), T
                               else TL, oneSub(T, V, V')
                               fi .

  op newVar : Variable TermSet Nat -> Variable .
  ceq newVar(V, V' | TrS, N) = newVar(V, TrS, s(N))
   if V' := qid(string(getName(V)) + string(N, 10) + ":" + string(getType(V))) .
  ceq newVar(V, TrS, N) = V'
   if V' := qid(string(getName(V)) + string(N, 10) + ":" + string(getType(V))) [owise] .

  op moreThanOne : Term TermSet -> TermSet .
  ceq moreThanOne(T, V | TrS) = V
   if numReps(T, V) =/= 1 .
  eq moreThanOne(T, TrS) = emptyTermSet [owise] .

  op numReps : Term Variable -> Nat .
  eq numReps(C, V) = 0 .
  eq numReps(V, V') = if V == V'
                      then 1
                      else 0
                      fi .
  eq numReps(Q[TL], V) = numReps*(TL, V) .

  op numReps* : TermList Variable -> Nat .
  eq numReps*(empty, V) = 0 .
  eq numReps*((T, TL), V) = numReps(T, V) + numReps*(TL, V) .

  op inferGoal : ScoreInfoSet ~> TermList .
  ceq inferGoal($ M, M', (T, TL)$ SIS) = TL2
   if TL' := TL, completeTermList(SIS) /\
      TL1 := inferGoal(M, (T, TL')) /\
      TL2 := renameRepVars*(TL1) .

  sort InferenceResult .
  op [_,_] : Term TermList -> InferenceResult [ctor] .

  op inferGoal : Module TermList -> TermList .
  ceq inferGoal(M, (T, TL)) = T1, TL'
   if [T1, TL1] := $inferGoal(M, T, TL, empty) /\
      TL' := inferGoal(M, TL1) .
  eq inferGoal(M, empty) = empty .

  op $inferGoal : Module Term TermList TermList ~> InferenceResult .
  eq $inferGoal(M, T, empty, TL') = [T, TL'] .
  ceq $inferGoal(M, T, (T', TL), TL') = $inferGoal(M, T'', TL, TL')
   if T'' := unifyGoal(M, T, T') .
  eq $inferGoal(M, T, (T', TL), TL') = $inferGoal(M, T, TL, (TL', T')) [owise] .

  op unifyGoal : Module Term Term ~> Term .
  eq unifyGoal(M, V, V') = V .
  eq unifyGoal(M, V, C) = V .
  ceq unifyGoal(M, C, C') = V
   if not isCtor(M, C) /\
      not isCtor(M, C') /\
      Ty := getType(C) /\
      sameKind(M, Ty, getType(C')) /\
      V := qid(substr(string(Ty), 0, 1) + ":" + string(Ty)) .
  ceq unifyGoal(M, Q[TL], Q[TL']) = Q[TL'']
   if TL'' := unifyGoal*(M, TL, TL') .
  eq unifyGoal(M, '_implies_[T, T'], T'') = unifyGoal(M, T', T'') .
  eq unifyGoal(M, T, '_implies_[T', T'']) = unifyGoal(M, T, T'') .
  ceq unifyGoal(M, T, T') = V
   if isCtor(M, T) /\
      isCtor(M, T') /\
      Ty := getType(metaReduce(M, T)) /\
      V := qid(substr(string(Ty), 0, 1) + ":" + string(Ty)) [owise] .

  op unifyGoal* : Module TermList TermList ~> TermList .
  eq unifyGoal*(M, empty, empty) = empty .
  eq unifyGoal*(M, (T, TL), (T', TL')) = unifyGoal(M, T, T'), unifyGoal*(M, TL, TL') .

  op printProof : Module Qid Qid TermList QidList -> QidList .
  eq printProof(M, Q, Q', TL, QIL) =
          '\n 'open Q' '. '\n
          '\t ':goal '`{ '\n
          printGoals(M, TL, Q, 0)
          '\t '`} '\n '\n
          QIL '\n
          'close .

  op printGoals : Module TermList Qid Nat -> QidList .
  eq printGoals(M, empty, Q, N) = nil .
  ceq printGoals(M, (T, TL), Q, N) =
          '\t '\t 'eq ' '`[ Q' ':nonexec '`] ' ':
                                 metaPrettyPrint(M, T, po) ' '= 'true '. '\n
          printGoals(M, TL, Q, s(N))
   if Q' := if N == 0
            then Q
            else qid(string(Q) + string(N, 10))
            fi .

  op printSub : Substitution -> QidList .
  eq printSub(none) = nil .
  eq printSub(V <- C ; SB) = V '<- getName(C) ';  printSub(SB) .
  eq printSub(V <- Q[TL] ; SB) = V '<- Q '`( printSub*(TL) '`) ';  printSub(SB) .

  op printSub* : TermList -> QidList .
  eq printSub*(empty) = nil .
  eq printSub*(C) = getName(C) .
  eq printSub*((C, T, TL)) = getName(C) '`, printSub*((T, TL)) .
  eq printSub*(Q[TL]) = Q '`( printSub*(TL) '`) .
  eq printSub*((Q[TL], T, TL')) = Q '`( printSub*(TL) '`) '`, printSub*((T, TL')) .
  eq printSub*((V, TL)) = printSub*(TL) .

  *** When inferring goal it is possible that fresh constants appear. In this case
  *** we need to add them or turn them into variables.

  sort SISPair .
  op [_,_] : ScoreInfoSet ScoreInfoSet -> SISPair [ctor] .

  ops fst snd : SISPair -> ScoreInfoSet .
  eq fst([SIS1, SIS2]) = SIS1 .
  eq snd([SIS1, SIS2]) = SIS2 .

  op divideByExecEqs : ScoreInfoSet Nat -> SISPair .
  eq divideByExecEqs(SIS, N) = $divideByExecEqs(SIS, N, [noScoreInfo, noScoreInfo]) .

  op $divideByExecEqs : ScoreInfoSet Nat SISPair -> SISPair .
  eq $divideByExecEqs(noScoreInfo, N, SISP) = SISP .
  eq $divideByExecEqs($ M, M', TL $ SIS, N, [SIS1, SIS2]) =
       if numExecEqs(M') == 0
       then $divideByExecEqs(SIS, N, [SIS1, SIS2])
       else if numExecEqs(M') == N
            then $divideByExecEqs(SIS, N, [$ M, M', TL $ SIS1, SIS2])
            else $divideByExecEqs(SIS, N, [SIS1, $ M, M', TL $ SIS2])
            fi
       fi .

  op numExecEqs : Module -> Nat .
  eq numExecEqs(M) = numExecEqs(getEqs(M)) .

  op numExecEqs : EquationSet -> Nat .
  ceq numExecEqs(eq T = T' [AtS] . EqS) = s(numExecEqs(EqS))
   if isExec(AtS) .
  ceq numExecEqs(ceq T = T' if COND [AtS] . EqS) = s(numExecEqs(EqS))
   if isExec(AtS) .
  eq numExecEqs(EqS) = 0 [owise] .

  ***********************************************************************************
  ***                             AUXILIARY FUNCTIONS                             ***
  ***                                 hasVars                                     ***
  ***********************************************************************************

  op hasVars : Term -> Bool [memo] .
  eq hasVars(Q[TL]) = hasVars*(TL) .
  eq hasVars(V) = true .
  eq hasVars(C) = false .

  op hasVars* : TermList -> Bool .
  eq hasVars*(empty) = false .
  eq hasVars*((T, TL)) = hasVars(T) or-else hasVars*(TL) .

  ***********************************************************************************
  ***                             AUXILIARY FUNCTIONS                             ***
  ***                            Case splitting: cvss                             ***
  ***********************************************************************************

  op subsortSingleBinaryOpConstraints : Module Term -> Bool .
  ceq subsortSingleBinaryOpConstraints(M, T) = subsortSingleBinaryOpConstraints(M, Ty)
   if Ty := getType(metaReduce(M, T)) .

  op subsortSingleBinaryOpConstraints : Module Type -> Bool .
  eq subsortSingleBinaryOpConstraints(M, Ty) = hasSingleBinaryCtor(getOps(M), Ty) and
                                               hasSubsort(getSubsorts(M), Ty) .

  op hasSingleBinaryCtor : OpDeclSet Type -> Bool .
  eq hasSingleBinaryCtor(op Q : Ty1 Ty2 -> Ty [ctor assoc AtS] . ODS, Ty) = hasNoOther(ODS, Ty) .
  eq hasSingleBinaryCtor(ODS, Ty) = false [owise] .

  op hasNoOther : OpDeclSet Type -> Bool .
  eq hasNoOther(op Q : TyL -> Ty [ctor AtS] . ODS, Ty) = false .
  eq hasNoOther(ODS, Ty) = true [owise] .

  op hasSubsort : SubsortDeclSet Type -> Bool .
  eq hasSubsort(subsort Ty1 < Ty . SSDS, Ty) = true .
  eq hasSubsort(SSDS, Ty) = false [owise] .


  ***********************************************************************************
  ***                             AUXILIARY FUNCTIONS                             ***
  ***                            Case splitting: cvs                              ***
  ***********************************************************************************

  op subsortUnaryBinaryOpConstraints : Module Term -> Bool .
  ceq subsortUnaryBinaryOpConstraints(M, T) = subsortUnaryBinaryOpConstraints(M, Ty)
   if Ty := getType(metaReduce(M, T)) .

  op subsortUnaryBinaryOpConstraints : Module Type -> Bool .
  eq subsortUnaryBinaryOpConstraints(M, Ty) = hasBinaryCtor(getOps(M), Ty) and
                                              *** hasUnaryCtor(getOps(M), Ty) and
                                              hasSubsort(getSubsorts(M), Ty) .

  op hasBinaryCtor : OpDeclSet Type -> Bool .
  eq hasBinaryCtor(op Q : Ty1 Ty2 -> Ty [ctor assoc AtS] . ODS, Ty) = true .
  eq hasBinaryCtor(ODS, Ty) = false [owise] .

  op hasUnaryCtor : OpDeclSet Type -> Bool .
  eq hasUnaryCtor(op Q : nil -> Ty [ctor AtS] . ODS, Ty) = true .
  eq hasUnaryCtor(ODS, Ty) = false [owise] .

  ***********************************************************************************
  ***                             AUXILIARY FUNCTIONS                             ***
  ***                                   getIndVar                                 ***
  ***********************************************************************************

  *** Variables
  *** Reduced term
  op getIndVar : Term TermSet ScoreInfoSet -> TermList .
  eq getIndVar(T, emptyTermSet, SIS) = empty .
  ceq getIndVar(T, (V | TrS), SIS) = V
   if isIndVar(T, V, SIS) .
  ceq getIndVar(T, (V | TrS), SIS) = getIndVar(T, TrS, SIS)
   if not isIndVar(T, V, SIS) .

  op isIndVar : Term Variable ScoreInfoSet -> Bool .
  eq isIndVar(T, V, noScoreInfo) = true .
  eq isIndVar(T, V, $ M, M', empty $ SIS) = isIndVar(T, V, SIS) .
  ceq isIndVar(T, V, $ M, M', (T', TL) $ SIS) = isIndVar(T, V, $ M, M', TL $ SIS)
   if T'' := getMatch(T, T', V) /\
      isCtor(M, T'') .
  *** In this case we have several goals and the current reduction is not related
  *** to the current goal.
  ceq isIndVar(T, V, $ M, M', (T', TL) $ SIS) = isIndVar(T, V, $ M, M', TL $ SIS)
   if getMatch(T, T', V) == empty .
  eq isIndVar(T, V, SIS) = false [owise] .

  op getMatch : Term Term Variable -> TermList .
  eq getMatch(V, T, V) = T .
  eq getMatch(Q[TL], Q[TL'], V) = getMatch*(TL, TL', V) .
  eq getMatch(T, '_implies_[T1, T2], V) = getMatch(T, T2, V) .
  eq getMatch('_implies_[T1, T2], T, V) = getMatch(T2, T, V) .
  eq getMatch(T, T', V) = empty [owise] .

  op getMatch* : TermList TermList Variable ~> TermList .
  eq getMatch*((T, TL), (T', TL'), V) = getMatch(T, T', V), getMatch*(TL, TL', V) .
  eq getMatch*(TL, TL', V) = empty [owise] .

  ***********************************************************************************
  ******************************* AUXILIARY FUNCTIONS *******************************
  ************************************* isCtor **************************************
  ***********************************************************************************

  *** This function checks whether the outer operator is a constructor while the rest
  *** of the arguments are fresh constants.
  *** In the case of constants it is enough for it to be a constructor.

  op isCtor : Module Term -> Bool .
  eq isCtor(M, T) = isCtor(getOps(M), T) .

  op isCtor : OpDeclSet Term -> Bool .
  eq isCtor(ODS, V) = true .
  ceq isCtor(op Q : nil -> Ty [ctor AtS] . ODS, C) = true
   if Q := getName(C) .
  eq isCtor(op Q : TyL -> Ty [ctor AtS] . ODS, Q[TL]) =
            allNonCtorConstants(op Q : TyL -> Ty [ctor AtS] . ODS, TL) .
  eq isCtor(ODS, T) = false [owise] .

  op allNonCtorConstants : OpDeclSet TermList -> Bool .
  eq allNonCtorConstants(ODS, empty) = true .
  eq allNonCtorConstants(ODS, (T, TL)) = nonCtorConstant(ODS, T) and
                                         allNonCtorConstants(ODS, TL) .

  op nonCtorConstant : OpDeclSet Term -> Bool .
  eq nonCtorConstant(ODS, V) = false .
  eq nonCtorConstant(ODS, Q[TL]) = false .
  ceq nonCtorConstant(op Q : nil -> Ty [ctor AtS] . ODS, C) = false
   if Q := getName(C) .
  eq nonCtorConstant(ODS, C) = true [owise] .

  ***********************************************************************************
  ******************************* AUXILIARY FUNCTIONS *******************************
  ********************************** EXTRACTS VARS **********************************
  ***********************************************************************************

  op getVars : Term -> TermSet .
  eq getVars(C) = emptyTermSet .
  eq getVars(V) = V .
  eq getVars(Q[TL]) = getVars*(TL) .

  op getVars* : TermList -> TermSet .
  eq getVars*(empty) = emptyTermSet .
  eq getVars*((T, TL)) = getVars(T) | getVars*(TL) .

  ***********************************************************************************
  ******************************* AUXILIARY FUNCTIONS *******************************
  ******************************** PRINT CTF COMMAND ********************************
  ***********************************************************************************

  op printCtfComm : Module Qid Equation -> QidList .
  eq printCtfComm(M, Q, eq T = T' [AtS] .) = '\t ':def Q '= ':ctf ' '`{ 'eq
                                             metaPrettyPrint(M, T, po) ' '=
                                             metaPrettyPrint(M, T', po) '. '`} '\n '\n
                                             '\t ':apply '`( Q '`) '\n '\n .

  op printCtfTermComm : Module Qid Term -> QidList .
  eq printCtfTermComm(M, Q, T) = '\t ':def Q '= ':ctf ' '`[
                                 metaPrettyPrint(M, T, po) ' '. '`] '\n '\n
                                 '\t ':apply '`( Q '`) '\n '\n .

  op printCtfComm : Module Qid Equation Nat -> QidList .
  eq printCtfComm(M, Q, eq T = T' [AtS] ., INDENT) =
                                 indent(INDENT) ':def Q '= ':ctf ' '`{ 'eq
                                 metaPrettyPrint(M, T, po) ' '=
                                 metaPrettyPrint(M, T', po) '. '`} '\n '\n
                                 indent(INDENT) ':apply '`( Q '`) '\n '\n .

  op printCtfTermComm : Module Qid Term Nat -> QidList .
  eq printCtfTermComm(M, Q, T, INDENT) =
                                 indent(INDENT) ':def Q '= ':ctf ' '`[
                                 metaPrettyPrint(M, T, po) ' '. '`] '\n '\n
                                 indent(INDENT) ':apply '`( Q '`) '\n '\n .

  op printCEVS : Module Qid Term -> QidList .
  eq printCEVS(M, Q, T) = '\t ':def Q '= ':cvs ' '`[
                          metaPrettyPrint(M, T, po) ' '. '`] '\n '\n
                          '\t ':apply '`( Q '`) '\n '\n .

  op printCESV : Module Qid Term -> QidList .
  eq printCESV(M, Q, T) = '\t ':def Q '= ':csv ' '`[
                          metaPrettyPrint(M, T, po) ' '. '`] '\n '\n
                          '\t ':apply '`( Q '`) '\n '\n .

  ***********************************************************************************
  ******************************* AUXILIARY FUNCTIONS *******************************
  ********************************** ADD NEW MACRO **********************************
  ***********************************************************************************

  sort NewMacPair .
  op |_,_| : Macros Qid -> NewMacPair [ctor] .

  op addNewMac : Macros Module Equation -> NewMacPair .
  eq addNewMac(MACS, M, Eq) = addNewMac(MACS, M, Eq, 1) .

  op addNewMac : Macros Module Equation Nat -> NewMacPair .
  ceq addNewMac(# M, Q - Eq # MACS, M', Eq', N) = addNewMac(# M, Q - Eq # MACS, M', Eq', s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(# M, Q - T # MACS, M', Eq', N) = addNewMac(# M, Q - T # MACS, M', Eq', s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(# M, Q - T . MLb # MACS, M', Eq', N) = addNewMac(# M, Q - T . MLb # MACS, M', Eq', s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(MACS, M, Eq, N) = | # M, Q - Eq # MACS, Q |
   if Q := qid("csb" + string(N, 10)) [owise] .

  op addNewMac : Macros Module Term -> NewMacPair .
  eq addNewMac(MACS, M, T) = addNewMac(MACS, M, T, 1) .

  op addNewMac : Macros Module Term Nat -> NewMacPair .
  ceq addNewMac(# M, Q - Eq # MACS, M', T, N) = addNewMac(# M, Q - Eq # MACS, M', T, s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(# M, Q - T # MACS, M', T', N) = addNewMac(# M, Q - T # MACS, M', T', s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(# M, Q - T . MLb # MACS, M', T', N) = addNewMac(# M, Q - T . MLb # MACS, M', T', s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(MACS, M, T, N) = | # M, Q - T # MACS, Q |
   if Q := qid("csb" + string(N, 10)) [owise] .

  op addNewMac : Macros Module Term MacroLabel -> NewMacPair .
  eq addNewMac(MACS, M, T, MLb) = addNewMac(MACS, M, T, MLb, 1) .

  op addNewMac : Macros Module Term MacroLabel Nat -> NewMacPair .
  ceq addNewMac(# M, Q - Eq # MACS, M', T, MLb, N) = addNewMac(# M, Q - Eq # MACS, M', T, MLb, s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(# M, Q - T # MACS, M', T', MLb, N) = addNewMac(# M, Q - T # MACS, M', T', MLb, s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(# M, Q - T . MLb # MACS, M', T', MLb', N) =
                                        addNewMac(# M, Q - T . MLb # MACS, M', T', MLb', s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(MACS, M, T, MLb, N) = | # M, Q - T . MLb # MACS, Q |
   if Q := qid("csb" + string(N, 10)) [owise] .

  ************************************************************************************
  ******************************* AUXILIARY FUNCTIONS ********************************
  ****************************** CONSTANT SUBSTITUTIONS ******************************
  ************************************************************************************

  sort ConsSub .
  op mtCS : -> ConsSub [ctor] .
  op _to_ : Constant Constant -> ConsSub [ctor] .
  op __ : ConsSub ConsSub -> ConsSub [ctor assoc comm id: mtCS] .

  *** Module for reduction
  *** Term in reduction
  *** Module for the goal
  *** Goal
  op getSub : Module Term Module Term ~> ConsSub .
  ceq getSub(M, Q[TL], M', Q[TL']) = getSub*(M, TL, M', TL')
   if Q =/= '_implies_ .
  eq getSub(M, V, M', V') = mtCS .
  eq getSub(M, C, M', C) = mtCS .
  ceq getSub(M, C, M', C') = C to C'
   if C =/= C' /\
      not isCtor(M, C) /\
      not isCtor(M', C') .
  eq getSub(M, '_implies_[T, T'], M', T'') = getSub(M, T', M', T'') .
  eq getSub(M, T, M', '_implies_[T', T'']) = getSub(M, T, M', T'') .

  op getSub* : Module TermList Module TermList ~> ConsSub .
  eq getSub*(M, empty, M', empty) = mtCS .
  eq getSub*(M, (T, TL), M', (T', TL')) = getSub(M, T, M', T')
                                          getSub*(M, TL, M', TL') .

  op applyCS : Term ConsSub -> Term .
  eq applyCS(Q[TL], CS) = Q[applyCS*(TL, CS)] .
  eq applyCS(V, CS) = V .
  eq applyCS(C, (C to C') CS) = C' .
  eq applyCS(C, CS) = C [owise] .

  op applyCS* : TermList ConsSub -> TermList .
  eq applyCS*(empty, CS) = empty .
  eq applyCS*((T, TL), CS) = applyCS(T, CS), applyCS*(TL, CS) .

  ************************************************************************************
  ******************************* AUXILIARY FUNCTIONS ********************************
  ************************************************************************************

  op parseModule4Vars : TermList -> OpDeclSet .
  eq parseModule4Vars(empty) = none .
  eq parseModule4Vars('__[TL]) = parseModule4Vars(TL) .
  eq parseModule4Vars(('var_:_.[T , T'], TL)) = parseVars('var_:_.[T , T'])
                                                parseModule4Vars(TL) .
  eq parseModule4Vars(('vars_:_.[T , T'], TL)) = parseVars('vars_:_.[T , T'])
                                                 parseModule4Vars(TL) .
  eq parseModule4Vars((T, TL)) = parseModule4Vars(TL) [owise] .

  op parseVars : Term -> OpDeclSet .
  ceq parseVars('var_:_.['neCafeTokenList['__[TL]], 'CafeToken[T]]) =
                                                           parseVars*(TL, Srt)
   if Srt := downQid(T) .
  ceq parseVars('vars_:_.['neCafeTokenList['__[TL]], 'CafeToken[T]]) =
                                                           parseVars*(TL, Srt)
   if Srt := downQid(T) .
  ceq parseVars('var_:_.['neCafeTokenList[T], 'CafeToken[T']]) =
                                                           op Q : nil -> Srt [none] .
   if Q := downQid(T) /\
      Srt := downQid(T') .
  ceq parseVars('var_:_.['neCafeTokenList[T], 'CafeToken[T']]) =
                                                           op Q : nil -> Srt [none] .
   if Q := downQid(T) /\
      Srt := downQid(T') .

  op parseVars* : TermList Sort -> OpDeclSet .
  eq parseVars*(empty, Srt) = none .
  eq parseVars*((T, TL), Srt) = op downQid(T) : nil -> Srt [none] .
                                parseVars*(TL, Srt) .

  op printRedRes : Module Term Term Type -> QidList .
  eq printRedRes(M, T, T', Ty) = '\n 'reduce metaPrettyPrint(M, T, po) '. '\n
                                 '\g '\! 'Result: '\o metaPrettyPrint(M, T', po) ': Ty
                                 '\n .

  op getHypotheses : Module -> TermList [memo] .
  eq getHypotheses(M) = getHypotheses(getEqs(M)) .

  op getHypotheses : EquationSet -> TermList .
  eq getHypotheses(eq T = 'true.Bool [metadata("HI") AtS] . EqS) = T, getHypotheses(EqS) .
  eq getHypotheses(EqS) = empty [owise] .

***(%
\end{comment}
}
{\codesize
\begin{verbatim}
%)

endm

***(%
\end{verbatim}
}

\subsection{Pretty printing\label{subsec:pretty}}

Once the modules are parsed, it might be interesting to print them. However, we
cannot print them from the corresponding Maude module, since we have lost information
about things like hidden sorts, behavioral equations, etc. For this reason, we will
show how to print the term standing for the original CafeOBJ specification.
%
The module \verb"CAFE-PRETTY-PRINT" is in charge of printing:

{\codesize
\begin{verbatim}
%)

mod CAFE-PRETTY-PRINT is
  pr CafePARSER .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  vars QIL QIL' QIL'' QIL1 QIL2 QIL3 QIL4 QILL QILA PL : QidList .
  vars T T' T'' T''' T1 T2 T3 TW TW' : Term .
  vars ODS ODS' ODS'' VDS : OpDeclSet .
  vars St St' St'' St''' : String .
  vars ME ME' : ModuleExpression .
  vars EqS EqS' : EquationSet .
  vars TL TL' TL'' : TermList .
  var  SSDS : SubsortDeclSet .
  vars AtS AtS' : AttrSet .
  vars Q Q' GID QI : Qid .
  vars RS RS' : RuleSet .
  var  COND : Condition .
  vars M M' FM : Module .
  var  RP : ResultPair .
  var  IL : ImportList .
  var  MAS : MembAxSet .
  var  DB : Database .
  var  Ct : Constant .
  var  C : Condition .
  var  V : Variable .
  var  SS : SortSet .
  vars B B' : Bool .
  vars N N' : Nat .
  var  H : Header .
  var  S : Sort .

***(%
\end{comment}
}

We fix the Maude options for printing in the \verb"printOpts" constant:

{\codesize
\begin{verbatim}
%)

  op printOpts : -> PrintOptionSet .
  eq printOpts = mixfix number rat format .

***(%
\end{verbatim}
}

The character preceding or following a scape character is usually printed without
separation, which worsens the legibility. To prevent the system from doing it, we
use the function \verb"addSpace", which adds extra space if required:

{\codesize
\begin{verbatim}
%)

  op addSpace : QidList -> QidList .
  eq addSpace(QIL) = addSpaceL(addSpaceR(QIL)) .

***(%
\end{verbatim}
}

\noindent
where the auxiliary functions \verb"addSpaceL" and \verb"addSpaceR"
add a space at the left and the right of the list, respectively:

{\codesize
\begin{verbatim}
%)

  op addSpaceL : QidList -> QidList .
  eq addSpaceL('`( QIL) = ' '`( QIL .
  eq addSpaceL('`[ QIL) = ' '`[ QIL .
  eq addSpaceL('`{ QIL) = ' '`{ QIL .
  eq addSpaceL(QIL) = QIL [owise] .

  op addSpaceR : QidList -> QidList .
  eq addSpaceR(QIL '`)) = QIL '`) ' .
  eq addSpaceR(QIL '`]) = QIL '`] ' .
  eq addSpaceR(QIL '`}) = QIL '`} ' .
  eq addSpaceR(QIL) = QIL [owise] .

***(%
\end{verbatim}
}

The function \verb"printCond" prints a condition. It traverses each
specific condition until \verb"nil" is reached. We just show the
equality case, where both terms are printed by using the
\texttt{printOpts} constant above:

{\codesize
\begin{verbatim}
%)

  op printCond : Module Condition -> QidList .
  eq printCond(M, nil) = nil .
  eq printCond(M, T = T' /\ C) = metaPrettyPrint(M, T, printOpts) '=
                                 metaPrettyPrint(M, T', printOpts)
                                 if C == nil
                                 then nil
                                 else '/\ printCond(M, C)
                                 fi .

***(%
   ...
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  eq printCond(M, T := T' /\ C) = metaPrettyPrint(M, T, printOpts) ':=
                                  metaPrettyPrint(M, T', printOpts)
                                  if C == nil
                                  then nil
                                  else '/\ printCond(M, C)
                                  fi .
  eq printCond(M, T => T' /\ C) = metaPrettyPrint(M, T, printOpts) '=>
                                  metaPrettyPrint(M, T', printOpts)
                                  if C == nil
                                  then nil
                                  else '/\ printCond(M, C)
                                  fi .
  eq printCond(M, T : S /\ C) = metaPrettyPrint(M, T, printOpts) ': S
                                if C == nil
                                then nil
                                else '/\ printCond(M, C)
                                fi .

  op printCafeAtS : AttrSet -> QidList .
  eq printCafeAtS(label(Q) AtS) = printCafeAtS(AtS) .
  eq printCafeAtS(metadata("added") AtS) = printCafeAtS(AtS) .
  eq printCafeAtS(none) = nil .
  eq printCafeAtS(AtS) = '\g ' '`{ '\o printCafeAtSAux(AtS) '\g '`} '\o .

  op printCafeAtSAux : AttrSet -> QidList .
  eq printCafeAtSAux(none) = nil .
  eq printCafeAtSAux(nonexec AtS) = 'nonexec printCafeAtSAux(AtS) .
  eq printCafeAtSAux(metadata(St) AtS) = 'metadata: qid(St) printCafeAtSAux(AtS) .
  eq printCafeAtSAux(AtS) = 'No 'print 'specified. [owise] .

  op printLabel : AttrSet -> QidList .
  ceq printLabel(label(Q) AtS) = ' '`[ Q '`] ' ':
   if substr(string(Q), 0, 5) =/= "lemma" .
  eq printLabel(AtS) = nil [owise] .

***(%
  **************************
  *** Print CafeOBJ Term ***
  **************************
\end{comment}
}

The function \verb"printCafeModule" is in charge of printing CafeOBJ modules.
We only distinguish cases to print the appropriate keyword, but the rest of the
methods are common for both kinds of modules:

{\codesize
\begin{verbatim}
%)

  op printCafeModule : Term Module Database Bool -> QidList .
  ceq printCafeModule('cmod!_`{_`}[T, T'], M, DB, B) =
                      '\n 'mod! printCafeName(DB, M, T) '`{
                      '\n first(printCafeBody*(paramSortsMap(T', empty, PL), M, DB, none, PL))
                      '\n '`}
   if PL := paramNames(T) .
  ceq printCafeModule('cmod*_`{_`}[T, T'], M, DB, B) =
                      '\n 'mod* printCafeName(DB, M, T) '`{
                      '\n first(printCafeBody*(paramSortsMap(T', empty, PL), M, DB, none, PL))
                      '\n '`}
   if PL := paramNames(T) .

***(%
\end{verbatim}
}

\noindent
where the function \verb"paramNames" just extracts the parameter names from
the term:

{\codesize
\begin{verbatim}
%)

  op paramNames : Term -> QidList .
  eq paramNames('_`(_`)[T, T']) = cafeParamNames(T') .

***(%
\end{verbatim}
}

The function \verb"printCafeName" is in charge of printing the header
of the module. It distinguishes between all the possible module expressions:

{\codesize
\begin{verbatim}
%)

  op printCafeName : Database Module Term -> QidList .
  eq printCafeName(DB, M, 'CafeToken[T]) = downQid(T) .
  eq printCafeName(DB, M, 'token[T]) = downQid(T) .
  ceq printCafeName(DB, M, '_`(_`)[T, T']) = QIL '`( QIL' '`) '
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeViewExp(DB, M, T') .
  ceq printCafeName(DB, M, '_*`{_`}[T, T']) = QIL '* ' '`{ QIL' '`}
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeRen(T') .
  ceq printCafeName(DB, M, '_+_[T, T']) = QIL '+ QIL'
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeName(DB, M, T') .

***(%
\end{verbatim}
}

The following auxiliary functions are required by \texttt{printCafeName}:
\begin{itemize}
\item
\verb"printCafeViewExp", which prints any view expression:

{\codesize
\begin{verbatim}
%)

  op printCafeViewExp : Database Module Term -> QidList .
  eq printCafeViewExp(DB, M, 'token[T]) = downQid(T) .
  ceq printCafeViewExp(DB, M, '_`,_[T, T']) = QIL '`, ' QIL'
   if QIL := printCafeViewExp(DB, M, T) /\
      QIL' := printCafeViewExp(DB, M, T') .
  ceq printCafeViewExp(DB, M, '_::_[T, T']) = QIL ':: QIL'
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeName(DB, M, T') .
  ceq printCafeViewExp(DB, M, '_<=_[T, T']) = QIL '<= QIL'
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeViewExp(DB, M, T') .
  ceq printCafeViewExp(DB, M, 'view`to_`{_`}[T, T']) =
                                     'view 'to QIL ' '`{ ' QIL' ' '`}
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeMaps(DB, M, T') .
  ceq printCafeViewExp(DB, M, '_`{_`}[T, T']) = QIL ' '`{ ' QIL' ''`}
   if QIL := printCafeName(DB, M, T) /\
      QIL' := printCafeMaps(DB, M, T') .

***(%
\end{verbatim}
}

\item
\verb"printCafeMaps", which prints the possible mappings appearing in views:

{\codesize
\begin{verbatim}
%)

  op printCafeMaps : Database Module Term -> QidList .
  ceq printCafeMaps(DB, M, '__[T, T']) = QIL QIL'
   if QIL := printCafeMaps(DB, M, T) /\
      QIL' := printCafeMaps(DB, M, T') .
  ceq printCafeMaps(DB, M, 'sort_->_.[T, T']) = 'sort Q 'to Q'
   if Q := printCafeName(DB, M, T) /\
      Q' := printCafeName(DB, M, T') .
  ceq printCafeMaps(DB, M, 'hsort_->_.[T, T']) = 'hsort Q 'to Q'
   if Q := printCafeName(DB, M, T) /\
      Q' := printCafeName(DB, M, T') .
  ceq printCafeMaps(DB, M, 'op_->_.['CafeBubble[T], 'CafeBubble[T']]) =
                                                          'op QIL '-> QIL'
   if QIL := metaPrettyPrint(M, T, printOpts) /\
      QIL' := metaPrettyPrint(M, T', printOpts) .

***(%
\end{verbatim}
}

\item
\verb"printCafeRen", which is in charge of printing renamings:

{\codesize
\begin{verbatim}
%)

  op printCafeRen : Term -> QidList .
  ceq printCafeRen('__[T, T']) = QIL '`, ' QIL'
   if QIL := printCafeRen(T) /\
      QIL' := printCafeRen(T') .
  ceq printCafeRen('sort_->_.[T, T']) = 'sort QIL '-> QIL'
   if QIL := printCafeSort(T) /\
      QIL' := printCafeSort(T') .
  ceq printCafeRen('hsort_->_.[T, T']) = 'hsort QIL '-> QIL'
   if QIL := printCafeSort(T) /\
      QIL' := printCafeSort(T') .
  ceq printCafeRen('op_->_.[T, T']) = 'op QIL '-> QIL'
   if QIL := printCafeTerm(T) /\
      QIL' := printCafeTerm(T') .
  ceq printCafeRen('bop_->_.[T, T']) = 'op QIL '-> QIL'
   if QIL := printCafeTerm(T) /\
      QIL' := printCafeTerm(T') .

***(%
\end{verbatim}
}

\item
\verb"printCafeTerm", which prints a token or a singleton bubble:

{\codesize
\begin{verbatim}
%)

  op printCafeTerm : Term -> QidList .
  eq printCafeTerm('token[T]) = downQid(T) .
  eq printCafeTerm('CafeToken[T]) = downQid(T) .
  eq printCafeTerm('CafeBubble[T]) = downQid(T) .

***(%
\end{verbatim}
}

\item
\verb"printCafeSort", which just prints a token or a quoted identifier:

{\codesize
\begin{verbatim}
%)

  op printCafeSort : Term -> QidList .
  eq printCafeSort('CafeToken[T]) = downQid(T) .
  eq printCafeSort(T) = downQid(T) [owise] .

***(%
\end{verbatim}
}

\end{itemize}

We define the sort \verb"PrintCafePair" to return a pair consisting of
the list of quoted identifier computed thus far and the set of variables
defined in the module:

{\codesize
\begin{verbatim}
%)

  sort PrintCafePair .
  op <_,_> : QidList OpDeclSet -> PrintCafePair [ctor] .

***(%
\end{verbatim}
}

We also define methods \verb"first" and \verb"second" to obtain the
corresponding components:

{\codesize
\begin{verbatim}
%)

  op first : PrintCafePair -> QidList .
  eq first(< QIL, ODS >) = QIL .

  op second : PrintCafePair -> OpDeclSet .
  eq second(< QIL, ODS >) = ODS .

***(%
\end{verbatim}
}

The function \verb"printCafeBody*" receives the term standing for the original
CafeOBJ specification, the obtained Maude module, the current database, a set of
variables, and a list of parameters and returns a term of sort containing the
representation of the module and the whole set of variables. It just traverses
all the sentences in the module applying \texttt{printCafeBody} to each of them:

{\codesize
\begin{verbatim}
%)

  op printCafeBody* : Term Module Database OpDeclSet QidList -> PrintCafePair .
  ceq printCafeBody*('__[T, T'], M, DB, ODS, PL) = <
                     if QIL =/= nil
                     then '\t QIL '\n
                     else nil
                     fi QIL', ODS'' >
   if < QIL, ODS' > := printCafeBody(T, M, DB, ODS, PL) /\
      < QIL', ODS'' > := printCafeBody*(T', M, DB, ODS', PL) .
  ceq printCafeBody*(T, M, DB, ODS, PL) = < '\t QIL, ODS' >
   if < QIL, ODS' > := printCafeBody(T, M, DB, ODS, PL) .

***(%
\end{verbatim}
}

The function \verb"printCafeBody" receives a specific CafeOBJ statement and prints it.
When dealing with importations, we just use the \texttt{printCafeName} shown above:

%  *************************
%  *** Importing modules ***
%  *************************

{\codesize
\begin{verbatim}
%)

  op printCafeBody : Term Module Database OpDeclSet QidList -> PrintCafePair .
  ceq printCafeBody('protecting`(_`)[T], M, DB, ODS, PL) =
                                                   < 'protecting '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('pr`(_`)[T], M, DB, ODS, PL) = < 'pr '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('extending`(_`)[T], M, DB, ODS, PL) =
                                                   < 'extending '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('ex`(_`)[T], M, DB, ODS, PL) = < 'ex '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('including`(_`)[T], M, DB, ODS, PL) =
                                                   < 'including '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('inc`(_`)[T], M, DB, ODS, PL) = < 'inc '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('using`(_`)[T], M, DB, ODS, PL) = < 'using '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .
  ceq printCafeBody('us`(_`)[T], M, DB, ODS, PL) = < 'us '`( QIL '`), ODS >
   if QIL := printCafeName(DB, M, T) .

***(%
\end{verbatim}
}

Printing sorts requires to modify them in order to qualify the terms following the
CafeOBJ syntax:

%  ************************
%  *** Sort definitions ***
%  ************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('*`[_`]*[T], M, DB, ODS, PL) = < '* '`[ QIL '`] '*, ODS >
   if QIL := prettyprintParams(printCafeSort(T), PL) .
  ceq printCafeBody('`[_`]['__[T, T']], M, DB, ODS, PL) = < '`[ QIL QIL' '`], ODS >
   if QIL := prettyprintParams(printCafeSort(T), PL) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) .
  ceq printCafeBody('`[_`]['CafeToken[T]], M, DB, ODS, PL) = < '`[ QIL '`], ODS >
   if QIL := prettyprintParams(printCafeSort(T), PL) .
  ceq printCafeBody('`[_`]['_<_[T, T']], M, DB, ODS, PL) = < '`[ QIL '< QIL' '`], ODS >
   if QIL := prettyprintParams*(printCafeSortList(T), PL) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) .

***(%
\end{verbatim}
}

The auxiliary function required by this function are:
\begin{itemize}
\item
\verb"prettyprintParams", which translates sorts from Maude syntax
to CafeOBJ syntax. As we decribed in Section~\ref{subsec:parsing}, we distinguish
whether the character stands for a variable or a constant. If it is a constant, we
have to reorder the term:

{\codesize
\begin{verbatim}
%)

  op prettyprintParams : Qid QidList -> Qid .
  ceq prettyprintParams(Q, PL) = QI
   if St := string(Q) /\
      find(St, ":", 0) == notFound /\
      N := find(St, "$", 0) /\
      St' := substr(St, 0, N) /\
      Q' := qid(St') /\
      Q' in PL /\
      St'' := substr(St, N + 1, length(St)) /\
      QI := qid(St'' + "." + St') .

***(%
\end{verbatim}
}

If it is a variable, we have to mantain the variable name at the beginning of
the character:

{\codesize
\begin{verbatim}
%)

  ceq prettyprintParams(Q, PL) = QI
   if St := string(Q) /\
      N := find(St, ":", 0) /\
      N' := find(St, "$", 0) /\
      St' := substr(St, 0, N) /\
      St'' := substr(St, N + 1, sd(N', N + 1)) /\
      Q' := qid(St'') /\
      Q' in PL /\
      St''' := substr(St, N' + 1, length(St)) /\
      QI := qid(St' + ":" + St''' + "." + St'') .
  eq prettyprintParams(Q, PL) = Q [owise] .

***(%
\end{verbatim}
}

\noindent
and \verb"prettyprintParams*" just traverses the list, applying
\texttt{prettyprintParams} to each element:

{\codesize
\begin{verbatim}
%)

  op prettyprintParams* : QidList QidList -> QidList .
  eq prettyprintParams*(nil, PL) = nil .
  eq prettyprintParams*(Q QIL, PL) =
                 prettyprintParams(Q, PL)
                 prettyprintParams*(QIL, PL) .

***(%
\end{verbatim}
}

\item
\verb"printCafeSortList", which prints all the subterms of the given term by
traversing the flattened list:

{\codesize
\begin{verbatim}
%)

  op printCafeSortList : Term -> QidList .
  ceq printCafeSortList('__[TL]) = QIL
   if QIL := printCafeSortList*(flatten(TL)) .
  eq printCafeSortList(T) = printCafeSort(T) [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"printCafeSortList*" just traverses the list, applying
\verb"printCafeSort" to each element:

{\codesize
\begin{verbatim}
%)

  op printCafeSortList* : TermList -> QidList .
  eq printCafeSortList*(empty) = nil .
  eq printCafeSortList*((T, TL)) = printCafeSort(T) printCafeSortList*(TL) .

***(%
\end{verbatim}
}

\noindent
and \verb"flatten" just removes the juxtaposition operator from a list:

{\codesize
\begin{verbatim}
%)

  op flatten : TermList -> TermList .
  eq flatten(empty) = empty .
  eq flatten(('__[TL], TL')) = flatten((TL, TL')) .
  eq flatten((T, TL)) = T, flatten(TL) [owise] .

***(%
\end{verbatim}
}

\end{itemize}

The printing function does not print variables, since the parsing to compute the
structure of the terms eliminates the syntactic sugar. Instead, we add the variables
to the set of operators:

%  *****************************
%  *** Variable declarations ***
%  *****************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('var_:_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                                       < nil, ODS ODS' >
   if ODS' := parseVars(downQidList(T), downQid(T')) .
  ceq printCafeBody('vars_:_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                                       < nil, ODS ODS' >
   if ODS' := parseVars(downQidList(T), downQid(T')) .

***(%
\end{verbatim}
}

Although several cases are distinguished for printing operators, most of them
work in the same way. We just show the case for basic operator declarations,
where the head and the coarity are printed:

%  *****************************
%  *** Operator declarations ***
%  *****************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('op_:`->_.[T, 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'op QIL ': '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := downQid(T') .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq printCafeBody('op_:`->_`{_`}.[T, 'CafeToken[T'], T''], M, DB, ODS, PL) =
                                        < 'op QIL ': '-> Q' ' '`{ QIL' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('bop_:`->_.[T, 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'bop QIL ': '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := prettyprintParams(downQid(T'), PL) .
  ceq printCafeBody('bop_:`->_`{_`}.[T, 'CafeToken[T'], T''], M, DB, ODS, PL) =
                                        < 'bop QIL ': '-> Q' ' '`{ QIL' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      Q' := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('ops_:`->_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'ops QIL ': '-> Q, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) .
  ceq printCafeBody('ops_:`->_`{_`}.['neCafeTokenList[T], 'CafeToken[T'], T''],
                    M, DB, ODS, PL) = < 'ops QIL ': '-> Q ' '`{ QIL' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('bops_:`->_.['neCafeTokenList[T], 'CafeToken[T']], M, DB, ODS, PL) =
                                        < 'bops QIL ': '-> Q, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) .
  ceq printCafeBody('bops_:`->_`{_`}.['neCafeTokenList[T], 'CafeToken[T'], T''],
                    M, DB, ODS, PL) = < 'bops QIL ': '-> Q ' '`{ QIL' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      Q := prettyprintParams(downQid(T'), PL) /\
      QIL' := printCafeAttS(T'', M, DB) .
  ceq printCafeBody('op_:_->_.[T, T', 'CafeToken[T'']], M, DB, ODS, PL) =
                                        < 'op QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('op_:_->_`{_`}.[T, T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'op QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .
  ceq printCafeBody('bop_:_->_.[T, T', 'CafeToken[T'']], M, DB, ODS, PL) =
                                        < 'bop QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('bop_:_->_`{_`}.[T, T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'bop QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .
  ceq printCafeBody('ops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']],
                    M, DB, ODS, PL) = < 'ops QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('ops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'ops QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .
  ceq printCafeBody('bops_:_->_.['neCafeTokenList[T], T', 'CafeToken[T'']],
                    M, DB, ODS, PL) = < 'bops QIL ': QIL' '-> Q', ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) .
  ceq printCafeBody('bops_:_->_`{_`}.['neCafeTokenList[T], T', 'CafeToken[T''], T'''],
                    M, DB, ODS, PL) = < 'bops QIL ': QIL' '-> Q' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeSortList(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      Q' := prettyprintParams(downQid(T''), PL) /\
      QIL'' := printCafeAttS(T''', M, DB) .

***(%
\end{comment}
}

\noindent
and for predicates, where we take care of parameters in the arity:

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('pred_:_.[T, T'], M, DB, ODS, PL) =
                                        < 'pred QIL ': QIL' '., ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq printCafeBody('pred_:_`{_`}.[T, T', T''], M, DB, ODS, PL) =
                                        < 'pred QIL ': QIL' ' '`{ QIL'' '`}, ODS >
   if QIL := printCafeOperatorHead(T) /\
      QIL' := prettyprintParams*(printCafeSortList(T'), PL) /\
      QIL'' := printCafeAttS(T'', M, DB) .

***(%
\end{comment}
}

The auxiliary function \verb"printCafeOperatorHead" just puts together all the
characters in the operator name:

{\codesize
\begin{verbatim}
%)

  op printCafeOperatorHead : Term -> QidList .
  eq printCafeOperatorHead('CafeToken[T]) = downQid(T) .
  ceq printCafeOperatorHead('__[T, T']) = QIL QIL'
   if QIL := printCafeOperatorHead(T) /\
      QIL' := printCafeOperatorHead(T') .

***(%
\end{verbatim}
}

The printing function for equations and rules are also very similar, so we will
only describe an unconditional equation and a conditional rule. Since we are interested
in each part of the equation the parsing in this case is complicated, so we explain
it in detail:
\begin{itemize}
\item
We check whether the term has a label by parsing the term after trying to extract it.
If the parsing succeeds, then we keep in the \texttt{TW} the term after removing the
label; otherwise, we keep the same term.

\item
Similarly, we extract the attributes from the righthand side. However, this function
cannot fail, so it is not necessary to parse the obtained term.

\item
We compute the list of quoted identifiers standing for the new lefthand side. It will
be use to compute the new variables, kept in \verb"ODS'".

\item
We solve the bubbles in the lefthand side and keep the result in \verb"T1".

\item
We solve the bubbles in the righthand side and keep the obtained term in \verb"T2".
Solving this term requires a special function that takes into account the new
variables that appeared in the lefthand side.

\item
The representation of these terms is kept in \verb"QIL'" and \verb"QIL''", respectively.

\item
The representation of the label is stored in \verb"QILL", while the representation of
the attributes is kept in \verb"QILA".

\item
Finally, the equation is built and returned.

\end{itemize}

%  *****************************
%  *** Equation declarations ***
%  *****************************

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('eq_=_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'eq QILL QIL' '= QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  ceq printCafeBody('beq_=_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'eq QILL QIL' '= QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[TW'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('ceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ceq QILL QIL' '= QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[T'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                       solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .
  ceq printCafeBody('bceq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ceq QILL QIL' '= QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[T'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                       solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .
  ceq printCafeBody('cq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'cq QILL QIL1 '= QIL2 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[T'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL1 := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL2 := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                        solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .
  ceq printCafeBody('bcq_=_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'cq QILL QIL1 '= QIL2 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[T'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL1 := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL2 := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                        solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

  *************************
  *** Rule declarations ***
  *************************
  ceq printCafeBody('trans_=>_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'trans QILL QIL' '=> QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[TW'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('btrans_=>_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'trans QILL QIL' '=> QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      *** T2 := solveBubbles('bubble[TW'], M, false, ODS', DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('trns_=>_.['CafeBubble[T], 'CafeBubble[T']], M, DB, ODS, PL) =
                            < 'trans QILL QIL' '=> QIL'' QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[TW'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T')) .
  ceq printCafeBody('ctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ctrans QILL QIL' '=> QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                         solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

  ceq printCafeBody('bctrans_=>_if_.['CafeBubble[T], 'CafeBubble[T'], 'CafeBubble[T'']],
                    M, DB, ODS, PL) =
                           < 'ctrans QILL QIL' '=> QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                         solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

***(%
\end{comment}
}

Regarding conditional transitions, we have to extended the operations we performed for
unconditional statements by:
\begin{itemize}
\item
Extracting the attributes from the term standing for the condition, since this is now
the last term.

\item
Extending the module with information about sorts, required by the operators defined
with the sort \verb"Universal", to parse the condition. This is performed by applying
the Full Maude function \verb"addInfoConds" to the module extended with the variables
defined in the lefthand side.

\item
Using this extended module to solve the bubbles in the condition, and then printing
it in \verb"QIL3".

\item
The printed transition is finally composed and returned.
\end{itemize}

{\codesize
\begin{verbatim}
%)

  ceq printCafeBody('ctrns_=>_if_.['CafeBubble[T], 'CafeBubble[T'],
                    'CafeBubble[T'']], M, DB, ODS, PL) =
                           < 'ctrns QILL QIL' '=> QIL'' 'if QIL3 QILA '., ODS >
   if TW := if solveBubbles('bubble[extractLabel(T)], M, false, ODS, DB) :: Term
            then extractLabel(T)
            else T
            fi /\
      TW' := removeEqAtS(T'') /\
      QIL := downQidList(TW) /\
      ODS' := ODS opDeclSetFromQidList(QIL) /\
      T1 := solveBubbles('bubble[TW], M, false, ODS, DB) /\
      T2 := solveSecondTerm(M, 'bubble[TW], 'bubble[T'], ODS', DB) /\
      QIL' := prettyprintParams*(addSpace(metaPrettyPrint(M, T1, printOpts)), PL) /\
      QIL'' := prettyprintParams*(addSpace(metaPrettyPrint(M, T2, printOpts)), PL) /\
      M' := addInfoConds(addOps(ODS', M)) /\
      QIL3 := prettyprintParams*(printCond(M,
                    solveBubblesCond('bubble[TW'], M, M', false, ODS', DB)), PL) /\
      QILL := printLabel(T) /\
      QILA := printAtS(getEqAtS(T'')) .

***(%
\end{verbatim}
}

The auxiliary functions used in this case are:
\begin{itemize}
\item
\verb"solveSecondTerm", which add a special operator \verb"_=_" on a new sort
\verb"@@@". We then solve the bubbles in this new sort by using the new operator.
Finally, the constants used in the parsing process are transformed back into variables
if they appear in the operator set:

{\codesize
\begin{verbatim}
%)

  op solveSecondTerm : Module Term Term OpDeclSet Database -> Term .
  ceq solveSecondTerm(M, 'bubble[T], 'bubble[T'], ODS, DB) = T2
   if M' := addOps((ODS op '_=_ : 'Universal 'Universal -> 'Bool [poly(1 2)] .),
               addSorts('@@@, M)) /\
      QIL := downQidList(T) /\
      QIL' := downQidList(T') /\
      RP := metaParse(M', '`( QIL '`) '= '`( QIL' '`), '@@@) /\
      '_=_[T1, T2] := constsToVars(getTerm(RP), ODS) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  eq printCafeBody(T, M, DB, ODS, PL) = < '\r '\! 'Print 'error. '\o, ODS > [owise] .

***(%
\end{comment}
}

\item
\verb"extractLabel", which extracts a label at the beggining of the term:

{\codesize
\begin{verbatim}
%)

  op extractLabel : Term -> Term .
  ceq extractLabel('__[''`[.Qid, T, ''`].Qid, '':.Qid, TL]) = '__[TL]
   if TL =/= empty /\
      Q := downTerm(T) .
  eq extractLabel(T) = T [owise] .

***(%
\end{verbatim}
}

\item
\verb"printLabel", which transforms a term into a list of quoted identifiers.
If the term does not correspond with a label, it is not printed:

{\codesize
\begin{verbatim}
%)

  op printLabel : Term -> QidList .
  ceq printLabel('__[''`[.Qid, T, ''`].Qid, '':.Qid, TL]) = ' '`[ Q '`] ' ':
   if TL =/= empty /\
      Q := downTerm(T) .
  eq printLabel(T) = nil [owise] .

***(%
\end{verbatim}
}

\item
\verb"removeEqAtS", which traverses the list of terms, looking for possible
attributes:

{\codesize
\begin{verbatim}
%)

  op removeEqAtS : Term -> Term .
  ceq removeEqAtS('__[TL]) = if sizeTL(TL') > 1
                             then '__[TL']
                             else TL'
                             fi
   if TL' := removeEqAts*(TL) .
  eq removeEqAtS(TL) = TL [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"removeEqAts*" removes the \verb"nonexec" and \verb"metadata" attributes:

{\codesize
\begin{verbatim}
%)

  op removeEqAts* : TermList -> TermList .
  eq removeEqAts*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) = TL .
  eq removeEqAts*((TL, ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid)) = TL .
  eq removeEqAts*(TL) = TL [owise] .

***(%
\end{verbatim}
}

\item
Analogously, \verb"getEqAtS" returns the terms standing for the attributes:

{\codesize
\begin{verbatim}
%)

  op getEqAtS : Term -> TermList .
  eq getEqAtS('__[TL]) = getEqAtS*(TL) .
  eq getEqAtS(T) = empty [owise] .

***(%
\end{verbatim}
}

\noindent
where \verb"getEqAtS*" just looks for the \verb"nonexec" or \verb"metadata" attributes:

{\codesize
\begin{verbatim}
%)

  op getEqAtS* : Term -> TermList .
  eq getEqAtS*((TL, ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid)) =
                                   ''`{.Qid, ''nonexec.Qid, TL'', ''`}.Qid .
  eq getEqAtS*((TL, ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid)) =
                                   ''`{.Qid, ''metadata.Qid, TL'', ''`}.Qid .
  eq getEqAtS*(TL) = empty [owise] .

***(%
\end{verbatim}
}

\item
Finally, \verb"printAtS" prints the list by placing spaces at both sides (since
the attributes are placed inside curly braces):

{\codesize
\begin{verbatim}
%)

  op printAtS : TermList -> QidList .
  eq printAtS(empty) = nil .
  eq printAtS(TL) = ' downQidList(TL) ' [owise] .

***(%
\end{verbatim}
}

\end{itemize}

{\codesize
\begin{comment}

The function \verb"printCafeAttS" is used to print the attributes in operator
declarations:
%)

  op printCafeAttS : Term Module Database -> QidList .
  ceq printCafeAttS('__[T, T'], M, DB) = QIL QIL'
   if QIL := printCafeAttS(T, M, DB) /\
      QIL' := printCafeAttS(T', M, DB) .
  eq printCafeAttS('constr.@CafeAttr@, M, DB) = 'constr .
  eq printCafeAttS('associative.@CafeAttr@, M, DB) = 'associative .
  eq printCafeAttS('assoc.@CafeAttr@, M, DB) = 'assoc .
  eq printCafeAttS('l-assoc.@CafeAttr@, M, DB) = 'l-assoc .
  eq printCafeAttS('r-assoc.@CafeAttr@, M, DB) = 'r-assoc .
  eq printCafeAttS('commutative.@CafeAttr@, M, DB) = 'commutative .
  eq printCafeAttS('comm.@CafeAttr@, M, DB) = 'comm .
  eq printCafeAttS('idempotent.@CafeAttr@, M, DB) = 'idempotent .
  eq printCafeAttS('idem.@CafeAttr@, M, DB) = 'idem .
  eq printCafeAttS('nonexec.@CafeAttr@, M, DB) = 'nonexec .
  ceq printCafeAttS('prec:_['CafeToken[T]], M, DB) = 'prec: Q
   if Q := downQid(T) .
  ceq printCafeAttS('id:`(_`)['CafeBubble[T]], M, DB) = 'id: '`( QIL '`) '
   if T1 := solveBubbles('bubble[T], M, false, none, DB) /\
      QIL := metaPrettyPrint(M, T1, printOpts) .
  ceq printCafeAttS('id:_['CafeBubble[T]], M, DB) = 'id: QIL '
   if T1 := solveBubbles('bubble[T], M, false, none, DB) /\
      QIL := metaPrettyPrint(M, T1, printOpts) .
  ceq printCafeAttS('idr:`(_`)['CafeBubble[T]], M, DB) = 'idr: '`( QIL '`) '
   if T1 := solveBubbles('bubble[T], M, false, none, DB) /\
      QIL := metaPrettyPrint(M, T1, printOpts) .

***(%
\end{comment}
}
{\codesize
\begin{verbatim}
%)

endm

***(%
\end{verbatim}
}

\subsection{Defining commands for CafeOBJ specifications\label{subsec:cafe:commands}}

We present here how to define the behavior of the commands specified for CafeOBJ
specifications. To add any other command the programmer must define it in the module
\texttt{TRANSLATION-COMMANDS} described in Section~\ref{subsec:syntax} and then define
its behavior in
the \texttt{CAFE2MAUDE-DATABASE-HANDLING} module:

{\codesize
\begin{verbatim}
%)

mod CAFE2MAUDE-DATABASE-HANDLING is
  pr CAFE-PRETTY-PRINT .
  pr CafePARSER .

***(%
\end{verbatim}
}

This module define the \verb"CafeDatabaseClass" sort, which will be used in all
the rules involving CafeOBJ specifications. Since we also want the rest of rules
from Full Maude to work, we add a subsort declaration stating that our class is
a subclass of \verb"DatabaseClass", defined in Full Maude. Finally, we define a
constant \texttt{CafeDatabase} for creating new objects:

{\codesize
\begin{verbatim}
%)

  sort CafeDatabaseClass .
  subsort CafeDatabaseClass < DatabaseClass .
  op CafeDatabase : -> CafeDatabaseClass [ctor] .

***(%
\end{verbatim}
}

We also define a new attribute, that will store whether the user wants the system
to perform a strict translation:

{\codesize
\begin{verbatim}
%)

  op strict :_ : Bool -> Attribute [ctor] .

***(%
\end{verbatim}
}

We specify an attribute \verb"psorts" to keep track of the principal sorts
in the module:

{\codesize
\begin{verbatim}
%)

  op psorts :_ : SortMap -> Attribute [ctor] .

***(%
\end{verbatim}
}

Similarly, the attribute \verb"hsorts" keeps track of hidden sorts:

{\codesize
\begin{verbatim}
%)

  op hsorts :_ : TheorySortMap -> Attribute [ctor] .

  op provided :_ : QidSet -> Attribute [ctor] .

  op scoreInfoMap :_ : ScoreInfoMap -> Attribute [ctor] .

  op maxDepth :_ : Nat -> Attribute [ctor] .

  op initialPrincipalSorts : -> SortMap .
  eq initialPrincipalSorts = ('NAT |-> 'Nat) .

  op initCafeAttS : -> AttributeSet .
  eq initCafeAttS = strict : false, psorts : initialPrincipalSorts, hsorts : empty,
                    provided : none, scoreInfoMap : mtSIM, maxDepth : 5 .


***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  var  N : Nat .
  var  X@Database : CafeDatabaseClass .
  var  CafeM : CafeModule .
  var  O : Oid .
  vars Q Q' QI F : Qid .
  vars QIL QIL' QIL'' : QidList .
  vars T T' T'' : Term .
  var  TL : TermList .
  vars H H' : Header .
  vars DB DB' DB'' : Database .
  vars MD SM SM' SM'' : SModule .
  var  Atts : AttributeSet .
  vars RP RP' : ResultPair? .
  vars ME ME' ME'' : ModuleExpression .
  var  B : Bool .
  var  ODS : OpDeclSet .
  vars M M' : Module .
  **** PSM: Principal Sort Map
  vars PSM PSM' : SortMap .
  vars HSM HSM' : TheorySortMap .
  var  TSM : TheorySortMap .
  vars QS QS' : QidSet .
  vars SIM SIM' : ScoreInfoMap .

***(%
\end{comment}
}

The rule \verb"load-CafeLOOSE" is in charge of loading a module with loose semantics.
It uses the function \verb"procCafeMod" from Section~\ref{subsec:parsing} to parse the
terms. If there is no errors (i.e., the variable \verb"QIL" is equals to \verb"nil")
then the database is updated and a message indicating that the module has been introduced
is shown.
If \verb"QIL" we check whether it contains an error that can be solved by translating
theories as modules. If this is the case and the user does not need a strict translation
(the boolean variable \verb"B" in the attribute \verb"strict" is set to \verb"false")
then the database is updated and a warning message is shown. Otherwise, the database
is not modified and a message is printed:

{\codesize
\begin{verbatim}
%)

  crl [load-CafeLOOSE] :
      < O : X@Database | input : ('cmod*_`{_`}[T, T']), db : DB, output : nil,
                         default : ME, strict : B, psorts : PSM, hsorts : HSM, Atts >
   => if QIL == nil
      then
      < O : X@Database | input : nilTermList, db : DB',
                         output : ('Introduced 'Loose 'Cafe 'Module:
                                   '\g header2Qid(parseHeader(getHeader(T))) '\o '\n),
                         default : parseHeader(getHeader(T)), strict : B,
                         psorts : PSM', hsorts : HSM', Atts >
      else if QIL == paramThWarn
           then if B then
                     < O : X@Database | input : nilTermList, db : DB, output : QIL,
                                        default : ME, strict : B, psorts : PSM,
                                        hsorts : HSM, Atts >
                else
                     < O : X@Database | input : nilTermList, db : DB', output : QIL,
                                        default : parseHeader(getHeader(T)),
                                        strict : B, psorts : PSM',
                                        hsorts : HSM', Atts >
                fi
           else < O : X@Database | input : nilTermList, db : DB, output : QIL,
                                   default : ME, strict : B, psorts : PSM,
                                   hsorts : HSM, Atts >
           fi
      fi
   if TSM := getTheorySort(DB) /\
      < DB', PSM', HSM', QIL > := procCafeMod('cmod*_`{_`}[T, T'], PSM, HSM, TSM, DB) .

***(%
\end{verbatim}
}

The auxiliary function \verb"getHeader" just returns the module name without parameters
and using a Maude token constructor:

{\codesize
\begin{verbatim}
%)

  op getHeader : Term -> Term .
  eq getHeader('CafeToken[T]) = 'token[T] .
  eq getHeader('_`(_`)['CafeToken[T], T']) = 'token[T] .
  eq getHeader('_`[_`]['CafeToken[T], T']) = 'token[T] .
  eq getHeader('_`{_|_`}['CafeToken[T], T', T'']) = 'token[T] .

***(%
\end{verbatim}
}

Similarly to the previous rule, \verb"load-CafeTIGHT" is in charge of loading modules
with tight semantics. In this case we do not have to take into account whether the
message contains a warning message, because parameterized modules are allowed in Maude.
Hence, we just parse the terms with \verb"procCafeMod" and update the database if no
errors are found:

{\codesize
\begin{verbatim}
%)

   crl [load-CafeTIGHT] :
       < O : X@Database | input : ('cmod!_`{_`}[T, T']), db : DB, output : nil,
                          default : ME, strict : B, psorts : PSM, hsorts : HSM, Atts >
    => if QIL == nil
       then
       < O : X@Database | input : nilTermList, db : DB',
                          output : ('Introduced 'Tight 'Cafe 'Module: '\g
                                header2Qid(parseHeader(getHeader(T))) '\o '\n),
                          default : parseHeader(getHeader(T)), strict : B,
                          psorts : PSM', hsorts : HSM', Atts >
       else
       < O : X@Database | input : nilTermList, db : DB, output : QIL,
                          default : ME, strict : B, psorts : PSM, hsorts : HSM, Atts >
       fi
    if TSM := getTheorySort(DB) /\
       < DB', PSM', HSM', QIL > := procCafeMod('cmod!_`{_`}[T, T'], PSM, HSM, TSM, DB) .

***(%
\end{verbatim}
}

Finally, the rule \verb"load-CafeVIEW" loads a CafeOBJ view into the database.
It uses the \verb"procCafeView" function to parse the view and, if no errors are
found, then the database is updated:

{\codesize
\begin{verbatim}
%)

  crl [load-CafeVIEW] :
      < O : X@Database | input : ('cview_from_to_`{_`}[T, TL]), db : DB,
                         output : nil, psorts : PSM, Atts >
   => if QIL == nil
      then
      < O : X@Database | input : nilTermList, db : DB',
                         output : ('Introduced 'Cafe 'View: '\g
                                   header2Qid(parseHeader(getHeader(T))) '\o '\n),
                         psorts : PSM, Atts >
      else
      < O : X@Database | input : nilTermList, db : DB, output : QIL, psorts : PSM, Atts >
      fi
   if < DB', QIL > := procCafeView('cview_from_to_`{_`}[T, TL], PSM, DB) .

  crl [load-CafeVIEW] :
      < O : X@Database | input : ('cview_from_to_`{`}[T, TL]), db : DB,
                         output : nil, psorts : PSM, Atts >
   => if QIL == nil
      then
      < O : X@Database | input : nilTermList, db : DB',
                         output : ('Introduced 'Cafe 'View: '\g
                                   header2Qid(parseHeader(getHeader(T))) '\o '\n),
                         psorts : PSM, Atts >
      else
      < O : X@Database | input : nilTermList, db : DB, output : QIL, psorts : PSM, Atts >
      fi
   if < DB', QIL > := procCafeView('cview_from_to_`{`}[T, TL], PSM, DB) .

***(%
\end{verbatim}
}

{\codesize
\begin{comment}
%)

  crl [load-open-close-block] :
      < O : X@Database | input : ('copen_._close[T, T']), db : DB,
                         output : nil, psorts : PSM, hsorts : HSM,
                         scoreInfoMap : SIM, Atts >
   => if QIL == nil
      then
      < O : X@Database | input : nilTermList, db : DB,
                         output : ('\n '\! 'Opening 'module '\o
                                   getOpenName(T) ': '\n QIL' '\n),
                         psorts : PSM, hsorts : HSM,
                         scoreInfoMap : SIM', Atts >
      else
      < O : X@Database | input : nilTermList, db : DB, output : QIL,
                         psorts : PSM, hsorts : HSM,
                         scoreInfoMap : SIM, Atts >
      fi
   if TSM := getTheorySort(DB) /\
      < DB' | SIM' | QIL | QIL' > := procOpenCloseEnv(T, T', PSM, HSM, TSM, DB, SIM) .

  op getOpenName : Term -> QidList .
  eq getOpenName('CafeToken[T]) = downQid(T) .
  eq getOpenName('token[T]) = downQid(T) .
  eq getOpenName('_+_[T, T']) = getOpenName(T) '+ getOpenName(T') .
  eq getOpenName('`(_`)[T]) = getOpenName(T) .

***(%
\end{comment}
}

The rule \verb"original-cafe-module" displays the CafeOBJ module originally
introduced by the user. It just obtains the module name from the command,
looks for the module in the database and prints it with \texttt{printCafeModule}:

%  ************************************************************************
%  ************************* ORIGINAL CAFE MODULE *************************
%  ************************************************************************

{\codesize
\begin{verbatim}
%)

  crl [original-cafe-module] :
      < O : X@Database | input : ('original`CafeOBJ`module_.['token[T]]),
                         output : nil, db : DB, Atts >
   => < O : X@Database | input : nilTermList, output : QIL,
                         db : DB, Atts >
   if Q := downQid(T) /\
      < T' ; ODS ; M > := getTermModule(Q, DB) /\
      M' := getFlatModule(Q, DB) /\
      QIL := printCafeModule(T', M', DB, false) .

***(%
\end{verbatim}
}

Alternatively, the rule \verb"original-cafe-module-error" is applied when
the module cannot be found:

{\codesize
\begin{verbatim}
%)

  crl [original-cafe-module-error] :
      < O : X@Database | input : ('original`CafeOBJ`module_.['token[T]]),
                         output : nil, db : DB, Atts >
   => < O : X@Database | input : nilTermList, output : ('\n '\r 'ERROR: '\o
                                              'The 'module 'cannot 'be 'found. '\n),
                         db : DB, Atts >
   if Q := downQid(T) /\
      not getTermModule(Q, DB) :: Tuple{Term,OpDeclSet,Module} .

***(%
\end{verbatim}
}

The rule \verb"strict-on" sets the value in \verb"strict" to \verb"true", and
prints a message indicating that the operation was successful:

%  **********************************************************************
%  ************************* SEMANTICS COMMANDS *************************
%  **********************************************************************

{\codesize
\begin{verbatim}
%)

  rl [strict-on] :
     < O : X@Database | input : ('strict`translation`on`..@Command@), strict : B,
                        output : nil, Atts >
  => < O : X@Database | input : nilTermList, strict : true,
                        output : ('\n '\b 'The 'modules 'will 'be 'introduced
                                  'as 'originally 'written. '\o '\n), Atts > .

***(%
\end{verbatim}
}

Similarly, the rule \verb"strict-off" sets the value in \verb"strict" to \verb"false"
and prints the corresponding message:

{\codesize
\begin{verbatim}
%)

  rl [strict-off] :
     < O : X@Database | input : ('strict`translation`off`..@Command@), strict : B,
                        output : nil, Atts >
  => < O : X@Database | input : nilTermList, strict : false,
                        output : ('\n '\b 'The 'translation 'will 'adapt 'CafeOBJ
                                  'specifications 'to 'meet 'Maude 'requirements 'when
                                  'possible. '\o '\n), Atts > .

  crl [require] :
      < O : X@Database | input : ('require_['neCafeTokenList[T]]),
                         output : nil, provided : QS, Atts >
   => < O : X@Database | input : nilTermList,
                         output : QIL, provided : QS, Atts >
   if Q := getModuleRequired(T) /\
      Q' := getFileRequired(T) /\
      QIL := if contained(Q, QS)
             then '\! '\b 'Required 'module '\o Q '\! '\b 'loaded. '\n
             else '\n '\! '\r 'Module '\o Q '\! '\r 'from 'file '\o Q'
                  '\! '\r 'required. 'Please 'load 'the 'file. '\n
             fi .

  crl [provide] :
      < O : X@Database | input : ('provide_['neCafeTokenList[T]]), output : nil,
                         provided : QS, Atts >
   => < O : X@Database | input : nilTermList, output : nil,
                         provided : (QS ; QS'), Atts >
   if QS' := getProvided(T) .

  op getProvided : TermList -> QidSet .
  eq getProvided(empty) = none .
  eq getProvided('__[TL]) = getProvided(TL) .
  eq getProvided((T, TL)) = downQid(T) ; getProvided(TL) .
  eq getProvided(TL) = none [owise] .

  ops getModuleRequired getFileRequired : Term -> Qid .
  eq getModuleRequired('__[T, T']) = downQid(T) .
  eq getFileRequired('__[T, T']) = downQid(T') .

  op contained : Qid QidSet -> Bool .
  eq contained(Q, Q ; QS) = true .
  eq contained(Q, QS) = false [owise] .

***(%
\end{verbatim}
}

%  ***********************************************************************
%  ************************* AUXILIARY FUNCTIONS *************************
%  ***********************************************************************

{\codesize
\begin{verbatim}
%)

  var  SMI : Set{ModuleInfo} .
  vars SMN1 SMN2 SMN3 SMN4 : Set{ModuleName} .
  var  SVI : Set{ViewInfo} .
  var  SVE : Set{ViewExp} .
  var  MN : ModuleName .
  var  DT : Default{Term} .
  vars M1 M2 M3 M4 : Module .

  op getTheorySort : Database -> TheorySortMap [memo] .
  eq getTheorySort(db(SMI, SMN1, SVI, SVE, SMN2, SMN3, SMN4, QIL)) = getTheorySort(SMI) .

  op getTheorySort : Set{ModuleInfo} -> TheorySortMap [memo] .
  eq getTheorySort(emptyInfoSet) = predefinedTheorySort .
  ceq getTheorySort(< MN ; DT ; M1 ; M2 ; M3 ; ODS ; SMN1 ; SVE > SMI) =
       if isTheory(M1)
       then Q -> getSorts(M1)
       else empty
       fi, getTheorySort(SMI)
   if Q := getName(M1) .
  ceq getTheorySort(< MN ; M1 ; M2 ; M3 ; M4 ; ODS ; SMN1 ; SVE > SMI) =
       if isTheory(M2)
       then getName(M2) -> getSorts(M2)
       else empty
       fi, getTheorySort(SMI)
   if Q := getName(M1) .
  eq getTheorySort(SMI) = empty [owise] .

  var  IL : ImportList .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  var  MAS : MembAxSet .
  var  ES : EquationSet .
  var  RS : RuleSet .

  op isTheory : Module -> Bool .
  eq isTheory(fth H is IL sorts SS . SSDS ODS MAS ES endfth) = true .
  eq isTheory(th H is IL sorts SS . SSDS ODS MAS ES RS endth) = true .
  eq isTheory(M) = false [owise] .

  op predefinedTheorySort : -> TheorySortMap [memo] .
  *** TODO: add more predefined
  eq predefinedTheorySort = 'TRIV -> 'Elt .
endm

***(%
\end{verbatim}
}

The module \verb"LOOP-PRE-PROCESSING" performs some normalization actions on
the modules to simplify the parsing functions and the use of the \verb"metaParse"
command. This is specially important due to the use of bubbles, that do not delimit
the terms. Hence the functions in this module:
\begin{itemize}
\item
Add a dot at the end of the statements that do not require it and are not ``closed''
by themselves (e.g.\ the sort declaration constructor \verb"[_]" is closed, while
view mappings are not closed).

\item
Modify some characters that might cause ambiguity, such as the \verb"mod" keyword
at the beginning of a module and is also used by Maude modules.
\end{itemize}

Although the functions distinguish several cases all of them are basically implemented
in the same way, so we do not show the details here:

{\codesize
\begin{verbatim}
%)

mod LOOP-PRE-PROCESSING is
  pr LOOP-MODE .
  pr EXT-BOOL .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  vars Q Q' : Qid .
  vars QIL QIL' QIL'' QIL2 QIL3 : QidList .
  var  S : State .
  var  N : Nat .

***(%
\end{comment}
}

{\codesize
\begin{comment}

The function \verb"normalizeCafeOBJ" add a final \verb"." to delimit each possible
CafeOBJ statement:
%)

  op normalizeCafeOBJ : QidList -> QidList .
  ceq normalizeCafeOBJ(QIL Q Q' QIL') = normalizeCafeOBJ(QIL Q '. Q' QIL')
   if Q =/= '. /\ Q =/= '`, /\ Q =/= '`] /\ Q =/= '* /\ Q =/= '`) /\ Q =/= 'proof /\
     (Q' == 'eq or-else Q' == 'ceq or-else Q' == 'cq or-else
      Q' == 'op or-else Q' == 'ops or-else Q' == 'bop or-else
      Q' == 'bops or-else Q' == 'var or-else
      Q' == 'vars or-else Q' == 'beq or-else Q' == 'bceq or-else
      Q' == 'bcq or-else Q' == 'trans or-else Q' == 'btrans or-else
      Q' == 'ctrans or-else Q' == 'bctrans or-else Q' == 'trns or-else
      Q' == 'ctrns or-else Q' == 'btrns or-else Q' == 'bctrns or-else
      Q' == 'pred or-else Q' == 'red or-else Q' == 'reduce) .
  eq normalizeCafeOBJ(QIL Q '`}) = if Q =/= '. and Q =/= '`] and
                                      Q =/= '* and Q =/= '`) and Q =/= 'proof
                                   then normalizeImports(QIL Q '. '`})
                                   else normalizeImports(QIL Q '`})
                                   fi [owise] .
  eq normalizeCafeOBJ(QIL) = normalizeImports(QIL) [owise] .

  op normalizeImports : QidList -> QidList .
  eq normalizeImports(QIL) = normalizeImports(QIL, nil) .

  op normalizeImports : QidList QidList -> QidList .
  eq normalizeImports(nil, QIL) = QIL .
  ceq normalizeImports('protecting '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'pr '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('pr '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'pr '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('including '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'inc '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('inc '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'inc '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('extending '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'ex '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('ex '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'ex '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('using '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'us '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  ceq normalizeImports('us '`( QIL, QIL') = normalizeImports(QIL3, QIL' 'us '`( QIL2)
   if <<< QIL2, QIL3 >>> := normalizeImp(QIL, nil, 0) .
  eq normalizeImports(Q QIL, QIL') = normalizeImports(QIL, QIL' Q) [owise] .

  sort NormRes .
  op <<<_,_>>> : QidList QidList -> NormRes [ctor] .

  op normalizeImp : QidList QidList Nat -> NormRes .
  eq normalizeImp('`) QIL, QIL', 0) = <<< QIL' '`), QIL >>> .
  eq normalizeImp('`) QIL, QIL', s(N)) = normalizeImp(QIL, QIL' '`), N) .
  eq normalizeImp('`( QIL, QIL', N) = normalizeImp(QIL, QIL' '`(, s(N)) .
  ceq normalizeImp('`{ QIL, QIL', N) = normalizeImp(QIL3, QIL' '`{ QIL2, N)
   if <<< QIL2, QIL3 >>> := otfView(QIL, 0) .
  eq normalizeImp(Q QIL, QIL', N) = normalizeImp(QIL, QIL' Q, N) [owise] .


  op normalizeCafeOBJView : QidList -> QidList .
  ceq normalizeCafeOBJView(QIL '`, Q QIL') = normalizeCafeOBJView(QIL '. Q QIL')
   if Q == 'sort or-else Q == 'hsort or-else Q == 'op or-else
      Q == 'bop or-else Q == 'vvar or-else Q == 'vvars .
  eq normalizeCafeOBJView(QIL 'var QIL') = normalizeCafeOBJView(QIL 'vvar QIL') .
  eq normalizeCafeOBJView(QIL 'vars QIL') = normalizeCafeOBJView(QIL 'vvars QIL') .
  eq normalizeCafeOBJView(QIL) = QIL [owise] .

  op otfView : QidList Nat -> NormRes .
  eq otfView(QIL, N) = otfView(QIL, nil, N) .

  op otfView : QidList QidList Nat -> NormRes .
  eq otfView('`} QIL, QIL', 0) = <<< normalizeCafeOBJView(QIL' '. '`}), QIL >>> .
  eq otfView('`} QIL, QIL', s(N)) = otfView(QIL, QIL' '`}, N) .
  eq otfView('`{ QIL, QIL', N) = otfView(QIL, QIL' '`{, s(N)) .
  eq otfView(Q QIL, QIL', N) = otfView(QIL, QIL' Q, N) [owise] .

  op normalizeOpenClose : QidList -> QidList .
  *** We look for the end of the module expression to place the dot
  ceq normalizeOpenClose(Q Q' QIL) = Q '. normOpenCloseAux(Q' QIL)
   if Q' == '`[ or-else Q == '* or-else
      Q' == 'eq or-else Q' == 'ceq or-else Q' == 'cq or-else
      Q' == 'op or-else Q' == 'ops or-else Q' == 'bop or-else
      Q' == 'bops or-else Q' == 'var or-else
      Q' == 'vars or-else Q' == 'beq or-else Q' == 'bceq or-else
      Q' == 'bcq or-else Q' == 'trans or-else Q' == 'btrans or-else
      Q' == 'ctrans or-else Q' == 'bctrans or-else Q' == 'trns or-else
      Q' == 'ctrns or-else Q' == 'btrns or-else Q' == 'bctrns or-else
      Q' == 'pred or-else Q' == 'red or-else Q' == 'reduce .
  eq normalizeOpenClose(Q '. QIL) = Q '. normOpenCloseAux(QIL) .
  eq normalizeOpenClose(Q Q' QIL) = Q normalizeOpenClose(Q' QIL) [owise] .


  op normOpenCloseAux : QidList -> QidList .
  ceq normOpenCloseAux(QIL Q Q' QIL') = normOpenCloseAux(QIL Q '. Q' QIL')
   if Q =/= '. /\ Q =/= '`, /\ Q =/= '`] /\ Q =/= '* /\ Q =/= '`) /\ Q =/= '`{ /\
      Q =/= '`} /\ Q =/= 'proof /\
     (Q' == 'eq or-else Q' == 'ceq or-else Q' == 'cq or-else
      Q' == 'op or-else Q' == 'ops or-else Q' == 'bop or-else
      Q' == 'bops or-else Q' == 'var or-else
      Q' == 'vars or-else Q' == 'beq or-else Q' == 'bceq or-else
      Q' == 'bcq or-else Q' == 'trans or-else Q' == 'btrans or-else
      Q' == 'ctrans or-else Q' == 'bctrans or-else Q' == 'trns or-else
      Q' == 'ctrns or-else Q' == 'btrns or-else Q' == 'bctrns or-else
      Q' == 'pred or-else Q' == 'red or-else Q' == 'reduce) .
  eq normOpenCloseAux(QIL Q 'close) = if Q =/= '. and Q =/= '`] and
                                         Q =/= '* and Q =/= '`) and
                                         Q =/= '`} and Q =/= 'proof
                                      then QIL Q '. 'close
                                      else QIL Q 'close
                                      fi [owise] .

  eq ['mod! QIL '`}, S, QIL'] = [normalizeCafeOBJ('cmod! QIL '`}), S, QIL'] .
  eq ['module! QIL '`}, S, QIL'] = ['mod! QIL '`}, S, QIL'] .
  eq ['mod* QIL '`}, S, QIL'] = [normalizeCafeOBJ('cmod* QIL '`}), S, QIL'] .
  eq ['mod QIL '`}, S, QIL'] = [normalizeCafeOBJ('cmod* QIL '`}), S, QIL'] .
  eq ['module* QIL '`}, S, QIL'] = ['mod* QIL '`}, S, QIL'] .
  eq ['module QIL '`}, S, QIL'] = ['mod* QIL '`}, S, QIL'] .
  eq ['open QIL 'close, S, QIL'] = ['copen normalizeOpenClose(QIL 'close), S, QIL'] .
  ceq ['view QIL Q '`}, S, QIL'] = [normalizeCafeOBJView('cview QIL Q '. '`}), S, QIL']
   if Q =/= '`{ .
  eq ['view QIL '`{ '`}, S, QIL'] = [normalizeCafeOBJView('cview QIL '`{ '`}), S, QIL'] .
  eq ['make Q QIL, S, QIL'] = ['mod! Q '`{ 'pr QIL '`}, S, QIL'] .
  eq ['cmod! Q 'principal-sort Q' '`{ QIL', S, QIL''] =
     ['cmod! Q '`[ Q' '`] '`{ QIL', S, QIL''] .
  eq ['cmod* Q 'principal-sort Q' '`{ QIL', S, QIL''] =
     ['cmod* Q '`[ Q' '`] '`{ QIL', S, QIL''] .
  eq ['cmod! Q '`( QIL '`) 'principal-sort Q' '`{ QIL', S, QIL''] =
     ['cmod! Q '`{ QIL '| Q' '`} '`{ QIL', S, QIL''] .
  eq ['cmod* Q '`( QIL '`) 'principal-sort Q' '`{ QIL', S, QIL''] =
     ['cmod* Q '`{ QIL '| Q' '`} '`{ QIL', S, QIL''] .
  eq [QIL 'p-sort Q '`{ QIL', S, QIL''] = [QIL 'principal-sort Q '`{ QIL', S, QIL''] .
  ceq [QIL 'eq '`[ Q '`] Q' QIL', S, QIL''] = [QIL 'eq '`[ Q '`] ': Q' QIL', S, QIL'']
   if Q' =/= ': .
  eq ['select Q, S, QIL'] = ['select Q '., S, QIL'] .

***(%
\end{comment}
}
{\codesize
\begin{verbatim}
  ...
%)

endm

***(%
\end{verbatim}
}

Finally, the \verb"CAFE2MAUDE" module is the standard module dealing with input/output
through the Loop Mode~\cite[Chapter~17]{maude-book}. Basically, this module uses a tuple
built with the operator \verb"[_,_,_]", where the first argument corresponds to the
input introduced by the user, the third one the output shown to the user, and the second
one is a term of sort \verb"State" that can be defined by the user for each application:

{\codesize
\begin{verbatim}
%)

mod CAFE2MAUDE is
  ex LOOP-PRE-PROCESSING .
  pr META-CAFE2MAUDE-SIGNATURE .
  pr CAFE2MAUDE-DATABASE-HANDLING .

***(%
\end{verbatim}
}

We will use the sort \verb"Object" for the current state, which means that we will
store the values in a term built with the operator \verb"<_:_|_>", with the first
argument the name of the object, the second one the name of the class, and the third
one a set of attributes.
%
We also define a constant \verb"o" of sort \verb"Oid" to define the name of the initial
state:

{\codesize
\begin{verbatim}
%)

  subsort Object < State .
  op o : -> Oid .

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)

  var  H : Header .
  var  O : Oid .
  var  X@Database : CafeDatabaseClass .
  vars Q Q' QI : Qid .
  vars QIL QIL' QIL'' : QidList .
  var  TL : TermList .
  var  DB : Database .
  var  Atts : AttributeSet .
  var  S : State .

***(%
\end{comment}
}

We define the constant \verb"cafe4maude-init" as the initial system. The user has to
rewrite it with the special command \verb"loop" to start the input/output loop.

%  ---------------------------------------------------------------------------------------
%  --------------------------------------- IN --------------------------------------------
%  ---------------------------------------------------------------------------------------

{\codesize
\begin{verbatim}
%)

  op cafe4maude-init : -> System .

***(%
\end{verbatim}
}

When the user types that command the system will apply the rule \verb"init" below.
It creates the whole sytem, with an empty list of quoted identifiers in the input
(the first \verb"nil"), another one in the output (the second \verb"nil"), and an
object with name \verb"o", class \verb"CafeDatabase", and attributes for the database
(verb"db"), the parsed \verb"input", the messages we want to print (\verb"output"),
the \verb"default" modules (all these attributes are inherited from Full Maude),
and for indicating whether the translation is \verb"strict", which is initially
set to \verb"false":

{\codesize
\begin{verbatim}
%)

  rl [init] :
     cafe4maude-init
  => [nil, < o : CafeDatabase | db : initialDatabase, input : nilTermList,
                                output : ('\n '\t '\b 'CafeInMaude '2.1 '
                                          '`( 'August '8 '`, '2019 '`)
                                          '\o ' 'started. '\n),
                                default : 'CONVERSION, initCafeAttS >,
                                nil] .

***(%
\end{verbatim}
}

The rule \verb"input" moves the list of quoted identifiers in the first argument of the
tuple to the \verb"input" attribute, trying to parse it first. We use the
\verb"CafeGRAMMAR" module to parse this input since this module, as explained in
Section~\ref{subsec:syntax}, contains the syntax of all our programs and commands,
as well as the syntax inherited from Full Maude:

{\codesize
\begin{verbatim}
%)

  rl [input] :
     [QI QIL, < O : X@Database | input : nilTermList, output : nil, Atts >, QIL' ]
  => if metaParse(CafeGRAMMAR, QI QIL, '@Input@) :: ResultPair
     then [nil,
           < O : X@Database | input : getTerm(metaParse(CafeGRAMMAR, QI QIL, '@Input@)),
                              output : nil, Atts >,
          QIL']
     else [nil,
           < O : X@Database | input : nilTermList,
                              output : ('\r 'WARNING: '\o printSyntaxError(metaParse(
                                        CafeGRAMMAR, QI QIL, '@Input@), QI QIL) '\n
                                        'ERROR: 'No 'parse 'for 'input.), Atts >,
           QIL' ]
     fi .

***(%
\end{verbatim}
}

On the other hand, the rule \verb"output" moves the output from the attribute
\verb"output" to the third element of the tuple:

{\codesize
\begin{verbatim}
%)

  rl [output] :
     [QIL, < O : X@Database | output : (QI QIL'), Atts >, QIL'']
  => [QIL, < O : X@Database | output : nil, Atts >, (QI QIL' QIL'')] .
endm

***(%
\end{verbatim}
}
{\codesize
\begin{comment}
%)


set print conceal on .

print conceal mod_is_sorts_._____endm .
print conceal fmod_is_sorts_.____endfm .
print conceal db .


*** trace exclude CAFE2MAUDE .
set show loop stats off .
set show loop timing off .

*** for debugging purposes
set print attribute off .

set show advisories off .

***(%

\end{comment}
}
%)

load model-checker.maude

select CAFE2MAUDE .

loop cafe4maude-init .

*** 3TUPLE now available in Full Maude with different syntax
load predefined.maude