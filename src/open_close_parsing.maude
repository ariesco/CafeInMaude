fmod OPEN-CLOSE-PARSER is
 pr PROOF-DATA-STRUCTURES .
 pr OPEN-CLOSE-AUX .
 pr CafePARSER .
 pr TRIAL-PAIR .
 pr SUBS .

 vars M M' M'' M''' M1 M2 M3 TOP TOP' FLAT FLAT' : Module .
 vars PSM SM VM : SortMap . **** PSM: Principal Sort Map
 vars T T' T'' T''' T1 T2 T3 T4 T5 T6 T7 TP : Term .
 vars PrL PrL' PrL'' PrL1 PrL2 : ProofTreeList .
 vars STR STR' S S' S'' S''' St St' : String .
 vars TL TL' TL'' TLR TL1 TL2 : TermList .
 vars SIS SIS' SIS1 SIS2 : ScoreInfoSet .
 vars F Q Q' Q'' QI QI' ID CMD : Qid .
 vars QIL QIL' QIL'' QILR : QidList .
 vars ST ST' ST'' : SharingTable .
 vars PO PO' PO'' : ProofOrder .
 vars SIM SIM' : ScoreInfoMap .
 vars TSM MSS : TheorySortMap .
 vars EqS EqS' : EquationSet .
 var  SSDS : SubsortDeclSet .
 vars B B' CURR PRVN : Bool .
 vars MLb MLb' : MacroLabel .
 vars OT OT' : OpenTraverse .
 var  ME : ModuleExpression .
 vars P P' P'' : ProofTree .
 vars VS VS' : VariableSet .
 vars CND COND : Condition .
 vars ODS ODS' : OpDeclSet .
 vars MACS MACS' : Macros .
 var  PMAP : ParameterMap .
 vars TrS TrS' : TermSet .
 vars AtS AtS' : AttrSet .
 vars Eq Eq' : Equation .
 var  IPL : ImpPairList .
 var  SB : Substitution .
 vars Ty Ty1 Ty2 : Type .
 vars N N' INDENT : Nat .
 var  DB : ResDatabase .
 vars CS CS' : ConsSub .
 vars NL NL' : NatList .
 vars SS SSV : SortSet .
 var  IL : ImportList .
 vars Srt Srt' : Sort .
 vars G G' G'' : Goal .
 var  MAS : MembAxSet .
 vars V V' : Variable .
 vars C C' : Constant .
 vars QS QS' : QidSet .
 var  SR : SearchRes .
 var  SISP : SISPair .
 var  TyL : TypeList .
 var  RS : RuleSet .
 var  T? : [Term] .
 var  OD : OpDecl .
 var  ML : MList .
 var  H : Header .


 op openCloseModName : -> Qid .
 eq openCloseModName = 'OPEN_CLOSE .

 op procOpenCloseEnv : Term SortMap TheorySortMap ParameterMap TheorySortMap SortSet
                       -> CafeParseResult .
 ceq procOpenCloseEnv('copen_._close[T1, T2], PSM, TSM, PMAP, MSS, SSV) = < DB preOpen(M, Q, TrS, TL, TL'), nil >
  if T := changeTheoryByModule(T1, false, TSM) /\
     < ME, DB > := parseCafeModExp(T, PSM, TSM, PMAP, MSS, SSV) /\
     M := fmod openCloseModName is (including ME .) sorts none . none none none none endfm /\
     < Q, TrS, TL, TL' > := traverse(T2) .

 op traverse : Term -> OpenTraverse .
 eq traverse(T) = traverse(T, < 'no-label, emptyTermSet, empty, empty >) .

 op traverse : Term OpenTraverse -> OpenTraverse .
 ceq traverse('__[T, T'], OT) = traverse(T', OT')
  if OT' := traverse(T, OT) .
 eq traverse(':id`(_`)['CafeToken[T]], < QIL, TrS, TL, TL' >) = < downQid(T), TrS, TL, TL' > .



 eq traverse('reduce_.['CafeBubble[T]], < QIL, TrS, TL, TL' >) =
                                   < QIL, TrS, (TL, 'red_.['CafeBubble[T]]), (TL', 'red_.['CafeBubble[T]]) > .
 eq traverse('red_.['CafeBubble[T]], < QIL, TrS, TL, TL' >) =
                                   < QIL, TrS, (TL, 'red_.['CafeBubble[T]]), (TL', 'red_.['CafeBubble[T]]) > .
 eq traverse(':goal`{_`}[T], < QIL, TrS, TL, TL' >) = < QIL, TrS, TL, (TL', ':goal`{_`}[T]) > .
 eq traverse(':ind`on`(_`)['CafeToken[T]], < QIL, TrS, TL, TL' >) = < QIL, TrS, TL, (TL', ':ind`on`(_`)[T]) > .
 eq traverse(':apply`(_`)['neCafeTokenList[T]], < QIL, TrS, TL, TL' >) = < QIL, TrS, TL, (TL', ':apply`(_`)[T]) > .
 eq traverse(':sel`(_`)['CafeToken[T]], < QIL, TrS, TL, TL' >) = < QIL, TrS, TL, (TL', ':sel`(_`)[T]) > .
 eq traverse(':imp`[_`].['CafeToken[T]], < QIL, TrS, TL, TL' >) = < QIL, TrS, TL, (TL', ':imp`[_`].[T]) > .
 eq traverse(':imp`[_`]by`{_`}['CafeToken[T], 'neCafeTokenList[T']], < QIL, TrS, TL, TL' >) =
                                                                             < QIL, TrS, TL, (TL', ':imp`[_`]by`{_`}[T, T']) > .
 eq traverse(':proof`(_`)['CafeToken[T]], < QIL, TrS, TL, TL' >) = < QIL, TrS, TL, (TL', ':proof`(_`)[T]) > .
 eq traverse(':infer`(_`)['CafeToken[T]], < QIL, TrS, TL, TL' >) = < QIL, TrS, TL, (TL', ':infer`(_`)[T]) > .

 eq traverse(':def_=`:ctf`{_`}['CafeToken[T], T'], < QIL, TrS, TL, TL' >) = < QIL, TrS, TL, (TL',':def_=`:ctf`{_`}[T, T']) > .
 eq traverse(':def_=`:ctf`[_`]['CafeToken[T], 'CafeBubble[T']], < QIL, TrS, TL, TL' >) = < QIL, TrS, TL, (TL',':def_=`:ctf`[_`][T, T']) > .
 eq traverse(':def_=`:cvvs`[_`]['CafeToken[T], 'CafeBubble[T']], < QIL, TrS, TL, TL' >) =
                                                                < QIL, TrS, TL, (TL',':def_=`:cvvs`[_`][T, T']) > .
 eq traverse(':def_=`:cvss`[_`]['CafeToken[T], 'CafeBubble[T']], < QIL, TrS, TL, TL' >) =
                                                                < QIL, TrS, TL, (TL',':def_=`:cvss`[_`][T, T']) > .
 eq traverse(':def_=`:cvsv`[_`]['CafeToken[T], 'CafeBubble[T']], < QIL, TrS, TL, TL' >) =
                                                                < QIL, TrS, TL, (TL',':def_=`:cvsv`[_`][T, T']) > .
 eq traverse(':def_=`:cevss`[_`]['CafeToken[T], 'CafeBubble[T']], < QIL, TrS, TL, TL' >) =
                                                                < QIL, TrS, TL, (TL',':def_=`:cevss`[_`][T, T']) > .
 eq traverse(':def_=`:cvs`[_`]['CafeToken[T], 'CafeBubble[T']], < QIL, TrS, TL, TL' >) =
                                                                < QIL, TrS, TL, (TL',':def_=`:cvs`[_`][T, T']) > .
 eq traverse(':def_=`:csv`[_`]['CafeToken[T], 'CafeBubble[T']], < QIL, TrS, TL, TL' >) =
                                                                < QIL, TrS, TL, (TL',':def_=`:csv`[_`][T, T']) > .
 eq traverse(':def_=`:csvs`[_`]['CafeToken[T], 'CafeBubble[T']], < QIL, TrS, TL, TL' >) =
                                                                < QIL, TrS, TL, (TL',':def_=`:csvs`[_`][T, T']) > .


 eq traverse(':postpone`..@CafeInductiveComm@, < QIL, TrS, TL, TL' >) = < QIL, TrS, TL, (TL', ':postpone`..@CafeInductiveComm@) > .
 eq traverse(':show`proof`..@CafeInductiveComm@, < QIL, TrS, TL, TL' >) = < QIL, TrS, TL, (TL', ':show`proof`..@CafeInductiveComm@) > .
 eq traverse(':desc`proof`..@CafeInductiveComm@, < QIL, TrS, TL, TL' >) = < QIL, TrS, TL, (TL', ':desc`proof`..@CafeInductiveComm@) > .
 eq traverse(':desc`..@CafeInductiveComm@, < QIL, TrS, TL, TL' >) = < QIL, TrS, TL, (TL', ':desc`..@CafeInductiveComm@) > .
 eq traverse(T, < QIL, TrS, TL, TL' >) = < QIL, (TrS | T), TL, TL' > [owise] .

 op parseOpenEnv : Module Module Qid TermSet TermList TermList ScoreInfoMap -> CafeParseResult .
 ceq parseOpenEnv(TOP, FLAT, Q, TrS, TL, TL', SIM) = < SIM' | QIL | QIL' >
  if Q =/= 'no-label /\
     < TOP', FLAT', VS, QIL > := parseBubbles(TrS, TOP, FLAT) /\
     TLR := parseRedTerms(FLAT', TL, VS) /\
     SIM' := addSIM(SIM, Q, $ FLAT', TOP', TLR $) /\
     QIL' := processRedThCommands(FLAT', TL', mtPT, 'foo:Foo, mtMacros, finished, VS, SIM) .
 ceq parseOpenEnv(TOP, FLAT, 'no-label, TrS, TL, TL', SIM) = < SIM | QIL | QIL' >
  if < TOP', FLAT', VS, QIL > := parseBubbles(TrS, TOP, FLAT) /\
     QIL' := processRedThCommands(FLAT', TL', mtPT, 'foo:Foo, mtMacros, finished, VS, SIM) .
 eq parseOpenEnv(TOP, FLAT, Q, TrS, TL, TL', SIM) = < SIM | nil | 'Environment 'not 'parsed. > [owise] .

 op processRedThCommands : Module TermList ProofTree Variable Macros ProofOrder VariableSet ScoreInfoMap -> QidList .
 eq processRedThCommands(M, empty, P, V, MACS, PO, VS, SIM) = nil .
 ceq processRedThCommands(M, ('red_.['CafeBubble[T]], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, V, MACS, PO, VS, SIM)
  if QIL := evalRedCommand(M, T, VS) .
 ceq processRedThCommands(M, (':goal`{_`}[T], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P', V, MACS, PO', VS, SIM)
  if [P', PO', QIL] := evalGoalCommand(M, T, VS) .
 ceq processRedThCommands(M, (':ind`on`(_`)[T], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, T', MACS, PO, VS, SIM)
  if T' := downTerm(T) /\
     T' :: Variable /\
     QIL := '\n 'Induction 'set 'on metaPrettyPrint(M, T', po) '\n .
 ceq processRedThCommands(M, (':apply`(_`)[T], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, (':apply`(_`)['__[T3, TL']], TL), P', V, MACS, PO', VS, SIM)
  if '__[T2, T3, TL'] := T /\
     TL' =/= empty /\
     Q := downQid(T2) /\
     [P', PO', QIL] := evalApply(M, Q, P, V, MACS, PO) .
 ceq processRedThCommands(M, (':apply`(_`)[T], TL), P, V, MACS, PO, VS, SIM) =
          QIL processRedThCommands(M, (':apply`(_`)[T3], TL), P', V, MACS, PO', VS, SIM)
  if '__[T2, T3] := T /\
     Q := downQid(T2) /\
     [P', PO', QIL] := evalApply(M, Q, P, V, MACS, PO) .
 ceq processRedThCommands(M, (':apply`(_`)[T], TL), P, V, MACS, PO, VS, SIM) =
          QIL processRedThCommands(M, TL, P', V, MACS, PO', VS, SIM)
  if Q := downQid(T) /\
     [P', PO', QIL] := evalApply(M, Q, P, V, MACS, PO) .
  ceq processRedThCommands(M, (':sel`(_`)[T], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P', V, MACS, PO', VS, SIM)
   if Q := downQid(T) /\
      NL := qid2natlist(Q) /\
      P' := selectGoal(P, NL) /\
      PO' := selectGoal(PO, NL) /\
      QIL := '\n 'Sentence Q 'selected. '\n .
  ceq processRedThCommands(M, (':postpone`..@CafeInductiveComm@, TL), P, V, MACS, NL y PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P', V, MACS, PO', VS, SIM)
   if PO' := PO y NL /\
      P' := selectGoal(P, fst(PO')) /\
      QIL := '\n 'Sentence printIndex(NL) 'postponed. '\n .
  ceq processRedThCommands(M, (':imp`[_`].[T], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P', V, MACS, PO, VS, SIM)
   if Q := downQid(T) /\
      [P', B] := applyImp(P, Q) /\
      QIL := if B
             then '\n 'New 'goal 'generated: printCurrent(P')
             else '\n 'Command 'failed. '\n
             fi .
  ceq processRedThCommands(M, (':imp`[_`]by`{_`}[T, T'], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL,  P', V, MACS, PO, VS, SIM)
   if Q := downQid(T) /\
      SB := procImpSub(getMod(P, fst(PO)), T') /\
      [P', B] := applyImp(P, Q, SB) /\
      QIL := if B
             then '\n 'New 'goal 'generated: printCurrent(P')
             else '\n 'Command 'failed. '\n
             fi .
  ceq processRedThCommands(M, (':def_=`:ctf`{_`}[T, T'], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, V, MACS # M', Q - Eq #, PO, VS, SIM)
   if Q := downQid(T) /\
      # M', Q - Eq # := parseEqMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':ctf ' '`{ ' printEq(M', Eq) ' '`} '\n .
  ceq processRedThCommands(M, (':def_=`:ctf`[_`][T, T'], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, V, MACS # M', Q - T2 #, PO, VS, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':ctf ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, (':def_=`:cvss`[_`][T, T'], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, V, MACS # M', Q - T2 . cvss #, PO, VS, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      subsortSingleBinaryOpConstraints(M', T2) /\
      QIL := '\n Q 'defined 'as ':cvss ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, (':def_=`:cvvs`[_`][T, T'], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, V, MACS # M', Q - T2 . cvvs #, PO, VS, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':cvvs ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, (':def_=`:cvsv`[_`][T, T'], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, V, MACS # M', Q - T2 . cvsv #, PO, VS, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':cvsv ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, (':def_=`:cevss`[_`][T, T'], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, V, MACS # M', Q - T2 . cevss #, PO, VS, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      QIL := '\n Q 'defined 'as ':cevss ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, (':def_=`:cvs`[_`][T, T'], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, V, MACS # M', Q - T2 . cvs #, PO, VS, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      subsortUnaryBinaryOpConstraints(M', T2) /\
      QIL := '\n Q 'defined 'as ':cvs ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, (':def_=`:csv`[_`][T, T'], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, V, MACS # M', Q - T2 . csv #, PO, VS, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      subsortUnaryBinaryOpConstraints(M', T2) /\
      QIL := '\n Q 'defined 'as ':csv ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, (':def_=`:csvs`[_`][T, T'], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, V, MACS # M', Q - T2 . csvs #, PO, VS, SIM)
   if Q := downQid(T) /\
      # M', Q - T2 # := parseTermMacro(P, Q, T') /\
      subsortUnaryBinaryOpConstraints(M', T2) /\
      QIL := '\n Q 'defined 'as ':csvs ' '`[ ' metaPrettyPrint(M', T2, po) ' '`] '\n .
  ceq processRedThCommands(M, (':show`proof`..@CafeInductiveComm@, TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, V, MACS, PO, VS, SIM)
   if QIL := '\n 'Current 'goals: printGoals(P) .
  ceq processRedThCommands(M, (':desc`proof`..@CafeInductiveComm@, TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, V, MACS, PO, VS, SIM)
   if QIL := '\n 'Current 'proof: printProofTree(P) .
  ceq processRedThCommands(M, (':desc`..@CafeInductiveComm@, TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, V, MACS, PO, VS, SIM)
   if QIL := '\n 'Current 'goal: printCurrent(P) .
  eq processRedThCommands(M, (':id`(_`)[T], TL), P, V, MACS, PO, VS, SIM) =
           processRedThCommands(M, TL, P, V, MACS, PO, VS, SIM) .
  ceq processRedThCommands(M, (':proof`(_`)[T], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, V, MACS, PO, VS, SIM)
   if Q := downQid(T) /\
      QIL := inferProof(M, Q, SIM[Q], mtMacros) .
  ceq processRedThCommands(M, (':infer`(_`)[T], TL), P, V, MACS, PO, VS, SIM) =
           QIL processRedThCommands(M, TL, P, V, MACS, PO, VS, SIM)
   if Q := downQid(T) /\
      QIL := inferWithGoalProof(M, Q, SIM[Q], mtMacros) .
  eq processRedThCommands(M, (T, TL), P, V, MACS, PO, VS, SIM) =
           '\n 'Error 'in 'command.
           processRedThCommands(M, TL, P, V, MACS, PO, VS, SIM) [owise] .




 op evalRedCommand : Module Term VariableSet -> QidList .
 ceq evalRedCommand(M, T, VS) = QIL'
  if QIL := downQidList(T) /\
     T' := getTerm(metaParse(M, VS, QIL, anyType)) /\
     T'' := addComments(getTerm(metaReduce(M, T'))) /\
     QIL' := evalRedCommandFinal(M, T'', T') .

  op evalRedCommandFinal : Module Term Term -> QidList .
  ceq evalRedCommandFinal(M, T, T1) = QIL '\n QIL'
   if | T', QIL, ST | := changeSearch(M, T, mtST) /\
      {T'', Ty} := metaReduce(M, T') /\
      QIL' := printRedRes(M, T1, T'', Ty) .

  op evalGoalCommand : Module Term VariableSet -> GoalRes .
  ceq evalGoalCommand(M, T, VS) = [P, (nil).NatList, QIL']
   if TrS := getGoalEqs(T) /\
      < M', M', VS, QIL > := parseBubbles(TrS, M, M, VS) /\
      P := getNew(M, getEqs(M), getEqs(M')) /\
      QIL' := 'New 'goal 'introduced: '\n printGoals(P) '\n .
  eq evalGoalCommand(M, T, VS) = [mtPT, finished, '\n 'Error 'processing 'goal. '\n] [owise] .


  op getGoalEqs : Term -> TermSet .
  eq getGoalEqs('__[T, T']) = T | getGoalEqs(T') .
  eq getGoalEqs(T) = T [owise] .

  op evalApply : Module Qid ProofTree Variable Macros ProofOrder -> GoalRes .
  ceq evalApply(M, 'si, P, V, MACS, PO) = [P', PO', QIL]
   if [P', PO'] := applyInduction(P, V, PO) /\
      QIL := '\n 'Induction 'applied 'on metaPrettyPrint(M, V, po) ':
             '\n 'New 'goal: printGoals(P') '\n .
  ceq evalApply(M, 'tc, P, V, MACS, PO) = [P', PO', QIL]
   if [P', PO'] := applyTC(P, PO) /\
      QIL := '\n 'Theorem 'of 'constants 'applied.
             '\n 'New 'goal: printGoals(P') '\n .
  ceq evalApply(M, 'rd, P, V, MACS, PO) = [P'', PO', QIL]
   if [P', B] := applyRed(P) /\
      PO' := if B
             then pop(PO)
             else PO
             fi /\
      B' := PO' == finished /\
      P'' := if B and (not B')
             then selectGoal(P', fst(PO'))
             else P'
             fi /\
      QIL := '\n '\n 'Reduction 'applied.
             'The 'goal 'was if B then nil else 'not fi 'discharged
             if B and (not B')
             then '\n 'Next 'goal 'is '\! printIndex(fst(PO')) '\o
             else if B'
                  then '\n '\! 'PROOF 'FINISHED! '\o '\n
                  else nil
                  fi
             fi .
  ceq evalApply(M, 'rd-, P, V, MACS, PO) = [P'', PO', QIL]
   if [P', B] := applyRed(P) /\
      PO' := if B
             then pop(PO)
             else PO
             fi /\
      B' := PO' == finished /\
      P'' := if B and (not B')
             then selectGoal(P', fst(PO'))
             else P'
             fi /\
      QIL := '\n '\n 'Reduction 'applied.
             'The 'goal 'was if B then nil else 'not fi 'discharged
             if B and (not B')
             then '\n 'Next 'goal 'is '\! printIndex(fst(PO')) '\o
             else if B'
                  then '\n '\! 'PROOF 'FINISHED! '\o '\n
                  else nil
                  fi
             fi .
  ceq evalApply(M, Q, P, V, # M', Q - Eq # MACS, PO) = [P', PO', QIL]
   if P' := applyEquationMacro(P, Q, Eq) /\
      PO' := indProofOrder(fst(PO), 2) y pop(PO) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .
  ceq evalApply(M, Q, P, V, # M', Q - T # MACS, PO) = [P', PO', QIL]
   if Ty := getType(metaReduce(M', T)) /\
      [P', PO'] := applyTermMacro(P, PO, Q, T, Ty) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .
  ceq evalApply(M, Q, P, V, # M', Q - T . cvss # MACS, PO) = [P', PO', QIL]
   if Ty := getType(metaReduce(M', T)) /\
      [P', PO'] := applyTermMacro(P, PO, Q, T, cvss, Ty) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .
  ceq evalApply(M, Q, P, V, # M', Q - T . cvs # MACS, PO) = [P', PO', QIL]
   if Ty := getType(metaReduce(M', T)) /\
      [P', PO'] := applyTermMacro(P, PO, Q, T, cvs, Ty) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .
  ceq evalApply(M, Q, P, V, # M', Q - T . csv # MACS, PO) = [P', PO', QIL]
   if Ty := getType(metaReduce(M', T)) /\
      [P', PO'] := applyTermMacro(P, PO, Q, T, csv, Ty) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .
  ceq evalApply(M, Q, P, V, # M', Q - T . csvs # MACS, PO) = [P', PO', QIL]
   if Ty := getType(metaReduce(M', T)) /\
      [P', PO'] := applyTermMacro(P, PO, Q, T, csvs, Ty) /\
      QIL := '\n 'Generated 'new 'goals
             '\n printGoals(P') .

  op getCtors : Module Sort -> OpDeclSet .
  eq getCtors(M, Srt) = getCtors(M, getOps(M), Srt) .

  op getCtors : Module OpDeclSet Sort -> OpDeclSet .
  eq getCtors(M, op Q : TyL -> Srt [ctor AtS] . ODS, Srt) = op Q : TyL -> Srt [ctor AtS] .
                                                            getCtors(M, ODS, Srt) .
  ceq getCtors(M, op Q : TyL -> Ty [ctor AtS] . ODS, Srt) = op Q : TyL -> Ty [ctor AtS] .
                                                            getCtors(M, ODS, Srt)
   if Ty =/= 'Universal /\
      sameKind(M, Ty, Srt) /\
      sortLeq(M, Ty, Srt) .
  eq getCtors(M, ODS, Srt) = none [owise] .

  op getExactCtors : Module Sort -> OpDeclSet .
  eq getExactCtors(M, Srt) = getExactCtors(M, getOps(M), Srt) .

  op getExactCtors : Module OpDeclSet Sort -> OpDeclSet .
  eq getExactCtors(M, op Q : TyL -> Srt [ctor AtS] . ODS, Srt) = op Q : TyL -> Srt [ctor AtS] .
                                                            getExactCtors(M, ODS, Srt) .
  eq getExactCtors(M, ODS, Srt) = none [owise] .

  op buildTermsCtors : OpDeclSet String -> TermList .
  eq buildTermsCtors(none, STR) = empty .
  ceq buildTermsCtors(OD ODS, STR) = (T, TL)
   if T := buildTermCtor(OD, STR) /\
      TL := buildTermsCtors(ODS, STR) .

  op buildTermCtor : OpDecl String -> Term .
  ceq buildTermCtor(op Q : nil -> Srt [AtS] ., STR) = C
   if C := qid(string(Q) + "." + string(Srt)) .
  ceq buildTermCtor(op Q : TyL -> Srt [AtS] ., STR) = Q[TL]
   if TL := buildArgs(TyL, empty, STR) [owise] .

  op procImpSub : Module Term ~> Substitution .
  eq procImpSub(M, '__[TL]) = $procImpSub(M, getOps(M), TL) .

  op $procImpSub : Module OpDeclSet TermList ~> Substitution .
  eq $procImpSub(M, ODS, empty) = none .
  ceq $procImpSub(M, ODS, (T, ''<-.Qid, T', '';.Qid, TL)) = V <- C ; $procImpSub(M, ODS, TL)
   if V := downQid(T) /\
      Q := downQid(T') /\
      op Q : nil -> Ty [AtS] . ODS' := ODS /\
      sameKind(M, Ty, getType(V)) /\
      C := qid(string(Q) + "." + string(Ty)) .
  ceq $procImpSub(M, ODS, (T, ''<-.Qid, T', '';.Qid, TL)) = V <- C ; $procImpSub(M, ODS, TL)
   if V := downQid(T) /\
      C := downQid(T') .
  ceq $procImpSub(M, ODS, (T, ''<-.Qid, T', ''`(.Qid, TL, ''`).Qid,  '';.Qid, TL')) =
                                                      V <- Q[TL''] ; $procImpSub(M, ODS, TL')
   if V := downQid(T) /\
      Q := downQid(T') /\
      TL'' := parseSubList(ODS, TL) .

  op parseSubList : OpDeclSet TermList ~> TermList .
  eq parseSubList(ODS, empty) = empty .
  eq parseSubList(ODS, (''`,.Qid, TL)) = parseSubList(ODS, TL) .
  ceq parseSubList(ODS, (T, TL)) = C, parseSubList(ODS, TL)
   if Q := downQid(T) /\
      op Q : nil -> Ty [AtS] . ODS' := ODS /\
      C := qid(string(Q) + "." + string(Ty)) .
  ceq parseSubList(ODS, (T, TL)) = C, parseSubList(ODS, TL)
   if C := downQid(T) .
  ceq parseSubList(ODS, (T, ''`(.Qid, TL, ''`).Qid, TL')) = Q[TL''], parseSubList(ODS, TL')
   if Q := downQid(T) /\
      TL'' := parseSubList(ODS, TL) .

  ************************************************************************************
  ********************************* APPLY TERM MACRO *********************************
  ************************************************************************************

  op applyTermMacro : ProofTree ProofOrder Qid Term Type -> IndResPair .
  eq applyTermMacro(P, PO, Q, T, Ty) = $applyTermMacro(P, PO, Q, T, Ty) .

  op $applyTermMacro : ProofTree ProofOrder Qid Term Type -> IndResPair .
  eq $applyTermMacro(mtPT, PO, Q, T, Ty) = [mtPT, finished] .
  ceq $applyTermMacro(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, PO, Q, T, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if [ PrL', PO' ] := $applyTermMacro*(PrL, PO, Q, T, Ty) .
  ceq $applyTermMacro(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO, Q, T, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if ODS := getCtors(M, Ty) /\
      TL := ordTrueFalse(buildTermsCtors(ODS, "CS" + natlist2string(NL))) /\
      ML := createModules(M, T, TL) /\
      PrL' := createCTFTerm(ML, NL, Q, EqS) /\
      PO' := indProofOrder(fst(PO), size(TL)) y pop(PO) .

  op applyTermMacro : ProofTree ProofOrder Qid Term MacroLabel Type -> IndResPair .
  eq applyTermMacro(P, PO, Q, T, MLb, Ty) = $applyTermMacro(P, PO, Q, T, MLb, Ty) .
  ceq $applyTermMacro(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, PO, Q, T, MLb, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if [ PrL', PO' ] := $applyTermMacro*(PrL, PO, Q, T, MLb, Ty) .
  *** Case selection cvss: value (eq1) + seq seq (eq2)
  ceq $applyTermMacro(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO, Q, T, cvss, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if TL := buildVSS(M, Ty, "VSS" + natlist2string(NL)) /\
      ML := createModules(M, T, TL) /\
      PrL' := createCTFTerm(ML, NL, Q, EqS) /\
      PO' := indProofOrder(fst(PO), size(TL)) y pop(PO) .
  *** Case selection cvs: empty (eq1) + value seq (eq2)
  ceq $applyTermMacro(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO, Q, T, cvs, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if TL := buildEVS(M, Ty, "EVS" + natlist2string(NL)) /\
      TL' := joinConstantsEVS(TL, "EVS" + natlist2string(NL), 0) /\
      ML := createModules(M, T, TL') /\
      PrL' := createCTFTerm(ML, NL, Q, EqS) /\
      PO' := indProofOrder(fst(PO), size(TL')) y pop(PO) .
  *** Case selection csv: empty (eq1) + seq value (eq2)
  ceq $applyTermMacro(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO, Q, T, csv, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if TL := buildESV(M, Ty, "ESV" + natlist2string(NL)) /\
      TL' := joinConstantsESV(TL, "ESV" + natlist2string(NL), 0) /\
      ML := createModules(M, T, TL') /\
      PrL' := createCTFTerm(ML, NL, Q, EqS) /\
      PO' := indProofOrder(fst(PO), size(TL')) y pop(PO) .
  *** Case selection csvs: empty (eq1) + seq value seq (eq2)
  ceq $applyTermMacro(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO, Q, T, csvs, Ty) =
                               [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if TL := buildSVS(M, Ty, "ESVS" + natlist2string(NL)) /\
      TL' := joinConstantsESV(TL, "ESVS" + natlist2string(NL), 0) /\
      ML := createModules(M, T, TL') /\
      PrL' := createCTFTerm(ML, NL, Q, EqS) /\
      PO' := indProofOrder(fst(PO), size(TL')) y pop(PO) .

  op joinConstantsEVS : TermList String Nat -> TermList .
  ceq joinConstantsEVS((TL, Q[C, T'], TL', Q[C', T'], TL''), St, N) =
                                            joinConstantsEVS((TL, Q[T'', T'], TL''), St, s(N))
   if Ty := getType(C) /\
      Ty := getType(C') /\
      T'' := qid(substr(string(Ty), 0, 1) + string(N, 10) + St + string(Ty) + "." + string(Ty)) .
  eq joinConstantsEVS(TL, St, N) = TL [owise] .

  op joinConstantsESV : TermList String Nat -> TermList .
  ceq joinConstantsESV((TL, Q[T', C], TL', Q[T', C'], TL''), St, N) =
                                            joinConstantsESV((TL, Q[T', T''], TL''), St, s(N))
   if Ty := getType(C) /\
      Ty := getType(C') /\
      T'' := qid(substr(string(Ty), 0, 1) + string(N, 10) + St + string(Ty) + "." + string(Ty)) .
  eq joinConstantsESV(TL, St, N) = TL [owise] .

  op buildVSS : Module Type String -> TermList .
  ceq buildVSS(M, Ty, St) = TL', TL
   if ODS := getExactCtors(M, Ty) /\
      TL := buildTermsCtors(ODS, "VSS") /\
      SS := lesserSorts(M, Ty) /\
      TL' := buildTermsOrFreshConst(M, SS, St + "Sub") .

  op buildEVS : Module Type String -> TermList .
  ceq buildEVS(M, Ty, St) = combineEVS(TL, TL')
   if ODS := getExactCtors(M, Ty) /\
      TL := buildTermsCtors(ODS, St) /\
      SS := lesserSorts(M, Ty) /\
      TL' := buildTermsOrFreshConst(M, SS, St + "Sub") .

  op combineEVS : TermList TermList ~> TermList .
  eq combineEVS((C, T), TL) = C, putTogetherEVS(T, TL) .
  eq combineEVS((T, C), TL) = C, putTogetherEVS(T, TL) .

  op buildESV : Module Type String -> TermList .
  ceq buildESV(M, Ty, St) = combineESV(TL, TL')
   if ODS := getExactCtors(M, Ty) /\
      TL := buildTermsCtors(ODS, St) /\
      SS := lesserSorts(M, Ty) /\
      TL' := buildTermsOrFreshConst(M, SS, St + "Sub") .

  op combineESV : TermList TermList ~> TermList .
  eq combineESV((C, T), TL) = C, putTogetherESV(T, TL) .
  eq combineESV((T, C), TL) = C, putTogetherESV(T, TL) .

  op buildSVS : Module Type String -> TermList .
  ceq buildSVS(M, Ty, St) = combineSVS(TL, TL'', TL')
   if ODS := getExactCtors(M, Ty) /\
      TL := buildTermsCtors(ODS, St + "L") /\
      TL' := buildTermsCtors(ODS, St + "R") /\
      SS := lesserSorts(M, Ty) /\
      TL'' := buildTermsOrFreshConst(M, SS, St + "Sub") .

  op combineSVS : TermList TermList TermList ~> TermList .
  eq combineSVS(TL, (C, T), TL') = C, putTogetherESV(T, TL) .
  eq combineSVS(TL, (T, C), TL') = C, putTogetherESV(T, TL) .

  op putTogetherEVS : Term TermList -> TermList .
  eq putTogetherEVS(T, empty) = empty .
  eq putTogetherEVS(Q[T, T'], (T1, TL)) = Q[T1, T'], putTogetherEVS(Q[T, T'], TL) .

  op putTogetherESV : Term TermList -> TermList .
  eq putTogetherESV(T, empty) = empty .
  eq putTogetherESV(Q[T, T'], (T1, TL)) = Q[T, T1], putTogetherESV(Q[T, T'], TL) .

  op putTogetherSVS : TermList Term TermList -> TermList .
  eq putTogetherSVS(empty, T, empty) = empty .
  eq putTogetherSVS((T1, TL), Q[T, T'], (T2, TL')) = Q[T1, T, T2],
                                                     putTogetherSVS(TL, Q[T, T'], TL') .

  op buildTermsOrFreshConst : Module SortSet String -> TermList .
  eq buildTermsOrFreshConst(M, none, St) = empty .
  ceq buildTermsOrFreshConst(M, Srt ; SS, St) = TL, buildTermsOrFreshConst(M, SS, St)
   if ODS := getExactCtors(M, Srt) /\
      ODS =/= none /\
      TL := buildTermsCtors(ODS, St) .
  ceq buildTermsOrFreshConst(M, Srt ; SS, St) = T, buildTermsOrFreshConst(M, SS, St)
   if getExactCtors(M, Srt) == none /\
      T := qid(St + string(Srt) + "." + string(Srt)) .



  op $applyTermMacro : ProofTree ProofOrder Qid Term MacroLabel Type -> IndResPair .
  eq $applyTermMacro(mtPT, PO, Q, T, MLb, Ty) = [mtPT, finished] .

  op $applyTermMacro* : ProofTreeList ProofOrder Qid Term Type -> IndResPair .
  eq $applyTermMacro*(mtPT, PO, Q, T, Ty) = [mtPT, finished] .
  ceq $applyTermMacro*(| M', G, PrL, N | PrL', PO, Q, T, Ty) = [PrL1 PrL2, PO' y PO'']
   if [PrL1, PO'] := $applyTermMacro(| M', G, PrL, N |, PO, Q, T, Ty) /\
      [PrL2, PO''] := $applyTermMacro*(PrL', PO, Q, T, Ty) .

  op $applyTermMacro* : ProofTreeList ProofOrder Qid Term MacroLabel Type -> IndResPair .
  eq $applyTermMacro*(mtPT, PO, Q, T, MLb, Ty) = [mtPT, finished] .
  ceq $applyTermMacro*(| M', G, PrL, N | PrL', PO, Q, T, MLb, Ty) = [PrL1 PrL2, PO' y PO'']
   if [PrL1, PO'] := $applyTermMacro(| M', G, PrL, N |, PO, Q, T, MLb, Ty) /\
      [PrL2, PO''] := $applyTermMacro*(PrL', PO, Q, T, MLb, Ty) .

  sort MList .
  subsort Module < MList .

  op mtML : -> MList [ctor] .
  op _._ : MList MList -> MList [ctor assoc id: mtML] .

  op ordTrueFalse : TermList -> TermList .
  eq ordTrueFalse(('false.Bool, 'true.Bool)) = 'true.Bool, 'false.Bool .
  eq ordTrueFalse(TL) = TL [owise] .

  op createModules : Module Term TermList -> MList .
  eq createModules(M, T, empty) = mtML .
  ceq createModules(M, T, ('true.Bool, TL)) = addHyp(M, Eq) . createModules(M, T, TL)
   if '_=_[T1, T2] := T /\
      Eq := eq T1 = T2 [metadata("CTF-true")] . .
  ceq createModules(M, T, (T', TL)) = addHyp(addCons(M, T'), Eq) . createModules(M, T, TL)
   if STR := createName(T') /\
      Eq := eq T = T' [metadata(STR)] . [owise] .

  op createName : Term -> String .
  eq createName(C) = "CTF-" + string(getName(C)) .
  eq createName(V) = "CTF-" + string(getName(V)) .
  eq createName(Q[TL]) = "CTF-" + string(Q) .

  op createCTFTerm : MList NatList Qid EquationSet -> ProofTreeList .
  eq createCTFTerm(ML, NL, Q, EqS) = $createCTFTerm(ML, NL, Q, EqS, 1) .

  op $createCTFTerm : MList NatList Qid EquationSet Nat -> ProofTreeList .
  eq $createCTFTerm(mtML, NL, Q, EqS, N) = mtPT .
  eq $createCTFTerm(M . ML, NL, Q, EqS, N) = | M, [NL N, Q, EqS, N == 1, false], mtPT, 1 |
                                             $createCTFTerm(ML, NL, Q, EqS, s(N)) .

  ************************************************************************************
  ************************************ TERM MACRO ************************************
  ************************************************************************************

  op parseTermMacro : ProofTree Qid Term -> Macros .
  eq parseTermMacro(mtPT, Q, T) = mtMacros .
  eq parseTermMacro(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, Q, T) =
          parseTermMacro*(PrL, Q, T) .
  eq parseTermMacro(| M, [NL, CMD, EqS, true, PRVN], PrL, N' |, Q, T) =
          parseTermMacro(M, Q, T) .

  op parseTermMacro* : ProofTreeList Qid Term -> Macros .
  eq parseTermMacro*(mtPT, Q, T) = mtMacros .
  eq parseTermMacro*(| M', G, PrL, N | PrL', Q, T) = parseTermMacro(| M', G, PrL, N |, Q, T)
                                                     parseTermMacro*(PrL', Q, T) .

  op parseTermMacro : Module Qid Term -> Macros .
  ceq parseTermMacro(M, Q, '__[TL, ''..Qid]) = if T? :: Term
                                          then # M, Q - T? #
                                          else parseTermMacro(M, Q, '__[TL])
                                          fi
   if T? := getTerm(metaParse(M, downQidList('__[TL, '.]), anyType)) .
  ceq parseTermMacro(M, Q, T) = if T? :: Term
                                then # M, Q - T? #
                                else mtMacros
                                fi
   if T? := getTerm(metaParse(M, downQidList(T), anyType)) [owise] .

  ************************************************************************************
  ****************************** SIMULTANEOUS INDUCTION ******************************
  ************************************************************************************

  op applyInduction : ProofTree Variable ProofOrder -> IndResPair .
  eq applyInduction(mtPT, V, PO) = [mtPT, finished] .
  ceq applyInduction(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, V, PO) =
                          [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if [PrL', PO'] := applyInduction*(PrL, V, PO) .
  ceq applyInduction(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |, V, PO) =
                          [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if ODS := getCtors(M, getType(V)) /\
      TL := buildTermsCtors2(ODS, "", V) /\
      Ty := getType(V) /\
      PO' := indProofOrder(fst(PO), size(TL)) y pop(PO) /\
      PrL' := subGoal*(M, [NL, CMD, EqS, true, PRVN], V, Ty, TL, NL, 1) .

  op applyInduction* : ProofTreeList Variable ProofOrder -> IndResPair .
  eq applyInduction*(mtPT, V, PO) = [mtPT, finished] .
  ceq applyInduction*(| M', G, PrL, N | PrL', V, PO) = [P' P'', PO' y PO'']
   if [P', PO'] := applyInduction(| M', G, PrL, N |, V, PO) /\
      [P'', PO''] := applyInduction*(PrL', V, PO) .

  op subGoal* : Module Goal Variable Type TermList NatList Nat -> ProofTreeList .
  eq subGoal*(M, G, V, Ty, empty, NL, N) = mtPT .
  eq subGoal*(M, G, V, Ty, (T, TL), NL, N) = subGoal(M, getEq(G), V, Ty, T, NL, N)
                                             subGoal*(M, G, V, Ty, TL, NL, s(N)) .

  op subGoal : Module EquationSet Variable Type Term NatList Nat -> ProofTree .
  ceq subGoal(M, EqS, V, Ty, T, NL, N) =
            | addCons(M', T), [NL N, 'SI, makeSub(EqS, V, T), N == 1, false], mtPT, 1 |
   if TL := getConstsOfSort(M, T, Ty) /\
      EqS' := createHI(EqS, V, TL) /\
      M' := addHyp(M, EqS') .

  op getConstsOfSort : Module Term Type -> TermList .
  eq getConstsOfSort(M, Q[TL], Ty) = getConstsOfSort*(M, TL, Ty) .
  eq getConstsOfSort(M, T, Ty) = empty [owise] .

  op $getConstsOfSort : Module Term Type -> TermList .
  eq $getConstsOfSort(M, Q[TL], Ty) = getConstsOfSort*(M, TL, Ty) .
  ceq $getConstsOfSort(M, C, Ty) = C
   if Ty' := getType(C) /\
      sameKind(M, Ty', Ty) /\
      sortLeq(M, Ty', Ty) .
  eq $getConstsOfSort(M, T, Ty) = empty [owise] .

  op getConstsOfSort* : Module TermList Type -> TermList .
  eq getConstsOfSort*(M, empty, Ty) = empty .
  eq getConstsOfSort*(M, (T, TL), Ty) = $getConstsOfSort(M, T, Ty),
                                        getConstsOfSort*(M, TL, Ty) .

  *** We make sure not to add constant constructors by skipping them at first.
  op addCons : Module Term -> Module .
  ceq addCons(M, C) = M
   if Q := getName(C) /\
      Ty := getType(C) /\
      op Q : TyL -> Ty [AtS] . ODS := getOps(M) .
  eq addCons(M, T) = $addCons(M, T) [owise] .

  op $addCons : Module Term -> Module .
  eq $addCons(M, V) = M .
  ceq $addCons(M, C) = M
   if definedConst(M, C) .
  ceq $addCons(M, C) = addOp(M, OD)
   if not definedConst(M, C) /\
      OD := op getName(C) : nil -> getType(C) [metadata("generated-si")] . .
  eq $addCons(M, Q[TL]) = $addCons*(M, TL) .

  op $addCons* : Module TermList -> Module .
  eq $addCons*(M, empty) = M .
  eq $addCons*(M, (T, TL)) = $addCons*($addCons(M, T), TL) .

  op definedConst : Module Constant -> Bool .
  ceq definedConst(M, C) = true
   if Q := getName(C) /\
      Ty := getType(C) /\
      op Q : TyL -> Ty [AtS] . ODS := getOps(M) .
  eq definedConst(M, C) = false [owise] .

  op makeSub : EquationSet Variable Term -> EquationSet .
  eq makeSub(none, V, T) = none .
  eq makeSub(eq T = T' [AtS] . EqS, V, T1) =
         eq subTerm(T, V, T1) = subTerm(T', V, T1) [AtS] .
         makeSub(EqS, V, T1) .
  eq makeSub(ceq T = T' if COND [AtS] . EqS, V, T1) =
         ceq subTerm(T, V, T1) = subTerm(T', V, T1) if subCond(COND, V, T1) [AtS] .
         makeSub(EqS, V, T1) .

  op createHI : EquationSet Variable TermList -> EquationSet .
  eq createHI(none, V, TL) = none .
  eq createHI(Eq EqS, V, TL) = $createHI(Eq, V, TL)
                               createHI(EqS, V, TL) .

  op $createHI : Equation Variable TermList -> EquationSet .
  eq $createHI(Eq, V, empty) = none .
  eq $createHI(eq T = T' [AtS] ., V, (T1, TL)) =
        eq subTerm(T, V, T1) = subTerm(T', V, T1) [metadata("HI") AtS] .
        $createHI(eq T = T' [AtS] ., V, TL) .
  eq $createHI(ceq T = T' if COND [AtS] ., V, (T1, TL)) =
         ceq subTerm(T, V, T1) = subTerm(T', V, T1)
          if subCond(COND, V, T1) [metadata("HI") AtS] .
        $createHI(ceq T = T' if COND [AtS] ., V, TL) .

  op subTerm : Term Variable Term -> Term .
  eq subTerm(Q[TL], V, T) = Q[subTermList(TL, V, T)] .
  eq subTerm(V, V, T) = T .
  eq subTerm(T, V, T') = T [owise] .

  op subTermList : TermList Variable Term -> TermList .
  eq subTermList(empty, V, T) = empty .
  eq subTermList((T, TL), V, T') = subTerm(T, V, T'), subTermList(TL, V, T') .

  op subCond : Condition Variable Term -> Condition .
  eq subCond(nil, V, T) = nil .
  eq subCond(T = T' /\ COND, V, T1) = subTerm(T, V, T1) = subTerm(T', V, T1) /\
                                      subCond(COND, V, T1) .
  eq subCond(T : Srt /\ COND, V, T1) = subTerm(T, V, T1) : Srt /\
                                       subCond(COND, V, T1) .
  eq subCond(T := T' /\ COND, V, T1) = subTerm(T, V, T1) := subTerm(T', V, T1) /\
                                       subCond(COND, V, T1) .
  eq subCond(T => T' /\ COND, V, T1) = subTerm(T, V, T1) => subTerm(T', V, T1) /\
                                       subCond(COND, V, T1) .

  op buildArgs : TypeList TermList String -> TermList .
  eq buildArgs(nil, TL, STR) = empty .
  ceq buildArgs(Ty TyL, TL, STR) = (C, TL')
   if C := buildArg(Ty, TL, STR) /\
      TL' := buildArgs(TyL, (C, TL), STR) .

  op buildArg : Type TermList String -> TermList .
  ceq buildArg(Ty, (TL, C, TL'), St) = $buildArg(Ty, (TL, TL'), St, 0)
   if STR := string(Ty) /\
      C := qid(substr(STR, 0, 1) +  "#" + St + STR + "." + STR) .
  ceq buildArg(Ty, TL, St) = C
   if STR := string(Ty) /\
      C := qid(substr(STR, 0, 1) + "#" + St + STR + "." + STR) [owise] .

  op $buildArg : Type TermList String Nat -> TermList .
  ceq $buildArg(Ty, (TL, C, TL'), St, N) = $buildArg(Ty, (TL, TL'), St, s(N))
   if STR := string(Ty) /\
      C := qid(substr(STR, 0, 1) + string(N, 10) + "#" + St + STR + "." + STR) .
  ceq $buildArg(Ty, TL, St, N) = C
   if STR := string(Ty) /\
      C := qid(substr(STR, 0, 1) + string(N, 10) + "#" + St + STR + "." + STR) [owise] .

***(
 * to make the consistency of variable names
 * author: duongtd
 * date: 21/10/09
 *)
  op buildTermsCtors2 : OpDeclSet String Variable -> TermList .
  eq buildTermsCtors2(none, STR, V) = empty .
  ceq buildTermsCtors2(OD ODS, STR, V) = (T, TL)
   if T := buildTermCtor2(OD, STR, V) /\
      TL := buildTermsCtors2(ODS, STR, V) .

  op buildTermCtor2 : OpDecl String Variable -> Term .
  ceq buildTermCtor2(op Q : nil -> Srt [AtS] ., STR, V) = C
   if C := buildTermCtor(op Q : nil -> Srt [AtS] ., STR) .
  ceq buildTermCtor2(op Q : TyL -> Srt [AtS] ., STR, V) = Q[TL]
   if TL := buildArgs2(TyL, empty, STR, V) [owise] .

  op buildArgs2 : TypeList TermList String Variable -> TermList .
  eq buildArgs2(nil, TL, STR, V) = empty .
  ceq buildArgs2(Ty TyL, TL, STR, V) = (C, TL')
   if C := buildArg2(Ty, TL, STR, V) /\
      TL' := buildArgs2(TyL, (C, TL), STR, V) .

  op buildArg2 : Type TermList String Variable -> TermList .
  ceq buildArg2(Ty, (TL, C, TL'), St, V) = TL2
   if TL2 := buildArg(Ty, (TL, C, TL'), St) .
  ceq buildArg2(Ty, TL, St, V) = 
    (if Ty == getType(V) then 
      qid(string(getName(V)) + "#" + St + STR + "." + STR)
    else
      qid(substr(STR, 0, 1) + "#" + St + STR + "." + STR)
    fi)
   if STR := string(Ty) [owise] .
***(
 * end fix
 *)

  op indProofOrder : NatList Nat -> ProofOrder .
  eq indProofOrder(NL, s(N)) = indProofOrder(NL, N) y NL s(N) .
  eq indProofOrder(NL, 0) = finished .

  sort Vars2ConsPair .
  op [_,_] : Equation Module -> Vars2ConsPair [ctor] .
  op [_,_] : TermList Module -> Vars2ConsPair [ctor] .
  op [_,_] : Condition Module -> Vars2ConsPair [ctor] .

  ***********************************************************************************
  ***************************** APPLY IMPLIES SUBSTITUTION **************************
  ***********************************************************************************

  op applyImp : ProofTree Qid Substitution -> ProofBool .
  eq applyImp(mtPT, Q, SB) = [mtPT, false] .
  ceq applyImp(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, Q, SB) =
                           [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, B]
   if [PrL', B] := applyImp*(PrL, Q, SB) .
  ceq applyImp(| M, [NL, CMD, Eq, true, PRVN], mtPT, N' |, Q, SB) = [PrL', B]
   if [PrL', B] := applyImp(M, Eq, Q, NL, SB) .

  op applyImp* : ProofTreeList Qid Substitution -> ProofBool .
  eq applyImp*(mtPT, Q, SB) = [mtPT, false] .
  ceq applyImp*(| M', G, PrL, N | PrL', Q, SB) = [PrL1 PrL2, B or B']
   if [PrL1, B] := applyImp(| M', G, PrL, N |, Q, SB) /\
      [PrL2, B'] := applyImp*(PrL', Q, SB) .

  op applyImp : Module Equation Qid NatList Substitution -> ProofBool .
  ceq applyImp(M, Eq, Q, NL, SB) = [| M, [NL, 'imp, Eq', true, false], mtPT, 1 |, true]
   if eq T = 'true.Bool [label(Q) AtS] . EqS := getEqs(M) /\
      ODS := getOps(M) /\
      Eq' := impEq(M, Eq, substitute(T, SB)) .
  eq applyImp(M, Eq, Q, N, SB) = [mtPT, false] [owise] .

  ***********************************************************************************
  ********************************** APPLY IMPLIES **********************************
  ***********************************************************************************

  op applyImp : ProofTree Qid -> ProofBool .
  eq applyImp(mtPT, Q) = [mtPT, false] .
  ceq applyImp(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |, Q) =
                           [| M, [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, B]
   if [PrL', B] := $applyImp*(PrL, Q) .
  ceq applyImp(| M, [NL, CMD, Eq, true, PRVN], mtPT, N' |, Q) = [PrL', B]
   if [PrL', B] := applyImp(M, Eq, Q, NL) .

  op $applyImp* : ProofTreeList Qid -> ProofBool .
  eq $applyImp*(mtPT, Q) = [mtPT, false] .
  ceq $applyImp*(| M', G, PrL, N | PrL', Q) = [PrL1 PrL2, B or B']
   if [PrL1, B] := applyImp(| M', G, PrL, N |, Q) /\
      [PrL2, B'] := $applyImp*(PrL', Q) .

  op applyImp : Module Equation Qid NatList -> ProofBool .
  ceq applyImp(M, Eq, Q, NL) = [| M, [NL, 'imp, Eq', true, false], mtPT, 1 |, true]
   if eq T = 'true.Bool [label(Q) AtS] . EqS := getEqs(M) /\
      Eq' := impEq(M, Eq, T) .
  eq applyImp(M, EqS, Q, N) = [mtPT, false] [owise] .

  op impEq : Module Equation Term -> Equation .
  ceq impEq(M, eq T = 'true.Bool [AtS] ., T') = eq '_implies_[T1, T] = 'true.Bool [AtS] .
   if T1 := getTerm(metaReduce(M, T')) .
  ceq impEq(M, eq T = T' [AtS] ., T'') = eq '_implies_[T1, '_=_[T', T]] =
                                        'true.Bool [AtS] .
   if T1 := getTerm(metaReduce(M, T'')) [owise] .


  ************************************************************************************
  ******************************* THEOREM OF CONSTANTS *******************************
  ************************************************************************************

  op applyTC : ProofTree ProofOrder -> IndResPair .
  eq applyTC(P, PO) = $applyTC(P, PO) .

  op $applyTC : ProofTree ProofOrder -> IndResPair .
  eq $applyTC(mtPT, PO) = [mtPT, finished] .
  ceq $applyTC(| M', [NL, CMD, EqS, false, PRVN], PrL, N' |, PO) =
                         [| M', [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if [PrL', PO'] := $applyTC*(PrL, PO) .
  ceq $applyTC(| M', [NL, CMD, EqS, true, PRVN], mtPT, N' |, PO) =
                         [| M', [NL, CMD, EqS, false, PRVN], PrL', s(size*(PrL')) |, PO']
   if PrL' := vars2cons*(EqS, M', NL, 1) /\
      PO' := indProofOrder(fst(PO), sizeEQS(EqS)) y pop(PO) .

  op $applyTC* : ProofTreeList ProofOrder -> IndResPair .
  eq $applyTC*(mtPT, PO) = [mtPT, finished] .
  ceq $applyTC*(| M', G, PrL, N | PrL', PO) = [P PrL'', PO' y PO'']
   if [P, PO'] := $applyTC(| M', G, PrL, N |, PO) /\
      [PrL'', PO''] := $applyTC*(PrL', PO) .

  op vars2cons* : EquationSet Module NatList Nat -> ProofTreeList .
  eq vars2cons*(none, M, NL, N) = mtPT .
  ceq vars2cons*(Eq EqS, M, NL, N) = | M', [NL N, 'TC, Eq', N == 1, false], mtPT, 1 |
                                     vars2cons*(EqS, M, NL, s(N))
   if [Eq', M'] := vars2cons(Eq, M) .

  op vars2cons : Equation Module -> Vars2ConsPair .
  ceq vars2cons(eq T = T' [AtS] ., M) = [eq T1 = T2 [AtS] ., M'']
   if [T1, M'] := vars2cons(T, M) /\
      [T2, M''] := vars2cons(T', M') .
  ceq vars2cons(ceq T = T' if COND [AtS] ., M) =
               [ceq T1 = T2 if CND [AtS] ., M''']
   if [T1, M'] := vars2cons(T, M) /\
      [T2, M''] := vars2cons(T', M') /\
      [CND, M'''] := vars2cons*(COND, M) .

  op vars2cons* : TermList Module -> Vars2ConsPair .
  eq vars2cons*(empty, M) = [empty, M] .
  ceq vars2cons*((T, TL), M) = [(T', TL'), M'']
   if [T', M'] := vars2cons(T, M) /\
      [TL', M''] := vars2cons*(TL, M') .

  op vars2cons : Term Module -> Vars2ConsPair .
  eq vars2cons(C, M) = [C, M] .
  ceq vars2cons(V, M) = [C, M']
   if STR := string(getType(V)) /\
      C := qid(string(getName(V)) + "@" + STR + "." + STR) /\
      OD := op getName(C) : nil -> getType(V) [metadata("tc")] . /\
      M' := addOp(M, OD) .
  ceq vars2cons(Q[TL], M) = [Q[TL'], M']
   if [TL', M'] := vars2cons*(TL, M) .

  op vars2cons* : Condition Module -> Vars2ConsPair .
  eq vars2cons*((nil).Condition, M) = [(nil).Condition, M] .
  ceq vars2cons*(T = T' /\ COND, M) = [T1 = T2 /\ CND, M''']
   if [T1, M'] := vars2cons(T, M) /\
      [T2, M''] := vars2cons(T', M') /\
      [CND, M'''] := vars2cons*(COND, M'') .
  ceq vars2cons*(T : Srt /\ COND, M) = [T1 : Srt /\ CND, M'']
   if [T1, M'] := vars2cons(T, M) /\
      [CND, M''] := vars2cons*(COND, M') .
  ceq vars2cons*(T := T' /\ COND, M) = [T1 := T2 /\ CND, M''']
   if [T1, M'] := vars2cons(T, M) /\
      [T2, M''] := vars2cons(T', M') /\
      [CND, M'''] := vars2cons*(COND, M'') .
  ceq vars2cons*(T => T' /\ COND, M) = [T1 => T2 /\ CND, M''']
   if [T1, M'] := vars2cons(T, M) /\
      [T2, M''] := vars2cons(T', M') /\
      [CND, M'''] := vars2cons*(COND, M'') .

  op sizeEQS : EquationSet -> Nat .
  eq sizeEQS(none) = 0 .
  eq sizeEQS(Eq EqS) = s(sizeEQS(EqS)) .

  ***********************************************************************************
  *********************************** SELECT GOAL ***********************************
  ***********************************************************************************

  op selectGoal : ProofTree NatList -> ProofTree .
  eq selectGoal(mtPT, NL) = mtPT .
  ceq selectGoal(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |, NL') =
                            | M, [NL, CMD, EqS, NL == NL', PRVN], PrL', N' |
   if PrL' := selectGoal*(PrL, NL') .

  op selectGoal* : ProofTreeList NatList -> ProofTreeList .
  eq selectGoal*(mtPT, NL) = mtPT .
  eq selectGoal*(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' | PrL', NL') =
       selectGoal(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |, NL') selectGoal*(PrL', NL') .

  op qid2natlist : Qid -> NatList .
  eq qid2natlist(Q) = str2natlist(string(Q)) .

  op str2natlist : String -> NatList .
  ceq str2natlist(S) = rat(substr(S, 0, N), 10) str2natlist(substr(S, N + 1, length(S)))
   if N := find(S, "-", 0) .
  eq str2natlist(S) = rat(S, 10) [owise] .

  op selectGoal : ProofOrder NatList -> ProofOrder .
  eq selectGoal(PO y NL y PO', NL) = NL y PO y PO' .
  eq selectGoal(PO, NL) = PO [owise] .

  op addOp : Module OpDecl -> Module .
  eq addOp(fmod H is IL sorts SS . SSDS ODS MAS EqS endfm, OD) =
             fmod H is IL sorts SS . SSDS ODS OD MAS EqS endfm .
  eq addOp(mod H is IL sorts SS . SSDS ODS MAS EqS RS endm, OD) =
             mod H is IL sorts SS . SSDS ODS OD MAS EqS RS endm .
  eq addOp(fth H is IL sorts SS . SSDS ODS MAS EqS endfth, OD) =
             fth H is IL sorts SS . SSDS ODS OD MAS EqS endfth .
  eq addOp(th H is IL sorts SS . SSDS ODS MAS EqS RS endth, OD) =
             th H is IL sorts SS . SSDS ODS OD MAS EqS RS endth .

  op addEqs : Term Term -> Term .
  eq addEqs('__[T1, T2], T) = '__[T1, addEqs(T2, T)] .
  eq addEqs(T, T') = '__[T, T'] [owise] .

  ************************************************************************************
  *********************************** GET NEW GOAL ***********************************
  ************************************************************************************

  op getNew : Module EquationSet EquationSet ~> ProofTree .
  eq getNew(M, Eq EqS, Eq EqS') = getNew(M, EqS, EqS') .
  ceq getNew(M, none, EqS) = setToGoal(M, EqS)
   if EqS =/= none .

  op setToGoal : Module EquationSet -> ProofTree .
  eq setToGoal(M, EqS) = | M, [nil, 'root, EqS, true, false], mtPT, 1 | .

  ************************************************************************************
  *********************************** REDUCE COMMAND *********************************
  ************************************************************************************

  sort ProofBool .
  op [_,_] : ProofTreeList Bool -> ProofBool [ctor] .

  op applyRed : ProofTree -> ProofBool .
  ceq applyRed(| M, [NL, CMD, EqS, true, PRVN], PrL, N' |) =
               [| M, [NL, CMD, EqS', not B, B], PrL, N' |, B]
   if [EqS', B] := reduceAll(M, EqS) .
  ceq applyRed(| M, [NL, CMD, EqS, false, PRVN], PrL, N' |) =
                         [| M, [NL, CMD, EqS, false, PRVN], PrL', N' |, B]
   if [PrL', B] := applyRed*(PrL) .

  sort EquationReduction .
  op [_,_] : EquationSet Bool -> EquationReduction [ctor] .

  op reduceAll : Module EquationSet -> EquationReduction .
  eq reduceAll(M, none) = [none, true] .
  ceq reduceAll(M, eq T = T' [AtS] . EqS) = [Eq EqS', B and B']
   if T1 := getTerm(metaReduce(M, T)) /\
      T2 := getTerm(metaReduce(M, T')) /\
      B := T1 == T2 /\
      Eq := if B then eq T = T' [AtS] .
                 else eq T1 = T2 [AtS] .
                 fi /\
      [EqS', B'] := reduceAll(M, EqS) .

  op applyRed* : ProofTreeList -> ProofBool .
  eq applyRed*(mtPT) = [mtPT, false] .
  ceq applyRed*(| M, G, PrL, N' | PrL') = [P PrL'', B or B']
   if [P, B] := applyRed(| M, G, PrL, N' |) /\
      [PrL'', B'] := applyRed*(PrL') .

  op applyRed- : ProofTree -> ProofBool .
  ceq applyRed-(| M, [NL, CMD, eq T = T' [AtS] ., true, PRVN], PrL, N' |) =
               [| M, [NL, CMD, eq T = T' [AtS] ., not B, B], PrL, N' |, B]
   if T1 := getTerm(metaReduce(M, T)) /\
      T2 := getTerm(metaReduce(M, T')) /\
      B := T1 == T2 .
  ceq applyRed-(| M, [NL, CMD, Eq, false, PRVN], PrL, N' |) =
                         [| M, [NL, CMD, Eq, false, PRVN], PrL', N' |, B]
   if [PrL', B] := applyRed-*(PrL) .

  op applyRed-* : ProofTreeList -> ProofBool .
  eq applyRed-*(mtPT) = [mtPT, false] .
  ceq applyRed-*(| M, G, PrL, N' | PrL') = [P PrL'', B or B']
   if [P, B] := applyRed-(| M, G, PrL, N' |) /\
      [PrL'', B'] := applyRed-*(PrL') .

  **************************************************************************************
  *********************************** PRINT CURRENT ************************************
  **************************************************************************************

  op printCurrent : ProofTree -> QidList .
  eq printCurrent(mtPT) = nil .
  eq printCurrent(| M, [NL, CMD, EqS, true, PRVN], mtPT, N' |) =
                                   '\n CMD ' printEqS(M, EqS, ' ) '\n .
  eq printCurrent(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |) = printCurrent*(PrL) [owise] .

  op printCurrent* : ProofTreeList -> QidList .
  eq printCurrent*(mtPT) = nil .
  eq printCurrent*(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' | PrL') =
         printCurrent(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |) printCurrent*(PrL') .

  ************************************************************************************
  *********************************** PRINT PROOF ************************************
  ************************************************************************************

  op printProofTree : ProofTree -> QidList .
  eq printProofTree(P) = $printProofTree(P, 0) .

  op $printProofTree : ProofTree Nat -> QidList .
  eq $printProofTree(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N |, N') =
                               printPremises(M, N')
                               '\n printTab(N') printIndex(NL)
                               if PRVN then '* else nil fi
                               if CURR then '> else nil fi
                               CMD '
                               printEqS(M, EqS, printTab(N'))
                               $printProofTree*(PrL, s(N')) .

  op $printProofTree* : ProofTreeList Nat -> QidList .
  eq $printProofTree*(mtPT, N) = nil .
  eq $printProofTree*(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N | PrL', N') =
                       $printProofTree(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N |, N')
                       $printProofTree*(PrL', N') .

  op printTab : Nat -> QidList .
  eq printTab(0) = nil .
  eq printTab(s(N)) = '\t printTab(N) .

  ***********************************************************************************
  ********************************* PRINT PREMISES **********************************
  ***********************************************************************************

  op printPremises : Module Nat -> QidList .
  eq printPremises(M, N) = printPremises(M, getEqs(M), N) .

  op printPremises : Module EquationSet Nat -> QidList .
  ceq printPremises(M, eq T = T' [metadata(S) AtS] . EqS, N) =
        '\n printTab(N) '-- 'Assumption:
        '\n printTab(N) printEq(M, eq T = T' [metadata(S) AtS] .)
        printPremises(M, EqS, N)
   if S == "generated-si" or
      S == "HI" or
      find(S, "CTF", 0) =/= notFound .
  eq printPremises(M, EqS, N) = nil [owise] .

  *************************************************************************************
  *********************************** PRINT LEAVES ************************************
  *************************************************************************************

  op printGoals : ProofTree -> QidList .
  eq printGoals(mtPT) = nil .
  eq printGoals(| M, [NL, CMD, EqS, CURR, PRVN], mtPT, N' |) =
                                   '\n printIndex(NL)
                                   if PRVN then '* else nil fi
                                   if CURR then '> else nil fi
                                   CMD '
                                   printEqS(M, EqS, ') .
  eq printGoals(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |) = printGoals*(PrL) [owise] .

  op printGoals* : ProofTreeList -> QidList .
  eq printGoals*(mtPT) = nil .
  eq printGoals*(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' | PrL') =
         printGoals(| M, [NL, CMD, EqS, CURR, PRVN], PrL, N' |) printGoals*(PrL') .

  op printIndex : NatList -> QidList .
  eq printIndex(nil) = nil .
  eq printIndex(NL) = qid(natlist2string(NL)) .

  op natlist2string : NatList -> String .
  eq natlist2string(nil) = "" .
  eq natlist2string(N) = string(N, 10) + "." .
  eq natlist2string(N NL) = string(N, 10) + "-" + natlist2string(NL) [owise] .

  op printIndexNoDot : NatList -> QidList .
  eq printIndexNoDot(nil) = nil .
  eq printIndexNoDot(NL) = qid(natlist2stringNoDot(NL)) .

  op natlist2stringNoDot : NatList -> String .
  eq natlist2stringNoDot(nil) = "" .
  eq natlist2stringNoDot(N) = string(N, 10) .
  eq natlist2stringNoDot(N NL) = string(N, 10) + "-" + natlist2stringNoDot(NL) [owise] .

  op printEqS : Module EquationSet QidList -> QidList .
  eq printEqS(M, none, QIL) = nil .
  eq printEqS(M, Eq EqS, QIL) = printEq(M, Eq) '\n QIL printEqS(M, EqS, QIL) .

  op printEq : Module EquationSet -> QidList .
  eq printEq(M, eq T = T' [label(Q) nonexec] .) = 'eq ' '`[ Q ':nonexec '`] ':
                                                      metaPrettyPrint(M, T, po) ' '=
                                                      metaPrettyPrint(M, T', po) '. .
  eq printEq(M, eq T = T' [label(Q)] .) = 'eq ' '`[ Q '`] ':
                                              metaPrettyPrint(M, T, po) ' '=
                                              metaPrettyPrint(M, T', po) '. .
  eq printEq(M, eq T = T' [nonexec] .) = 'eq ' '`[ ':nonexec '`] ':
                                             metaPrettyPrint(M, T, po) ' '=
                                             metaPrettyPrint(M, T', po) '. .
  eq printEq(M, eq T = T' [metadata(S) AtS] .) = printEq(M, eq T = T' [AtS] .) .
  eq printEq(M, eq T = T' [none] .) = 'eq metaPrettyPrint(M, T, po) ' '=
                                          metaPrettyPrint(M, T', po) '. .
  eq printEq(M, ceq T = T' if COND [label(Q) nonexec] .) =
                    'ceq ' '`[ Q ':nonexec '`] ': metaPrettyPrint(M, T, po) ' '=
                                                 metaPrettyPrint(M, T', po) '. .
  eq printEq(M, ceq T = T' if COND [label(Q)] .) =
                    'ceq ' '`[ Q '`] ': metaPrettyPrint(M, T, po) ' '=
                                        metaPrettyPrint(M, T', po) '. .
  eq printEq(M, ceq T = T' if COND [nonexec] .) =
                    'ceq ' '`[ ':nonexec '`] ': metaPrettyPrint(M, T, po) ' '=
                                                metaPrettyPrint(M, T', po) '. .

  ************************************************************************************
  *********************************** INFER PROOF ************************************
  ************************************************************************************

  op inferProof : Module Qid ScoreInfoSet Macros -> QidList .
  ceq inferProof(M, Q, SIS, MACS) = printProof(M, Q, Q', TL, QIL)
   if Q' := getNameProofScore(SIS) /\
      TL := inferGoal(SIS) /\
      EqS := goalEqS(TL, Q, 0) /\
      P := | M, [nil, 'root, EqS, true, false], mtPT, 1 | /\
      QIL := developProof(P, nil, SIS, MACS) [print "Generate proof without goal"] .
  eq inferProof(M, Q, SIS, MACS) = '\n '\! '\r 'Error 'while
                                   'generating 'proof '\o '\n [owise] .

  op inferWithGoalProof : Module Qid ScoreInfoSet Macros -> QidList .
  ceq inferWithGoalProof(M, Q, SIS, MACS) = printProof(M, Q, Q', TL, QIL)
   if Q' := getNameProofScore(SIS) /\
      (V, TL) := getGoal(SIS) /\
      EqS := goalEqS(TL, Q, 0) /\
      P := | M, [nil, 'root, EqS, true, false], mtPT, 1 | /\
      [P', PO] := applyInduction(P, V, nil) /\
      QIL := '\t ':ind 'on ' '`( metaPrettyPrint(M, V, po) '`) '\n '\n
             '\t ':apply '`( 'si '`) '\n '\n
             developProof(P', PO, noScoreInfo, MACS) [print "Induction " V " Terms\n" TL] .
  eq inferWithGoalProof(M, Q, SIS, MACS) = '\n '\! '\r 'Error 'while
                                   'generating 'proof '\o '\n [print owise] .

  op getGoal : ScoreInfoSet -> TermList .
  ceq getGoal($ M, M', (T, TL)$ SIS) = V, $getGoal($ M, M', (T, TL)$ SIS)
   if V := getVars(T) .

  op $getGoal : ScoreInfoSet -> TermList .
  eq $getGoal(noScoreInfo) = empty .
  eq $getGoal($ M, M', empty $ SIS) = $getGoal(SIS) .
  eq $getGoal($ M, M', (T, TL)$ SIS) = getGoal(T),
                                       $getGoal($ M, M', TL $ SIS) .

  op getGoal : Term -> Term .
  eq getGoal(V) = V .
  eq getGoal(C) = qid(string(getName(C)) + ":" + string(getType(C))) .
  eq getGoal(Q[TL]) = Q[getGoal*(TL)] .

  op getGoal* : TermList -> TermList .
  eq getGoal*(empty) = empty .
  eq getGoal*((T, TL)) = getGoal(T), getGoal*(TL) .

  op goalEqS : TermList Qid Nat -> EquationSet .
  eq goalEqS(empty, Q, N) = none .
  ceq goalEqS((T, TL), Q, N) = eq T = 'true.Bool [label(Q') nonexec] .
                               goalEqS(TL, Q, s(N))
   if Q' := if N == 0
            then Q
            else qid(string(Q) + string(N, 10))
            fi .

  op developProof : ProofTree ProofOrder ScoreInfoSet Macros -> QidList .
  eq developProof(P, finished, SIS, MACS) = nil .
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS)
   if eq T = 'true.Bool [AtS] . EqS := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      V := indRequired(SIS, M, T) /\
      [P', PO'] := applyInduction(P, V, NL y PO) /\
      QIL := '\t ':ind 'on ' '`( metaPrettyPrint(M, V, po) '`) '\n '\n
             '\t ':apply '`( 'si '`) '\n '\n [print "Induction"] .
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS)
   if eq T = 'true.Bool [AtS] . EqS := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      (tcRequired(T) or EqS =/= none) /\
      [P', PO'] := applyTC(P, NL y PO) /\
      QIL := '\t ':apply '`( 'tc '`) '\n '\n [print "Theorem of constants"] .
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P'', PO', SIS2, MACS)
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      [true, SIS2] := redRequired(SIS, M, T) /\
      [P', B] := applyRed(P) /\
      PO' := if B
             then PO
             else NL y PO
             fi /\
      B' := PO' == finished /\
      P'' := if B and (not B')
             then selectGoal(P', fst(PO'))
             else P'
             fi /\
      QIL := '\t ':apply ' '`( 'rd '`) '\n '\n [print "Red\n"] .

  -----------------------------------------------------------------------------------
  ---                          developProof -> csv                                ---
  -----------------------------------------------------------------------------------
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS')
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      [false, SIS] := redRequired(SIS, M, T) /\
      T1 := cesvRequired(SIS, M, T) /\
      Ty := getType(metaNormalize(M, T1)) /\
      | MACS', Q | := addNewMac(MACS, M, T1, csv) /\
      [P', PO'] := applyTermMacro(P, NL y PO, Q, T1, csv, Ty) /\
      QIL := printCESV(M, Q, T1) [print NL " Termino csv: " T1 "\n"] .

  -----------------------------------------------------------------------------------
  ---                          developProof -> cvs                                ---
  -----------------------------------------------------------------------------------
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS')
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      [false, SIS] := redRequired(SIS, M, T) /\
      cesvRequired(SIS, M, T) == empty /\
      T1 := cevsRequired(SIS, M, T) /\
      Ty := getType(metaNormalize(M, T1)) /\
      | MACS', Q | := addNewMac(MACS, M, T1, cvs) /\
      [P', PO'] := applyTermMacro(P, NL y PO, Q, T1, cvs, Ty) /\
      QIL := printCEVS(M, Q, T1) [print NL " Termino cvs: " T1 "\n"] .

  -----------------------------------------------------------------------------------
  ---                          developProof -> csvs                                ---
  -----------------------------------------------------------------------------------
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS')
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      [false, SIS] := redRequired(SIS, M, T) /\
      cesvRequired(SIS, M, T) == empty /\
      cevsRequired(SIS, M, T) == empty /\
      T1 := csvsRequired(SIS, M, T) /\
      Ty := getType(metaNormalize(M, T1)) /\
      | MACS', Q | := addNewMac(MACS, M, T1, cvs) /\
      [P', PO'] := applyTermMacro(P, NL y PO, Q, T1, cvs, Ty) /\
      QIL := printCEVS(M, Q, T1) [print NL " Termino csvs: " T1 "\n"] .

  -----------------------------------------------------------------------------------
  ---                       developProof -> ctfTerm                               ---
  -----------------------------------------------------------------------------------
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS')
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      [false, SIS] := redRequired(SIS, M, T) /\
      cesvRequired(SIS, M, T) == empty /\
      cevsRequired(SIS, M, T) == empty /\
      csvsRequired(SIS, M, T) == empty /\
      T1 := ctfTermRequired(SIS, M, T) /\
      Ty := getType(metaNormalize(M, T1)) /\
      | MACS', Q | := addNewMac(MACS, M, T1) /\
      [P', PO'] := applyTermMacro(P, NL y PO, Q, T1, Ty) /\
      QIL := printCtfTermComm(M, Q, T1) [print NL " Term case split " T1] .

  -----------------------------------------------------------------------------------
  ---                          developProof -> ctf                                ---
  -----------------------------------------------------------------------------------
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO', SIS, MACS')
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      [false, SIS] := redRequired(SIS, M, T) /\
      cesvRequired(SIS, M, T) == empty /\
      cevsRequired(SIS, M, T) == empty /\
      csvsRequired(SIS, M, T) == empty /\
      ctfTermRequired(SIS, M, T) == empty /\
      Eq := ctfRequired(SIS, M, T) /\
      | MACS', Q | := addNewMac(MACS, M, Eq) /\
      P' := applyEquationMacro(P, Q, Eq) /\
      PO' := indProofOrder(NL, 2) y PO /\
      QIL := printCtfComm(M, Q, Eq) [print NL " Case split by " Eq] .

  -----------------------------------------------------------------------------------
  ---                          developProof -> imp                                ---
  -----------------------------------------------------------------------------------
  ceq developProof(P, NL y PO, SIS, MACS) = QIL developProof(P', NL y PO, SIS, MACS)
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      indRequired(SIS, M, T) == empty /\
      not tcRequired(T) /\
      [false, SIS] := redRequired(SIS, M, T) /\
      cesvRequired(SIS, M, T) == empty /\
      cevsRequired(SIS, M, T) == empty /\
      csvsRequired(SIS, M, T) == empty /\
      ctfTermRequired(SIS, M, T) == empty /\
      ctfRequired(SIS, M, T) == none /\
      | Q, SB | := impRequired(SIS, M, T) /\
      [P', B] := if SB == none
                 then applyImp(P, Q)
                 else applyImp(P, Q, SB)
                 fi /\
      B' := P == P' /\
      QIL := if SB == none
             then '\t ':imp ' '`[ Q '`] ' '. '\n '\n
             else '\t ':imp ' '`[ Q '`] ' 'by ' '`{ printSub(SB) '`} '\n '\n
             fi [print "Imp"] .
  ceq developProof(P, NL y PO, SIS, MACS) = inferNewProof(P, NL y PO, SIS, MACS)
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL)
                           [owise print "Try reduction and implication for " NL " (" T ")"] .

  -------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------
  ---                               inferNewProof                                   ---
  ---                                                                               ---
  --- This function tries to generate proofs that are not given by the proof        ---
  --- scores. It first tries to infer "forgotten" nodes, that is, those proof       ---
  --- scores that are implicitly required because of the rest of scores (e.g. in    ---
  --- case splitting the rest of cases are given).                                  ---
  ---                                                                               ---
  -------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------

  -------------------------------------------------------------------------------------
  ---                        inferNewProof -> red                                   ---
  --- We take into account that induction and TC are forced in the previous step.   ---
  -------------------------------------------------------------------------------------
  op inferNewProof : ProofTree ProofOrder ScoreInfoSet Macros -> QidList .
  ceq inferNewProof(P, NL y PO, SIS, MACS) = QIL developProof(P'', PO, SIS, MACS)
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      redForgotten(M, T) /\
      [P', true] := applyRed(P) /\
      B' := PO == finished /\
      P'' := if not B'
             then selectGoal(P', fst(PO))
             else P'
             fi /\
      QIL := '\t '-- 'The 'corresponding 'proof 'score 'was 'not 'present. '\n
             '\t ':apply ' '`( 'rd '`) '\n '\n [print "Red forgotten\n"] .
  ceq inferNewProof(P, NL y PO, SIS, MACS) = QIL developProof(P', PO, SIS, MACS)
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      not redForgotten(M, T) /\
      TL := getHypotheses(M) /\
      [IPL, true] := tryImplication(M, T, TL) /\
      QIL := printImpCom(IPL) /\
      B := PO == finished /\
      P' := if not B
            then selectGoal(P, fst(PO))
            else P
            fi [print "Imp forgotten\n"] .
  eq inferNewProof(P, NL y PO, SIS, MACS) =
                 createNewProof(P, NL y PO, SIS, MACS, backtrackLevels) [owise print "Infer proof for " NL] .

  ---------------------------------------------------------------------------------------
  ---                                createNewProof                                   ---
  --- The last argument indicates the maximum depth available when trying.            ---
  --- It returns either a proof or nil when the proof is not possible.                ---
  ---------------------------------------------------------------------------------------
  op createNewProof : ProofTree ProofOrder ScoreInfoSet Macros Nat -> QidList .
  eq createNewProof(P, PO, SIS, MACS, 0) = nil .
  eq createNewProof(P, finished, SIS, MACS, N) = nil .
  -------------------------------------------------------------------------------------
  ---                                reduction                                      ---
  -------------------------------------------------------------------------------------
  ceq createNewProof(P, NL y PO, SIS, MACS, s(N)) = QIL''
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      redForgotten(M, T) /\
      [P', true] := applyRed(P) /\
      B' := PO == finished /\
      P'' := if not B'
             then selectGoal(P', fst(PO))
             else P'
             fi /\
      QIL   := '\t '-- 'The 'corresponding 'proof 'score 'was 'not 'present. '\n
               '\t ':apply ' '`( 'rd '`) '\n '\n /\
      QIL'  := createNewProof(P'', PO, SIS, MACS, s(N)) /\
      QIL'' := if B' or QIL' =/= nil
               then QIL QIL'
               else nil
               fi [print "Red created\n"] .
  -------------------------------------------------------------------------------------
  ---                                implication                                    ---
  -------------------------------------------------------------------------------------
  ceq createNewProof(P, NL y PO, SIS, MACS, s(N)) = QIL''
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      not redForgotten(M, T) /\
      TL := getHypotheses(M) /\
      [IPL, true] := tryImplication(M, T, TL) /\
      QIL := printImpCom(IPL) /\
      B := PO == finished /\
      P' := if not B
             then selectGoal(P, fst(PO))
             else P
             fi /\
      QIL'  := createNewProof(P', PO, SIS, MACS, s(N)) /\
      QIL'' := if B or QIL' =/= nil
               then QIL QIL'
               else nil
               fi .
  ----------------------------------------------------------------------------------------
  ---                                case-splitting                                    ---
  ----------------------------------------------------------------------------------------
  ceq createNewProof(P, NL y PO, SIS, MACS, s(N)) =
            QIL
            if PO =/= finished
            then developProof(selectGoal(P, fst(PO)), PO, SIS, MACS')
            else nil
            fi
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      not redForgotten(M, T) /\
      TL := getHypotheses(M) /\
      [IPL, false] := tryImplication(M, T, TL) /\
      [QIL, MACS', true] := tryCaseSplitting([M, T, s(N)], MACS, nil,
                                             "Goal " + natlist2stringNoDot(NL), 1, NL)
        [print "Inference correct "] .

  op natlist2stringNoDot : NatList -> String .
  eq natlist2stringNoDot(nil) = "" .
  eq natlist2stringNoDot(N) = string(N, 10) .
  eq natlist2stringNoDot(N NL) = string(N, 10) + "-" + natlist2stringNoDot(NL) [owise] .

  ceq createNewProof(P, NL y PO, SIS, MACS, s(N)) =
            if PO =/= finished
            then QIL '\t ':postpone '. '\n '\n
                 developProof(selectGoal(P, fst(PO)), PO, SIS, MACS)
            else QIL '\t ':postpone '. '\n '\n
            fi
   if eq T = 'true.Bool [AtS] . := getGoal(P, NL) /\
      M := getMod(P, NL) /\
      not redForgotten(M, T) /\
      TL := getHypotheses(M) /\
      [IPL, false] := tryImplication(M, T, TL) /\
      [QIL, MACS', false] := tryCaseSplitting([M, T, s(N)], MACS, nil, "Goal 1", 1, NL)
        [owise print "Inference failure " NL] .

  eq createNewProof(P, NL y PO, SIS, MACS, N) =
            if PO =/= finished
            then '\t ':postpone '. '\n '\n
                 developProof(selectGoal(P, fst(PO)), PO, SIS, MACS)
            else '\t ':postpone '. '\n '\n
            fi [owise print "Final postpone " NL] .

  *** Goal to prove
  *** Current SIS
  *** Success QidList
  *** Failure QidList
  *** Indentation
  op tryCaseSplitting : IT Macros QidList String Nat NatList -> IR .
  ceq tryCaseSplitting([M, T, N], MACS, QILR, S, INDENT, NL) = [QILR QIL, MACS, true]
   if redForgotten(M, T) /\
      QIL := indent(INDENT) '-- qid(S) 'Success 'by 'reduction '\n
             indent(INDENT) ':apply ' '`( 'rd '`) '\n '\n .
  ceq tryCaseSplitting([M, T, N], MACS, QILR, S, INDENT, NL) = [QILR QIL, MACS, true]
   if not redForgotten(M, T) /\
      TL := getHypotheses(M) /\
      [IPL, true] := tryImplication(M, T, TL) /\
      QIL := printImpCom(IPL, S, INDENT) .
  ceq tryCaseSplitting([M, T, 0], MACS, QILR, S, INDENT, NL) = [QILR QIL, MACS, false]
   if not redForgotten(M, T) /\
      TL := getHypotheses(M) /\
      [IPL, false] := tryImplication(M, T, TL) /\
      QIL := indent(INDENT) '-- qid(S) 'cannot 'be 'discharged.
                            'Maximum 'depth 'reached. '\n '\n [print "Max depth"] .
  ceq tryCaseSplitting([M, T, s(N)], MACS, QILR, S, INDENT, NL) =
                 $tryCaseSplitting([M, T, s(N)], MACS, QILR, TPS, TPS'', S, INDENT, 1, NL)
   if not redForgotten(M, T) /\
      [IPL, false] := tryImplication(M, T, getHypotheses(M)) /\
      TrS := getEqualityTerms(M, T) /\
      TrS' := getEqTermsWithImps(M, T) /\
      TPS := processEqualityTerm*(M, TrS) /\
      TPS' := processEqualityTerm*(M, TrS' - TrS) /\
      TPS'' := (TPS' - TPS) [print "\nTrS " TrS "\n TrS'" TrS' "\nTPS " TPS "\nTPS' " TPS'' "\ninit-term " T] .

*** For testing purposes, inv9 - rec2
  op prior : TrialPairSet -> TrialPairSet .
  eq prior(['_=_['dc['S#Sys.Sys],'_`,_['pbps1@PBPSeq.PBPSeq,'<_`,_>['p1@Packet.Packet,'b1@Bit.Bit]]],ctf] TPS) =
      ['_=_['dc['S#Sys.Sys],'_`,_['pbps1@PBPSeq.PBPSeq,'<_`,_>['p1@Packet.Packet,'b1@Bit.Bit]]],ctf]
      prior(TPS) .
  eq prior(['_=_['sb['S#Sys.Sys],'b2@Bit.Bit],ctf] TPS) =
                  ['_=_['sb['S#Sys.Sys],'b2@Bit.Bit],ctf] prior(TPS) .
  eq prior(['_=_['p2s['S#Sys.Sys],'p2@Packet.Packet],ctf] TPS) =
                  ['_=_['p2s['S#Sys.Sys],'p2@Packet.Packet],ctf] prior(TPS) .
  eq prior(['pbps2@PBPSeq.PBPSeq,cesv] TPS) = ['pbps2@PBPSeq.PBPSeq,cesv] prior(TPS) .

  eq prior(TPS) = mtTPS [owise] .

  var  MACS'' : Macros .
  var  IT : IT .
  var  ITL : ITL .
  vars TPS TPS' TPS'' : TrialPairSet .
  var  TPair : TrialPair .
  var  CTXT : Context .
  var  IR : IR .

  op _-_ : TermSet TermSet -> TermSet .
  eq (T | TrS) - (T | TrS') = TrS - TrS' .
  eq TrS - TrS' = TrS [owise] .

  op _-_ : TrialPairSet TrialPairSet -> TrialPairSet .
  eq (TPair TPS) - (TPair TPS') = TPS - TPS' .
  eq TPS - TPS' = TPS [owise] .

  op $tryCaseSplitting : IT Macros QidList TrialPairSet TrialPairSet String Nat Nat NatList
                         -> IR .
  eq $tryCaseSplitting([M, T, 0], MACS, QILR, TPS, TPS', S, INDENT, N', NL) =
                                                 [QILR, MACS, false] [print "Maximum depth"] .
  eq $tryCaseSplitting([M, T, N], MACS, QILR, mtTPS, mtTPS, S, INDENT, N', NL) =
                                                 [QILR, MACS, false] [print "No more cs available"] .
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, ([T', ctf] TPS), TPS', S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', TPS, TPS', S, INDENT, s(N'), NL)
             fi
   if not hasCEVS(TPS) /\
      Eq := getEq(T') /\
      | MACS', Q | := addNewMac(MACS, M, Eq) /\
      M' := createCTFmodTrue(M, Eq) /\
      M'' := createCTFmodFalse(M, Eq) /\
      QIL := printCtfComm(M, Q, Eq, INDENT) /\
      [QIL', MACS'', B] := tryCaseSplitting*([M', T, N] [M'', T, N],
                                              MACS', S, s(INDENT), 1, NL) /\
      QIL'' := indent(INDENT)
               if B
               then '-- qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '-- qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting true-false 1 applied " Eq " - " B] .
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, ([T', term] TPS), TPS', S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', TPS, TPS', S, INDENT, s(N'), NL)
             fi
   if not hasCEVS(TPS) /\
      | MACS', Q | := addNewMac(MACS, M, T') /\
      Ty := getType(metaReduce(M, T')) /\
      ODS := getCtors(M, Ty) /\
      TL := ordTrueFalse(buildTermsCtors(ODS, "CS" + natlist2string(NL))) /\ ***  s(N')
      TL =/= empty /\
      ML := createModules(M, T', TL) /\
      ITL := createITL(ML, T, N) /\
      QIL := printCtfTermComm(M, Q, T', INDENT) /\
      [QIL', MACS'', B] := tryCaseSplitting*(ITL, MACS', S, s(INDENT), 1, NL) /\
      EqS := getEqs(M) /\
      QIL'' := indent(INDENT)
               if B
               then '-- qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '-- qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting term applied " T' " - " B " " TPS " - " TPS'] .
  ***********
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, mtTPS, ([T', ctf] TPS), S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', mtTPS, TPS, S, INDENT, s(N'), NL)
             fi
   if not hasCEVS(TPS) /\
      Eq := getEq(T') /\
      | MACS', Q | := addNewMac(MACS, M, Eq) /\
      M' := createCTFmodTrue(M, Eq) /\
      M'' := createCTFmodFalse(M, Eq) /\
      QIL := printCtfComm(M, Q, Eq, INDENT) /\
      [QIL', MACS'', B] := tryCaseSplitting*([M', T, N] [M'', T, N],
                                              MACS', S, s(INDENT), 1, NL) /\
      EqS := getEqs(M') /\
      QIL'' := indent(INDENT)
               if B
               then '-- qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '-- qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting true-false 2 applied " Eq " - " B " - " TPS] .
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, mtTPS, ([T', term] TPS), S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', mtTPS, TPS, S, INDENT, s(N'), NL)
             fi
   if not hasCEVS(TPS) /\
      | MACS', Q | := addNewMac(MACS, M, T') /\
      Ty := getType(metaReduce(M, T')) /\
      ODS := getCtors(M, Ty) /\
      TL := ordTrueFalse(buildTermsCtors(ODS, "CS" + natlist2string(NL))) /\ ***  s(N')
      TL =/= empty /\
      ML := createModules(M, T', TL) /\
      ITL := createITL(ML, T, N) /\
      QIL := printCtfTermComm(M, Q, T', INDENT) /\
      [QIL', MACS'', B] := tryCaseSplitting*(ITL, MACS', S, s(INDENT), 1, NL) /\
      EqS := getEqs(M) /\
      QIL'' := indent(INDENT)
               if B
               then '-- qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '-- qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting term applied " T' " - " B] .
  ****************** CEVS *************
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, ([T', cevs] TPS), TPS', S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', TPS, TPS', S, INDENT, s(N'), NL)
             fi
   if | MACS', Q | := addNewMac(MACS, M, T') /\
      Ty := getType(metaNormalize(M, T')) /\
      TL := buildEVS(M, Ty, "EVS" + natlist2string(NL)) /\
      TL' := joinConstantsEVS(TL, "EVS" + natlist2string(NL), 0) /\
      ML := createModules(M, T', TL') /\
      ITL := createITL(ML, T, N) /\
      QIL := printCEVS(M, Q, T') /\
      [QIL', MACS'', B] := tryCaseSplitting*(ITL, MACS', S, s(INDENT), 1, NL) /\
      ODS := getOps(M) /\
      EqS := getEqs(M) /\
      QIL'' := indent(INDENT)
               if B
               then '-- qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '-- qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting cevs term applied " T' " - " B " - " TL'] .
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, mtTPS, ([T', cevs] TPS'), S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', mtTPS, TPS', S, INDENT, s(N'), NL)
             fi
   if | MACS', Q | := addNewMac(MACS, M, T') /\
      Ty := getType(metaNormalize(M, T')) /\
      TL := buildEVS(M, Ty, "EVS" + natlist2string(NL)) /\
      TL' := joinConstantsEVS(TL, "EVS" + natlist2string(NL), 0) /\
      ML := createModules(M, T', TL') /\
      ITL := createITL(ML, T, N) /\
      QIL := printCEVS(M, Q, T') /\
      [QIL', MACS'', B] := tryCaseSplitting*(ITL, MACS', S, s(INDENT), 1, NL) /\
      QIL'' := indent(INDENT)
               if B
               then '-- qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '-- qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting cevs term applied " T' " - " B] .
  *** CESV
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, ([T', cesv] TPS), TPS', S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', TPS, TPS', S, INDENT, s(N'), NL)
             fi
   if | MACS', Q | := addNewMac(MACS, M, T') /\
      Ty := getType(metaNormalize(M, T')) /\
      TL := buildESV(M, Ty, "ESV" + natlist2string(NL)) /\
      TL' := joinConstantsEVS(TL, "ESV" + natlist2string(NL), 0) /\
      ML := createModules(M, T', TL') /\
      ITL := createITL(ML, T, N) /\
      QIL := printCEVS(M, Q, T') /\
      [QIL', MACS'', B] := tryCaseSplitting*(ITL, MACS', S, s(INDENT), 1, NL) /\
      ODS := getOps(M) /\
      EqS := getEqs(M) /\
      QIL'' := indent(INDENT)
               if B
               then '-- qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '-- qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting cevs term applied " T' " - " B " - " TL'] .
  ceq $tryCaseSplitting([M, T, s(N)], MACS, QILR, mtTPS, ([T', cesv] TPS'), S, INDENT, N', NL) =
             if B
             then [QIL'', MACS'', true]
             else $tryCaseSplitting([M, T, s(N)], MACS, QIL'', mtTPS, TPS', S, INDENT, s(N'), NL)
             fi
   if | MACS', Q | := addNewMac(MACS, M, T') /\
      Ty := getType(metaNormalize(M, T')) /\
      TL := buildESV(M, Ty, "ESV" + natlist2string(NL)) /\
      TL' := joinConstantsESV(TL, "ESV" + natlist2string(NL), 0) /\
      ML := createModules(M, T', TL') /\
      ITL := createITL(ML, T, N) /\
      QIL := printCEVS(M, Q, T') /\
      [QIL', MACS'', B] := tryCaseSplitting*(ITL, MACS', S, s(INDENT), 1, NL) /\
      QIL'' := indent(INDENT)
               if B
               then '-- qid(S) ' '- ' metaPrettyPrint(M, T, po) ' '- 'Success '\n
               else QILR '-- qid(S) '`, 'Try qid(string(N', 10)) '- '
                    metaPrettyPrint(M, T, po) ' '- 'Failure '\n
               fi
               QIL QIL' [print "Case splitting cevs term applied " T' " - " B] .

  op hasCEVS : TrialPairSet -> Bool .
  eq hasCEVS([T, cevs] TPS) = true .
  eq hasCEVS(TPS) = false [owise] .

  op createITL : MList Term Nat -> ITL .
  eq createITL(mtML, T, N) = nilITL .
  eq createITL(M . ML, T, N) = [M, T, N] createITL(ML, T, N) .

  op getEq : Term ~> Equation .
  eq getEq('_=_[T, 'false.Bool]) = getEq(T) .
  eq getEq('_=_[T, T']) = eq T = T' [none] . .

  op tryCaseSplitting* : ITL Macros String Nat Nat NatList -> IR .
  ceq tryCaseSplitting*(IT ITL, MACS, S, INDENT, N, NL) = [QIL QIL', MACS'', B and B']
   if [QIL, MACS', B] := tryCaseSplitting(IT, MACS, nil, S + "-" + string(N, 10), INDENT, NL N) /\
      [QIL', MACS'', B'] := tryCaseSplitting*(ITL, MACS', S, INDENT, s(N), NL) .
  eq tryCaseSplitting*(nilITL, MACS, S, INDENT, N, NL) = [nil, MACS, true] .

  op processEqualityTerm : Module Term -> TrialPairSet .
  ceq processEqualityTerm(M, T) = mtTPS
   if hasVars(T) .
  ceq processEqualityTerm(M, '_=_[T, T']) = mtTPS
   if subterm(T, T') .
  ceq processEqualityTerm(M, Q[TL]) = processEqualityTerm*(M, tl2ts(TL))
   if containsBoolOps*(TL) or (Q == '_or_) or (Q == '_and_) or
      (Q == '_xor_) or (Q == 'if_then_else_fi) [print "Equality Bools " Q "(" TL ")"] .
  eq processEqualityTerm(M, '_=_[T, T]) = mtTPS .
  *** Built-in strategies for sequences: built sequences with same top constructor
  ceq processEqualityTerm(M, '_=_[T, T']) = seqEqualities(M, T, T')
   if sameSeqCtor(M, T, T') /\
      sameSize(T, T') . *** [print "s&s " T " = " T'] .
  *** Built-in strategies for sequences: seq = seq, elem*, seq
  ceq processEqualityTerm(M, '_=_[T, T']) = seqEqConst2Seq(M, T, T')
   if not subterm(T, T') /\
      const2seq(M, T, T') [print "c&ses 1 " T " = " T'] .
  *** Built-in strategies for sequences: seq, elem*, seq = seq
  ceq processEqualityTerm(M, '_=_[T, T']) = seqEqConst2Seq(M, T', T)
   if not subterm(T', T) /\
      const2seq(M, T', T) [print "c&ses 2 " T " = " T'] .
  *** Built-in strategies for sequences: elem^n, seq = seq,elem^n,seq
  ceq processEqualityTerm(M, '_=_[T, T']) = es&ses(M, T, T')
   if es&sesCheck(M, T, T') [print "es&ses " T " = " T'] .
  *** Built-in strategies for sequences: seq,elem^n, seq = elem^n,seq
  ceq processEqualityTerm(M, '_=_[T, T']) = es&ses(M, T', T)
   if es&sesCheck(M, T', T) [print "es&ses " T' " = " T] .
  *** Built-in strategies for sequences: elem^n, seq = seq,elem^n,seq
  ceq processEqualityTerm(M, '_=_[T, T']) = se&ses(M, T', T)
   if se&sesCheck(M, T', T) [print "se&ses " T " = " T'] .
  *** Built-in strategies for sequences: elem^n, seq = elem^n,seq
  ceq processEqualityTerm(M, '_=_[T, T']) = es&es(M, T, T')
   if es&esCheck(M, T, T') [print "es&es " T " = " T'] .
  *** Unary sequence, no constructors
  ceq processEqualityTerm(M, '_=_[T, T']) = ['_=_[T, T'], ctf]
   if T =/= T' /\
      unarySeqCheck(M, T, T') [print "Unary " T " = " T'] .
  *** Built-in strategies for sequences: seq, elem, elem, seq, elem = seq,elem
  ceq processEqualityTerm(M, '_=_[T, T']) = seese&se(T, T')
   if seese&seCheck(M, T, T') [print "seese&se " T " = " T'] .
  *** Default
  ceq processEqualityTerm(M, '_=_[T, T']) = ['_=_[T, T'], ctf]
   if T =/= T' /\
      not containsBoolOps*((T, T')) /\
      not sees&seCheck(M, T, T') /\
      sameSeqCtor(M, T, T') /\
      not sameSize(T, T') /\
      not se&sesCheck(M, T, T') /\
      not es&sesCheck(M, T, T') /\
      not es&sesCheck(M, T', T) /\
      not es&esCheck(M, T, T') /\
      not seese&seCheck(M, T, T') /\
      not es&esCheck(M, T', T) [print "Default seq " T " = " T'] .
  *** seq1, elem1, elem2, seq2 = seq3, elem3 -> seq3 = seq1, elem1
  ceq processEqualityTerm(M, '_=_[T, T']) = sees&se(M, T, T')
   if sees&seCheck(M, T, T') [print "sees&se " T " = " T'] .
  *** Default
  ceq processEqualityTerm(M, '_=_[T, T']) = ['_=_[T, T'], ctf]
   if T =/= T' /\
      not containsBoolOps*((T, T')) /\
      not subterm(T, T') /\
      Q[T1] := T /\
      isFreshCons(M, T1) /\
      Q'[TL'] := T' /\
      not seqCtor(getOps(M), Q) /\
      seqCtor(getOps(M), Q') /\ *** Both sequences, one of the is a function
      anyTC(M, TL') /\
      not es&sesCheck(M, T, T') /\
      not es&sesCheck(M, T', T) /\
      not se&sesCheck(M, T, T') /\
      not es&esCheck(M, T, T') /\
      not seese&seCheck(M, T, T') /\
      not es&esCheck(M, T', T) [print "es&es 2 " T " = " T'] .
  eq processEqualityTerm(M, T) = $processEqualityTerm(M, T) . *** [owise print "Eq terms owise " T] .

  op subterm : Term Term -> Bool .
  eq subterm(T, Q[TL, T, TL']) = true .
  eq subterm(T, T') = false [owise] .

  op anyTC : Module TermList -> Bool .
  eq anyTC(M, empty) = false .
  eq anyTC(M, (Q[TL], TL')) = false .
  eq anyTC(M, (V, TL)) = false .
  eq anyTC(M, (C, TL)) = fromTC(getOps(M), C) or-else anyTC(M, TL) .

  op fromTC : OpDeclSet Constant -> Bool .
  ceq fromTC(op Q : nil -> Ty [metadata("tc")] . ODS, C) = true
   if Q := getName(C) /\
      Ty := getType(C) .
  eq fromTC(ODS, C) = false [owise] .

  op $processEqualityTerm : Module Term -> TrialPairSet .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = mtTPS
   if allCtor(M, T1) /\
      allCtor(M, T2) . *** [print "Eqt 1" T1] . *** [print "Equality term 1 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = if isCevs(M, T2)
                                              then [T2, cevs]
                                              else [T2, term] *** ['_=_[T2, T1], ctf]
                                              fi
   if allCtor(M, T1) /\
      isFreshCons(M, T2) . *** [print "Equality term 2 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = if isCevs(M, T1)
                                              then [T1, cevs]
                                              else [T1, term]
                                              fi
   if isFreshCons(M, T1) /\
      allCtor(M, T2) . *** [print "Equality term 3 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = ['_=_[T1, T2], ctf] *** cevs?
   if isFreshCons(M, T1) /\
      isFreshCons(M, T2) . *** [print "Equality term 4 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) =  $processEqualityTerm(M, T1)
   if not (allCtor(M, T1) or isFreshCons(M, T1)) /\
      allCtor(M, T2) . *** [print "Equality term 5 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = ['_=_[T1, T2], ctf]
                                              $processEqualityTerm(M, T1)
   if not (allCtor(M, T1) or isFreshCons(M, T1)) /\
      isFreshCons(M, T2) . *** [print "Equality term 6 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = $processEqualityTerm(M, T2)
   if allCtor(M, T1) /\
      not (allCtor(M, T2) or isFreshCons(M, T2)) . *** [print "Equality term 7 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = mtTPS
   if isFreshCons(M, T1) /\
      hasVars(T2) /\
      not (allCtor(M, T2) or isFreshCons(M, T2)) .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = ['_=_[T2, T1], ctf] *** ['_=_[T1, T2], ctf]
                                              $processEqualityTerm(M, T2)
   if isFreshCons(M, T1) /\
      not hasVars(T2) /\
      not (allCtor(M, T2) or isFreshCons(M, T2)) . *** [print "Equality term 8 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = ['_=_[T1, T2], ctf] *** !!! Seq
                                              processEqualityTerm*(M, T1 | T2)
   if not (allCtor(M, T1) or isFreshCons(M, T1)) /\
      not (allCtor(M, T2) or isFreshCons(M, T2)) /\
      noneCtor(M, T1) /\ noneCtor(M, T2) . *** [print "Equality term 9 " T1 " = " T2] .
  ceq $processEqualityTerm(M, '_=_[T1, T2]) = processEqualityTerm*(M, T1 | T2)
   if not (allCtor(M, T1) or isFreshCons(M, T1)) /\
      not (allCtor(M, T2) or isFreshCons(M, T2)) /\
      not (noneCtor(M, T1) and noneCtor(M, T2)) . *** [print "Equality term 10 " T1 " = " T2] .
  ceq $processEqualityTerm(M, Q[TL]) = processEqualityTerm*(M, tl2ts(TL))
   if (Q == '_or_) or (Q == '_and_) or (Q == '_xor_) .
  eq $processEqualityTerm(M, 'not_[T]) = $processEqualityTerm(M, T) .
  eq $processEqualityTerm(M, 'if_then_else_fi[T, TL]) = $processEqualityTerm(M, T) .
  ceq $processEqualityTerm(M, T) = $processEqualityTerm(M, T1)
   if T1 := reduce(M, T) /\
      T =/= T1 .
  ceq $processEqualityTerm(M, T) = mtTPS
   if allCtor(M, T) . *** [print "Equality term 12 " T] .
  eq $processEqualityTerm(M, T) = $$processEqualityTerm(M, T, getEqs(M)) [owise] . *** print "Equality term 13 " T] .

  op $$processEqualityTerm : Module Term EquationSet -> TrialPairSet .
  ceq $$processEqualityTerm(M, T, EqS) = if TPS == mtTPS
                                         then decomposeTerm(M, T)
                                         else TPS
                                         fi
   if TPS := processEq*(M, T, EqS) . *** [print "Double $$: " T " returns " TPS] .

  op sameSeqCtor : Module Term Term -> Bool .
  eq sameSeqCtor(M, Q[TL], Q[TL']) = seqCtor(getOps(M), Q) .
  eq sameSeqCtor(M, T, T') = false [owise] .

  op seqCtor : OpDeclSet Qid -> Bool .
  eq seqCtor(op Q : TyL -> Ty [ctor assoc AtS] . ODS, Q) = true .
  eq seqCtor(ODS, Q) = false [owise] .

  op const2seq : Module Term Term -> Bool .
  ceq const2seq(M, C, Q[T, TL]) = true
   if seqCtor(getOps(M), Q) /\
      hasId(getOps(M), Q) /\
      isCevs(M, C) /\
      isCevs(M, T) .
  eq const2seq(M, T, T') = false [owise] .

  op hasId : OpDeclSet Qid -> Bool .
  eq hasId(op Q : TyL -> Ty [id(T) AtS] . ODS, Q) = true .
  eq hasId(ODS, Q) = false [owise] .

  op unarySeqCheck : Module Term Term -> Bool .
  ceq unarySeqCheck(M, Q[TL], Q'[TL']) = (not isCtor(getOps(M), Q)) and-then
                                         (not isCtor(getOps(M), Q')) and-then
                                         isCevs(Ty, getSubsorts(M), getOps(M))
   if Ty := getType(metaReduce(M, Q[TL])) /\
      Ty := getType(metaReduce(M, Q'[TL'])) .

  op seqEqConst2Seq : Module Term Term ~> TrialPairSet .
  eq seqEqConst2Seq(M, C, Q[T, TL]) = [T, cevs] . *** ['_=_[C, TL], ctf] . *** If the first fails the second makes no sense

  op sees&seCheck : Module Term Term -> Bool .
  ceq sees&seCheck(M, T, T') = true
   if sameSeqCtor(M, T, T') /\
      Q[T1, T2, T3, T4] := T /\
      Q[T5, T6] := T' /\
      isCevs(M, T1) /\
      isCevs(M, T4) /\
      isCevs(M, T5) /\
      not isCevs(M, T2) /\
      not isCevs(M, T3) /\
      not isCevs(M, T6) /\
      T5 =/= T1 .
  eq sees&seCheck(M, T, T') = false [owise] .

  op seese&se : Term Term ~> TrialPairSet .
  eq seese&se(Q[T1, T2, T3, T4, T5], Q[T6, T7]) = ['_=_[T6, Q[T1, T2, T3, T4]], ctf] .

  op seese&seCheck : Module Term Term -> Bool .
  ceq seese&seCheck(M, T, T') = true
   if sameSeqCtor(M, T, T') /\
      Q[T1, T2, T3, T4, T5] := T /\
      Q[T6, T7] := T' /\
      isCevs(M, T1) /\
      isCevs(M, T4) /\
      isCevs(M, T6) /\
      not isCevs(M, T2) /\
      not isCevs(M, T3) /\
      not isCevs(M, T5) /\
      not isCevs(M, T7)  .
  eq seese&seCheck(M, T, T') = false [owise] .

  op sees&se : Module Term Term -> TrialPairSet .
  ceq sees&se(M, Q[T1, T2, T3, T4], Q[T5, T6]) = [T4, cesv]
   if eq '_=_[T5, Q[T1, T2]] = 'false.Bool [AtS] . EqS := getEqs(M) .
  eq sees&se(M, Q[T1, T2, T3, T4], Q[T5, T6]) = ['_=_[T5, Q[T1, T2]], ctf] [owise] .

  op es&sesCheck : Module Term Term -> Bool .
  eq es&sesCheck(M, T, Q[T', TL]) =
                             es&sesSize(M, T, Q[T', TL]) and-then
                             es&sesTypes(M, T, Q[T', TL]) and-then
                             sameSeqCtor(M, T, Q[T', TL]) and-then
                             isCevs(M, T') .

  op se&sesCheck : Module Term Term -> Bool .
  eq se&sesCheck(M, T, Q[TL, T']) =
                             es&sesSize(M, T, Q[TL, T']) and-then
                             se&sesTypes(M, T, Q[TL, T']) and-then
                             sameSeqCtor(M, T, Q[TL, T']) and-then
                             isCevs(M, T') .

  op es&esCheck : Module Term Term -> Bool .
  eq es&esCheck(M, T, T') = sameSeqCtor(M, T, T') and-then
                            not sameSize(T, T') and-then
                            not es&sesCheck(M, T, T') and-then
                            firstIsElem(M, T) and-then
                            firstIsElem(M, T') .

  op firstIsElem : Module Term -> Bool .
  eq firstIsElem(M, Q[T, TL]) = not isCevs(M, T) .
  eq firstIsElem(M, T) = false [owise] .

  op es&sesSize : Module Term Term -> Bool .
  eq es&sesSize(M, Q[TL], Q[TL']) = (size(TL) + 1) == size(TL') .
  eq es&sesSize(M, T, T') = false [owise] .

  op es&sesTypes : Module Term Term -> Bool .
  eq es&sesTypes(M, Q[TL], Q[T', TL']) = es&sesTypes*(M, TL, TL') .

  op se&sesTypes : Module Term Term -> Bool .
  eq se&sesTypes(M, Q[TL], Q[TL', T']) = es&sesTypes*(M, TL, TL') .

  op es&sesTypes* : Module TermList TermList -> Bool .
  eq es&sesTypes*(M, (T, TL), (T', TL')) =
                              getType(metaReduce(M, T)) == getType(metaReduce(M, T')) and
                              es&sesTypes*(M, TL, TL') .
  eq es&sesTypes*(M, empty, empty) = true .
  eq es&sesTypes*(M, TL, TL') = false [owise] .

  op es&ses : Module Term Term ~> TrialPairSet .
  eq es&ses(M, Q[TL], Q[T', TL']) = [T', cevs] . *** $processEqualityTerm(M, '_=_[Q[TL], Q[TL']]) .

  op se&ses : Module Term Term ~> TrialPairSet .
  eq se&ses(M, Q[TL], Q[TL', T']) = [T', cevs] . *** $processEqualityTerm(M, '_=_[Q[TL], Q[TL']]) .


  op es&es : Module Term Term ~> TrialPairSet .
  ceq es&es(M, Q[T, TL], Q[T', TL']) = processEqualityTerm*(M, TrS) *** ['_=_[Q[TL], Q[TL']], ctf]
   if T1 := reduce(M, '_=_[T, T']) /\
      TrS := getEqualityTerms(M, T1) .

  *** TODO: With different sizes it would be possible to make different equalities.
  op sameSize : Term Term -> Bool [comm] .
  eq sameSize(Q[TL], Q[TL']) = size(TL) == size(TL') .
  eq sameSize(Q[TL], C) = false .
  eq sameSize(Q[TL], V) = true .
  eq sameSize(T, T') = true [owise] .

  op seqEqualities : Module Term Term ~> TrialPairSet .
  eq seqEqualities(M, Q[TL], Q[TL']) = seqEqualities*(M, TL, TL') .

  op seqEqualities* : Module TermList TermList ~> TrialPairSet .
  eq seqEqualities*(M, empty, empty) = mtTPS .
  eq seqEqualities*(M, (T, TL), (T', TL')) = processEqualityTerm(M, '_=_[T, T'])
                                             seqEqualities*(M, TL, TL') [print "Sequence inference " T " = " T'] .

  op divideEqSeq : Module Term Term ~> TrialPairSet .
  eq divideEqSeq(M, Q[TL], Q[TL']) = divideEqSeq*(M, TL, TL') .

  op divideEqSeq* : Module TermList TermList ~> TrialPairSet .
  eq divideEqSeq*(M, empty, empty) = mtTPS .
  eq divideEqSeq*(M, (T, TL), (T', TL')) = processEqualityTerm(M, '_=_[T, T'])
                                           divideEqSeq*(M, TL, TL') .

  op decomposeTerm : Module Term -> TrialPairSet .
  eq decomposeTerm(M, V) = mtTPS .
  eq decomposeTerm(M, C) = if allCtor(M, C) or isFreshCons(M, C)
                           then mtTPS
                           else if isCevs(M, C)
                                then [C, cevs] *** [C, term] *** Adrian
                                else [C, term]
                                fi
                           fi .
  eq decomposeTerm(M, Q[TL]) = if allCtor(M, Q[TL]) or Q == 'if_then_else_fi
                               then mtTPS
                               else decomposeTerm*(M, TL)
                                    if isCtor(getOps(M), Q)
                                    then mtTPS
                                    else if isCevs(M, Q[TL])
                                         then [Q[TL], cevs] *** [Q[TL], term] *** Adrian
                                         else [Q[TL], term]
                                         fi
                                    fi
                               fi .

  op decomposeTerm* : Module TermList -> TrialPairSet .
  eq decomposeTerm*(M, empty) = mtTPS .
  eq decomposeTerm*(M, (T, TL)) = decomposeTerm(M, T) decomposeTerm*(M, TL) .

  op isCevs : Module Term -> Bool .
  eq isCevs(M, V) = false .
  ceq isCevs(M, C) = (not isCtor(getOps(M), getName(C))) and
                     isCevs(Ty, getSubsorts(M), getOps(M))
   if Ty := getType(metaReduce(M, C)) .
  ceq isCevs(M, Q[TL]) = allConstants(TL) and isCevs(Ty, getSubsorts(M), getOps(M))
   if Ty := getType(metaReduce(M, Q[TL])) .

  op allConstants : TermList -> Bool .
  eq allConstants(empty) = true .
  eq allConstants((C, TL)) = allConstants(TL) .
  eq allConstants(TL) = false [owise] .

  op isCevs : Type SubsortDeclSet OpDeclSet -> Bool .
  eq isCevs(Ty, subsort Ty' < Ty . SSDS, ODS) = isCevs(Ty, ODS) .
  eq isCevs(Ty, SSDS, ODS) = false [owise] .

  op isCevs : Type OpDeclSet -> Bool .
  eq isCevs(Ty, op Q : TyL -> Ty [ctor assoc id(T) AtS] . ODS) = true .
  eq isCevs(Ty, ODS) = false [owise] .

  op isCtor : OpDeclSet Qid -> Bool .
  eq isCtor(op Q : TyL -> Ty [ctor AtS] . ODS, Q) = true .
  eq isCtor(ODS, Q) = false [owise] .

  op containsBoolOps : Term -> Bool .
  eq containsBoolOps(V) = false .
  eq containsBoolOps(C) = false .
  ceq containsBoolOps(Q[TL]) = true
   if (Q == '_or_) or (Q == '_and_) or (Q == '_xor_) or (Q == 'if_then_else_fi) .
  eq containsBoolOps(Q[TL]) = containsBoolOps*(TL) [owise] .

  op containsBoolOps* : TermList -> Bool .
  eq containsBoolOps*(empty) = false .
  eq containsBoolOps*((T, TL)) = containsBoolOps(T) or-else containsBoolOps*(TL) .

  op processEq* : Module Term EquationSet -> TrialPairSet .
  eq processEq*(M, T, EqS) = processEq*(M, T, EqS, mtTPS) .

  op processEq* : Module Term EquationSet TrialPairSet -> TrialPairSet .
  ceq processEq*(M, T, Eq EqS, TPS) = processEq*(M, T, EqS, TPS TPS')
   if ceq T1 = T2 if COND [AtS] . := Eq /\
      TPS' := processEq(M, T, Eq, 0) /\
      TPS' =/= mtTPS .
  eq processEq*(M, T, EqS, TPS) = if TPS == mtTPS
                                  then decomposeTerm(M, T)
                                  else TPS
                                  fi [owise] .


  op processEq : Module Term Equation Nat -> TrialPairSet .
  ceq processEq(M, T, ceq T1 = T2 if COND [AtS] ., N) = mtTPS
   if metaXmatch(M, T1, T, nil, 0, unbounded, N) == noMatch .
  ceq processEq(M, T, Eq, N) = processCond(M, COND, SB)
                               processEq(M, T, Eq, s(N))
   if ceq T1 = T2 if COND [AtS] . := Eq /\
      {SB, CTXT} := metaXmatch(M, T1, T, nil, 0, unbounded, N) /\
      checkCond(M, COND, SB) .
  ceq processEq(M, T, Eq, N) = processEq(M, T, Eq, s(N))
   if ceq T1 = T2 if COND [AtS] . := Eq /\
      {SB, CTXT} := metaXmatch(M, T1, T, nil, 0, unbounded, N) /\
      not checkCond(M, COND, SB) .

  *** We assume only equalities are possible, since we are using CafeOBJ modules
  op checkCond : Module Condition Substitution -> Bool .
  eq checkCond(M, nil, SB) = true .
  ceq checkCond(M, T = T' /\ COND, SB) = ((T1 == T2) or
                                          (not allCtor(M, T1)) or
                                          (not allCtor(M, T2))) and-then
                                         checkCond(M, COND, SB)
   if T1 := substitute(T, SB) /\
      T2 := substitute(T', SB) .

  op processCond : Module Condition Substitution -> TrialPairSet .
  eq processCond(M, nil, SB) = mtTPS .
  ceq processCond(M, T = T' /\ COND, SB) =
                             processEqualityTerm(M, '_=_[T1, T2])
                             processCond(M, COND, SB)
   if T1 := substitute(T, SB) /\
      T2 := substitute(T', SB) .

  op processEqualityTerm* : Module TermSet -> TrialPairSet .
  eq processEqualityTerm*(M, emptyTermSet) = mtTPS .
  eq processEqualityTerm*(M, T | TrS) = processEqualityTerm(M, T)
                                        processEqualityTerm*(M, TrS) .

  op allCtor : Module Term -> Bool .
  eq allCtor(M, T) = allCtor(getOps(M), T) .

  op allCtor : OpDeclSet Term -> Bool .
  eq allCtor(ODS, V) = false .
  ceq allCtor(op Q : nil -> Ty [ctor AtS] . ODS, C) = true
   if Q := getName(C) .
  eq allCtor(op Q : TyL -> Ty [ctor AtS] . ODS, Q[TL]) =
            allCtor*(op Q : TyL -> Ty [ctor AtS] . ODS, TL) .
  eq allCtor(ODS, T) = false [owise] .

  op allCtor* : OpDeclSet TermList -> Bool .
  eq allCtor*(ODS, empty) = true .
  eq allCtor*(ODS, (T, TL)) = allCtor(ODS, T) and allCtor*(ODS, TL) .

  op noneCtor : Module Term -> Bool .
  eq noneCtor(M, T) = noneCtor(getOps(M), T) .

  op noneCtor : OpDeclSet Term -> Bool .
  eq noneCtor(ODS, V) = false .
  ceq noneCtor(op Q : nil -> Ty [ctor AtS] . ODS, C) = false
   if Q := getName(C) .
  ceq noneCtor(op Q : nil -> Ty [AtS] . ODS, C) = true
   if Q := getName(C) [owise] .
  eq noneCtor(op Q : TyL -> Ty [ctor AtS] . ODS, Q[TL]) = false .
  eq noneCtor(op Q : TyL -> Ty [AtS] . ODS, Q[TL]) =
            noneCtor*(op Q : TyL -> Ty [ctor AtS] . ODS, TL) [owise] .

  op noneCtor* : OpDeclSet TermList -> Bool .
  eq noneCtor*(ODS, empty) = true .
  eq noneCtor*(ODS, (T, TL)) = noneCtor(ODS, T) and noneCtor*(ODS, TL) .

  op tl2ts : TermList -> TermSet .
  eq tl2ts(empty) = emptyTermSet .
  eq tl2ts((T, TL)) = T | tl2ts(TL) .

  *** Inference tuple
  sort IT ITL .
  subsort IT < ITL .

  op [_,_,_] : Module Term Nat -> IT [ctor] .

  op nilITL : -> IT [ctor] .
  op __ : ITL ITL -> ITL [ctor assoc id: nilITL] .

  sort IR .
  *** Command list
  *** Updated ScoreInfoSet
  *** Successful or not
  op [_,_,_] : QidList Macros Bool -> IR [ctor] .

  op indent : Nat -> QidList .
  eq indent(0) = nil .
  eq indent(s(N)) = '\t indent(N) .

***(%
\end{verbatim}
}

\noindent
and \verb"sizeTL" just computes the size of a list of terms:

{\codesize
\begin{verbatim}
%)

  op sizeTL : TermList -> Nat .
  eq sizeTL(empty) = 0 .
  eq sizeTL((T, TL)) = s(sizeTL(TL)) .

  ---------------------------------------------------------------------------------------
  ---                              getEqTermsWithImps                                 ---
  ---------------------------------------------------------------------------------------

  op getEqTermsWithImps : Module Term -> TermSet .
  ceq getEqTermsWithImps(M, T) = getEqTermsWithImps*(M, T, TL)
   if TL := getHypotheses(M) .

  op getEqTermsWithImps* : Module Term TermList -> TermSet .
  eq getEqTermsWithImps*(M, T, empty) = emptyTermSet .
  ceq getEqTermsWithImps*(M, Q[TL], (Q[TL'], TL'')) =
               getEqualityTerms(M, reduce(M, '_implies_[substitute(Q[TL'], SB), Q[TL]]), Q[TL]) |
               getEqTermsWithImps*(M, Q[TL], TL'')
   if SB := basicSB*(TL', TL) . *** [print "Implication with " Q "(" TL' ") - " SB] .
  ceq getEqTermsWithImps*(M, T, (T', TL)) = getEqTermWithImpsInst(M, T, TSPS) |
                                            getEqTermsWithImps*(M, T, TL)
   if numVars(T') <= numInstVars /\
      TSPS := allIns(M, [T', none, getLabel(M, T')]) [owise] .
  ceq getEqTermsWithImps*(M, T, (T', TL)) = getEqualityTerms(M, T1, T) |
                                            getEqTermsWithImps*(M, T, TL)
   if T1 := reduce(M, '_implies_[T', T]) [owise] . *** print "Implication owise with " T' " - " T1] .

  op getEqTermWithImpsInst : Module Term TermSubPairSet -> TermSet .
  eq getEqTermWithImpsInst(M, T, mtTSPS) = emptyTermSet .
  ceq getEqTermWithImpsInst(M, T, [T', SB, Q] TSPS) = getEqualityTerms(M, T1, T) |
                                                      getEqTermWithImpsInst(M, T, TSPS)
   if T1 := reduce(M, '_implies_[T', T]) .

  ---------------------------------------------------------------------------------------
  ---                               getEqualityTerms                                  ---
  ---------------------------------------------------------------------------------------

  op getEqualityTerms : Module Term -> TermSet .
  ceq getEqualityTerms(M, T) = getEqualityTerms(M, T', T)
   if T' := reduce(M, T) .

  op getEqualityTerms : Module Term Term -> TermSet .
  ceq getEqualityTerms(M, '_=_[T1, T2], T) = reorder(M, '_=_[T1, T2], T)
   if not containsBoolOps('_=_[T1, T2]) .
  ceq getEqualityTerms(M, Q[TL], T) = getEqualityTerms*(M, TL, T)
   if Q =/= 'if_then_else_fi /\
      containsBoolOps(Q[TL]) .
  eq getEqualityTerms(M, 'not_[T], T') = getEqualityTerms(M, T, T') .
  eq getEqualityTerms(M, 'if_then_else_fi[T, T', T''], T1) = getEqualityTerms(M, T, T1) .
  eq getEqualityTerms(M, 'true.Bool, T) = emptyTermSet .
  eq getEqualityTerms(M, 'false.Bool, T) = emptyTermSet .
  eq getEqualityTerms(M, T, T') = '_=_[T, 'true.Bool] [owise] .

  op getEqualityTerms* : Module TermList Term -> TermSet .
  eq getEqualityTerms*(M, empty, T) = emptyTermSet .
  eq getEqualityTerms*(M, (T, TL), T') = getEqualityTerms(M, T, T') |
                                         getEqualityTerms*(M, TL, T') .

  op reorder : Module Term Term -> Term .
  eq reorder(M, '_=_[C, T], Q[TL, C, TL']) = '_=_[T, C] .
  ceq reorder(M, '_=_[Q[TL], C], Q'[TL']) = '_=_[C, Q[TL]]
   if not C in TL' /\
      isCtor(getOps(M), Q) .
  ceq reorder(M, '_=_[C, Q[TL]], T) = '_=_[Q[TL], C]
   if not isCtor(getOps(M), Q) .
  ceq reorder(M, '_=_[C, Q[TL]], T) = '_=_[Q[TL], C]
   if C in TL .
  ***(
  ceq reorder(M, '_=_[T1, T2], T) = '_=_[T2, T1]
   if eq T3 = T4 [AtS] . EqS := getEqs(M) /\
      T1 := reduce(M, T4) .
  )
  ceq reorder(M, '_=_[Q[TL], Q[TL']], T) = '_=_[Q[TL'], Q[TL]]
   if sameSeqCtor(M, Q[TL], Q[TL']) /\
      size(TL') > size(TL) .
  eq reorder(M, T, T') = T [owise] .

  op _in_ : Term TermList -> Bool .
  eq T in (TL, T, TL') = true .
  eq T in TL = false [owise] .

  ---------------------------------------------------------------------------------------
  ---                                tryImplication                                   ---
  ---------------------------------------------------------------------------------------

  sort ImpPair ImpPairList ImpTryRes .
  subsort ImpPair < ImpPairList .

  op [_,_,_] : Term Qid Substitution -> ImpPair [ctor] .

  op nilIPL : -> ImpPairList [ctor] .
  op __ : ImpPairList ImpPairList -> ImpPairList [ctor assoc id: nilIPL] .

  op [_,_] : ImpPairList Bool -> ImpTryRes [ctor] .






  var SB? : [Substitution] .
  var SB' : Substitution .
  var TS? : [TermSet] .

  op preSubstitution : Module Term Term ~> SbSet .
  eq preSubstitution(M, T, T') = preSubstitution(M, T, T', 0) .

  op preSubstitution : Module Term Term Nat ~> SbSet .
  ceq preSubstitution(M, T, T', N) = SB +
                                     if SB == none
                                     then mtSBS
                                     else preSubstitution(M, T, T', s(N))
                                     fi
   if TrS := getEquals(reduce(M, '_implies_[T, T'])) /\
      SB := traverseEquals(M, TrS, N, none) .

  op traverseEquals : Module TermSet Nat Substitution ~> Substitution .
  ceq traverseEquals(M, ('_=_[T, T']) | TrS, N, SB) =
                                                traverseEquals(M, TrS, N, SB ; SB?)
   if T1 := substitute(T, SB) /\
      T2 := substitute(T', SB) /\
      hasVars(T1) /\
      not (T1 :: Variable) /\
      not hasVars(T2) /\
      SB? := metaMatch(M, T1, T2, nil, N) /\
      SB? :: Substitution .
  ceq traverseEquals(M, ('_=_[T, T']) | TrS, N, SB) =
                                                traverseEquals(M, TrS, N, SB ; SB?)
   if T1 := substitute(T, SB) /\
      T2 := substitute(T', SB) /\
      hasVars(T2) /\
      not (T2 :: Variable) /\
      not hasVars(T1) /\
      SB? := metaMatch(M, T2, T1, nil, N) /\
      SB? :: Substitution .
  ceq traverseEquals(M, ('_=_[T, T']) | ('_=_[T, T'']) | TrS, N, SB) =
                                                traverseEquals(M, TrS, N, SB ; SB?)
   if T1 := substitute(T'', SB) /\
      T2 := substitute(T', SB) /\
      hasVars(T2) /\
      not (T2 :: Variable) /\
      not hasVars(T1) /\
      SB? := metaMatch(M, T2, T1, nil, N) /\
      SB? :: Substitution .
  eq traverseEquals(M, TrS, N, SB) = SB [owise] .

  op getEquals : Term -> TermSet .
  eq getEquals(T) = getEquals(T, emptyTermSet) .

  op getEquals : Term TermSet -> TermSet .
  eq getEquals(C, TrS) = TrS .
  eq getEquals(V, TrS) = TrS .
  eq getEquals('_=_[TL], TrS) = ('_=_[TL]) | TrS .
  eq getEquals(Q[TL], TrS) = getEquals*(TL, TrS) [owise] .

  op getEquals* : TermList TermSet -> TermSet .
  eq getEquals*(empty, TrS) = TrS .
  ceq getEquals*((T, TL), TrS) = getEquals*(TL, TrS')
   if TrS' := getEquals(T, TrS) .

  sort SbSet .
  subsort Substitution < SbSet .

  op mtSBS : -> SbSet .
  op _+_ : SbSet SbSet -> SbSet [ctor assoc comm id: mtSBS] .

  eq (V <- T ; SB) + none = (V <- T ; SB) .

  var SBS : SbSet .


  sorts TermSubPair TermSubPairSet .
  subsort TermSubPair < TermSubPairSet .

  op mtTSPS : -> TermSubPairSet [ctor] .
  op [_,_,_] : Term Substitution Qid -> TermSubPair [ctor] .
  op __ : TermSubPairSet TermSubPairSet -> TermSubPairSet [ctor assoc comm id: mtTSPS] .

  vars TSPS TSPS' : TermSubPairSet .
  var  TSP  : TermSubPair .
  var  IPL' : ImpPairList .
  var  IP : ImpPair .

  op tryImplication : Module Term TermList -> ImpTryRes .
  eq tryImplication(M, T, TL) = tryImplication(M, T, TL, extraImpLevels) .

  op tryImplication : Module Term TermList Nat -> ImpTryRes .
  ceq tryImplication(M, Q[TL], (TL1, Q[TL'], TL2), N) =
                                    if T'' == 'true.Bool
                                    then [IP, true]
                                    else $tryImplication(M, '_implies_[T', Q[TL]],
                                                         (TL1, Q[TL'], TL2),
                                                         (TL1, Q[TL'], TL2), IP, N)
                                    fi
   if SB := basicSB*(TL', TL) /\
      T' := substitute(Q[TL'], SB) /\
      T'' := reduce(M, '_implies_[T', Q[TL]]) /\
      Q' := getLabel(M, Q[TL']) /\
      IP := [T', Q', SB] .

  op $tryImplication : Module Term TermList TermList ImpPair Nat -> ImpTryRes .
  eq $tryImplication(M, T, empty, TL, IP, N) = [nilIPL, false] .
  eq $tryImplication(M, T, TL, TL', IP, 0) = [nilIPL, false] .
  ceq $tryImplication(M, T, (T', TL), TL', IP, s(0)) = [IP [T'', Q, SB'], true]
   if (SB + SBS) := preSubstitution(M, T', T) /\
      T1 := substitute(T', SB) /\
      numVars(T1) <= numInstVars /\
      [T'', SB', Q] TSPS := allIns(M, [T1, SB, getLabel(M, T')]) /\
      reduce(M, '_implies_[T'', T]) == 'true.Bool .
  ceq $tryImplication(M, T, (T', TL), TL', IP, s(s(N))) = [IP [T'', Q, SB'], true]
   if (SB + SBS) := preSubstitution(M, T', T) /\
      T1 := substitute(T', SB) /\
      numVars(T1) <= numInstVars /\
      [T'', SB', Q] TSPS := allIns(M, [T1, SB, getLabel(M, T')]) /\
      [IPL, true] := $tryImplication(M, '_implies_[T'', T], TL', TL', IP, s(N)) .
  eq $tryImplication(M, T, (T', TL), TL', IP, s(N)) = $tryImplication(M, T, TL, TL', IP, s(N)) [owise print "A"] .

  op allIns : Module TermSubPairSet -> TermSubPairSet [memo] .
  ceq allIns(M, [T, SB, Q] TSPS) = allIns(M, TSPS TSPS')
   if hasVars(T) /\
      TSPS' := allIns([T, SB, Q], getOps(M), mtTSPS) .
  eq allIns(M, TSPS) = TSPS [owise] .

  op allIns : TermSubPair OpDeclSet TermSubPairSet ~> TermSubPairSet .
  ceq allIns([Q[TL, V, TL'], SB, Q'], op Q'' : nil -> Ty [metadata(S) AtS] . ODS, TSPS) =
                                        allIns([Q[TL, V, TL'], SB, Q'], ODS, TSPS [Q[TL, C, TL'], V <- C ; SB, Q'])
   if not hasVars*(TL) /\
      Ty := getType(V) /\
      (S == "generated-si" or S == "tc") /\
      C := qid(string(Q'') + "." + string(Ty)) .
  eq allIns(TSP, ODS, TSPS) = TSPS [owise] .

  op basicSB* : TermList TermList -> Substitution .
  eq basicSB*(empty, empty) = none .
  eq basicSB*((V, TL), (C, TL')) = V <- C ; basicSB*(TL, TL') .
  eq basicSB*((T, TL), (T', TL')) = basicSB*(TL, TL') [owise] .



  op numVars : Term -> Nat .
  eq numVars(T) = size(getVars(T)) .

  op size : TermSet -> Nat .
  eq size(T | TrS) = s(size(TrS)) .
  eq size(TrS) = 0 [owise] .

  op getLabel : Module Term ~> Qid [memo] .
  eq getLabel(M, T) = getLabel(getEqs(M), T) .

  op getLabel : EquationSet Term ~> Qid [memo] .
  eq getLabel(eq T = 'true.Bool [label(Q) AtS] . EqS, T) = Q .

  *** Term in premise
  *** Term in goal
  *** We assume the first term has vars
  op getImpSubs : Module Term Term -> Substitution [memo] .
  ceq getImpSubs(M, T, T') = getImpSubs(T1, T2)
   if T1 := reduce(M, T) /\
      T2 := reduce(M, T') .

  op getImpSubs : Term Term -> Substitution .
  ceq getImpSubs(Q[TL], T) = getImpSubs*(TL, T)
   if tryMatch(Q[TL], T) == none or
      not (tryMatch(Q[TL], T) :: Substitution) .
  ceq getImpSubs(Q[TL], T) = SB
   if SB := tryMatch(Q[TL], T) /\
      SB =/= none .
  eq getImpSubs(T, T') = none [owise] .

  op getImpSubs* : TermList Term -> Substitution .
  eq getImpSubs*(empty, T) = none .
  eq getImpSubs*((T, TL), T') = getImpSubs(T, T') ; getImpSubs*(TL, T') .

  op tryMatch : Term Term ~> Substitution .
  eq tryMatch(Q[TL], Q[TL']) = tryMatch*(TL, TL') .
  ceq tryMatch(Q[TL], Q'[TL']) = traverseRest(Q[TL], TL')
   if Q =/= Q' .

  op traverseRest : Term TermList ~> Substitution .
  ceq traverseRest(T, (T', TL)) = SB
   if SB := tryMatch(T, T') /\ SB =/= none .
  ceq traverseRest(T, (T', TL)) = traverseRest(T, TL)
   if not (tryMatch(T, T') :: Substitution) or
      tryMatch(T, T') == none .
  eq traverseRest(T, empty) = none .

  op tryMatch* : TermList TermList ~> Substitution .
  eq tryMatch*(empty, empty) = none .
  eq tryMatch*((V, TL), (C, TL')) = V <- C ; tryMatch*(TL, TL') .
  eq tryMatch*((T, TL), (T', TL')) = tryMatch*(TL, TL') [owise] .

  op applyImpSub : Term Substitution -> Term .
  eq applyImpSub(Q[TL], SB) = Q[applyImpSub*(TL, SB)] .
  eq applyImpSub(C, SB) = C .
  eq applyImpSub(V, V <- T ; SB) = T .
  eq applyImpSub(V, SB) = V [owise] .

  op applyImpSub* : TermList Substitution -> TermList .
  eq applyImpSub*((T, TL), SB) = applyImpSub(T, SB), applyImpSub*(TL, SB) .
  eq applyImpSub*(empty, SB) = empty .

  op isFreshCons : Module Term -> Bool .
  ceq isFreshCons(M, C) = true
   if Q := getName(C) /\
      Ty := getType(C) /\
      op Q : nil -> Ty [metadata("generated-si") AtS] . ODS := getOps(M) .
  ceq isFreshCons(M, C) = true
   if Q := getName(C) /\
      Ty := getType(C) /\
      op Q : nil -> Ty [metadata("tc") AtS] . ODS := getOps(M) .
  ceq isFreshCons(M, C) = true
   if Q := getName(C) /\
      Ty := getType(C) /\
      op Q : nil -> Ty [metadata(St) AtS] . ODS := getOps(M) /\
      find(St, "CTF-", 0) =/= notFound .
  eq isFreshCons(M, T) = false [owise] .


  ------------------------------------------------------------------------------------
  ---                                printImpCom                                   ---
  ------------------------------------------------------------------------------------

  *** We assume it reduces the term to true, so the last command is a reduction.
  op printImpCom : ImpPairList -> QidList .
  eq printImpCom(nilIPL) =
             '\t '-- 'The 'corresponding 'proof 'score 'was 'not 'present. '\n
             '\t ':apply ' '`( 'rd '`) '\n '\n .
  eq printImpCom([T, Q, SB] IPL) =
             '\t '-- 'The 'corresponding 'proof 'score 'was 'not 'present. '\n
             if SB == none
             then '\t ':imp ' '`[ Q '`] ' '. '\n '\n
             else '\t ':imp ' '`[ Q '`] ' 'by ' '`{ printSub(SB) '`} '\n '\n
             fi
             printImpCom(IPL) .

  *** We assume it reduces the term to true, so the last command is a reduction.
  op printImpCom : ImpPairList String Nat -> QidList .
  eq printImpCom(IPL, S, INDENT) =
             indent(INDENT) '-- qid(S) 'Success 'by 'implication 'and 'reduction. '\n
             printImpCom(IPL, INDENT) .

  op printImpCom : ImpPairList Nat -> QidList .
  eq printImpCom(nilIPL, INDENT) =
             indent(INDENT) ':apply ' '`( 'rd '`) '\n '\n .
  eq printImpCom([T, Q, SB] IPL, INDENT) =
             if SB == none
             then indent(INDENT) ':imp ' '`[ Q '`] ' '. '\n '\n
             else indent(INDENT) ':imp ' '`[ Q '`] ' 'by ' '`{ printSub(SB) '`} '\n '\n
             fi
             printImpCom(IPL, INDENT) .

  -------------------------------------------------------------------------------------
  ---                                redForgotten                                   ---
  -------------------------------------------------------------------------------------

  op redForgotten : Module Term -> Bool .
  eq redForgotten(M, T) = getTerm(metaReduce(M, T)) == 'true.Bool .

  -------------------------------------------------------------------------------------
  ---                                 indRequired                                   ---
  -------------------------------------------------------------------------------------

  op indRequired : ScoreInfoSet Module Term -> TermList .
  ceq indRequired(SIS, M, T) = V
   if SIS =/= noScoreInfo /\
      TrS := getVars(T) /\
      V := getIndVar(T, TrS, SIS) .
  eq indRequired(SIS, M, T) = empty [owise] .

  -------------------------------------------------------------------------------------
  ---                                 tcRequired                                    ---
  -------------------------------------------------------------------------------------

  op tcRequired : Term -> Bool .
  eq tcRequired(T) = hasVars(T) .

  -------------------------------------------------------------------------------------
  ---                              cevsTermRequired                                 ---
  -------------------------------------------------------------------------------------

  op cevsRequired : ScoreInfoSet Module Term -> TermList .
  ceq cevsRequired(SIS, M, T) = $cevsRequired(SIS1, SIS2, M, T, 2)
   if [SIS1, SIS2] := divideByExecEqs(SIS, 1) .
  op $cevsRequired : ScoreInfoSet ScoreInfoSet Module Term Nat -> TermList .
  ceq $cevsRequired($ M, M', (TL, T, TL') $ SIS, SIS2, M'', T', N) = T5
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      eq T3 = T'' [AtS] . EqS := getEqs(M') /\
      isExec(AtS) /\
      T5 := instantiateVars(M, M'', T3, CS) /\
      isCEVS(M, T'') /\
      not isEquality(T3) /\
      ((T'' =/= 'true.Bool) and (T'' =/= 'false.Bool)) /\
      not eqDefinedFor(M'', T5) /\
      termDefinedInAll(SIS SIS2, M'', T', T5) .
  ceq $cevsRequired($ M, M', (TL, T, TL') $ SIS,
                    $ M1, M2, (TL1, T1, TL2) $ SIS2, M'', T', N) = T5
   if CS := getSub(M, T, M'', T') /\
      CS' := getSub(M1, T1, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      consistentPremises(M2, M'', CS) /\
      *** Case distinction in the same term
      eq T3 = T'' [AtS] . EqS := getEqs(M') /\
      eq T3 = T''' [AtS'] . EqS' := getEqs(M2) /\
      *** Both equations are executable
      isExec(AtS) /\
      isExec(AtS') /\
      T5 := instantiateVars(M, M'', T3, CS) /\
      isCEVS(M1, T''') /\
      not isEquality(T3) /\
      ((T'' =/= 'true.Bool) and (T'' =/= 'false.Bool)) /\
      not eqDefinedFor(M'', T5) /\
      termDefinedInAll(SIS SIS2, M'', T', T5) .
  eq $cevsRequired(SIS1, SIS2, M, T, N) =
      if (SIS2 == noScoreInfo) or
         (ctfTermRequired(SIS1, M, T) =/= empty) or
         (ctfRequired(SIS1, M, T) =/= none)
      then empty
      else $cevsRequired(fst(divideByExecEqs(SIS2, N)),
                         snd(divideByExecEqs(SIS2, N)), M, T, s(N))
      fi [owise] .

  var Ty' : Type .

  op isCEVS : Module Term -> Bool .
  eq isCEVS(M, T) = subsortUnaryBinaryOpConstraints(M, T) and checkTermCEVS(M, T) .
  eq isCEVS(M, T) = false [owise] .

  op checkTermCEVS : Module Term -> Bool .
  ceq checkTermCEVS(M, Q[T, T']) = true
   if op Q : Ty1 Ty2 -> Ty [ctor assoc AtS] . ODS := getOps(M) /\
      Ty' := getType(metaReduce(M, T)) /\
      Ty' =/= Ty1 /\
      sortLeq(M, Ty', Ty1) /\
      getType(metaReduce(M, T')) == Ty2 .
  eq checkTermCEVS(M, T) = false [owise] .

  -------------------------------------------------------------------------------------
  ---                              csvsTermRequired                                 ---
  -------------------------------------------------------------------------------------

  op csvsRequired : ScoreInfoSet Module Term -> TermList .
  ceq csvsRequired(SIS, M, T) = $csvsRequired(SIS1, SIS2, M, T, 2)
   if [SIS1, SIS2] := divideByExecEqs(SIS, 1) .
  op $csvsRequired : ScoreInfoSet ScoreInfoSet Module Term Nat -> TermList .
  ceq $csvsRequired($ M, M', (TL, T, TL') $ SIS, SIS2, M'', T', N) = T5
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      eq T3 = T'' [AtS] . EqS := getEqs(M') /\
      isExec(AtS) /\
      T5 := instantiateVars(M, M'', T3, CS) /\
      isCSVS(M, T'') /\
      not isEquality(T3) /\
      ((T'' =/= 'true.Bool) and (T'' =/= 'false.Bool)) /\
      not eqDefinedFor(M'', T5) /\
      termDefinedInAll(SIS SIS2, M'', T', T5) .
  ceq $csvsRequired($ M, M', (TL, T, TL') $ SIS,
                    $ M1, M2, (TL1, T1, TL2) $ SIS2, M'', T', N) = T5
   if CS := getSub(M, T, M'', T') /\
      CS' := getSub(M1, T1, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      consistentPremises(M2, M'', CS) /\
      *** Case distinction in the same term
      eq T3 = T'' [AtS] . EqS := getEqs(M') /\
      eq T3 = T''' [AtS'] . EqS' := getEqs(M2) /\
      *** Both equations are executable
      isExec(AtS) /\
      isExec(AtS') /\
      T5 := instantiateVars(M, M'', T3, CS) /\
      isCSVS(M1, T''') /\
      not isEquality(T3) /\
      ((T'' =/= 'true.Bool) and (T'' =/= 'false.Bool)) /\
      not eqDefinedFor(M'', T5) /\
      termDefinedInAll(SIS SIS2, M'', T', T5) .
  eq $csvsRequired(SIS1, SIS2, M, T, N) =
      if (SIS2 == noScoreInfo) or
         (ctfTermRequired(SIS1, M, T) =/= empty) or
         (ctfRequired(SIS1, M, T) =/= none)
      then empty
      else $csvsRequired(fst(divideByExecEqs(SIS2, N)),
                         snd(divideByExecEqs(SIS2, N)), M, T, s(N))
      fi [owise] .

  op isCSVS : Module Term -> Bool .
  eq isCSVS(M, T) = subsortUnaryBinaryOpConstraints(M, T) and checkTermCSVS(M, T) .
  eq isCSVS(M, T) = false [owise] .

  op checkTermCSVS : Module Term -> Bool .
  ceq checkTermCSVS(M, Q[T, T', T'']) = true
   if op Q : Ty1 Ty2 -> Ty [ctor assoc AtS] . ODS := getOps(M) /\
      Ty' := getType(metaReduce(M, T')) /\
      Ty' =/= Ty1 /\
      sortLeq(M, Ty', Ty1) /\
      getType(metaReduce(M, T)) == Ty2 /\
      getType(metaReduce(M, T'')) == Ty2 .
  eq checkTermCSVS(M, T) = false [owise] .

  -------------------------------------------------------------------------------------
  ---                              cesvTermRequired                                 ---
  -------------------------------------------------------------------------------------

  op cesvRequired : ScoreInfoSet Module Term -> TermList .
  ceq cesvRequired(SIS, M, T) = $cesvRequired(SIS1, SIS2, M, T, 2)
   if [SIS1, SIS2] := divideByExecEqs(SIS, 1) .

  op $cesvRequired : ScoreInfoSet ScoreInfoSet Module Term Nat -> TermList .
  ceq $cesvRequired($ M, M', (TL, T, TL') $ SIS, SIS2, M'', T', N) = T5
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      eq T3 = T'' [AtS] . EqS := getEqs(M') /\
      isExec(AtS) /\
      T5 := instantiateVars(M, M'', T3, CS) /\
      isCESV(M, T'') /\
      not isEquality(T3) /\
      ((T'' =/= 'true.Bool) and (T'' =/= 'false.Bool)) /\
      not eqDefinedFor(M'', T5) /\
      termDefinedInAll(SIS SIS2, M'', T', T5) .
  ceq $cesvRequired($ M, M', (TL, T, TL') $ SIS,
                    $ M1, M2, (TL1, T1, TL2) $ SIS2, M'', T', N) = T5
   if CS := getSub(M, T, M'', T') /\
      CS' := getSub(M1, T1, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      consistentPremises(M2, M'', CS) /\
      *** Case distinction in the same term
      eq T3 = T'' [AtS] . EqS := getEqs(M') /\
      eq T3 = T''' [AtS'] . EqS' := getEqs(M2) /\
      *** Both equations are executable
      isExec(AtS) /\
      isExec(AtS') /\
      T5 := instantiateVars(M, M'', T3, CS) /\
      isCESV(M1, T''') /\
      not isEquality(T3) /\
      ((T'' =/= 'true.Bool) and (T'' =/= 'false.Bool)) /\
      not eqDefinedFor(M'', T5) /\
      termDefinedInAll(SIS SIS2, M'', T', T5) .
  eq $cesvRequired(SIS1, SIS2, M, T, N) =
      if (SIS2 == noScoreInfo) or
         (ctfTermRequired(SIS1, M, T) =/= empty) or
         (ctfRequired(SIS1, M, T) =/= none)
      then empty
      else $cesvRequired(fst(divideByExecEqs(SIS2, N)),
                         snd(divideByExecEqs(SIS2, N)), M, T, s(N))
      fi [owise] .

  op isCESV : Module Term -> Bool .
  eq isCESV(M, T) = subsortUnaryBinaryOpConstraints(M, T) and checkTermCESV(M, T) .
  eq isCESV(M, T) = false [owise] .

  op checkTermCESV : Module Term -> Bool .
  ceq checkTermCESV(M, Q[T, T']) = true
   if op Q : Ty1 Ty2 -> Ty [ctor assoc AtS] . ODS := getOps(M) /\
      Ty1 == getType(metaReduce(M, T)) /\
      Ty' := getType(metaReduce(M, T')) /\
      Ty' =/= Ty2 /\
      sortLeq(M, Ty', Ty2) .
  eq checkTermCESV(M, T) = false [owise] .

  -------------------------------------------------------------------------------------
  ---                              instantiateVars                                  ---
  -------------------------------------------------------------------------------------

  op instantiateVars : Module Module Term ConsSub -> Term .
  ceq instantiateVars(M, M', T, CS) = T
   if getTerm(metaReduce(M', T)) :: Term .
  ceq instantiateVars(M, M', T, CS) = instantiateVars(EqS, M, M', applyCS(T, CS))
   if EqS := applySubEqs(getEqs(M), CS) [owise] .

  op instantiateVars : EquationSet Module Module Term -> Term .
  ceq instantiateVars(EqS, M, M', T) = T
   if getTerm(metaReduce(M', T)) :: Term .
  ceq instantiateVars(eq T1 = T2 [AtS] . EqS, M, M', T) =
                      instantiateVars(applySubEqs(EqS, CS), M, M', applyCS(T, CS))
   if not (getTerm(metaReduce(M', T)) :: Term) /\
      eq T1 = T3 [AtS'] . EqS' := getEqs(M') /\
      CS := getSub(M, T2, M', T3) .

  op applySubEqs : EquationSet ConsSub -> EquationSet .
  ceq applySubEqs(eq T = T' [AtS] . EqS, CS) = eq applyCS(T, CS) = applyCS(T', CS) [AtS] .
                                               applySubEqs(EqS, CS)
   if isExec(AtS) .
  eq applySubEqs(EqS, CS) = none [owise] .

  ------------------------------------------------------------------------------------
  ---                              ctfTermRequired                                 ---
  ------------------------------------------------------------------------------------

  op ctfTermRequired : ScoreInfoSet Module Term -> TermList .
  ceq ctfTermRequired(SIS, M, T) = $ctfTermRequired(SIS1, SIS2, M, T, 2)
   if [SIS1, SIS2] := divideByExecEqs(SIS, 1) .

  op $ctfTermRequired : ScoreInfoSet ScoreInfoSet Module Term Nat -> TermList .
  ceq $ctfTermRequired($ M, M', (TL, T, TL') $ SIS, SIS2, M'', T', N) = T3
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      eq T1 = T2 [AtS] . EqS := getEqs(M') /\
      isExec(AtS) /\
      ((T2 == 'true.Bool) or (T2 == 'false.Bool)) /\
      not isEquality(T1) /\
      T3 := instantiateVars(M, M'', T1, CS) /\
      T4 := instantiateVars(M, M'', T2, CS) /\
      not eqDefinedFor(M'', T3) /\
      T5 := getTerm(metaReduce(M'', '_=_[T3, T4])) /\
      T5 =/= 'true.Bool /\
      T5 =/= 'false.Bool /\
      termDefinedInAll(SIS SIS2, M'', T', T3) .
  ceq $ctfTermRequired($ M, M', (TL, T, TL') $ SIS, SIS2, M'', T', N) = T5
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      *** Any level
      $ M1, M2, (TL1, T1, TL2) $ SIS1 := SIS SIS2 /\
      CS' := getSub(M1, T1, M'', T') /\
      *** Consistent premises
      consistentPremises(M2, M'', CS') /\
      eq T3 = T'' [AtS] . EqS := getEqs(M') /\
      isExec(AtS) /\
      eq T4 = T''' [AtS'] . EqS' := getEqs(M2) /\
      isExec(AtS') /\
      T5 := instantiateVars(M, M'', T3, CS) /\
      T5 := instantiateVars(M, M'', T4, CS) /\
      T'' =/= T''' /\
      isCtor(M, T'') /\
      isCtor(M1, T''') /\
      not isEquality(T3) /\
      not isEquality(T4) /\
      ((T'' =/= 'true.Bool) and (T'' =/= 'false.Bool)) /\
      ((T''' =/= 'true.Bool) and (T''' =/= 'false.Bool)) /\
      not eqDefinedFor(M'', T5) /\
      termDefinedInAll(SIS SIS2, M'', T', T5) .
  eq $ctfTermRequired(SIS1, SIS2, M, T, N) =
      if (SIS2 == noScoreInfo) or (ctfRequired(SIS1, M, T) =/= none)
      then empty
      else $ctfTermRequired(fst(divideByExecEqs(SIS2, N)),
                            snd(divideByExecEqs(SIS2, N)), M, T, s(N))
      fi [owise] .

  *** Term in the goal and term generated
  op termDefinedInAll : ScoreInfoSet Module Term Term -> Bool .
  ceq termDefinedInAll($ M, M', (TL, T, TL') $ SIS, M'', T', T1) = false
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      not hasTermDefined(M, M', M'', T1, CS) .
  eq termDefinedInAll(SIS, M, T, T1) = true [owise] .

  op hasTermDefined : Module Module Module Term ConsSub -> Bool .
  ceq hasTermDefined(M, M', M'', T, CS) = true
   if eq T1 = T2 [AtS] . EqS := getEqs(M') /\
      T := instantiateVars(M, M'', T1, CS)  .
  eq hasTermDefined(M, M', M'', T, CS) = false [owise] .

  op eqDefinedFor : Module Term -> Bool .
  ceq eqDefinedFor(M, T) = true
   if eq T = T' [AtS] . EqS := getEqs(M) .
  ceq eqDefinedFor(M, T) = true
   if eq '_=_[T, T'] = T'' [AtS] . EqS := getEqs(M) .
  eq eqDefinedFor(M, '_=_[T, T']) = eqDefinedFor(M, T, T') .
  eq eqDefinedFor(M, T) = false [owise] .

  op eqDefinedFor : Module Term Term -> Bool .
  ceq eqDefinedFor(M, T, T') = true
   if eq T = T' [AtS] . EqS := getEqs(M) .
  ceq eqDefinedFor(M, T, T') = true
   if eq '_=_[T, T'] = T'' [AtS] . EqS := getEqs(M) .
  ceq eqDefinedFor(M, T, 'false.Bool) = true
   if eqDefinedFor(M, T, 'true.Bool) .
  eq eqDefinedFor(M, '_=_[T, T'], 'true.Bool) = eqDefinedFor(M, T, T') .
  eq eqDefinedFor(M, T, T') = false [owise] .

  ------------------------------------------------------------------------------------
  ---                                ctfRequired                                   ---
  ------------------------------------------------------------------------------------

  op ctfRequired : ScoreInfoSet Module Term -> EquationSet .
  ceq ctfRequired(SIS, M, T) = $ctfRequired(SIS1, SIS2, M, T, 2)
   if [SIS1, SIS2] := divideByExecEqs(SIS, 1) .

  op $ctfRequired : ScoreInfoSet ScoreInfoSet Module Term Nat -> EquationSet .
  ceq $ctfRequired($ M, M', (TL, T, TL') $ SIS, SIS2, M'', T', N) = eq T5 = T6 [none] .
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremisesEq(M, M', M'', CS) /\
      eq T1 = T2 [AtS] . EqS := getEqs(M') /\
      isExec(AtS) /\
      T3 := instantiateVars(M, M'', T1, CS) /\
      T4 := instantiateVars(M, M'', T2, CS) /\
      not eqDefinedFor(M'', T3, T4) /\
      eq T5 = T6 [none] . := ctfEq(T3, T4) /\
      eqDefinedInAll(SIS SIS2, M'', T', T5, T6) .
  eq $ctfRequired(SIS1, SIS2, M, T, N) =
      if SIS2 == noScoreInfo
      then none
      else $ctfRequired(fst(divideByExecEqs(SIS2, N)),
                        snd(divideByExecEqs(SIS2, N)), M, T, s(N))
      fi [owise] .

  *** Term in the goal and terms for the generated equation
  op eqDefinedInAll : ScoreInfoSet Module Term Term Term -> Bool .
  ceq eqDefinedInAll($ M, M', (TL, T, TL') $ SIS, M'', T', T1, T2) = false
   if CS := getSub(M, T, M'', T') /\
      *** Consistent premises
      consistentPremises(M', M'', CS) /\
      not hasEqDefined(M, M', M'', T1, T2, CS) .
  eq eqDefinedInAll(SIS, M, T, T1, T2) = true [owise] .

  op hasEqDefined : Module Module Module Term Term ConsSub -> Bool .
  ceq hasEqDefined(M, M', M'', T, T', CS) = true
   if eq T1 = T2 [AtS] . EqS := getEqs(M') /\
      T := instantiateVars(M, M'', T1, CS) /\
      T' := instantiateVars(M, M'', T2, CS) .
  ceq hasEqDefined(M, M', M'', T, T', CS) = true
   if eq '_=_[T1, T2] = 'false.Bool [AtS] . EqS := getEqs(M') /\
      T := instantiateVars(M, M'', T1, CS) /\
      T' := instantiateVars(M, M'', T2, CS) .
  eq hasEqDefined(M, M', M'', T, T', CS) = false [owise] .

  op ctfEq : Term Term -> Equation .
  eq ctfEq('_=_[T1, T2], 'false.Bool) = eq T1 = T2 [none] . .
  eq ctfEq(T1, T2) = if T2 == 'false.Bool
                     then eq T1 = 'true.Bool [none] .
                     else eq T1 = T2 [none] .
                     fi [owise] .

  op isExec : AttrSet -> Bool .
  eq isExec(nonexec AtS) = false .
  eq isExec(AtS) = true [owise] .

  ------------------------------------------------------------------------------------
  ---                                impRequired                                   ---
  ------------------------------------------------------------------------------------

  sort ImpRequiredPair .
  op noImpRequired : -> ImpRequiredPair [ctor] .
  op |_,_| : Qid Substitution -> ImpRequiredPair [ctor] .

  op impRequired : ScoreInfoSet Module Term -> ImpRequiredPair .
  ceq impRequired($ M, M', (TL, '_implies_[T1, T2], TL') $ SIS, M'', T) = | Q, none |
   if CS := getSub(M, T2, M'', T) /\
      *** Same premises
      samePremises(M, M', M'', CS) /\
      T3 := getTermImplication(M, M'', '_implies_[T1, T2], T, CS) /\
      eq T3 = 'true.Bool [label(Q) AtS] . EqS := getEqs(M'') .
  ceq impRequired($ M, M', (TL, '_implies_[T1, T2], TL') $ SIS, M'', T) = | Q, SB |
   if CS := getSub(M, T2, M'', T) /\
      *** Same premises
      samePremises(M, M', M'', CS) /\
      T3 := getTermImplication(M, M'', '_implies_[T1, T2], T, CS) /\
      eq T4 = 'true.Bool [label(Q) AtS] . EqS := getEqs(M'') /\
      T3 =/= T4 /\
      SB := computeSub(T4, T3) .
  eq impRequired(SIS, M, T) = noImpRequired [owise] .

  op getTermImplication : Module Module Term Term ConsSub -> TermList .
  ceq getTermImplication(M, M', '_implies_[T1, T2], T, CS) = T4
   if impLevels(T) == impLevels(T2) /\
      T3 := applyCS(T1, CS) /\
      T4 := instantiateVars(M, M', T3, CS) .
  ceq getTermImplication(M, M', '_implies_[T1, T2], T, CS) = getTermImplication(M, M', T2, T, CS)
   if impLevels(T2) > impLevels(T) .
  eq getTermImplication(M, M', T, T', CS) = empty [owise] .

  *** Term with variables (premise)
  *** Ground term (term being reduced, once substituted)
  op computeSub : Term Term ~> Substitution .
  eq computeSub(C, C) = none .
  eq computeSub(V, T) = V <- T .
  eq computeSub(Q[TL], Q[TL']) = computeSub*(TL, TL') .

  op computeSub* : TermList TermList ~> Substitution .
  eq computeSub*(empty, empty) = none .
  eq computeSub*((T, TL), (T', TL')) = computeSub(T, T') ; computeSub*(TL, TL') .

  op implies? : Term -> Bool .
  eq implies?('_implies_[TL]) = true .
  eq implies?(T) = false [owise] .

  op impLevels : Term -> Nat .
  eq impLevels('_implies_[T, T']) = s(impLevels(T')) .
  eq impLevels(T) = 0 [owise] .

  ------------------------------------------------------------------------------------
  ---                                redRequired                                   ---
  ------------------------------------------------------------------------------------

  sort RedReqRes .
  op [_,_] : Bool ScoreInfoSet -> RedReqRes [ctor] .

  op redRequired : ScoreInfoSet Module Term -> RedReqRes .
  ceq redRequired($ M, M', (TL, T, TL') $ SIS, M'', T') = [true, SIS2]
   if CS := getSub(M, T, M'', T') /\
      *** Same premises
      samePremises(M, M', M'', CS) /\
      impLevels(T) == impLevels(T') /\
      T1 := applyCS(T, CS) /\
      T2 := getTerm(metaReduce(M, T)) /\
      T3 := getTerm(metaReduce(M'', T')) /\
      T2 == T3 /\
      SIS2 := if (TL == empty) and (TL' == empty)
              then SIS
              else $ M, M', (TL, TL') $ SIS
              fi .
  eq redRequired(SIS, M, T) = [false, SIS] [owise] .

  op isEquality : Term -> Bool .
  eq isEquality('_=_[T1, T2]) = true .
  eq isEquality(T) = false [owise] .

  *** Flat module
  *** Top module
  *** Goal module
  op samePremises : Module Module Module ConsSub -> Bool .
  eq samePremises(M, M', M'', CS) = samePremises(M, getEqs(M'), M'', CS) .

  op samePremises : Module EquationSet Module ConsSub -> Bool .
  ceq samePremises(M, eq T = T' [AtS] . EqS, M', CS) = exactEq(M', T1, T2) and
                                                       samePremises(M, EqS, M', CS)
   if isExec(AtS) /\
      T1 := instantiateVars(M, M', T, CS) /\
      T2 := instantiateVars(M, M', T', CS) .
  eq samePremises(M, EqS, M', CS) = true [owise] .

  op exactEq : Module Term Term -> Bool .
  ceq exactEq(M, T, T') = true
   if eq T = T' [AtS] . EqS := getEqs(M) .
  eq exactEq(M, T, T') = false [owise] .

  *** Flat module
  *** Top module
  *** Goal module
  op consistentPremises : Module Module ConsSub -> Bool .
  eq consistentPremises(M, M', CS) = consistentPremises(getEqs(M), M, M', CS) .

  op consistentPremises : EquationSet Module Module ConsSub -> Bool [memo] .
  ceq consistentPremises(eq T = T' [AtS] . EqS, M, M', CS) = (T3 =/= 'false.Bool) and
                                                             *** exactEq(M', T1, T2) and
                                                             consistentPremises(EqS, M, M', CS)
   if isExec(AtS) /\
      T1 := instantiateVars(M, M', T, CS) /\
      T2 := instantiateVars(M, M', T', CS) /\
      eqDefinedFor(M', T1) /\
      T3 := getTerm(metaReduce(M', '_=_[T1, T2])) .
  ceq consistentPremises(eq T = T' [AtS] . EqS, M, M', CS) = exactEq(M', T1, T2) and
                                                             consistentPremises(EqS, M, M', CS)
   if isExec(AtS) /\
      T1 := instantiateVars(M, M', T, CS) /\
      T2 := instantiateVars(M, M', T', CS) /\
      eqDefinedFor(M', T1) /\
      not (getTerm(metaReduce(M', '_=_[T1, T2])) :: Term) .
  eq consistentPremises(EqS, M, M', CS) = true [owise] .

  *** Flat module
  *** Top module
  *** Goal module
  op consistentPremisesEq : Module Module Module ConsSub -> Bool [memo] .
  eq consistentPremisesEq(M, M', M'', CS) = consistentPremisesEq(getEqs(M'), M, M', M'', CS) .

  op consistentPremisesEq : EquationSet Module Module Module ConsSub -> Bool .
  ceq consistentPremisesEq(eq T = T' [AtS] . EqS, M, M', M'', CS) =
                           ((T3 =/= 'false.Bool) or-else definedForOther(M'', T1, T2)) and
                           *** asd (exactEq(M'', T1, T2) or-else definedForOther(M'', T1, T2)) and
                           consistentPremisesEq(EqS, M, M', M'', CS)
   if isExec(AtS) /\
      T1 := instantiateVars(M, M'', T, CS) /\
      T2 := instantiateVars(M, M'', T', CS) /\
      eqDefinedFor(M'', T1) /\
      T3 := getTerm(metaReduce(M'', '_=_[T1, T2])) .
  ceq consistentPremisesEq(eq T = T' [AtS] . EqS, M, M', M'', CS) =
                               (exactEq(M'', T1, T2) or definedForOther(M'', T1, T2)) and
                               consistentPremisesEq(EqS, M, M', M'', CS)
   if isExec(AtS) /\
      T1 := instantiateVars(M, M'', T, CS) /\
      T2 := instantiateVars(M, M'', T', CS) /\
      eqDefinedFor(M'', T1) /\
      not (getTerm(metaReduce(M'', '_=_[T1, T2])) :: Term) .
  eq consistentPremisesEq(EqS, M, M', M'', CS) = true [owise] .

  op definedForOther : Module Term Term -> Bool .
  eq definedForOther(M, T, T') = definedForOther(M, getEqs(M), T, T') .

  op definedForOther : Module EquationSet Term Term -> Bool .
  ceq definedForOther(M, eq T = T2 [AtS] . EqS, T, T') = true
   if not isCtor(M, T') /\
      not isCtor(M, T2) /\
      T' =/= T2 .
  ceq definedForOther(M, eq '_=_[T, T1] = 'false.Bool [AtS] . EqS, T, T') = true
   if not isCtor(M, T') /\
      T1 =/= T' .
  eq definedForOther(M, EqS, T, T') = false [owise] .

  op getNameProofScore : ScoreInfoSet -> Qid .
  eq getNameProofScore($ M, M', (T, TL)$ SIS) = getNameProofScore(getImports(M')) .

  op getNameProofScore : ImportList -> Qid .
  eq getNameProofScore(including 'BOOL . IL) = getNameProofScore(IL) .
  eq getNameProofScore(protecting 'EQL . IL) = getNameProofScore(IL) .
  eq getNameProofScore(including Q . IL) = cut(Q) [owise] .

  op cut : Qid -> Qid .
  ceq cut(Q) = qid(substr(STR, 0, N))
   if STR := string(Q) /\
      N := find(STR, "-MODCAFE", 0) .
  eq cut(Q) = Q [owise] .

  op renameRepVars : Term -> Term .
  ceq renameRepVars(T) = T
   if TrS := getVars(T) /\
      moreThanOne(T, TrS) == emptyTermSet .
  ceq renameRepVars(T) = renameRepVars(oneSub(T, V, V'))
   if TrS := getVars(T) /\
      V := moreThanOne(T, TrS) /\
      V' := newVar(V, TrS, 0) .

  op renameRepVars* : TermList -> TermList .
  eq renameRepVars*(empty) = empty .
  eq renameRepVars*((T, TL)) = renameRepVars(T), renameRepVars*(TL) .

  op oneSub : Term Variable Variable -> Term .
  eq oneSub(Q[TL], V, V') = Q[oneSub*(TL, V, V')] .
  eq oneSub(V, V, V') = V' .
  eq oneSub(T, V, V') = T [owise] .

  op oneSub* : TermList Variable Variable -> TermList .
  eq oneSub*(empty, V, V') = empty .
  eq oneSub*((TL, T), V, V') = if oneSub(T, V, V') == T
                               then oneSub*(TL, V, V'), T
                               else TL, oneSub(T, V, V')
                               fi .

  op newVar : Variable TermSet Nat -> Variable .
  ceq newVar(V, V' | TrS, N) = newVar(V, TrS, s(N))
   if V' := qid(string(getName(V)) + string(N, 10) + ":" + string(getType(V))) .
  ceq newVar(V, TrS, N) = V'
   if V' := qid(string(getName(V)) + string(N, 10) + ":" + string(getType(V))) [owise] .

  op moreThanOne : Term TermSet -> TermSet .
  ceq moreThanOne(T, V | TrS) = V
   if numReps(T, V) =/= 1 .
  eq moreThanOne(T, TrS) = emptyTermSet [owise] .

  op numReps : Term Variable -> Nat .
  eq numReps(C, V) = 0 .
  eq numReps(V, V') = if getName(V) == getName(V')
                      then 1
                      else 0
                      fi .
  eq numReps(Q[TL], V) = numReps*(TL, V) .

  op numReps* : TermList Variable -> Nat .
  eq numReps*(empty, V) = 0 .
  eq numReps*((T, TL), V) = numReps(T, V) + numReps*(TL, V) .

  op inferGoal : ScoreInfoSet ~> TermList .
  ceq inferGoal($ M, M', (T, TL)$ SIS) = TL2
   if TL' := TL, completeTermList(SIS) /\
      TL1 := inferGoal(M, (T, TL')) /\
      TL2 := renameRepVars*(TL1) .

  sort InferenceResult .
  op [_,_] : Term TermList -> InferenceResult [ctor] .

  op inferGoal : Module TermList -> TermList .
  ceq inferGoal(M, (T, TL)) = T1, TL'
   if [T1, TL1] := $inferGoal(M, T, TL, empty) /\
      TL' := inferGoal(M, TL1) .
  eq inferGoal(M, empty) = empty .

  op $inferGoal : Module Term TermList TermList ~> InferenceResult .
  eq $inferGoal(M, T, empty, TL') = [T, TL'] .
  ceq $inferGoal(M, T, (T', TL), TL') = $inferGoal(M, T'', TL, TL')
   if T'' := unifyGoal(M, T, T') .
  eq $inferGoal(M, T, (T', TL), TL') = $inferGoal(M, T, TL, (TL', T')) [owise] .

  op unifyGoal : Module Term Term ~> Term .
  eq unifyGoal(M, V, V') = V .
  eq unifyGoal(M, V, C) = V .
  ceq unifyGoal(M, C, C') = V
   if not isCtor(M, C) /\
      not isCtor(M, C') /\
      Ty := getType(C) /\
      sameKind(M, Ty, getType(C')) /\
      V := qid(substr(string(Ty), 0, 1) + ":" + string(Ty)) .
  ceq unifyGoal(M, Q[TL], Q[TL']) = Q[TL'']
   if TL'' := unifyGoal*(M, TL, TL') .
  eq unifyGoal(M, '_implies_[T, T'], T'') = unifyGoal(M, T', T'') .
  eq unifyGoal(M, T, '_implies_[T', T'']) = unifyGoal(M, T, T'') .
  ceq unifyGoal(M, T, T') = V
   if isCtor(M, T) /\
      isCtor(M, T') /\
      Ty := getType(metaReduce(M, T)) /\
      V := qid(substr(string(Ty), 0, 1) + ":" + string(Ty)) [owise] .

  op unifyGoal* : Module TermList TermList ~> TermList .
  eq unifyGoal*(M, empty, empty) = empty .
  eq unifyGoal*(M, (T, TL), (T', TL')) = unifyGoal(M, T, T'), unifyGoal*(M, TL, TL') .

  op printProof : Module Qid Qid TermList QidList -> QidList .
  eq printProof(M, Q, Q', TL, QIL) =
          '\n 'open Q' '. '\n
          '\t ':goal '`{ '\n
          printGoals(M, TL, Q, 0)
          '\t '`} '\n '\n
          QIL '\n
          'close .

  op printGoals : Module TermList Qid Nat -> QidList .
  eq printGoals(M, empty, Q, N) = nil .
  ceq printGoals(M, (T, TL), Q, N) =
          '\t '\t 'eq ' '`[ Q' ':nonexec '`] ' ':
                                 metaPrettyPrint(M, T, po) ' '= 'true '. '\n
          printGoals(M, TL, Q, s(N))
   if Q' := if N == 0
            then Q
            else qid(string(Q) + string(N, 10))
            fi .

  op printSub : Substitution -> QidList .
  eq printSub(none) = nil .
  eq printSub(V <- C ; SB) = V '<- getName(C) ';  printSub(SB) .
  eq printSub(V <- Q[TL] ; SB) = V '<- Q '`( printSub*(TL) '`) ';  printSub(SB) .

  op printSub* : TermList -> QidList .
  eq printSub*(empty) = nil .
  eq printSub*(C) = getName(C) .
  eq printSub*((C, T, TL)) = getName(C) '`, printSub*((T, TL)) .
  eq printSub*(Q[TL]) = Q '`( printSub*(TL) '`) .
  eq printSub*((Q[TL], T, TL')) = Q '`( printSub*(TL) '`) '`, printSub*((T, TL')) .
  eq printSub*((V, TL)) = printSub*(TL) .

  *** When inferring goal it is possible that fresh constants appear. In this case
  *** we need to add them or turn them into variables.

  sort SISPair .
  op [_,_] : ScoreInfoSet ScoreInfoSet -> SISPair [ctor] .

  ops fst snd : SISPair -> ScoreInfoSet .
  eq fst([SIS1, SIS2]) = SIS1 .
  eq snd([SIS1, SIS2]) = SIS2 .

  op divideByExecEqs : ScoreInfoSet Nat -> SISPair .
  eq divideByExecEqs(SIS, N) = $divideByExecEqs(SIS, N, [noScoreInfo, noScoreInfo]) .

  op $divideByExecEqs : ScoreInfoSet Nat SISPair -> SISPair .
  eq $divideByExecEqs(noScoreInfo, N, SISP) = SISP .
  eq $divideByExecEqs($ M, M', TL $ SIS, N, [SIS1, SIS2]) =
       if numExecEqs(M') == 0
       then $divideByExecEqs(SIS, N, [SIS1, SIS2])
       else if numExecEqs(M') == N
            then $divideByExecEqs(SIS, N, [$ M, M', TL $ SIS1, SIS2])
            else $divideByExecEqs(SIS, N, [SIS1, $ M, M', TL $ SIS2])
            fi
       fi .

  op numExecEqs : Module -> Nat .
  eq numExecEqs(M) = numExecEqs(getEqs(M)) .

  op numExecEqs : EquationSet -> Nat .
  ceq numExecEqs(eq T = T' [AtS] . EqS) = s(numExecEqs(EqS))
   if isExec(AtS) .
  ceq numExecEqs(ceq T = T' if COND [AtS] . EqS) = s(numExecEqs(EqS))
   if isExec(AtS) .
  eq numExecEqs(EqS) = 0 [owise] .

  ***********************************************************************************
  ***                             AUXILIARY FUNCTIONS                             ***
  ***                                 hasVars                                     ***
  ***********************************************************************************

  op hasVars : Term -> Bool [memo] .
  eq hasVars(Q[TL]) = hasVars*(TL) .
  eq hasVars(V) = true .
  eq hasVars(C) = false .

  op hasVars* : TermList -> Bool .
  eq hasVars*(empty) = false .
  eq hasVars*((T, TL)) = hasVars(T) or-else hasVars*(TL) .

  ***********************************************************************************
  ***                             AUXILIARY FUNCTIONS                             ***
  ***                            Case splitting: cvss                             ***
  ***********************************************************************************

  op subsortSingleBinaryOpConstraints : Module Term -> Bool .
  ceq subsortSingleBinaryOpConstraints(M, T) = subsortSingleBinaryOpConstraints(M, Ty)
   if Ty := getType(metaReduce(M, T)) .

  op subsortSingleBinaryOpConstraints : Module Type -> Bool .
  eq subsortSingleBinaryOpConstraints(M, Ty) = hasSingleBinaryCtor(getOps(M), Ty) and
                                               hasSubsort(getSubsorts(M), Ty) .

  op hasSingleBinaryCtor : OpDeclSet Type -> Bool .
  eq hasSingleBinaryCtor(op Q : Ty1 Ty2 -> Ty [ctor assoc AtS] . ODS, Ty) = hasNoOther(ODS, Ty) .
  eq hasSingleBinaryCtor(ODS, Ty) = false [owise] .

  op hasNoOther : OpDeclSet Type -> Bool .
  eq hasNoOther(op Q : TyL -> Ty [ctor AtS] . ODS, Ty) = false .
  eq hasNoOther(ODS, Ty) = true [owise] .

  op hasSubsort : SubsortDeclSet Type -> Bool .
  eq hasSubsort(subsort Ty1 < Ty . SSDS, Ty) = true .
  eq hasSubsort(SSDS, Ty) = false [owise] .


  ***********************************************************************************
  ***                             AUXILIARY FUNCTIONS                             ***
  ***                            Case splitting: cvs                              ***
  ***********************************************************************************

  op subsortUnaryBinaryOpConstraints : Module Term -> Bool .
  ceq subsortUnaryBinaryOpConstraints(M, T) = subsortUnaryBinaryOpConstraints(M, Ty)
   if Ty := getType(metaReduce(M, T)) .

  op subsortUnaryBinaryOpConstraints : Module Type -> Bool .
  eq subsortUnaryBinaryOpConstraints(M, Ty) = hasBinaryCtor(getOps(M), Ty) and
                                              *** hasUnaryCtor(getOps(M), Ty) and
                                              hasSubsort(getSubsorts(M), Ty) .

  op hasBinaryCtor : OpDeclSet Type -> Bool .
  eq hasBinaryCtor(op Q : Ty1 Ty2 -> Ty [ctor assoc AtS] . ODS, Ty) = true .
  eq hasBinaryCtor(ODS, Ty) = false [owise] .

  op hasUnaryCtor : OpDeclSet Type -> Bool .
  eq hasUnaryCtor(op Q : nil -> Ty [ctor AtS] . ODS, Ty) = true .
  eq hasUnaryCtor(ODS, Ty) = false [owise] .

  ***********************************************************************************
  ***                             AUXILIARY FUNCTIONS                             ***
  ***                                   getIndVar                                 ***
  ***********************************************************************************

  *** Variables
  *** Reduced term
  op getIndVar : Term TermSet ScoreInfoSet -> TermList .
  eq getIndVar(T, emptyTermSet, SIS) = empty .
  ceq getIndVar(T, (V | TrS), SIS) = V
   if isIndVar(T, V, SIS) .
  ceq getIndVar(T, (V | TrS), SIS) = getIndVar(T, TrS, SIS)
   if not isIndVar(T, V, SIS) .

  op isIndVar : Term Variable ScoreInfoSet -> Bool .
  eq isIndVar(T, V, noScoreInfo) = true .
  eq isIndVar(T, V, $ M, M', empty $ SIS) = isIndVar(T, V, SIS) .
  ceq isIndVar(T, V, $ M, M', (T', TL) $ SIS) = isIndVar(T, V, $ M, M', TL $ SIS)
   if T'' := getMatch(T, T', V) /\
      isCtor(M, T'') .
  *** In this case we have several goals and the current reduction is not related
  *** to the current goal.
  ceq isIndVar(T, V, $ M, M', (T', TL) $ SIS) = isIndVar(T, V, $ M, M', TL $ SIS)
   if getMatch(T, T', V) == empty .
  eq isIndVar(T, V, SIS) = false [owise] .

  op getMatch : Term Term Variable -> TermList .
  eq getMatch(V, T, V) = T .
  eq getMatch(Q[TL], Q[TL'], V) = getMatch*(TL, TL', V) .
  eq getMatch(T, '_implies_[T1, T2], V) = getMatch(T, T2, V) .
  eq getMatch('_implies_[T1, T2], T, V) = getMatch(T2, T, V) .
  eq getMatch(T, T', V) = empty [owise] .

  op getMatch* : TermList TermList Variable ~> TermList .
  eq getMatch*((T, TL), (T', TL'), V) = getMatch(T, T', V), getMatch*(TL, TL', V) .
  eq getMatch*(TL, TL', V) = empty [owise] .

  ***********************************************************************************
  ******************************* AUXILIARY FUNCTIONS *******************************
  ************************************* isCtor **************************************
  ***********************************************************************************

  *** This function checks whether the outer operator is a constructor while the rest
  *** of the arguments are fresh constants.
  *** In the case of constants it is enough for it to be a constructor.

  op isCtor : Module Term -> Bool .
  eq isCtor(M, T) = isCtor(getOps(M), T) .

  op isCtor : OpDeclSet Term -> Bool .
  eq isCtor(ODS, V) = true .
  ceq isCtor(op Q : nil -> Ty [ctor AtS] . ODS, C) = true
   if Q := getName(C) .
  eq isCtor(op Q : TyL -> Ty [ctor AtS] . ODS, Q[TL]) =
            allNonCtorConstants(op Q : TyL -> Ty [ctor AtS] . ODS, TL) .
  eq isCtor(ODS, T) = false [owise] .

  op allNonCtorConstants : OpDeclSet TermList -> Bool .
  eq allNonCtorConstants(ODS, empty) = true .
  eq allNonCtorConstants(ODS, (T, TL)) = nonCtorConstant(ODS, T) and
                                         allNonCtorConstants(ODS, TL) .

  op nonCtorConstant : OpDeclSet Term -> Bool .
  eq nonCtorConstant(ODS, V) = false .
  eq nonCtorConstant(ODS, Q[TL]) = false .
  ceq nonCtorConstant(op Q : nil -> Ty [ctor AtS] . ODS, C) = false
   if Q := getName(C) .
  eq nonCtorConstant(ODS, C) = true [owise] .

  ***********************************************************************************
  ******************************* AUXILIARY FUNCTIONS *******************************
  ********************************** EXTRACTS VARS **********************************
  ***********************************************************************************

  op getVars : Term -> TermSet .
  eq getVars(C) = emptyTermSet .
  eq getVars(V) = V .
  eq getVars(Q[TL]) = getVars*(TL) .

  op getVars* : TermList -> TermSet .
  eq getVars*(empty) = emptyTermSet .
  eq getVars*((T, TL)) = getVars(T) | getVars*(TL) .

  ***********************************************************************************
  ******************************* AUXILIARY FUNCTIONS *******************************
  ******************************** PRINT CTF COMMAND ********************************
  ***********************************************************************************

  op printCtfComm : Module Qid Equation -> QidList .
  eq printCtfComm(M, Q, eq T = T' [AtS] .) = '\t ':def Q '= ':ctf ' '`{ 'eq
                                             metaPrettyPrint(M, T, po) ' '=
                                             metaPrettyPrint(M, T', po) '. '`} '\n '\n
                                             '\t ':apply '`( Q '`) '\n '\n .

  op printCtfTermComm : Module Qid Term -> QidList .
  eq printCtfTermComm(M, Q, T) = '\t ':def Q '= ':ctf ' '`[
                                 metaPrettyPrint(M, T, po) ' '. '`] '\n '\n
                                 '\t ':apply '`( Q '`) '\n '\n .

  op printCtfComm : Module Qid Equation Nat -> QidList .
  eq printCtfComm(M, Q, eq T = T' [AtS] ., INDENT) =
                                 indent(INDENT) ':def Q '= ':ctf ' '`{ 'eq
                                 metaPrettyPrint(M, T, po) ' '=
                                 metaPrettyPrint(M, T', po) '. '`} '\n '\n
                                 indent(INDENT) ':apply '`( Q '`) '\n '\n .

  op printCtfTermComm : Module Qid Term Nat -> QidList .
  eq printCtfTermComm(M, Q, T, INDENT) =
                                 indent(INDENT) ':def Q '= ':ctf ' '`[
                                 metaPrettyPrint(M, T, po) ' '. '`] '\n '\n
                                 indent(INDENT) ':apply '`( Q '`) '\n '\n .

  op printCEVS : Module Qid Term -> QidList .
  eq printCEVS(M, Q, T) = '\t ':def Q '= ':cvs ' '`[
                          metaPrettyPrint(M, T, po) ' '. '`] '\n '\n
                          '\t ':apply '`( Q '`) '\n '\n .

  op printCESV : Module Qid Term -> QidList .
  eq printCESV(M, Q, T) = '\t ':def Q '= ':csv ' '`[
                          metaPrettyPrint(M, T, po) ' '. '`] '\n '\n
                          '\t ':apply '`( Q '`) '\n '\n .

  ***********************************************************************************
  ******************************* AUXILIARY FUNCTIONS *******************************
  ********************************** ADD NEW MACRO **********************************
  ***********************************************************************************

  sort NewMacPair .
  op |_,_| : Macros Qid -> NewMacPair [ctor] .

  op addNewMac : Macros Module Equation -> NewMacPair .
  eq addNewMac(MACS, M, Eq) = addNewMac(MACS, M, Eq, 1) .

  op addNewMac : Macros Module Equation Nat -> NewMacPair .
  ceq addNewMac(# M, Q - Eq # MACS, M', Eq', N) = addNewMac(# M, Q - Eq # MACS, M', Eq', s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(# M, Q - T # MACS, M', Eq', N) = addNewMac(# M, Q - T # MACS, M', Eq', s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(# M, Q - T . MLb # MACS, M', Eq', N) = addNewMac(# M, Q - T . MLb # MACS, M', Eq', s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(MACS, M, Eq, N) = | # M, Q - Eq # MACS, Q |
   if Q := qid("csb" + string(N, 10)) [owise] .

  op addNewMac : Macros Module Term -> NewMacPair .
  eq addNewMac(MACS, M, T) = addNewMac(MACS, M, T, 1) .

  op addNewMac : Macros Module Term Nat -> NewMacPair .
  ceq addNewMac(# M, Q - Eq # MACS, M', T, N) = addNewMac(# M, Q - Eq # MACS, M', T, s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(# M, Q - T # MACS, M', T', N) = addNewMac(# M, Q - T # MACS, M', T', s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(# M, Q - T . MLb # MACS, M', T', N) = addNewMac(# M, Q - T . MLb # MACS, M', T', s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(MACS, M, T, N) = | # M, Q - T # MACS, Q |
   if Q := qid("csb" + string(N, 10)) [owise] .

  op addNewMac : Macros Module Term MacroLabel -> NewMacPair .
  eq addNewMac(MACS, M, T, MLb) = addNewMac(MACS, M, T, MLb, 1) .

  op addNewMac : Macros Module Term MacroLabel Nat -> NewMacPair .
  ceq addNewMac(# M, Q - Eq # MACS, M', T, MLb, N) = addNewMac(# M, Q - Eq # MACS, M', T, MLb, s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(# M, Q - T # MACS, M', T', MLb, N) = addNewMac(# M, Q - T # MACS, M', T', MLb, s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(# M, Q - T . MLb # MACS, M', T', MLb', N) =
                                        addNewMac(# M, Q - T . MLb # MACS, M', T', MLb', s(N))
   if Q := qid("csb" + string(N, 10)) .
  ceq addNewMac(MACS, M, T, MLb, N) = | # M, Q - T . MLb # MACS, Q |
   if Q := qid("csb" + string(N, 10)) [owise] .

  ************************************************************************************
  ******************************* AUXILIARY FUNCTIONS ********************************
  ****************************** CONSTANT SUBSTITUTIONS ******************************
  ************************************************************************************

  sort ConsSub .
  op mtCS : -> ConsSub [ctor] .
  op _to_ : Constant Constant -> ConsSub [ctor] .
  op __ : ConsSub ConsSub -> ConsSub [ctor assoc comm id: mtCS] .

  *** Module for reduction
  *** Term in reduction
  *** Module for the goal
  *** Goal
  op getSub : Module Term Module Term ~> ConsSub .
  ceq getSub(M, Q[TL], M', Q[TL']) = getSub*(M, TL, M', TL')
   if Q =/= '_implies_ .
  eq getSub(M, V, M', V') = mtCS .
  eq getSub(M, C, M', C) = mtCS .
  ceq getSub(M, C, M', C') = C to C'
   if C =/= C' /\
      not isCtor(M, C) /\
      not isCtor(M', C') .
  eq getSub(M, '_implies_[T, T'], M', T'') = getSub(M, T', M', T'') .
  eq getSub(M, T, M', '_implies_[T', T'']) = getSub(M, T, M', T'') .

  op getSub* : Module TermList Module TermList ~> ConsSub .
  eq getSub*(M, empty, M', empty) = mtCS .
  eq getSub*(M, (T, TL), M', (T', TL')) = getSub(M, T, M', T')
                                          getSub*(M, TL, M', TL') .

  op applyCS : Term ConsSub -> Term .
  eq applyCS(Q[TL], CS) = Q[applyCS*(TL, CS)] .
  eq applyCS(V, CS) = V .
  eq applyCS(C, (C to C') CS) = C' .
  eq applyCS(C, CS) = C [owise] .

  op applyCS* : TermList ConsSub -> TermList .
  eq applyCS*(empty, CS) = empty .
  eq applyCS*((T, TL), CS) = applyCS(T, CS), applyCS*(TL, CS) .

  ************************************************************************************
  ******************************* AUXILIARY FUNCTIONS ********************************
  ************************************************************************************

  op parseModule4Vars : TermList -> OpDeclSet .
  eq parseModule4Vars(empty) = none .
  eq parseModule4Vars('__[TL]) = parseModule4Vars(TL) .
  eq parseModule4Vars(('var_:_.[T , T'], TL)) = parseVars('var_:_.[T , T'])
                                                parseModule4Vars(TL) .
  eq parseModule4Vars(('vars_:_.[T , T'], TL)) = parseVars('vars_:_.[T , T'])
                                                 parseModule4Vars(TL) .
  eq parseModule4Vars((T, TL)) = parseModule4Vars(TL) [owise] .

  op parseVars : Term -> OpDeclSet .
  ceq parseVars('var_:_.['neCafeTokenList['__[TL]], 'CafeToken[T]]) =
                                                           parseVars*(TL, Srt)
   if Srt := downQid(T) .
  ceq parseVars('vars_:_.['neCafeTokenList['__[TL]], 'CafeToken[T]]) =
                                                           parseVars*(TL, Srt)
   if Srt := downQid(T) .
  ceq parseVars('var_:_.['neCafeTokenList[T], 'CafeToken[T']]) =
                                                           op Q : nil -> Srt [none] .
   if Q := downQid(T) /\
      Srt := downQid(T') .
  ceq parseVars('var_:_.['neCafeTokenList[T], 'CafeToken[T']]) =
                                                           op Q : nil -> Srt [none] .
   if Q := downQid(T) /\
      Srt := downQid(T') .

  op parseVars* : TermList Sort -> OpDeclSet .
  eq parseVars*(empty, Srt) = none .
  eq parseVars*((T, TL), Srt) = op downQid(T) : nil -> Srt [none] .
                                parseVars*(TL, Srt) .

  op printRedRes : Module Term Term Type -> QidList .
  eq printRedRes(M, T, T', Ty) = '\n 'reduce metaPrettyPrint(M, T, po) '. '\n
                                 '\g '\! 'Result: '\o metaPrettyPrint(M, T', po) ': Ty
                                 '\n .

  op getHypotheses : Module -> TermList [memo] .
  eq getHypotheses(M) = getHypotheses(getEqs(M)) .

  op getHypotheses : EquationSet -> TermList .
  eq getHypotheses(eq T = 'true.Bool [metadata("HI") AtS] . EqS) = T, getHypotheses(EqS) .
  eq getHypotheses(EqS) = empty [owise] .

***(%
\end{comment}
}
{\codesize
\begin{verbatim}
%)

endfm
