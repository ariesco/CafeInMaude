***(

    This file is part of the Maude 2 interpreter.

    Copyright 1997-2019 SRI International, Menlo Park, CA 94025, USA.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

)

----                                                     To be run on Maude 3.0
----                                                    author: Francisco Duran
----                           printSyntaxError functionality by Peter Olveczky
----                                       narrowing search by Santiago Escobar

set show loop stats off .
set show loop timing off .
----set show advisories off .

fmod FM-BANNER is
  pr STRING .
  op banner : -> String .
  eq banner = "Full Maude 3.0 Dec 17 2019" .
endfm

---- Latest changes and bugs fixed:
----
---- - Sept 2019
----   - Removed preregularity warnings on operator getName
----   - Removed constructor consistency warning on operator _{_}
----   - Bug in the parsing of bubbles fixed. It was in FM since the change of
----     the parser in alpha 119. Bubbles in eqs/rls/mbs cannot contain
----     operators op, ops, sorts, subsort, subsorts, class, classes, subclass,
----     subclasses, eq, eqs, rl, rls, mb or mbs.
----   - The behavior of parameterized modules and views has been adapted to the
----     one available in core Maude since alpha 121.
---- - Jan 24, 2019
----   - Add vu-narrow and fvu-narrow commands and leave search_~>_ for
----     experimentation
----
---- Things to come:
----
---- - Commands missing:
----   - continue .
----   - show search graph .
----   - show path <number> .
----   - show path labels <number> .
----   - show components .
---- - On parameterized theories and views: linked parameters, composed and
----   lifted views, and default views.
---- - ops names in op declarations
---- - FM modules cannot include eqs/rls/mbs using operators including tokens
----   eq, eqs, rl, rls, op, ops, mb, mbs, sorts, subsorts, class, subclass, ...
----   Bubble parsing gets into ambiguous parsing very easily, the only way
----   to parse modules wa to rule out these tokens. The only alternative would
----   be to discard parses after non-parsable bubbles, but it would be very
----   expensive, if at all possible.
----
---- Known bugs:
----
---- - error messages could be given in down commands
---- - Check: perhaps we need to convert constants back into vbles in
----   procViewAux
---- - Parameterized sorts don't work in sort constraints (nor by themselves,
----   nor in the conditions of axioms. They are accepted in their equivalent
----   single token form but do not get instantiated
----     cmb (A, B) S : PFun(X, Y) if not(A in dom(S)) /\ S : PFun`(X`,Y`) .

set include BOOL off .
set include TRUTH-VALUE on .
set show advisories off .

mod FM-CONFIGURATION is
  sorts Attribute AttributeSet .
  subsort Attribute < AttributeSet .
  op none : -> AttributeSet  [ctor] .
  op _,_ : AttributeSet AttributeSet -> AttributeSet
    [ctor assoc comm id: none] .

  sorts Oid Cid Object Msg Portal Configuration .
  subsort Object Msg Portal < Configuration .
  op <_:_|_> : Oid Cid AttributeSet -> Object [ctor object] .
  op none : -> Configuration [ctor] .
  op __ : Configuration Configuration -> Configuration
    [ctor config assoc comm id: none] .
  op <> : -> Portal [ctor] .
endm

mod CONFIGURATION+ is
  including FM-CONFIGURATION .
  op <_:_|`> : Oid Cid -> Object .
  op getClass : Object -> Cid .
  ---- eq < O:Oid : C:Cid | > = < O:Oid : C:Cid | none > .
  eq getClass(< O:Oid : C:Cid | A:AttributeSet >) = C:Cid .
endm

set include BOOL on .
set include TRUTH-VALUE off .

*******************************************************************************
*******************************************************************************
***
*** Narrowing and Equational Unification
*** by Santiago Escobar
***
fmod FM-META-LEVEL-MNPA is
  pr META-LEVEL * (op `{_`,_`} : Term Nat -> SmtResult to `{_`,_`}Smt )  .
endfm

fmod FM-UNIFICATIONTRIPLE is
  protecting FM-META-LEVEL-MNPA .
  protecting INT .

  --- UnificationPair --------------------------------------------
  ---sorts UnificationPair UnificationPair? .
  ---op {_,_} : Substitution Nat -> UnificationPair [ctor] .
  ---subsort UnificationPair < UnificationPair? .
  ---op noUnifier : -> UnificationPair? [ctor] .

  op getSubst : UnificationPair -> Substitution .
  eq getSubst({S1:Substitution, N:Nat}) = S1:Substitution .
  op getNextVar : UnificationPair -> Nat .
  eq getNextVar({S1:Substitution, N:Nat}) = N:Nat .

  --- UnificationTriple --------------------------------------------
  ---sorts UnificationTriple UnificationTriple? .
  ---op {_,_,_} : Substitution Substitution Nat -> UnificationTriple [ctor] .
  ---subsort UnificationTriple < UnificationTriple? .
  ---op noUnifier : -> UnificationTriple? [ctor] .

  op getLSubst : UnificationTriple -> Substitution .
  eq getLSubst({S1:Substitution, S2:Substitution, N:Nat}) = S1:Substitution .
  op getRSubst : UnificationTriple -> Substitution .
  eq getRSubst({S1:Substitution, S2:Substitution, N:Nat}) = S2:Substitution .
  op getNextVar : UnificationTriple -> Nat .
  eq getNextVar({S1:Substitution, S2:Substitution, N:Nat}) = N:Nat .

endfm

fmod FM-TERM-HANDLING is
  protecting META-TERM .
  protecting FM-META-LEVEL-MNPA .
  protecting EXT-BOOL .

  var T T' T'' : Term .
  var C C' : Constant .
  var QIL : QidList .
  var N N' : Nat .
  var NL NL' : NatList .
  var Q F F' : Qid .
  var AtS : AttrSet .
  var EqS : EquationSet .
  var Eq : Equation .
  var Cond : Condition .
  var TP : Type .
  var TPL TPL' : TypeList .
  var TL TL' TL'' : TermList .
  var B : Bool .
  var V V' : Variable .
  var Ct : Context .
  var CtL : NeCTermList .
  var NeTL : NeTermList .
  var M : Module .

  *** root  ******************************
  op root : Term -> Qid .
  eq root(V) = V .
  eq root(C) = C .
  eq root(F[TL]) = F .

  *** size  ******************************
  op size : TermList -> Nat .
  eq size(empty) = 0 .
  eq size((T,TL)) = s(size(TL)) .

  *** elem_of_ *****************************************************
  op elem_of_ : Nat TermList ~> Term .
  eq elem 1 of (T,TL) = T .
  eq elem s(s(N)) of (T,TL) = elem s(N) of TL .

  *** subTerm_of_ *****************************************************
  op subTerm_of_ : NatList Term ~> Term .
  eq subTerm NL of T = subTerm* NL of T  .

  op subTerm*_of_ : NatList Term ~> Term .
  eq subTerm* nil of T = T .
  eq subTerm* N NL of (F[TL]) = subTerm* NL of (elem N of TL) .

  *** ToDo: UPGRADE THIS NOTION TO MODULO AC *********************
  *** is_subTermOf_ *****************************************************
  op is_subTermOf_ : Term TermList -> Bool .
  eq is T subTermOf (T',NeTL) = is T subTermOf T'
                                or-else is T subTermOf NeTL .
  eq is T subTermOf T = true .
  eq is T subTermOf T' = is T subTermOf* T' [owise] .

  op is_subTermOf*_ : Term TermList -> Bool .
  eq is T subTermOf* (F[TL]) = is T subTermOf TL .
  eq is T subTermOf* T' = false [owise] .

  *** noVarOfSort_In_ *****************************************************
  op noVarOfSort_In_ : Type TermList -> Bool .
  eq noVarOfSort T:Type In V = getType(V) =/= T:Type .
  eq noVarOfSort T:Type In (F[TL]) = noVarOfSort T:Type In TL .
  eq noVarOfSort T:Type In (T',NeTL)
   = noVarOfSort T:Type In T' and noVarOfSort T:Type In NeTL .
  eq noVarOfSort T:Type In X:TermList = true [owise] .

  *** findSubTermOf_In_ ***********************************************
  op findSubTermOf_In_ : NeCTermList TermList ~> Term .
  eq findSubTermOf (TL, [], TL') In (TL, T, TL') = T .
  eq findSubTermOf (TL, F[CtL], TL'') In (TL, F[TL'], TL'')
   = findSubTermOf CtL In TL' .

  *** replaceElem_of_by_ ****************************************************
  op replaceElem_of_by_ : Nat TermList Term ~> TermList .
  eq replaceElem 1 of (T,TL) by T' = (T',TL) .
  eq replaceElem s(s(N)) of (T,TL) by T' = (T,replaceElem s(N) of TL by T') .

  *** replaceSubTerm_of_by_ *************************************************
  op replaceSubTerm_of_by_ : NatList TermList Term ~> TermList .
  eq replaceSubTerm nil of T by T' = T' .
  eq replaceSubTerm N NL of (F[TL]) by T'
   = F[replaceSubTermL N NL of TL by T'] .

  op replaceSubTermL_of_by_ : NatList TermList Term ~> TermList .
  eq replaceSubTermL 1 NL of (T,TL) by T'
   = (replaceSubTerm NL of T by T', TL) .
  eq replaceSubTermL s(s(N)) NL of (T,TL) by T'
   = (T,replaceSubTermL s(N) NL of TL by T') .

  op replaceTerm_by_in_ : Term Term TermList ~> TermList .
  eq replaceTerm T by T' in T = T' .
  eq replaceTerm T by T' in (F[TL]) = F[replaceTerm T by T' in TL] .
  eq replaceTerm T by T' in T'' = T'' [owise] .
  eq replaceTerm T by T' in (T'',NeTL)
   = (replaceTerm T by T' in T'',replaceTerm T by T' in NeTL) .

  *** context replacement **************************************************

  op _[_] : Context Context -> Context .
  op _[_] : NeCTermList Context -> NeCTermList .
  eq [] [ Ct ] = Ct .
  eq (F[CtL])[ Ct ] = F[ CtL [ Ct ] ] .
  eq (CtL,NeTL) [Ct] = (CtL [Ct] ), NeTL .
  eq (NeTL,CtL) [Ct] = NeTL, (CtL [Ct] ) .

  op _[_] : Context Term -> Term .
  op _[_] : NeCTermList Term -> TermList .
  eq [] [ T ] = T .
  eq (F[CtL])[ T ] = F[ CtL [ T ] ] .
  eq (CtL,NeTL) [T] = (CtL [T] ), NeTL .
  eq (NeTL,CtL) [T] = NeTL, (CtL [T] ) .

  *** is_substring_ *****************************************
  op is_substring_ : Qid Qid -> Bool [memo] .
  eq is F:Qid substring F':Qid
   = rfind(string(F':Qid), string(F:Qid), length(string(F':Qid))) =/= notFound .

  *** addprefix_To_ addsufix_To_ *****************************************
  op addprefix_To_ : Qid Variable -> Variable [memo] .
  eq addprefix Q To V
   = qid(string(Q) + string(getName(V)) + ":" + string(getType(V))) .

  op addprefix_To_ : Qid Constant -> Constant [ditto] .
  eq addprefix Q To F
   = if noUnderBar(F) and getName(F) :: Qid then
       if getType(F) :: Type then
         qid(string(Q) + string(getName(F)) + "." + string(getType(F)))
       else
         qid(string(Q) + string(getName(F)))
       fi
     else
       qid(string(Q) + string(F))
     fi .

  op addsufix_To_ : Qid Variable -> Variable [memo] .
  eq addsufix Q To V
   = qid(string(getName(V)) + string(Q) + ":" + string(getType(V))) .

  op addsufix_To_ : Qid Constant -> Constant [ditto] .
  eq addsufix Q To F
   = if noUnderBar(F) and getName(F) :: Qid then
       if getType(F) :: Type then
         qid(string(getName(F)) + string(Q) + "." + string(getType(F)))
       else
         qid(string(getName(F)) + string(Q))
       fi
     else
       qid(string(F) + string(Q))
     fi .

  op addType_ToVar_ : Type Qid -> Variable [memo] .
  eq addType TP:Qid ToVar V:Qid
   = qid(string(V:Qid) + ":" + string(TP:Qid)) .

  *** noUnderBar (auxiliary) ****************************
  op noUnderBar : Qid -> Bool .
  eq noUnderBar(F)
   = rfind(string(F), "_", length(string(F))) == notFound .

  *** addType  ******************************
  op addType : Qid Type -> Qid .
  eq addType(F,TP)
   = if noUnderBar(F) and getName(F) :: Qid then
       qid( string(getName(F)) + "." + string(TP) )
     else
       qid( string(F) + "." + string(TP) )
     fi .

  *** addTypeVar  ******************************
  op addTypeVar : Qid Type -> Qid .
  eq addTypeVar(F,TP)
   = qid( string(F) + ":" + string(TP) ) .

endfm

fmod FM-SUBSTITUTION-HANDLING is
  protecting META-TERM .
  protecting FM-META-LEVEL-MNPA .
  protecting FM-TERM-HANDLING .

  var S S' Subst Subst' : Substitution .
  var V V' : Variable .
  var C C' : Constant .
  var Ct : Context .
  var T T' T1 T2 T1' T2' T1'' T2'' : Term .
  var F F' : Qid .
  var TL TL' TL1 TL2 TL1' TL2' : TermList .
  var Att : AttrSet .
  var RLS : RuleSet .
  var Rl : Rule .
  var TP : Type .
  var N : Nat .
  var NeTL : NeTermList .
  var CtL : NeCTermList .

  --- Apply Substitution to Term --------------------------------------------
  op _<<_ : Term Substitution -> Term .
  eq TL << none = TL .
  eq C << Subst = C .
  eq V << ((V <- T) ; Subst) = T .
  eq V << Subst = V [owise] .
  eq F[TL] << Subst = F[TL << Subst] .

  op _<<_ : TermList Substitution -> TermList .
  eq (T, NeTL) << Subst = (T << Subst, NeTL << Subst) .
  eq empty << Subst = empty .

  op _<<_ : Context Substitution -> Context .
  eq Ct << none = Ct .
  eq [] << Subst = [] .
  eq F[CtL,NeTL] << Subst = F[CtL << Subst,NeTL << Subst] .
  eq F[NeTL,CtL] << Subst = F[NeTL << Subst, CtL << Subst] .
  eq F[Ct] << Subst = F[Ct << Subst] .

  op _<<_ : Substitution Substitution -> Substitution .
  eq S << (none).Substitution = S .
  eq (none).Substitution << S = (none).Substitution .
  eq ((V' <- T) ; S') <<  S
   = (V' <- (T << S))
     ;
     (S' << S) .

  --- Combine Substitutions -------------------------------------------------
  op _.._ : Substitution Substitution -> Substitution .
  eq S .. S' = (S << S') ; S' .

  --- Restrict Assignments to Variables in a Term ----------------------
  op _|>_ : Substitution TermList -> Substitution .

  eq Subst |> TL = Subst |>* Vars(TL) .

  op _|>*_ : Substitution TermList -> Substitution .
---   eq noMatch |>* TL = noMatch .
  eq Subst |>* TL = Subst |>** TL [none] .

  op _|>**_[_] : Substitution TermList
                 Substitution -> Substitution .
  eq none |>** TL [Subst']
   = Subst' .
  eq ((V <- V) ; Subst) |>** TL [Subst']
   = Subst |>** TL [Subst'] .
  eq ((V <- T') ; Subst) |>** TL [Subst']
    = Subst |>** TL
      [Subst' ; if any V in TL then (V <- T') else none fi] .

  --- Remove Variables from list ----------------------
  op _intersect_ : TermList TermList -> TermList .
  eq (TL1,T,TL2) intersect (TL1',T,TL2')
   = (T,((TL1,TL2) intersect (TL1',TL2'))) .
  eq TL intersect TL' = empty [owise] .

  op _intersectVar_ : TermList TermList -> TermList .
  eq TL1 intersectVar TL2
   = TL1 intersectVar* Vars(TL2) .

  op _intersectVar*_ : TermList TermList -> TermList .
  eq (T,TL1) intersectVar* TL2
   = (if any Vars(T) in TL2 then T else empty fi,TL1 intersectVar* TL2) .
  eq empty intersectVar* TL2
   = empty .

  --- Remove Variables from list ----------------------
  op _setMinus_ : TermList TermList -> TermList .
  eq (TL1,T,TL2) setMinus (TL1',T,TL2')
   = (TL1,TL2) setMinus (TL1',T,TL2') .
  eq TL setMinus TL' = TL [owise] .

  --- Variables ---
  op Vars : GTermList -> TermList .
  eq Vars((T,TL:GTermList)) = VarsTerm(T),Vars(TL:GTermList) .
  eq Vars((Ct,TL:GTermList)) = VarsTerm(Ct),Vars(TL:GTermList) .
  eq Vars(empty) = empty .

  op VarsTerm : Term -> TermList . ---warning memo
  eq VarsTerm(V) = V .
  eq VarsTerm(F[TL:TermList]) = Vars(TL:TermList) .
  eq VarsTerm(C) = empty .

  op VarsTerm : Context -> TermList . ---warning memo
  eq VarsTerm(F[TL:GTermList]) = Vars(TL:GTermList) .

  --- membership ---
  op _in_ : Term TermList -> Bool .
  eq T in (TL,T,TL') = true .
  eq T in TL = false [owise] .

  --- membership ---
  op any_in_ : TermList TermList -> Bool . --- [memo] .
  eq any empty in TL = false .
  eq any (TL1,T,TL2) in (TL1',T,TL2') = true .
  eq any TL in TL' = false [owise] .

  --- membership ---
  op all_in_ : TermList TermList -> Bool . --- [memo] .
  eq all empty in TL = true .
  eq all (TL1,T,TL2) in (TL1',T,TL2') = all (TL1,TL2) in (TL1',T,TL2') .
  eq all TL in TL' = false [owise] .

  --- Occur check ---
  op allVars_inVars_ : GTermList GTermList -> Bool .
  eq allVars TL:GTermList inVars TL':GTermList
   = all Vars(TL:GTermList) in Vars(TL':GTermList) .

  op anyVars_inVars_ : GTermList GTermList -> Bool .
  eq anyVars TL:GTermList inVars TL':GTermList
   = any Vars(TL:GTermList) in Vars(TL':GTermList) .

  op rangeVars : Substitution -> TermList .
  eq rangeVars(V <- T ; Subst) = (Vars(T),rangeVars(Subst)) .
  eq rangeVars(none) = empty .

  op dom_inVars_ : Substitution TermList -> Bool .
  eq dom Subst inVars TL = dom Subst in Vars(TL) .

  op dom_in_ : Substitution TermList -> Bool .
  eq dom (V <- T ; Subst) in (TL1,V,TL2) = true .
  eq dom Subst in TL = false [owise] .

  op dom_notInVars_ : Substitution TermList -> Bool .
  eq dom Subst notInVars TL = dom Subst notIn Vars(TL) .

  op dom_notIn_ : Substitution TermList -> Bool .
  eq dom none notIn TL = true .
 ceq dom (V <- T ; Subst) notIn TL = true if not (V in TL) .
  eq dom Subst notIn TL = false [owise] .

  op range_inVars_ : Substitution TermList -> Bool .
  eq range Subst inVars TL = range Subst in Vars(TL) .

  op range_in_ : Substitution TermList -> Bool .
  eq range (V <- T ; Subst) in TL
   = any Vars(T) in TL or-else range Subst in TL .
  eq range none in TL
   = false .

  op valid-occur-check? : Substitution -> Bool .
  eq valid-occur-check?(Subst)
   = not (dom Subst inVars (rangeVars(Subst))) .

  op extract-bindings : Substitution -> TermList .
  eq extract-bindings(none) = empty .
  eq extract-bindings(V <- T ; Subst) = (T,extract-bindings(Subst)) .

  op isRenaming : Substitution -> Bool .
  eq isRenaming(none)
   = true .
  eq isRenaming((V <- V') ; Subst)
   = isRenaming(Subst) .
  eq isRenaming((V <- T) ; Subst)
   = false [owise] .
endfm

fmod FM-TERMSET is
  protecting FM-META-LEVEL-MNPA .
  protecting FM-SUBSTITUTION-HANDLING .

  sort TermSet .
  subsort Term < TermSet .
  op emptyTermSet : -> TermSet [ctor] .
  op _|_ : TermSet TermSet -> TermSet
    [ctor assoc comm id: emptyTermSet format (d n d d)] .
  eq X:Term | X:Term = X:Term .

  op _in_ : Term TermSet -> Bool .
  eq T:Term in (T:Term | TS:TermSet) = true .
  eq T:Term in TS:TermSet = false [owise] .

  op TermSet : TermList -> TermSet .
  eq TermSet(empty)
   = emptyTermSet .
  eq TermSet((T:Term,TL:TermList))
   = T:Term | TermSet(TL:TermList) .

endfm

fmod FM-RENAMING is
  protecting META-TERM .
  protecting FM-META-LEVEL-MNPA .
  protecting FM-TERM-HANDLING .
  protecting FM-SUBSTITUTION-HANDLING .
  protecting FM-TERMSET .
  protecting CONVERSION .
  protecting QID .
  protecting INT .
  protecting FM-UNIFICATIONTRIPLE .

  var S S' Subst Subst' : Substitution .
  var V V' : Variable .
  var C C' : Constant .
  var CtL : NeCTermList .
  var Ct : Context .
  var T T' T1 T2 T1' T2' T1'' T2'' : Term .
  var F F' : Qid .
  var TL TL' TL'' TL''' : TermList .
  var Att : AttrSet .
  var RLS : RuleSet .
  var Rl : Rule .
  var TP : Type .
  var N N' : Nat .
  var NeTL : NeTermList .

  var Q Q' : Qid .
  var IL : ImportList .
  var SS : SortSet .
  var SSDS : SubsortDeclSet .
  var OPDS : OpDeclSet .
  var MAS : MembAxSet .
  var EQS : EquationSet .

  var TPL : TypeList .

  --- Extra filter for substitutions ------
  op _|>_ : Substitution Nat -> Substitution .
  eq Subst |> N
   = Subst |>* N [none] .

  op _|>*_[_] : Substitution Nat Substitution -> Substitution .
  eq none |>* N [Subst']
   = Subst' .
  eq ((V <- T') ; Subst) |>* N [Subst']
   = Subst |>* N
     [Subst' ; if highestVar(V) < N then (V <- T') else none fi ] .

  --- instantiatesAbove -----------------------------------
  op _instantiatesAbove_ : Substitution Nat -> Bool .
  eq none instantiatesAbove N = false .
  eq ((V <- T') ; Subst) instantiatesAbove N
   = highestVar(V) >= N
     or-else
     Subst instantiatesAbove N .

  ----------------------------------------------
  --- New Renaming Utilities -------------------
  op highestVar : GTermList -> Nat .
  eq highestVar(TL:GTermList)
   = highestVar(TL:GTermList,0) .

  op highestVarTerm : Term -> Nat . ---warning memo
  op highestVarTerm : Context -> Nat . ---warning memo
  eq highestVarTerm([]) = 0 .
  eq highestVarTerm(C) = 0 .
  eq highestVarTerm(V)
   = if rfind(string(V), "#", length(string(V))) =/= notFound
        and
        rfind(string(V), ":", length(string(V))) =/= notFound
        and
        rat(substr(string(V),
                   rfind(string(V), "#", length(string(V))) + 1,
                   rfind(string(V), ":", length(string(V))) + (- 1))
            ,10)
        :: Nat
     then rat(substr(string(V),
                   rfind(string(V), "#", length(string(V))) + 1,
                   rfind(string(V), ":", length(string(V))) + (- 1))
              ,10)
     else
         if rfind(string(V), "%", length(string(V))) =/= notFound
            and
            rfind(string(V), ":", length(string(V))) =/= notFound
            and
            rat(substr(string(V),
                       rfind(string(V), "%", length(string(V))) + 1,
                       rfind(string(V), ":", length(string(V))) + (- 1))
                ,10)
            :: Nat
         then rat(substr(string(V),
                         rfind(string(V), "%", length(string(V))) + 1,
                         rfind(string(V), ":", length(string(V))) + (- 1))
                  ,10)
         else 0
         fi
     fi .

  eq highestVarTerm(F[TL:GTermList])
   = highestVar(TL:GTermList,0) .

  op highestVar : GTermList Nat -> Nat .
  eq highestVar(empty,N)
   = N .
  eq highestVar((Ct,TL:GTermList),N)
   = highestVar(TL:GTermList,
       if highestVarTerm(Ct) > N then highestVarTerm(Ct) else N fi
     ) .
  eq highestVar((T,TL:GTermList),N)
   = highestVar(TL:GTermList,
       if highestVarTerm(T) > N then highestVarTerm(T) else N fi
     ) .

  --- For substitutions
  op highestVar : Substitution -> Nat . --- [memo] .
  eq highestVar(Subst)
   = highestVar(Subst,0) .

  op highestVar : Substitution Nat -> Nat .
  eq highestVar((none).Substitution,N) = N .
  eq highestVar(V <- T ; Subst,N)
   = highestVar(Subst,highestVar((T,V),N)) .

  --- Renaming ------------------------------------------------------
  op newVar : Nat TypeList -> TermList .
  eq newVar(N,nil) = empty .
  eq newVar(N,TP TPL) = (newVar*(N,TP),newVar(s(N),TPL)) .

  op newVar* : Nat Type -> Variable .
  eq newVar*(N,TP)
   = qid("#" + string(N,10) + ":" + string(TP)) .

  op simplifyVars : TermList -> TermList .
  eq simplifyVars(TL) = TL << 0 < .

  op _<<`(_`)< : TermList GTermList -> TermList .
  eq X:TermList <<(TL:GTermList)<
   = X:TermList << highestVar(TL:GTermList) + 1 < .

  op _<<_ : TermList UnificationPair -> TermList .
  eq TL << {Subst,N} = TL << Subst .

  op _<<_ : TermList UnificationTriple -> TermList .
  eq TL << {Subst,Subst',N} = TL << (Subst ; Subst') .

  op _<<_ : Substitution UnificationTriple -> Substitution .
  eq S:Substitution << {Subst,Subst',N} = S:Substitution << (Subst ; Subst') .

  op _<<_< : TermList Nat -> TermList .
  eq TL << N < = TL << (TL << { none, N } <) .

  op _<<_< : TermList UnificationPair -> UnificationPair . ***Huge [memo] .
  eq C << {S,N} < = {S,N} .
  eq F[TL] << {S,N} < = TL << {S,N} < .
  eq V << {S,N} <
   = if not (dom S inVars V)
     then {S ; V <- newVar(N,getType(V)), N + 1}
     else {S,N}
     fi .

  eq (T,TL:NeTermList) << {S,N} <
   = TL:NeTermList << (T << {S,N} < ) < .
  eq empty << {S,N} <
   = {S,N} .

endfm

fmod FM-SUBSTITUTIONSET is
  protecting FM-SUBSTITUTION-HANDLING .
  protecting FM-META-LEVEL-MNPA .
  protecting FM-TERMSET .
  protecting FM-RENAMING .

  sort SubstitutionSet NeSubstitutionSet .
  subsort Substitution < NeSubstitutionSet < SubstitutionSet .
  op empty : -> SubstitutionSet [ctor] .
  op _|_ : SubstitutionSet SubstitutionSet -> SubstitutionSet
    [ctor assoc comm id: empty format (d n d d)] .
  op _|_ : NeSubstitutionSet SubstitutionSet -> NeSubstitutionSet
    [ctor ditto] .
  eq X:Substitution | X:Substitution = X:Substitution .

  vars SS SS' : SubstitutionSet .
  vars S S' Subst : Substitution .
  vars T T' : Term .
  vars TL TL' : TermList .
  vars N N' : Nat .
  var V : Variable .

  op _<<_ : Substitution SubstitutionSet -> SubstitutionSet .
  eq S << empty = empty .
  ceq S << (S' | SS') = (S << S') | (S << SS') if SS' =/= empty .

  op _..._ : SubstitutionSet [SubstitutionSet]
          -> SubstitutionSet [strat (1) gather (e E)] .

  eq empty ... SS':[SubstitutionSet] = empty .
  eq (S | SS) ... SS':[SubstitutionSet]
   = (S ...' SS':[SubstitutionSet])
     |
     (SS ... SS':[SubstitutionSet]) .

  op _...'_ : Substitution SubstitutionSet -> SubstitutionSet .

  eq S ...' empty
   = empty .

  eq S ...' (S' | SS')
   = (S .. S')
     |
     (S ...' SS') .

  op _|>_ : SubstitutionSet TermList -> SubstitutionSet .
  eq (empty).SubstitutionSet |> TL = empty .
  eq (S | SS:NeSubstitutionSet) |> TL
   = (S |> TL) | (SS:NeSubstitutionSet |> TL) .

  op _|>_ : SubstitutionSet Nat -> SubstitutionSet .
  eq SS:NeSubstitutionSet |> N
   = SS:NeSubstitutionSet |> (0,N) .

  op _|>`(_,_`) : SubstitutionSet Nat Nat -> SubstitutionSet .
  eq (empty).SubstitutionSet |> (N,N') = empty .
  eq (S | SS:NeSubstitutionSet) |> (N,N')
   = (S |> (N,N')) | (SS:NeSubstitutionSet |> (N,N')) .

  op _|>`(_,_`) : Substitution Nat Nat -> Substitution .
  eq none |> (N,N') = none .
  eq ((V <- T') ; Subst) |> (N,N')
   = if N <= highestVar(V) and highestVar(V) <= N'
     then (V <- T')
     else none
     fi
     ; (Subst |> (N,N')) .

  op filter_by!InVars_ : SubstitutionSet TermList -> SubstitutionSet .
  eq filter (empty).SubstitutionSet by!InVars TL
   = (empty).SubstitutionSet .
  eq filter (S | SS) by!InVars TL
   = if dom S inVars TL
     then empty
     else S
     fi
     | filter SS by!InVars TL .

  op _==* none : SubstitutionSet -> Bool .
  eq (none | SS) ==* none = SS ==* none .
  eq (empty).SubstitutionSet ==* none = true .
  eq SS ==* none = false [owise] .

  op |_| : SubstitutionSet -> Nat .
  eq | (empty).SubstitutionSet | = 0 .
  eq | (S | SS) | = s(| SS |) .

endfm

fmod FM-UNIFICATIONPAIRSET is
  protecting FM-SUBSTITUTIONSET .
  protecting FM-RENAMING .
  protecting FM-UNIFICATIONTRIPLE .

  vars V V' : Variable .
  vars U U' : UnificationPair .
  vars US US' : UnificationPairSet .
  vars S S' S1 S1' S2 S2' : Substitution .
  var SS : SubstitutionSet .
  vars N N' N1 N2 : Nat .
  vars T T' : Term .
  var TL : TermList .
  var M : Module .

  --- Combine UnificationPair ---------------------------------------------
  op _.._ : UnificationPair UnificationPair -> UnificationPair .
  eq {S,N} .. {S',N'} = {S .. S',max(N,N')} .

  --- Detect used variables ----------------------------------------------
  op dom_inVars_ : UnificationPair TermList -> Bool . --- [memo] .
  eq dom {S,N} inVars TL = dom S inVars TL .

  --- UnificationPairSet --------------------------------------------------
  sort UnificationPairSet .
  subsort UnificationPair < UnificationPairSet .
  op empty : -> UnificationPairSet [ctor] .
  op _|_ : UnificationPairSet UnificationPairSet -> UnificationPairSet
    [ctor assoc comm id: empty format (d n d d)] .
  eq X:UnificationPair | X:UnificationPair = X:UnificationPair .

  op _..._ : UnificationPairSet [UnificationPairSet]
          -> UnificationPairSet [strat (1) gather (e E)] .

  eq (empty).UnificationPairSet ... US':[UnificationPairSet]
   = (empty).UnificationPairSet .
  eq (U | US) ... US':[UnificationPairSet]
   = (U ...' US':[UnificationPairSet])
     |
     (US ... US':[UnificationPairSet]) .

  op _...'_ : UnificationPair UnificationPairSet -> UnificationPairSet .

  eq U ...' (empty).UnificationPairSet
   = (empty).UnificationPairSet .

  eq U ...' (U' | US')
   = (U .. U')
     |
     (U ...' US') .

  --- Restriction -----------------------
  op _|>_ : UnificationPairSet TermList -> UnificationPairSet .
  eq (empty).UnificationPairSet |> TL = empty .
  eq ({S,N} | US) |> TL = {(S |> TL),N} | (US |> TL) .

  op filter_by!InVars_ : UnificationPairSet TermList
                      -> UnificationPairSet .
  eq filter (empty).UnificationPairSet by!InVars TL
   = (empty).UnificationPairSet .
  eq filter (U | US) by!InVars TL
   = if dom U inVars TL
     then empty
     else U
     fi
     | filter US by!InVars TL .

  op toUnificationPair[_]`(_`) : Nat SubstitutionSet -> UnificationPairSet .
  eq toUnificationPair[N](empty)
   = empty .
  eq toUnificationPair[N](S | SS)
   = {S,highestVar(S,N)}
     | toUnificationPair[N](SS) .

  op toSubstitution : UnificationPairSet -> SubstitutionSet .
  eq toSubstitution((empty).UnificationPairSet)
   = empty .
  eq toSubstitution({S,N} | US)
   = S | toSubstitution(US) .

  op _in_ : UnificationPair UnificationPairSet -> Bool .
  eq X:UnificationPair in (X:UnificationPair | XS:UnificationPairSet) = true .
  eq X:UnificationPair in XS:UnificationPairSet = false [owise] .

endfm

fmod FM-UNIFICATIONTRIPLESET is
  protecting FM-SUBSTITUTIONSET .
  protecting FM-RENAMING .
  protecting FM-UNIFICATIONPAIRSET .

  vars V V' : Variable .
  var C : Constant .
  var F : Qid .
  vars U U' : UnificationTriple .
  vars US US' : UnificationTripleSet .
  vars S S' S1 S1' S2 S2' : Substitution .
  var SS : SubstitutionSet .
  var SSe : NeSubstitutionSet .
  vars N N' N1 N2 NextVar : Nat .
  vars T T' : Term .
  var TL : TermList .
  var NeTL : NeTermList .
  var M : Module .
  var UPS : UnificationPairSet .

  --- Combine UnificationPair ---------------------------------------------
  op _.._ : UnificationTriple UnificationTriple -> UnificationTriple .
  eq {S1,S1',N1} .. {S2,S2',N2} = {S1 .. S2,S1' .. S2',max(N1,N2)} .

  --- UnificationPairSet --------------------------------------------------
  sort UnificationTripleSet .
  subsort UnificationTriple < UnificationTripleSet .
  op empty : -> UnificationTripleSet [ctor] .
  op _|_ : UnificationTripleSet UnificationTripleSet
        -> UnificationTripleSet
    [ctor assoc comm id: empty format (d n d d)] .
  eq X:UnificationTriple | X:UnificationTriple = X:UnificationTriple .

  op _..._ : UnificationTripleSet [UnificationTripleSet]
          -> UnificationTripleSet [strat (1) gather (e E)] .

  eq (empty).UnificationTripleSet ... US':[UnificationTripleSet]
   = (empty).UnificationTripleSet .
  eq (U | US) ... US':[UnificationTripleSet]
   = (U ...' US':[UnificationTripleSet])
     |
     (US ... US':[UnificationTripleSet]) .

  op _...'_ : UnificationTriple UnificationTripleSet
           -> UnificationTripleSet .

  eq U ...' (empty).UnificationTripleSet
   = (empty).UnificationTripleSet .

  eq U ...' (U' | US')
   = (U .. U')
     |
     (U ...' US') .

  --- convert  -----------------------------------------------------
  op split : UnificationPair Nat -> UnificationTriple .
  eq split({none,N},N') = {none,none,N} .
  eq split({(V <- T') ; S,N},N')
   = if highestVar(V) < N'
     then {(V <- T'),none,N}
     else {none,(V <- T'),N}
     fi
     .. split({S,N},N') .

  op split : UnificationPairSet Term Term -> UnificationTripleSet .
  eq split(empty,T,T') = empty .
  eq split({S,N} | UPS,T,T') = {S |> T, S |> T',N} | split(UPS,T,T') .

  op toUnificationTriple[_]`(_`) :
             Nat SubstitutionSet -> UnificationTripleSet .
  eq toUnificationTriple[N](SS)
   = toUnificationTriple*[N](SS,empty) .

  op toUnificationTriple*[_]`(_,_`) :
             Nat SubstitutionSet
             UnificationTripleSet -> UnificationTripleSet .
  eq toUnificationTriple*[N](empty,US)
   = US .
  eq toUnificationTriple*[N](S | SS,US)
   = toUnificationTriple*[N](SS, US | {none,S,highestVar(S,N)}) .

  op toUnificationTriple[_,_]`(_`) :
             Nat Nat SubstitutionSet -> UnificationTripleSet .
  eq toUnificationTriple[NextVar,N](SS)
   = toUnificationTriple*[NextVar,N](SS,empty) .

  op toUnificationTriple*[_,_]`(_,_`) :
             Nat Nat SubstitutionSet
             UnificationTripleSet -> UnificationTripleSet .
  eq toUnificationTriple*[NextVar,N](empty,US)
   = US .
  eq toUnificationTriple*[NextVar,N](S | SS,US)
   = toUnificationTriple*[NextVar,N](SS,
             US | split({S,highestVar(S,N)},NextVar)) .

  op toUnificationTriple[_,_,_]`(_`) :
             Term Term Nat SubstitutionSet -> UnificationTripleSet .
  eq toUnificationTriple[T,T',N](SS)
   = toUnificationTriple*[T,T',N](SS,empty) .

  op toUnificationTriple*[_,_,_]`(_,_`) :
             Term Term Nat SubstitutionSet
             UnificationTripleSet -> UnificationTripleSet .
  eq toUnificationTriple*[T,T',N](empty,US)
   = US .
  eq toUnificationTriple*[T,T',N](S | SS,US)
   = toUnificationTriple*[T,T',N](SS, US | {S |> T,S |> T',highestVar(S,N)}) .

  op toSubstitution : UnificationTripleSet -> SubstitutionSet .
  eq toSubstitution(US)
   = toSubstitution*(US,empty) .

  op toSubstitution* : UnificationTripleSet
                       SubstitutionSet -> SubstitutionSet .
  eq toSubstitution*((empty).UnificationTripleSet,SS)
   = SS .
  eq toSubstitution*({S,S',N} | US,SS)
   = toSubstitution*(US,SS | (S ; S')) .

  op _in_ : UnificationTriple UnificationTripleSet -> Bool .
  eq X:UnificationTriple
     in (X:UnificationTriple | XS:UnificationTripleSet) = true .
  eq X:UnificationTriple in XS:UnificationTripleSet = false [owise] .

  --- restriction ---------------------------------------------------
  op _|>_ : UnificationTripleSet TermList -> UnificationTripleSet .
  eq US |> TL
   = US *|> TL [empty] .

  op _*|>_[_] : UnificationTripleSet TermList
               UnificationTripleSet -> UnificationTripleSet .
  eq (empty).UnificationTripleSet *|> TL [US']
   = US' .
  eq ({S,S',N} | US) *|> TL [US']
   = US *|> TL [US' | {(S |> TL),(S' |> TL),N} ] .

  op _filterBy_ : UnificationTripleSet Nat -> UnificationTripleSet .
  eq US filterBy NextVar
   = US filterBy* NextVar [empty] .

  op _filterBy*_[_] : UnificationTripleSet Nat
                     UnificationTripleSet -> UnificationTripleSet .
  eq empty filterBy* NextVar [US']
   = US' .
  eq ({S,S',N} | US) filterBy* NextVar [US']
   = US filterBy* NextVar
     [US' | if S instantiatesAbove NextVar then empty else {S,S',N} fi ] .
endfm

fmod FM-MODULE-HANDLING is
  protecting INT .
  protecting FM-META-LEVEL-MNPA .
  protecting EXT-BOOL .
  protecting FM-SUBSTITUTION-HANDLING .
  protecting FM-UNIFICATIONTRIPLESET .

  var T T' T'' T1 T2 Lhs Rhs : Term .
  var C C' : Constant .
  var QIL : QidList .
  var N N' : Nat .
  var NL NL' : NatList .
  var Q F F' : Qid .
  vars AtS AtS' : AttrSet .
  var EqS : EquationSet .
  var Eq : Equation .
  var RlS : RuleSet .
  var Rl : Rule .
  var Cond : Condition .
  var TP TP' TP1 TP2 : Type .
  var TPL TPL' : TypeList .
  ---var TPL TPL' : ETypeList .
  ---var ET ET' : EType .
  var VDS OPDS : OpDeclSet .
  var OPD : OpDecl .
  vars M M' : Module .
  var TL TL' TL'' : TermList .
  var B : Bool .
  var V V' : Variable .
  var I  : Int .
  vars S S' : Substitution .
  var US : UnificationTripleSet .

  *** canonice  ******************************
  op canonice : Module TermList -> TermList .
---  eq canonice(M,T) = getTerm(metaReduce(eraseRls(eraseEqs(M)),T)) .
  eq canonice(M,(empty).TermList) = empty .
  eq canonice(M,(T,TL)) = (getTerm(metaNormalize(M,T)),canonice(M,TL)) .

  op canonice : Module Substitution -> Substitution .
  eq canonice(M,(none).Substitution) = none .
  eq canonice(M,V <- T ; S) = V <- canonice(M,T) ; canonice(M,S)  .

  op canonice : Module UnificationTripleSet -> UnificationTripleSet .
  eq canonice(M,(empty).UnificationTripleSet) = (empty).UnificationTripleSet .
  eq canonice(M,{S,S',N} | US) = {canonice(M,S),canonice(M,S'),N} | canonice(M,US) .

  *** normalize  ******************************
  op normalize : Module Term -> Term .
  eq normalize(M,T) = getTerm(metaReduce(eraseRls(M),T)) .

  op normalize : Module Substitution -> Substitution .
  eq normalize(M,(none).Substitution) = none .
  eq normalize(M,V <- T ; S) = V <- normalize(M,T) ; normalize(M,S)  .

  op normalize : Module SModule -> SModule .
  eq normalize(M,
       mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   =   mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       normalize(M,E:EquationSet)
       R:RuleSet
      endm .
  op normalize : Module FModule -> FModule .
  eq normalize(M,
       fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   =   fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       normalize(M,E:EquationSet)
      endfm .

  op normalize : Module EquationSet -> EquationSet .
  eq normalize(M,(eq T = T' [AtS] .) EqS)
   = (eq T = normalize(M,T') [AtS] .) normalize(M,EqS) .
  eq normalize(M,(ceq T = T' if Cond [AtS] .) EqS)
   = (ceq T = normalize(M,T') if Cond [AtS] .) normalize(M,EqS) .
  eq normalize(M,(none).EquationSet)
   = (none).EquationSet .

  *** normalizeRls  ******************************
  op normalizeRls : Module Term -> Term .
  eq normalizeRls(M,T) = getTerm(metaReduce(rls2eqs(M),T)) .

  op normalizeRls : Module Substitution -> Substitution .
  eq normalizeRls(M,(none).Substitution) = none .
  eq normalizeRls(M,V <- T ; S) = V <- normalizeRls(M,T) ; normalizeRls(M,S)  .

  *** typeLeq **************************************************
  op typeLeq : Module TypeList TypeList ~> Bool [memo] .

  eq typeLeq(M,TP:Sort TPL,TP':Sort TPL')
   = sortLeq(M,TP:Sort,TP':Sort) and typeLeq(M,TPL,TPL') .
  eq typeLeq(M,TP:Sort TPL,TP':Kind TPL')
   = getKind(M,TP:Sort) == TP':Kind
     and typeLeq(M,TPL,TPL') .
  eq typeLeq(M,TP:Kind TPL,TP':Sort TPL')
   = false .
  eq typeLeq(M,TP:Kind TPL,TP':Kind TPL')
   = TP:Kind == TP':Kind and typeLeq(M,TPL,TPL') .
  eq typeLeq(M,nil,nil)
   = true .

  *** getTypes **************************************************
  op getTypes : Module TermList -> TypeList . ---Memo is huge
  eq getTypes(M, (T, TL)) = leastSort(M, T) getTypes(M, TL) .
  eq getTypes(M, empty) = nil .

  *** getFrozen ************************************************
  op getFrozen : Module Qid TypeList -> NatList [memo] .
  eq getFrozen(M,F,TPL) = getFrozen(getOpsOfQid(M,F,TPL)) .

  op getFrozen : OpDeclSet -> NatList .
  eq getFrozen((op F : TPL -> TP [frozen(NL) AtS] .) OPDS) = NL .
  eq getFrozen(OPDS) = 0 [owise] .

  *** inNatList ************************************************
  op _inNatList_ : Nat NatList -> Bool .
  eq N inNatList (NL N NL') = true .
  eq N inNatList NL = false [owise] .

  *** membership ************************************************
  op _in_ : Type TypeList ~> Bool .
  eq TP in (TPL TP TPL') = true .
  eq TP in TPL = false [owise] .

  *** isConstructor  ******************************
  op isConstructor : Module Term -> Bool .
  op isConstructor : Module Qid TypeList -> Bool [memo] .
  op isConstructor : OpDeclSet -> Bool .

  eq isConstructor(M,V) = false .
  eq isConstructor(M,C) = isConstructor(M,C,nil) .
  eq isConstructor(M,F[TL]) = isConstructor(M,F,getTypes(M,TL)) .

  eq isConstructor(M,F,TPL)
   = getEqsOfQid(M,F,TPL) == none or-else isConstructor(getOpsOfQid(M,F,TPL)) .

  eq isConstructor((op F : TPL -> TP [ctor AtS] .) OPDS) = true .
  eq isConstructor(OPDS) = false [owise] .

  *** getOpsOfType ***********************************************
  op getOpsOfType : Module Type -> OpDeclSet [memo] .
  op getOpsOfType : Module OpDeclSet Type -> OpDeclSet .

  eq getOpsOfType(M,TP) = getOpsOfType(M,getOps(M),TP) .

  eq getOpsOfType(M,((op F : TPL -> TP [AtS] .) OPDS),TP')
    = if TP == TP'
      then (op F : TPL -> TP [AtS] .)
           getOpsOfType(M,OPDS,TP')
      else getOpsOfType(M,OPDS,TP')
      fi .

  eq getOpsOfType(M,OPDS,TP)
   = none
     [owise] .

  *** getOpsOfQid ***********************************************
  op getOpsOfQid : Module Qid -> OpDeclSet [memo] .
  op getOpsOfQid : Module Qid TypeList -> OpDeclSet [memo] .
  op getOpsOfQid : Module OpDeclSet Qid -> OpDeclSet .
  op getOpsOfQid : Module OpDeclSet Qid TypeList -> OpDeclSet .

  eq getOpsOfQid(M,F)
   = getOpsOfQid(M,getOps(M),F) .

  eq getOpsOfQid(M,F,TPL)
   = if getOpsOfQid(M,getOps(M),F,TPL) =/= none
     then getOpsOfQid(M,getOps(M),F,TPL)
     else getOpsOfQid(M,getOps(M),F,restrict TPL To 2)
     fi .

  eq getOpsOfQid(M,((op F : TPL -> TP [AtS] .) OPDS),F)
    = (op F : TPL -> TP [AtS] .)
      getOpsOfQid(M,OPDS,F) .

  eq getOpsOfQid(M,OPDS,F')
   = none
     [owise] .

  eq getOpsOfQid(M,((op F : TPL -> TP [AtS] .) OPDS),F,TPL')
    = if eSameKind(M,TPL,TPL')
      then (op F : TPL -> TP [AtS] .)
           getOpsOfQid(M,OPDS,F,TPL')
      else getOpsOfQid(M,OPDS,F,TPL')
      fi .

  eq getOpsOfQid(M,OPDS,F',TPL')
   = none
     [owise] .

  op restrict_To_ : TypeList Nat -> TypeList .
  eq restrict nil To NL = nil .
  eq restrict TPL To 0 = nil .
  eq restrict (TP,TPL) To s(N) = (TP, restrict TPL To N) .

  *** getOpsOfEqs ******************************************************
  op getOpsOfEqs : EquationSet -> QidList [memo] .
  eq getOpsOfEqs((eq C = T' [AtS] .) EqS )
   = C getOpsOfEqs(EqS) .
  eq getOpsOfEqs((eq F[TL] = T' [AtS] .) EqS )
   = F getOpsOfEqs(EqS) .
  eq getOpsOfEqs((none).EquationSet)
   = nil .

  *** getEqsOfQid ******************************************************
  op getEqsOfQid : Module Qid TypeList -> EquationSet [memo] .
  op getEqsOfQid : Module Qid TypeList EquationSet -> EquationSet .

  eq getEqsOfQid(M, F,TPL) = getEqsOfQid(M, F, TPL, getEqs(M)) .

  ceq getEqsOfQid(M, F, TPL, (eq C = T' [AtS] .) EqS )
   = (eq C = T' [AtS] .) getEqsOfQid(M, F, TPL, EqS)
   if F == C .
  ceq getEqsOfQid(M, F, TPL, (eq F[TL] = T' [AtS] .) EqS )
   = (eq F[TL] = T' [AtS] .) getEqsOfQid(M, F, TPL, EqS)
   if eSameKind(M,getTypes(M,TL),TPL) .
  ceq getEqsOfQid(M, F, TPL, (ceq C = T' if Cond [AtS] .) EqS )
   = (ceq C = T' if Cond [AtS] .) getEqsOfQid(M, F, TPL, EqS)
   if F == C .
  ceq getEqsOfQid(M, F, TPL, (ceq F[TL] = T' if Cond [AtS] .) EqS )
   = (ceq F[TL] = T' if Cond [AtS] .) getEqsOfQid(M, F, TPL, EqS)
   if eSameKind(M,getTypes(M,TL),TPL) .
  eq getEqsOfQid(M, F, TPL, Eq EqS )
   = getEqsOfQid(M, F, TPL, EqS) [owise] .
  eq getEqsOfQid(M, F, TPL, (none).EquationSet )
   = (none).EquationSet .

  *** getTypesOfQid  ****************************************
  op getTypesOfQid : Module Qid TypeList -> TypeSet [memo] .
  op getTypesOfQid : OpDeclSet -> TypeSet .

  eq getTypesOfQid(M,F,TPL) = getTypesOfQid(getOpsOfQid(M,F,TPL)) .
  eq getTypesOfQid((op F : TPL -> TP [AtS] .) OPDS)
   = TP ; getTypesOfQid(OPDS) .
  eq getTypesOfQid((none).OpDeclSet) = (none).TypeSet .

  *** filterConstructorSymbols ************************************
  op filterConstructorSymbols : OpDeclSet -> OpDeclSet .
  eq filterConstructorSymbols(((op F : TPL -> TP [AtS] .) OPDS))
    = if isConstructor((op F : TPL -> TP [AtS] .) none)
      then (op F : TPL -> TP [AtS] .)
           filterConstructorSymbols(OPDS)
      else filterConstructorSymbols(OPDS)
      fi .
  eq filterConstructorSymbols(none)
    = none .

  *** filterDefinedSymbols *****************************************
  op filterDefinedSymbols : OpDeclSet -> OpDeclSet .
  eq filterDefinedSymbols(((op F : TPL -> TP [ctor AtS] .) OPDS))
    = filterDefinedSymbols(OPDS) .
  eq filterDefinedSymbols(((op F : TPL -> TP [AtS] .) OPDS))
    = (op F : TPL -> TP [AtS] .) filterDefinedSymbols(OPDS) [owise] .
  eq filterDefinedSymbols(none)
    = none .

  *** isCommutative ******************************
  op isCommutative : Module Term -> Bool .
  op isCommutative : Module Qid TypeList -> Bool [memo] .
  op isCommutative : OpDeclSet -> Bool .

  eq isCommutative(M,V) = false .
  eq isCommutative(M,C) = false .
  eq isCommutative(M,F[TL]) = isCommutative(M,F,getTypes(M,TL)) .

  eq isCommutative(M,F,TPL) = isCommutative(getOpsOfQid(M,F,TPL)) .

  eq isCommutative((op F : TPL -> TP [comm AtS] .) OPDS) = true .
  eq isCommutative(OPDS) = false [owise] .

  *** isAssociative ******************************
  op isAssociative : Module Term -> Bool .
  op isAssociative : Module Qid TypeList -> Bool [memo] .
  op isAssociative : OpDeclSet -> Bool .

  eq isAssociative(M,V) = false .
  eq isAssociative(M,C) = false .
  eq isAssociative(M,F[TL]) = isAssociative(M,F,getTypes(M,TL)) .

  eq isAssociative(M,F,TPL) = isAssociative(getOpsOfQid(M,F,TPL)) .

  eq isAssociative((op F : TPL -> TP [assoc AtS] .) OPDS) = true .
  eq isAssociative(OPDS) = false [owise] .

  *** getIdSymbol ******************************
  op getIdSymbol : Module Term ~> Term .
  eq getIdSymbol(M,F[TL]) = getIdSymbol(M,F,getTypes(M,TL)) .

  op getIdSymbol : Module Qid TypeList ~> Term [memo] .
  eq getIdSymbol(M,F,TPL) = getIdSymbol(getOpsOfQid(M,F,TPL)) .

  op getIdSymbol : OpDeclSet ~> Term .
  eq getIdSymbol((op F : TPL -> TP [id(T) AtS] .) OPDS) = T .

  op getLeftIdSymbol : Module Term ~> Term .
  eq getLeftIdSymbol(M,F[TL]) = getLeftIdSymbol(M,F,getTypes(M,TL)) .

  op getLeftIdSymbol : Module Qid TypeList ~> Term .
  eq getLeftIdSymbol(M,F,TPL) = getLeftIdSymbol(getOpsOfQid(M,F,TPL)) .

  op getLeftIdSymbol : OpDeclSet ~> Term .
  eq getLeftIdSymbol((op F : TPL -> TP [left-id(T) AtS] .) OPDS) = T .

  op getRightIdSymbol : Module Term ~> Term .
  eq getRightIdSymbol(M,F[TL]) = getRightIdSymbol(M,F,getTypes(M,TL)) .

  op getRightIdSymbol : Module Qid TypeList ~> Term .
  eq getRightIdSymbol(M,F,TPL) = getRightIdSymbol(getOpsOfQid(M,F,TPL)) .

  op getRightIdSymbol : OpDeclSet ~> Term .
  eq getRightIdSymbol((op F : TPL -> TP [right-id(T) AtS] .) OPDS) = T .

  *** anyIdSymbol ******************************
  op anyIdSymbol : Module Term -> Bool .
  eq anyIdSymbol(M,C:Constant)
   = false .
  eq anyIdSymbol(M,V:Variable)
   = false .
  eq anyIdSymbol(M,F:Qid[TL:TermList])
   = getIdSymbol(M,F:Qid[TL:TermList]) :: Term
     or-else
     anyIdSymbol*(M,TL:TermList) .

  op anyIdSymbol* : Module TermList -> Bool .
  eq anyIdSymbol*(M,empty)
   = false .
  eq anyIdSymbol*(M,(T:Term,TL:TermList))
   = anyIdSymbol(M,T:Term)
     or-else
     anyIdSymbol*(M,TL:TermList) .

  ****
  op anyIdSymbol : Module Substitution -> Bool .
  eq anyIdSymbol(M,(none).Substitution) = false .
  eq anyIdSymbol(M,V:Variable <- T:Term ; S:Substitution)
   = anyIdSymbol(M,T:Term)
     or-else
     anyIdSymbol(M,S:Substitution) .

  *** eSameKind ******************************
  op eSameKind : Module TypeList TypeList -> Bool [memo] .
  eq eSameKind(M,TP TPL, TP' TPL')
   = sameKind(M,TP,TP') and eSameKind(M,TPL,TPL') .
  eq eSameKind(M,nil,nil) = true .
  eq eSameKind(M,TPL,nil) = true .
  eq eSameKind(M,nil,TPL') = true .
  ---eq eSameKind(M,TPL,TPL') = false [owise] .

  *** eqs2rls *******************************
  sort EqSet&RlsSet .
  op {_,_} : EquationSet RuleSet -> EqSet&RlsSet .
  op getEqs : EqSet&RlsSet -> EquationSet .
  eq getEqs({EqS,RlS}) = EqS .
  op getRls : EqSet&RlsSet -> RuleSet .
  eq getRls({EqS,RlS}) = RlS .

  op eqs2rls# : EquationSet -> EqSet&RlsSet [memo] .
  eq eqs2rls#(none) = {none,none} .
  eq eqs2rls#((eq Lhs = Rhs [AtS] .) EqS)
   = {getEqs(eqs2rls#(EqS)),
      (rl Lhs => Rhs [AtS] .) getRls(eqs2rls#(EqS))
     } .
  eq eqs2rls#((ceq Lhs = Rhs if Cond [AtS] .) EqS)
   = {getEqs(eqs2rls#(EqS)),
      (crl Lhs => Rhs if Cond [AtS] .) getRls(eqs2rls#(EqS))
     } .

  op eqs2rls : SModule -> SModule .
  eq eqs2rls(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqs(eqs2rls#(E:EquationSet))
       getRls(eqs2rls#(E:EquationSet))
     endm .

  op eqs2rls : FModule -> FModule .
  eq eqs2rls(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqs(eqs2rls#(E:EquationSet))
       getRls(eqs2rls#(E:EquationSet))
     endm .

  op eqsNoBuiltInUnify2rls : SModule -> SModule .
  eq eqsNoBuiltInUnify2rls(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       (getEqs(eqs2rls#(getEqsNoBuiltInUnify(E:EquationSet))) getEqsBuiltInUnify(E:EquationSet))
       getRls(eqs2rls#(getEqsNoBuiltInUnify(E:EquationSet)))
     endm .

  op eqsNoBuiltInUnify2rls : FModule -> SModule .
  eq eqsNoBuiltInUnify2rls(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       (getEqs(eqs2rls#(getEqsNoBuiltInUnify(E:EquationSet))) getEqsBuiltInUnify(E:EquationSet))
       getRls(eqs2rls#(getEqsNoBuiltInUnify(E:EquationSet)))
     endm .

  op eqsNoVariant2rls : SModule -> SModule .
  eq eqsNoVariant2rls(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       (getEqs(eqs2rls#(getEqsNoVariant(E:EquationSet))) getEqsVariant(E:EquationSet))
       getRls(eqs2rls#(getEqsNoVariant(E:EquationSet)))
     endm .

  op eqsNoVariant2rls : FModule -> SModule .
  eq eqsNoVariant2rls(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       (getEqs(eqs2rls#(getEqsNoVariant(E:EquationSet))) getEqsVariant(E:EquationSet))
       getRls(eqs2rls#(getEqsNoVariant(E:EquationSet)))
     endm .

  op eqsVariant2rls : SModule -> SModule .
  eq eqsVariant2rls(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       (getEqs(eqs2rls#(getEqsVariant(E:EquationSet))) getEqsNoVariant(E:EquationSet))
       getRls(eqs2rls#(getEqsVariant(E:EquationSet)))
     endm .

  op eqsVariant2rls : FModule -> SModule .
  eq eqsVariant2rls(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = mod (addsufix '-EQS2RLS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       (getEqs(eqs2rls#(getEqsVariant(E:EquationSet))) getEqsNoVariant(E:EquationSet))
       getRls(eqs2rls#(getEqsVariant(E:EquationSet)))
     endm .

  op removeVariantLabel : SModule -> SModule .
  eq removeVariantLabel(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-EQSV2EQSNV To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       removeVariantLabel(E:EquationSet)
       R:RuleSet
      endm .

  op removeVariantLabel : FModule -> SModule .
  eq removeVariantLabel(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = fmod (addsufix '-EQSV2EQSNV To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       removeVariantLabel(E:EquationSet)
     endfm .

  op removeVariantLabel : EquationSet -> EquationSet .
  eq removeVariantLabel((eq Lhs = Rhs [AtS variant] .) EqS)
   = (eq Lhs = Rhs [AtS] .)
     removeVariantLabel(EqS) .
  eq removeVariantLabel(EqS)
   = EqS [owise] .

  *** getEqsNoBuiltInUnify *******************************
  op getEqsNoBuiltInUnify : Module -> EquationSet .
  eq getEqsNoBuiltInUnify(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = getEqsNoBuiltInUnify(E:EquationSet) .
  eq getEqsNoBuiltInUnify(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = getEqsNoBuiltInUnify(E:EquationSet) .

  op getEqsNoBuiltInUnify : EquationSet -> EquationSet [memo] .
  eq getEqsNoBuiltInUnify(none) = none .
  eq getEqsNoBuiltInUnify((eq Lhs = Rhs [AtS metadata("builtin-unify")] .) EqS)
   = getEqsNoBuiltInUnify(EqS) .
  eq getEqsNoBuiltInUnify((eq Lhs = Rhs [AtS] .) EqS)
   = (eq Lhs = Rhs [AtS] .) getEqsNoBuiltInUnify(EqS)
  [owise] .
  eq getEqsNoBuiltInUnify((ceq Lhs = Rhs if Cond [AtS] .) EqS)
   = (ceq Lhs = Rhs if Cond [AtS] .) getEqsNoBuiltInUnify(EqS) .

  *** getEqsNoVariant *******************************
  op getEqsNoVariant : Module -> EquationSet .
  eq getEqsNoVariant(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = getEqsNoVariant(E:EquationSet) .
  eq getEqsNoVariant(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = getEqsNoVariant(E:EquationSet) .

  op getEqsNoVariant : EquationSet -> EquationSet [memo] .
  eq getEqsNoVariant(none) = none .
  eq getEqsNoVariant((eq Lhs = Rhs [AtS variant] .) EqS)
   = getEqsNoVariant(EqS) .
  eq getEqsNoVariant((eq Lhs = Rhs [AtS] .) EqS)
   = (eq Lhs = Rhs [AtS] .) getEqsNoVariant(EqS)
  [owise] .
  eq getEqsNoVariant((ceq Lhs = Rhs if Cond [AtS] .) EqS)
   = (ceq Lhs = Rhs if Cond [AtS] .) getEqsNoVariant(EqS) .

  *** getEqsVariant *******************************
  op getEqsVariant : Module -> EquationSet .
  eq getEqsVariant(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = getEqsVariant(E:EquationSet) .
  eq getEqsVariant(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = getEqsVariant(E:EquationSet) .

  op getEqsVariant : EquationSet -> EquationSet [memo] .
  eq getEqsVariant(none) = none .
  eq getEqsVariant((eq Lhs = Rhs [AtS variant] .) EqS)
   = (eq Lhs = Rhs [AtS variant] .)
     getEqsVariant(EqS) .
  eq getEqsVariant((eq Lhs = Rhs [AtS] .) EqS)
   = getEqsVariant(EqS)
  [owise] .
  eq getEqsVariant((ceq Lhs = Rhs if Cond [AtS] .) EqS)
   = (ceq Lhs = Rhs if Cond [AtS] .) getEqsVariant(EqS) .

  *** onlyEqsNoBuiltInUnify *******************************
  op onlyEqsNoBuiltInUnify : Module -> Module .
  eq onlyEqsNoBuiltInUnify(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = fmod (addsufix '-OnlyEqsNoBuiltInUnify To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsNoBuiltInUnify(E:EquationSet)
     endfm .
  eq onlyEqsNoBuiltInUnify(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-OnlyEqsNoBuiltInUnify To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsNoBuiltInUnify(E:EquationSet)
       R:RuleSet
     endm .

  *** onlyEqsNoVariant *******************************
  op onlyEqsNoVariant : Module -> Module .
  eq onlyEqsNoVariant(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = fmod (addsufix '-OnlyEqsNoVariant To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsNoVariant(E:EquationSet)
     endfm .
  eq onlyEqsNoVariant(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-OnlyEqsNoVariant To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsNoVariant(E:EquationSet)
       R:RuleSet
     endm .

  *** getEqsBuiltInUnify *******************************
  op getEqsBuiltInUnify : Module -> EquationSet .
  eq getEqsBuiltInUnify(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = getEqsBuiltInUnify(E:EquationSet) .
  eq getEqsBuiltInUnify(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = getEqsBuiltInUnify(E:EquationSet) .

  op getEqsBuiltInUnify : EquationSet -> EquationSet [memo] .
  eq getEqsBuiltInUnify(none) = none .
  eq getEqsBuiltInUnify((eq Lhs = Rhs [AtS metadata("builtin-unify")] .) EqS)
   = (eq Lhs = Rhs [AtS metadata("builtin-unify")] .) getEqsBuiltInUnify(EqS) .
  eq getEqsBuiltInUnify((eq Lhs = Rhs [AtS] .) EqS)
   = getEqsBuiltInUnify(EqS)
  [owise] .
  eq getEqsBuiltInUnify((ceq Lhs = Rhs if Cond [AtS] .) EqS)
   = getEqsBuiltInUnify(EqS) .

  *** getEqsVariant *******************************
  op getEqsVariant : Module -> EquationSet .
  eq getEqsVariant(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = getEqsVariant(E:EquationSet) .
  eq getEqsVariant(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = getEqsVariant(E:EquationSet) .

  op getEqsVariant : EquationSet -> EquationSet [memo] .
  eq getEqsVariant(none) = none .
  eq getEqsVariant((eq Lhs = Rhs [AtS variant] .) EqS)
   = (eq Lhs = Rhs [AtS variant] .) getEqsVariant(EqS) .
  eq getEqsVariant((eq Lhs = Rhs [AtS] .) EqS)
   = getEqsVariant(EqS)
  [owise] .
  eq getEqsVariant((ceq Lhs = Rhs if Cond [AtS] .) EqS)
   = getEqsVariant(EqS) .

  *** onlyEqsBuiltInUnify *******************************
  op onlyEqsBuiltInUnify : Module -> Module .
  eq onlyEqsBuiltInUnify(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsBuiltInUnify(E:EquationSet)
     endfm .
  eq onlyEqsBuiltInUnify(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsBuiltInUnify(E:EquationSet)
       R:RuleSet
     endm .

  *** onlyEqsVariant *******************************
  op onlyEqsVariant : Module -> Module .
  eq onlyEqsVariant(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsVariant(E:EquationSet)
     endfm .
  eq onlyEqsVariant(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       getEqsVariant(E:EquationSet)
       R:RuleSet
     endm .

  *** rls2eqs *******************************
  op rls2eqs# : RuleSet -> EquationSet [memo] .
  eq rls2eqs#(none) = none .
  eq rls2eqs#((rl Lhs => Rhs [AtS] .) RlS)
   = (eq Lhs = Rhs [AtS] .) rls2eqs#(RlS) .
  eq rls2eqs#((crl Lhs => Rhs if Cond [AtS] .) RlS)
   = (ceq Lhs = Rhs if Cond [AtS] .) rls2eqs#(RlS) .

  op rls2eqs : SModule -> SModule .
  eq rls2eqs(
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod (addsufix '-RLS2EQS To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet rls2eqs#(R:RuleSet)
       none
     endm .

  *** flipRls *******************************
  op flipRls : RuleSet -> RuleSet [memo] .
  eq flipRls(none) = none .
  eq flipRls((rl Lhs => Rhs [AtS] .) RlS:RuleSet)
   = if all Vars(Lhs) in Vars(Rhs)
     then (rl Rhs => Lhs [removeNonExec(AtS)] .)
     else (rl Rhs => Lhs [nonexec removeNonExec(AtS)] .)
     fi
     flipRls(RlS:RuleSet) .
  eq flipRls((crl Lhs => Rhs if Cond [AtS] .) RlS:RuleSet)
   = if all Vars(Lhs) in Vars(Rhs)
     then (crl Rhs => Lhs if Cond [removeNonExec(AtS)] .)
     else (crl Rhs => Lhs if Cond [nonexec removeNonExec(AtS)] .)
     fi
     flipRls(RlS:RuleSet) .

  op removeNonExec : AttrSet -> AttrSet .
  eq removeNonExec(nonexec AtS) = AtS .
  eq removeNonExec(AtS) = AtS [owise] .

  op flipRls : SModule -> SModule .
  eq flipRls(mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
             O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm)
   = mod (addsufix '-FLIPPEDRLS To Q:Qid)
     is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
     O:OpDeclSet M:MembAxSet E:EquationSet flipRls(R:RuleSet) endm .

  *** addOp *******************************
  op addOps : OpDeclSet SModule -> SModule .
  eq addOps(OO:OpDeclSet,mod Q:Qid is IL:ImportList sorts S:SortSet .
      S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm)
   = mod (addsufix '-ADDEDOPS To Q:Qid)
     is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
     override(O:OpDeclSet,OO:OpDeclSet)
     M:MembAxSet E:EquationSet R:RuleSet endm .
  op addOps : OpDeclSet FModule -> FModule .
  eq addOps(OO:OpDeclSet,fmod Q:Qid is IL:ImportList sorts S:SortSet .
      S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet endfm)
   = fmod (addsufix '-ADDEDOPS To Q:Qid)
     is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
     override(O:OpDeclSet,OO:OpDeclSet)
     M:MembAxSet E:EquationSet endfm .

  op override : OpDeclSet OpDeclSet -> OpDeclSet .
  eq override(
      (op F : TPL -> TP [AtS] .)  O:OpDeclSet,
      (op F : TPL -> TP [AtS'] .) O':OpDeclSet)
   = override(O:OpDeclSet,(op F : TPL -> TP [AtS'] .) O':OpDeclSet) .
  eq override(O:OpDeclSet,O':OpDeclSet)
   = O:OpDeclSet O':OpDeclSet [owise] .

  *** addRules *******************************
  op addRules : RuleSet SModule -> SModule [memo] .
  eq addRules(RR:RuleSet,mod Q:Qid is IL:ImportList sorts S:SortSet .
          S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm)
   = mod (addsufix '-ADDEDRLS To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet (R:RuleSet RR:RuleSet) endm .

  *** addEqs *******************************
  op addEqs : EquationSet SModule -> SModule .
  op addEqs : EquationSet FModule -> FModule .
  eq addEqs(ES:EquationSet,mod Q:Qid is IL:ImportList sorts S:SortSet .
          S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm)
   = mod (addsufix '-ADDEDEQS To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet (E:EquationSet ES:EquationSet) R:RuleSet endm .
  eq addEqs(ES:EquationSet,fmod Q:Qid is IL:ImportList sorts S:SortSet .
          S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet endfm)
   = fmod (addsufix '-ADDEDEQS To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet (E:EquationSet ES:EquationSet) endfm .

  *** addSorts *******************************
  op addSorts : SortSet SModule -> SModule .
  op addSorts : SortSet FModule -> FModule .
  eq addSorts(X:SortSet,
       mod Q:Qid is IL:ImportList sorts S:SortSet .
       S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm)
   = mod Q:Qid is IL:ImportList sorts (X:SortSet ; S:SortSet) .
       S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm .
  eq addSorts(X:SortSet,
       fmod Q:Qid is IL:ImportList sorts S:SortSet .
       S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet endfm)
   = fmod Q:Qid is IL:ImportList sorts (X:SortSet ; S:SortSet) .
       S:SubsortDeclSet O:OpDeclSet M:MembAxSet E:EquationSet endfm .

  *** putFrozen *******************************
  op putFrozen : NatList Qid TypeList SModule -> SModule [memo] .
  eq putFrozen(NL,F,TPL,
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [frozen(NL') AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix F To (addsufix '-FROZEN# To Q:Qid))
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [frozen(NL) AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm) .
  eq putFrozen(NL,F,TPL,
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix F To (addsufix '-FROZEN# To Q:Qid))
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [frozen(NL) AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm) [owise] .

  *** putStrat *******************************
  op putStrat : NatList Qid TypeList SModule -> SModule [memo] .
  eq putStrat(NL,F,TPL,
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [strat(NL') AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix F To (addsufix '-STRAT#EQ# To Q:Qid))
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [strat(NL) AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm) .
  eq putStrat(NL,F,TPL,
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix F To (addsufix '-STRAT#EQ# To Q:Qid))
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [strat(NL) AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm) [owise] .

  op putStrat : NatList Qid TypeList FModule -> FModule [memo] .
  eq putStrat(NL,F,TPL,
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [strat(NL') AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet endfm))
   = (fmod (addsufix F To (addsufix '-STRAT#EQ# To Q:Qid))
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [strat(NL) AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet endfm) .
  eq putStrat(NL,F,TPL,
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet endfm))
   = (fmod (addsufix F To (addsufix '-STRAT#EQ# To Q:Qid))
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [strat(NL) AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet endfm) [owise] .

  *** clearFrozen *******************************
  op clearFrozen : NatList Qid TypeList SModule -> SModule [memo] .
  eq clearFrozen(NL,F,TPL,
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [frozen(NL') AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [AtS] .) O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm) .
  eq clearFrozen(NL,F,TPL,M)
   = M [owise] .

  *** clearEqsFrozen *******************************
  op clearEqsFrozen : SModule -> SModule [memo] .
  eq clearEqsFrozen(M)
   = clearEqsFrozen*(M) .

  op clearEqsFrozen* : SModule -> SModule .
  eq clearEqsFrozen*(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [frozen(NL') AtS] .) O:OpDeclSet)
      M:MembAxSet
      ((eq F[TL] = Rhs [AtS'] .) E:EquationSet)
      R:RuleSet endm))
   = clearEqsFrozen*(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      ((op F : TPL -> TP [AtS] .) O:OpDeclSet)
      M:MembAxSet
      ((eq F[TL] = Rhs [AtS'] .) E:EquationSet)
      R:RuleSet endm)) .
  eq clearEqsFrozen*(M)
   = M [owise] .

  *** clearAllFrozen *******************************
  op clearAllFrozen : SModule -> SModule [memo] .
  eq clearAllFrozen(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet
      M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix '-CLEARFROZEN To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      clearAllFrozen(O:OpDeclSet)
      M:MembAxSet E:EquationSet R:RuleSet endm) .

  op clearAllFrozen : FModule -> FModule [memo] .
  eq clearAllFrozen(
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet
      M:MembAxSet E:EquationSet endfm))
   = (fmod (addsufix '-CLEARFROZEN To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      clearAllFrozen(O:OpDeclSet)
      M:MembAxSet E:EquationSet endfm) .

  op clearAllFrozen : OpDeclSet -> OpDeclSet .
  eq clearAllFrozen(none)
   = none .
  eq clearAllFrozen(
      (op F : TPL -> TP [frozen(NL) AtS] .) O:OpDeclSet)
   = (op F : TPL -> TP [AtS] .)
     clearAllFrozen(O:OpDeclSet) .
  eq clearAllFrozen(
      (op F : TPL -> TP [AtS] .) O:OpDeclSet)
   = (op F : TPL -> TP [AtS] .)
     clearAllFrozen(O:OpDeclSet) [owise] .

  *** anyNonExec *******************************
  op anyNonExec : SModule -> Bool [memo] .
  eq anyNonExec(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm))
   = anyNonExec(E:EquationSet) or-else anyNonExec(R:RuleSet) .

  op anyNonExec : RuleSet -> Bool .
  eq anyNonExec(
      (rl Lhs => Rhs [nonexec AtS] .) R:RuleSet)
   = true .
  eq anyNonExec(
      (crl Lhs => Rhs if Cond [nonexec AtS] .) R:RuleSet)
   = true .
  eq anyNonExec(R:RuleSet)
   = false [owise] .

  op anyNonExec : EquationSet -> Bool .
  eq anyNonExec(
      (eq Lhs = Rhs [nonexec AtS] .) R:EquationSet)
   = true .
  eq anyNonExec(
      (ceq Lhs = Rhs if Cond [nonexec AtS] .) R:EquationSet)
   = true .
  eq anyNonExec(R:EquationSet)
   = false [owise] .

  *** clearNonExec *******************************
  op clearNonExecRls&Eqs : SModule -> SModule [memo] .
  eq clearNonExecRls&Eqs(M:SModule)
   = clearNonExecRls(clearNonExecEqs(M:SModule)) .

  op clearNonExecRls : SModule -> SModule [memo] .
  eq clearNonExecRls(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix '-CLEARNONEXEC To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet
        E:EquationSet clearNonExec(R:RuleSet) endm) .

  op clearNonExecEqs : SModule -> SModule [memo] .
  eq clearNonExecEqs(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix '-CLEARNONEXEC To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet
        clearNonExec(E:EquationSet) R:RuleSet endm) .

  op clearNonExecEqs : FModule -> FModule [memo] .
  eq clearNonExecEqs(
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet endfm))
   = (fmod (addsufix '-CLEARNONEXEC To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet
        clearNonExec(E:EquationSet) endfm) .

  op clearNonExec : RuleSet -> RuleSet .
  eq clearNonExec((none).RuleSet)
   = (none).RuleSet .
  eq clearNonExec(
      (rl Lhs => Rhs [nonexec AtS] .) R:RuleSet)
   = (rl Lhs => Rhs [AtS] .)
     clearNonExec(R:RuleSet) .
  eq clearNonExec(
      (rl Lhs => Rhs [AtS] .) R:RuleSet)
   = (rl Lhs => Rhs [AtS] .)
     clearNonExec(R:RuleSet) [owise] .

  op clearNonExec : EquationSet -> EquationSet .
  eq clearNonExec((none).EquationSet)
   = (none).EquationSet .
  eq clearNonExec(
      (eq Lhs = Rhs [nonexec AtS] .) R:EquationSet)
   = (eq Lhs = Rhs [AtS] .)
     clearNonExec(R:EquationSet) .
  eq clearNonExec(
      (eq Lhs = Rhs [AtS] .) R:EquationSet)
   = (eq Lhs = Rhs [AtS] .)
     clearNonExec(R:EquationSet) [owise] .

  *** eraseRls *******************************
  op eraseRls : Module -> Module [memo] .
  eq eraseRls(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet none endm) .
  eq eraseRls(
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet endfm))
   = (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet endfm) .

  *** eraseEqs *******************************
  op eraseEqs : Module -> Module [memo] .
  eq eraseEqs(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet none R:RuleSet endm) .
  eq eraseEqs(
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet endfm))
   = (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet none endfm) .

  *** flatten  ******************************
  op flatten : Module TermList -> TermList .
  eq flatten(M,V) = V .
  eq flatten(M,C) = C .
  eq flatten(M,F[TL:NeTermList])
   = if isAssociative(M,F,getTypes(M,TL:NeTermList))
     then F[aliens(TL:NeTermList,F)]
     else F[flatten(M,TL:NeTermList)]
     fi .
  eq flatten(M,(T:Term,TL:NeTermList))
   = (flatten(M,T:Term),flatten(M,TL:NeTermList)) .

  op aliens : TermList Qid -> TermList .
  eq aliens(empty,F) = empty .
  eq aliens((F[TL':NeTermList],TL:TermList),F)
   = aliens((TL':NeTermList,TL:TermList),F) .
  eq aliens((T:Term,TL:TermList),F)
   = (T:Term,aliens(TL:TermList,F)) [owise] .

  *** unflatten  ******************************
  op unflatten : Module TermList -> TermList .
  eq unflatten(M,T) = unflatten*(M,T) .

  op unflatten* : Module TermList -> TermList .
  eq unflatten*(M,V) = V .
  eq unflatten*(M,C) = C .
  eq unflatten*(M,F[TL:NeTermList])
   = if isAssociative(M,F,getTypes(M,TL:NeTermList))
     then unflatten**(M,F,TL:NeTermList)
     else F[unflatten*(M,TL:NeTermList)]
     fi .
  eq unflatten*(M,(T:Term,TL:NeTermList))
   = (unflatten*(M,T:Term),unflatten*(M,TL:NeTermList)) .

  op unflatten** : Module Qid TermList -> TermList .
  eq unflatten**(M,F,(T1:Term,TL:NeTermList))
   = F[unflatten*(M,T1:Term),unflatten**(M,F,TL:NeTermList)] .
  eq unflatten**(M,F,T:Term)
   = unflatten*(M,T:Term) .

  *** wrapRules_bySymbol_ *******************************
  op wrapRules_bySymbol_ : SModule Qid -> SModule [memo] .
  eq wrapRules
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet
      M:MembAxSet E:EquationSet R:RuleSet endm)
     bySymbol F:Qid
   = (mod (addsufix F:Qid To (addsufix '-WRAPPED# To Q:Qid))
       is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet
      M:MembAxSet E:EquationSet
      wrapRules R:RuleSet bySymbol F:Qid endm) .

  op wrapRules_bySymbol_ : RuleSet Qid -> RuleSet .
  eq wrapRules none bySymbol F:Qid = none .
  eq wrapRules ((rl Lhs => Rhs [AtS] .) RlS:RuleSet) bySymbol F:Qid
   = (rl F:Qid[Lhs] => F:Qid[Rhs] [AtS] .)
     wrapRules RlS:RuleSet bySymbol F:Qid .
  eq wrapRules ((crl Lhs => Rhs if Cond [AtS] .) RlS:RuleSet) bySymbol F:Qid
   = (crl F:Qid[Lhs] => F:Qid[Rhs] if Cond [AtS] .)
     wrapRules RlS:RuleSet bySymbol F:Qid .

  op toSModule : FModule -> SModule .
  eq toSModule(
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   =  mod (addsufix '-CONVERTED#SMODULE To Q:Qid) is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       none
      endm .

  op newName : Qid SModule -> SModule .
  op newName : Qid FModule -> FModule .
  eq newName(F:Qid,
      fmod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm)
   = fmod F:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
      endfm .
  eq newName(F:Qid,
      mod Q:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm)
   = mod F:Qid is
       IL:ImportList
       sorts S:SortSet .
       S:SubsortDeclSet
       O:OpDeclSet
       M:MembAxSet
       E:EquationSet
       R:RuleSet
      endm .

  ***
  op removeBoolEqs : Module -> Module [memo] .
  eq removeBoolEqs(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet
      removeBoolEqs(E:EquationSet)
      R:RuleSet endm) .
  eq removeBoolEqs(
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet endfm))
   = (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet
      removeBoolEqs(E:EquationSet) endfm) .

  op removeBoolEqs : EquationSet -> EquationSet .
  eq removeBoolEqs((eq '_and_[TL] = Rhs [AtS] .) EqS)
   = removeBoolEqs(EqS) .
  eq removeBoolEqs((eq 'not_[TL] = Rhs [AtS] .) EqS)
   = removeBoolEqs(EqS) .
  eq removeBoolEqs((eq '_or_[TL] = Rhs [AtS] .) EqS)
   = removeBoolEqs(EqS) .
  eq removeBoolEqs((eq '_xor_[TL] = Rhs [AtS] .) EqS)
   = removeBoolEqs(EqS) .
  eq removeBoolEqs((eq '_implies_[TL] = Rhs [AtS] .) EqS)
   = removeBoolEqs(EqS) .
  eq removeBoolEqs(EqS)
   = EqS [owise] .

  *******************************************
  op changeNonSupportedAttr : Module -> Module [memo] .
  eq changeNonSupportedAttr(
     (mod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet R:RuleSet endm))
   = (mod (addsufix '-CHANGED-NONSUPPORTED-ATTRIBUTED To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      changeNonSupportedAttr*(O:OpDeclSet)
      M:MembAxSet
      changeNonSupportedAttr*(O:OpDeclSet,E:EquationSet)
      R:RuleSet endm) .
  eq changeNonSupportedAttr(
     (fmod Q:Qid is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      O:OpDeclSet M:MembAxSet E:EquationSet endfm))
   = (fmod (addsufix '-CHANGED-NONSUPPORTED-ATTRIBUTED To Q:Qid)
      is IL:ImportList sorts S:SortSet . S:SubsortDeclSet
      changeNonSupportedAttr*(O:OpDeclSet)
      M:MembAxSet
      changeNonSupportedAttr*(O:OpDeclSet,E:EquationSet)
      endfm) .

  op changeNonSupportedAttr* : OpDeclSet -> OpDeclSet .
 ceq changeNonSupportedAttr*((op F : TPL -> TP [assoc id(T) AtS] .) OPDS)
   = changeNonSupportedAttr*((op F : TPL -> TP [assoc AtS] .) OPDS)
  if not comm in AtS .
 ceq changeNonSupportedAttr*((op F : TPL -> TP [assoc left-id(T) AtS] .) OPDS)
   = changeNonSupportedAttr*((op F : TPL -> TP [assoc AtS] .) OPDS)
  if not comm in AtS .
 ceq changeNonSupportedAttr*((op F : TPL -> TP [assoc right-id(T) AtS] .) OPDS)
   = changeNonSupportedAttr*((op F : TPL -> TP [assoc AtS] .) OPDS)
  if not comm in AtS .
  eq changeNonSupportedAttr*(OPDS)
   = OPDS [owise] .

  op changeNonSupportedAttr* : OpDeclSet EquationSet -> EquationSet .
 ceq changeNonSupportedAttr*((op F : TP1 TP2 -> TP [assoc id(T) AtS] .) OPDS,EqS)
   = changeNonSupportedAttr*(OPDS,
       (eq F[addType TP1 ToVar 'X,T] = addType TP1 ToVar 'X [variant] .)
       (eq F[T,addType TP2 ToVar 'X] = addType TP2 ToVar 'X [variant] .)
       EqS)
  if not comm in AtS .
 ceq changeNonSupportedAttr*((op F : TP1 TP2 -> TP [assoc left-id(T) AtS] .) OPDS,EqS)
   = changeNonSupportedAttr*(OPDS,
       (eq F[T,addType TP2 ToVar 'X] = addType TP2 ToVar 'X [variant] .)
       EqS)
  if not comm in AtS .
 ceq changeNonSupportedAttr*((op F : TP1 TP2 -> TP [assoc right-id(T) AtS] .) OPDS,EqS)
   = changeNonSupportedAttr*(OPDS,
       (eq F[addType TP1 ToVar 'X,T] = addType TP1 ToVar 'X [variant] .)
       EqS)
  if not comm in AtS .
  eq changeNonSupportedAttr*(OPDS,EqS)
   = EqS [owise] .

  op _in_ : Attr AttrSet -> Bool .
  eq X:Attr in X:Attr XS:AttrSet = true .
  eq X:Attr in XS:AttrSet = false [owise] .

endfm

fmod FM-VARIANT is
  pr FM-SUBSTITUTION-HANDLING .
  pr FM-MODULE-HANDLING .
  pr FM-META-LEVEL-MNPA .

  var M : Module .
  vars T T' TS TS' CtTS CtTS' Lhs Rhs : Term .
  vars N N' NextVar NextVar' NextVar'' : Nat .
  var B : Bound .
  var TL TL' : TermList .
  var NeTL : NeTermList .
  var EqS : EquationSet .
  var AtS : AttrSet .
  var Q : Qid .
  vars S S' : Substitution .
  var V : Variable .
  vars TP TP' : Type .
  var C : Constant .
  vars F F' : Qid .

  --- Variants ----------------------------------------------------------
---  sort Variant .
---  op {_,_,_,_,_} : Term Substitution Nat Parent Bool -> Variant [ctor] .

  sort VariantTripleSet .
---  subsort VariantTriple < VariantTripleSet .
  subsort Variant < VariantTripleSet .
  op empty : -> VariantTripleSet [ctor] .
  op _|_ : VariantTripleSet VariantTripleSet -> VariantTripleSet
    [ctor assoc comm id: empty prec 65 format (d d n d)] .
---  eq X:VariantTriple | X:VariantTriple = X:VariantTriple .
  eq X:Variant | X:Variant = X:Variant .

  op getTerms : VariantTripleSet -> TermSet .
  eq getTerms({T:Term,S:Substitution,NextVar:Nat,P:Parent,B:Bool}
              | R:VariantTripleSet)
   = T:Term | getTerms(R:VariantTripleSet) .
  eq getTerms((empty).VariantTripleSet)
   = emptyTermSet .

  op getSubstitutions : VariantTripleSet -> SubstitutionSet .
  eq getSubstitutions({T:Term,S:Substitution,NextVar:Nat,P:Parent,B:Bool}
              | R:VariantTripleSet)
   = S:Substitution | getSubstitutions(R:VariantTripleSet) .
  eq getSubstitutions((empty).VariantTripleSet)
   = empty .

  --- Variants ----------------------------------------------------------
  sort VariantFour .
  op {_,_,_,_} : Term Substitution Substitution Nat -> VariantFour [ctor] .

  sort VariantFourSet .
  subsort VariantFour < VariantFourSet .
  op empty : -> VariantFourSet [ctor] .
  op _|_ : VariantFourSet VariantFourSet -> VariantFourSet
    [ctor assoc comm id: empty prec 65 format (d d n d)] .
  eq X:VariantFour | X:VariantFour = X:VariantFour .

endfm

fmod FM-META-MINIMIZE-BINDINGS is
  pr FM-SUBSTITUTION-HANDLING .
  pr FM-MODULE-HANDLING .
  pr FM-SUBSTITUTIONSET .
  pr FM-UNIFICATIONTRIPLESET .
  pr CONVERSION .
  pr FM-META-LEVEL-MNPA .
  pr FM-VARIANT .

  vars M : Module .
  vars T T' T1 T2 T3 : Term .
  vars TL TL' TL1 TL2 TL3 : TermList .
  vars F F' : Qid .
  vars S S' S* S'* : Substitution .
  vars V V' V1 V2 : Variable .
  vars N N' NOld : Nat .
  var US? : [UnificationTripleSet] .
  vars US US' : UnificationTripleSet .
  vars VTS VTS' : VariantFourSet .

  --- minimizeBindings ---
  op minimizeBindingsTerm : Module TermList UnificationTripleSet
                         -> UnificationTripleSet .
  eq minimizeBindingsTerm(M,TL,US)
   = minimizeBindingsTerm(M,TL,highestVar(TL),US) .

  op minimizeBindingsTerm : Module TermList Nat UnificationTripleSet
                         -> UnificationTripleSet .
  eq minimizeBindingsTerm(M,TL,NOld,US)
   = minimizeBindingsTerm*(M,TL,NOld,US,empty) .

  op minimizeBindingsTerm* : Module TermList Nat UnificationTripleSet
                             UnificationTripleSet -> UnificationTripleSet .
  eq minimizeBindingsTerm*(M,TL,NOld,empty,US')
   = US' .
  eq minimizeBindingsTerm*(M,TL,NOld,{S,S',N} | US,US')
   = minimizeBindingsTerm*(M,TL,NOld,US,
        US' | minimizeBindingsTerm**(M,TL,NOld,{S,S',N},S,S')
     ) .

  ****************
  op minimizeBindingsTerm** : Module TermList ---variables to minimize bindings
                             Nat --- or maximum index of variables
                             UnificationTriple Substitution Substitution
                          -> UnificationTriple .
  eq minimizeBindingsTerm**(M,TL',NOld,{S*,S'*,N},none,none)
   = {remDup(S*),remDup(S'*),N} .

 ceq minimizeBindingsTerm**(M,TL',NOld,{S*,V <- V' ; S'*,N},none,V <- V' ; S')
   = minimizeBindingsTerm**(M,TL',NOld,
         {  S* << (V' <- V),    S'* .. (V' <- V),  N},
         none,
         S' .. (V' <- V)
     )
  if V' =/= V and-then not (V in TL') and-then not (V' in TL')
     and-then highestVar(V) < NOld
     and-then highestVar(V') >= NOld
     and-then typeLeq(M,getTypes(M,V),getTypes(M,V')) .

  eq minimizeBindingsTerm**(M,TL',NOld,{S*,V <- T' ; S'*,N},none,V <- T' ; S')
   = minimizeBindingsTerm**(M,TL',NOld,{S*,V <- T' ; S'*,N},none,S')
  [owise] .

 ceq minimizeBindingsTerm**(M,TL',NOld,{V <- V' ; S*,S'*,N},V <- V' ; S,S')
   = minimizeBindingsTerm**(M,TL',NOld,
         { S* << (V' <- V),   S'* .. (V' <- V),   N},
         S << (V' <- V),
         S' .. (V' <- V)
     )
  if V' =/= V and-then V in TL' and-then not (V' in TL')
     and-then typeLeq(M,getTypes(M,V),getTypes(M,V')) .

  eq minimizeBindingsTerm**(M,TL',NOld,{V <- T' ; S*,S'*,N},V <- T' ; S,S')
   = minimizeBindingsTerm**(M,TL',NOld,{V <- T' ; S*,S'*,N},S,S')
  [owise] .

  --- minimizeBindings ---
  op minimizeBindingsTerm : Module TermList VariantFourSet
                         -> VariantFourSet .
  eq minimizeBindingsTerm(M,TL,VTS)
   = minimizeBindingsTerm(M,TL,highestVar(TL),VTS) .

  op minimizeBindingsTerm : Module TermList Nat VariantFourSet
                         -> VariantFourSet .
  eq minimizeBindingsTerm(M,TL,NOld,VTS)
   = minimizeBindingsTerm*(M,TL,NOld,VTS,empty) .

  op minimizeBindingsTerm* : Module TermList Nat VariantFourSet
                             VariantFourSet -> VariantFourSet .
  eq minimizeBindingsTerm*(M,TL,NOld,empty,VTS')
   = VTS' .
  eq minimizeBindingsTerm*(M,TL,NOld,{T,S,S',N} | VTS,VTS')
   = minimizeBindingsTerm*(M,TL,NOld,VTS,
        VTS' | minimizeBindingsTerm**(M,TL,NOld,{T,S,S',N},S,S')
     ) .

  ****************
  op minimizeBindingsTerm** : Module TermList ---variables to minimize bindings
                             Nat --- or maximum index of variables
                             VariantFour Substitution Substitution
                          -> VariantFour .
  eq minimizeBindingsTerm**(M,TL',NOld,{T,S*,S'*,N},none,none)
   = {T,remDup(S*),remDup(S'*),N} .

 ceq minimizeBindingsTerm**(M,TL',NOld,{T,S*,V <- V' ; S'*,N},none,V <- V' ; S')
   = minimizeBindingsTerm**(M,TL',NOld,
         { T << (V' <- V), S* << (V' <- V),    S'* .. (V' <- V),  N},
         none,
         S' .. (V' <- V)
     )
  if V' =/= V and-then not (V in TL') and-then not (V' in TL')
     and-then highestVar(V) < NOld
     and-then highestVar(V') >= NOld
     and-then typeLeq(M,getTypes(M,V),getTypes(M,V')) .

  eq minimizeBindingsTerm**(M,TL',NOld,{T,S*,V <- T' ; S'*,N},none,V <- T' ; S')
   = minimizeBindingsTerm**(M,TL',NOld,{T,S*,V <- T' ; S'*,N},none,S')
  [owise] .

 ceq minimizeBindingsTerm**(M,TL',NOld,{T,V <- V' ; S*,S'*,N},V <- V' ; S,S')
   = minimizeBindingsTerm**(M,TL',NOld,
         { T << (V' <- V), S* << (V' <- V),   S'* .. (V' <- V),   N},
         S << (V' <- V),
         S' .. (V' <- V)
     )
  if V' =/= V and-then V in TL' and-then not (V' in TL')
     and-then typeLeq(M,getTypes(M,V),getTypes(M,V')) .

  eq minimizeBindingsTerm**(M,TL',NOld,{T,V <- T' ; S*,S'*,N},V <- T' ; S,S')
   = minimizeBindingsTerm**(M,TL',NOld,{T,V <- T' ; S*,S'*,N},S,S')
  [owise] .

  ****
  op remDup : Substitution -> Substitution .
  eq remDup(V <- V ; S) = remDup(S) .
  eq remDup(S) = S [owise] .
endfm

fmod FM-TYPEOFNARROWING is
  pr QID .
  pr META-TERM .

  --- TypeOfNarrowing ----------------------------------
  sorts TypeOfNarrowingElem TypeOfNarrowing .
  subsort TypeOfNarrowingElem < TypeOfNarrowing .
  op none : -> TypeOfNarrowing [ctor] .
  op __ : TypeOfNarrowing TypeOfNarrowing -> TypeOfNarrowing
          [ctor assoc comm id: none] .
  ---eq X:TypeOfNarrowingElem X:TypeOfNarrowingElem = X:TypeOfNarrowingElem .

  *** select one and only one of the following
  op full : -> TypeOfNarrowingElem [ctor] .
  op basic : -> TypeOfNarrowingElem [ctor] .
  op variant : -> TypeOfNarrowingElem [ctor] .
  op variant : Nat -> TypeOfNarrowingElem [ctor] .
  op E-rewriting : -> TypeOfNarrowingElem [ctor] .

  *** Extra flags
  op rigidife : Qid -> TypeOfNarrowingElem [ctor] .

  *** Irreducible terms for equational unification to check
  op irrTerms : TermList -> TypeOfNarrowingElem [ctor] .

  op getIrrTerms : TypeOfNarrowing -> TermList .
  eq getIrrTerms(X:TypeOfNarrowing irrTerms(TL:TermList)) = TL:TermList .
  eq getIrrTerms(X:TypeOfNarrowing) = empty [owise] .

  *** select one and only one of the following
  op E-ACU-unify : -> TypeOfNarrowingElem [ctor] .
  op E-ACU-unify-Irr : -> TypeOfNarrowingElem [ctor] .
  op ACU-unify : -> TypeOfNarrowingElem [ctor] .
  op BuiltIn-unify : -> TypeOfNarrowingElem [ctor] .
  op E-BuiltIn-unify : -> TypeOfNarrowingElem [ctor] .
  op E-BuiltIn-unify-Irr : -> TypeOfNarrowingElem [ctor] .

  *** select one and only one of the following
  op noStrategy : -> TypeOfNarrowingElem [ctor] .
  op topmost : -> TypeOfNarrowingElem [ctor] .
  op innermost : -> TypeOfNarrowingElem [ctor] .
  op outermost : -> TypeOfNarrowingElem [ctor] .

  *** select any combination of the following
  op E-normalize-terms : -> TypeOfNarrowingElem [ctor] .
  op normalize-terms : -> TypeOfNarrowingElem [ctor] .
  op computed-normalized-subs : -> TypeOfNarrowingElem [ctor] .
  op applied-normalized-subs : -> TypeOfNarrowingElem [ctor] .
  op minimal-unifiers : -> TypeOfNarrowingElem [ctor] .
  op testUnifier : -> TypeOfNarrowingElem [ctor] .
  op alsoAtVarPosition : -> TypeOfNarrowingElem [ctor] .

  op _in_ : TypeOfNarrowingElem TypeOfNarrowing -> Bool .
  eq X:TypeOfNarrowingElem in X:TypeOfNarrowingElem XS:TypeOfNarrowing
   = true .
  eq variant in variant(N:Nat) XS:TypeOfNarrowing
   = true .
  eq X:TypeOfNarrowingElem in XS:TypeOfNarrowing
   = false [owise] .

  op _!in_ : TypeOfNarrowingElem TypeOfNarrowing -> Bool .
  eq X:TypeOfNarrowingElem !in XS:TypeOfNarrowing
   = not (X:TypeOfNarrowingElem in XS:TypeOfNarrowing) .
  -------------------------------------------------------

  sort TypeOfRelation .
  ops '* '! '+ : -> TypeOfRelation .

  op [_] : TypeOfRelation -> Qid .
  eq [ '+ ] = qid("+") .
  eq [ '* ] = qid("*") .
  eq [ '! ] = qid("!") .

  op typeOfRelation : Qid ~> TypeOfRelation .
  eq typeOfRelation( '+ ) = '+ .
  eq typeOfRelation( '* ) = '* .
  eq typeOfRelation( '! ) = '! .
endfm

fmod FM-IRR-FLAGS is
  sort IrrFlags .
  op __ : IrrFlags IrrFlags -> IrrFlags [assoc comm id: none] .
  op none : -> IrrFlags [ctor] .
  op irreducible : -> IrrFlags [ctor] .
  op reducible : -> IrrFlags [ctor] .
  op minimal-unifiers : -> IrrFlags [ctor] .
endfm

fmod FM-EFLAGS is
  pr FM-TYPEOFNARROWING .
  pr FM-IRR-FLAGS .

  sort EFlags .
  subsort IrrFlags < EFlags .
  op __ : EFlags EFlags -> EFlags [assoc comm id: none] .
  op none : -> EFlags [ctor] .
  op ACUUnify : -> EFlags [ctor] .
  op BuiltInUnify : -> EFlags [ctor] .
  op testUnifier : -> EFlags [ctor] .

  op _in_ : EFlags EFlags -> Bool .
  eq X:EFlags in X:EFlags Y:EFlags = true .
  eq X:EFlags in Y:EFlags = false [owise] .

  op _!in_ : EFlags EFlags -> Bool .
  eq X:EFlags !in Y:EFlags = not (X:EFlags in Y:EFlags) .

  op [_] : EFlags -> TypeOfNarrowing .
  eq [ ACUUnify X:EFlags ] = ACU-unify [ X:EFlags ] .
  eq [ BuiltInUnify X:EFlags ] = BuiltIn-unify [ X:EFlags ] .
  eq [ minimal-unifiers X:EFlags ] = minimal-unifiers [ X:EFlags ] .
  eq [ testUnifier X:EFlags ] = testUnifier [ X:EFlags ] .
  eq [ X:EFlags ] = none [owise] .
endfm

fmod FM-RESULT-CONTEXT-SET is
  protecting META-TERM .
  protecting FM-META-LEVEL-MNPA .
  protecting FM-TERM-HANDLING .
  protecting FM-SUBSTITUTION-HANDLING .
  protecting FM-RENAMING .
  protecting FM-SUBSTITUTIONSET .
  protecting FM-UNIFICATIONTRIPLESET .
  protecting FM-MODULE-HANDLING .

  vars T T' TS CtTS : Term .
  var TP : Type .
  vars S S' Subst Subst' : Substitution .
  var NL : NatList .
  var M : Module .
  vars Ct CtS : Context .
  vars RTS RTS' : ResultContextSet .
  vars NextVar N : Nat .
  var TL : TermList .

  op subTerm_of_ : NatList ResultTriple ~> ResultTriple .
  eq subTerm NL of {T,TP,S} = {subTerm NL of T,TP,S} .

  op replaceSubTerm_of_by_ : NatList ResultTriple Term ~> ResultTriple .
  eq replaceSubTerm NL of {T,TP,S} by T' = {replaceSubTerm NL of T by T',TP,S} .

  --- ResultTriple ---------------------------
  --- op {_,_,_} : Term Type Substitution -> ResultTriple [ctor] .

  sort ResultTripleSet .
  subsort ResultTriple < ResultTripleSet .
  op empty : -> ResultTripleSet [ctor] .
  op _|_ : ResultTripleSet ResultTripleSet -> ResultTripleSet
    [ctor assoc comm id: empty prec 65 format (d d n d)] .
  eq X:ResultTriple | X:ResultTriple = X:ResultTriple .

  var RT : ResultTripleSet .

  op _|>_ : ResultTripleSet TermList -> ResultTripleSet .
  eq (empty).ResultTripleSet |> TL = (empty).ResultTripleSet .
  eq ({T,TP,S} | RT) |> TL = {T,TP,S |> TL} | (RT |> TL) .
  eq (failure | RT ) |> TL = failure | (RT |> TL) .

  op getTerms : ResultTripleSet -> TermSet .
  eq getTerms({T:Term,TP:Type,S:Substitution} | R:ResultTripleSet)
   = T:Term | getTerms(R:ResultTripleSet) .
  eq getTerms((empty).ResultTripleSet)
   = emptyTermSet .

  op getSubstitutions : ResultTripleSet -> SubstitutionSet .
  eq getSubstitutions({T,TP,S} | R:ResultTripleSet)
   = S | getSubstitutions(R:ResultTripleSet) .
  eq getSubstitutions((empty).ResultTripleSet)
   = (empty).SubstitutionSet .

  --- ResultContextSet ---------------------------

  --- Flags
  sort Flags Flag .
  subsort Flag < Flags .

  op empty : -> Flags [ctor] .
  op __ : Flags Flags -> Flags [ctor assoc comm id: empty] .
  eq X:Flag X:Flag = X:Flag .

  --- Flag to know whether term is a end point or not
  op end : Bool -> Flag [ctor frozen] .

  op end : Bool Flags -> Flags .
  eq end(B:Bool, end(B':Bool) B:Flags) = end(B:Bool) B:Flags .
  eq end(B:Bool, B:Flags) = end(B:Bool) B:Flags [owise] .

  op end : Flags -> Bool .
  eq end(end(B:Bool) B:Flags) = B:Bool .
  eq end(B:Flags) = false [owise] .
  ---

  sorts TraceNarrowStep TraceNarrow TraceNarrowSet .
  subsort TraceNarrowStep < TraceNarrow < TraceNarrowSet .
  op {_,_,_,_} : Term Substitution Type Rule -> TraceNarrowStep [ctor format (d d d d d n d n d d)] .
  op nil : -> TraceNarrow [ctor] .
  op __ : TraceNarrow TraceNarrow -> TraceNarrow [ctor assoc id: nil format (d n d)] .
  op empty : -> TraceNarrowSet [ctor] .
  op _|_ : TraceNarrowSet TraceNarrowSet -> TraceNarrowSet [ctor assoc comm id: empty format (d n n d)] .

  ---
  sorts ResultContext ResultContextSet ResultContextNeSet .
  op {_,_,_,_,_,_,_,_,_,_,_} :
      Term Type
      Substitution Substitution --- computed subs and applied subst
      Context Context --- Original and WithSubst
      Term Term --- TermWithSubst and ContextWithTermAndSubt
      Nat --- highest index of variable
      TraceNarrow
      Flags
      -> ResultContext [ctor] .

  subsort ResultContext < ResultContextNeSet < ResultContextSet .
  op empty : -> ResultContextSet [ctor] .
  op _|_ : ResultContextSet ResultContextSet -> ResultContextSet
    [ctor assoc comm id: empty prec 65 format (d n d d)] .
  op _|_ : ResultContextNeSet ResultContextSet -> ResultContextNeSet
    [ctor ditto] .
  eq X:ResultContext | X:ResultContext = X:ResultContext .

  op getCTTerm : ResultContext -> Term .
  eq getCTTerm(
      {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags})
   = CtTS:Term .
  op getNextVar : ResultContext -> Nat .
  eq getNextVar(
      {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags})
   = NextVar .
  op getLSubst : ResultContext -> Substitution .
  eq getLSubst(
      {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags})
   = S .
  op getRSubst : ResultContext -> Substitution .
  eq getRSubst(
      {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags})
   = S' .

  op _<<_ : ResultContext UnificationTripleSet -> ResultContextSet .
  eq {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
     << (empty).UnificationTripleSet
   = (empty).ResultContextSet .
  eq {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
     << ({Subst,Subst',N} | SS:UnificationTripleSet)
   = {T,
      TP,
      (S .. Subst) << Subst', (S' .. Subst') << Subst,
      Ct:Context,
      CtS:Context << (Subst ; Subst'),
      TS:Term << (Subst ; Subst'),
      CtTS:Term << (Subst ; Subst'),
      max(NextVar,N + 1),
      (Tr:TraceNarrow << T TP <) << {Subst,Subst',N},
      B:Flags}
     | {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
         << SS:UnificationTripleSet .

  op _<<__< : TraceNarrow Term Type -> TraceNarrow .
  eq (nil).TraceNarrow << T:Term TP:Type <
   = (nil).TraceNarrow .
  eq (Tr:TraceNarrow {T$:Term,none,TP$:Type,R:Rule}) --- Subst none here is special
     << T:Term TP:Type <
   = (Tr:TraceNarrow {T:Term,none,TP:Type,R:Rule}) .
  eq (Tr:TraceNarrow {T$:Term,S:Substitution,TP$:Type,R:Rule})
     << T:Term TP:Type <
   = (Tr:TraceNarrow {T$:Term,S:Substitution,TP$:Type,R:Rule}) [owise] .

  op _<<_ : TraceNarrow UnificationTriple -> TraceNarrow .
  eq (nil).TraceNarrow << {Subst,Subst',N}
   = (nil).TraceNarrow .
  eq (Tr:TraceNarrow {T$:Term,S:Substitution,TP$:Type,R:Rule}) --- Subst none here is special
     << {Subst,Subst',N}
   = (Tr:TraceNarrow {T$:Term << (Subst ; Subst'),S:Substitution .. (Subst ; Subst'),TP$:Type,R:Rule}) .

  op canonice : Module TraceNarrow -> TraceNarrow .
  eq canonice(M, (nil).TraceNarrow) = nil .
  eq canonice(M, Tr:TraceNarrow {T$:Term,S:Substitution,TP$:Type,R:Rule})
   = {canonice(M,T$:Term),canonice(M,S:Substitution),TP$:Type,R:Rule} canonice(M, Tr:TraceNarrow) .

  op toTriple : Module ResultContextSet -> ResultTripleSet .
  eq toTriple(M, empty ) = empty .
  eq toTriple(M, {T,TP,S,S',Ct,CtS,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags} | RTS )
   = {CtTS:Term, leastSort(M,CtTS:Term), S .. S'}
     | toTriple(M,RTS) .

  op _|>_ : ResultContextSet TermList -> ResultContextSet .
  eq (empty).ResultContextSet |> TL = (empty).ResultContextSet .
  eq ({T,TP,S,S',Ct,CtS,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
      | RTS:ResultContextSet) |> TL
   = {T,TP,S |> TL,S' |> TL,Ct,CtS,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
     | (RTS:ResultContextSet |> TL) .

  op getTerms : ResultContextSet -> TermSet .
  eq getTerms({T,TP,S,S',Ct,CtS,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags} | RTS)
   = CtTS:Term | getTerms(RTS) .
  eq getTerms((empty).ResultContextSet)
   = emptyTermSet .

  op toUnificationTriples : ResultContextSet -> UnificationTripleSet .
  eq toUnificationTriples(
      {T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags} | R:ResultContextSet)
   = {S,S',NextVar}
     | toUnificationTriples(R:ResultContextSet) .
  eq toUnificationTriples((empty).ResultContextSet)
   = (empty).UnificationTripleSet .

  *** auxiliary Sort SubstitutionCond for metaNarrowSearch *****
  sort SubstitutionCond .
  subsort Substitution < SubstitutionCond .

  op |_| : ResultTripleSet -> Nat .
  eq | (empty).ResultTripleSet | = 0 .
  eq | (RT:ResultTriple | RTS:ResultTripleSet) |
   = | RTS:ResultTripleSet | + 1 .

  op |_| : ResultContextSet -> Nat .
  eq | (empty).ResultContextSet | = 0 .
  eq | (RT:ResultContext | RTS:ResultContextSet) |
   = | RTS:ResultContextSet | + 1 .

endfm

fmod FM-META-MATCH is
  protecting FM-TERM-HANDLING .
  protecting FM-MODULE-HANDLING .
  protecting FM-SUBSTITUTION-HANDLING .
  protecting FM-META-LEVEL-MNPA .
  protecting FM-RENAMING .
  protecting FM-SUBSTITUTIONSET .

  vars T T' : Term .
  vars TL TL' : TermList .
  var M : Module .
  vars S S' : Substitution .
  var S? : Substitution? .
  vars SS SS' : SubstitutionSet .
  vars V V' : Variable .
  vars TPL TPL' : TypeList .
  vars N N' : Nat .

  --- Not defined in this module ----------------------------------------
  op isNF$ : Module Term ~> Bool .
  --- Not defined in this module ----------------------------------------

  --- metaCoreMatch(M,T,T') implies that T is an instance of T'
  op metaCoreMatch : Module Term Term -> SubstitutionSet .
  eq metaCoreMatch(M,T,T')
   = metaCoreMatch$(M,canonice(M,T),canonice(M,T')) .

  op metaCoreMatch$ : Module Term Term -> SubstitutionSet .
  eq metaCoreMatch$(M,T,T')
   = if glbSorts(M,leastSort(M,T),leastSort(M,T')) == none
     then empty
     else metaCoreMatchCollect(eraseEqs(eraseRls(M)),T,T')
     fi .

  op metaCoreMatch? : Module Term Term -> Bool .
  eq metaCoreMatch?(M,T,T')
   = metaCoreMatch?$(M,canonice(M,T),canonice(M,T')) .

  op metaCoreMatch?$ : Module Term Term -> Bool .
  eq metaCoreMatch?$(M,T,T')
   = glbSorts(M,leastSort(M,T),leastSort(M,T')) =/= none
     and-then
     metaMatch(eraseEqs(eraseRls(M)),T',T,nil,0) =/= noMatch .

  --- metaCoreMatchCollect(M,T,T') calls Maude metaMatch
  op metaCoreMatchCollect : Module Term Term -> SubstitutionSet .
  eq metaCoreMatchCollect(M,T,T')
   = metaCoreMatchCollect*(M,T,T',empty,0) .

  op metaCoreMatchCollect* : Module Term Term SubstitutionSet Nat
                             -> SubstitutionSet .
  eq metaCoreMatchCollect*(M,T,T',SS,N:Nat)
   = if metaMatch(M,T',T,nil,N:Nat) =/= noMatch
     then metaCoreMatchCollect*(M,T,T',
                            SS | metaMatch(M,T',T,nil,N:Nat),
                            s(N:Nat))
     else SS
     fi .

  op metaBuiltInEqual : Module TermList Term Term -> Bool .
  eq metaBuiltInEqual(M,TL,T,T')
   = canonice(M,T) == canonice(M,T') .

endfm
fmod FM-VARIANT-HANDLING is
  pr FM-SUBSTITUTION-HANDLING .
  pr FM-META-MINIMIZE-BINDINGS .
  pr FM-RESULT-CONTEXT-SET .
  pr FM-MODULE-HANDLING .
  pr FM-META-LEVEL-MNPA .
  pr FM-VARIANT .

  var M : Module .
  vars T T' TS TS' CtTS CtTS' Lhs Rhs : Term .
  vars N N' NextVar NextVar' NextVar'' : Nat .
  var B : Bound .
  var TL TL' : TermList .
  var NeTL : NeTermList .
  var EqS : EquationSet .
  var AtS : AttrSet .
  var Q : Qid .
  vars S S' : Substitution .
  var V : Variable .
  var R RT : ResultContext .
  vars RTS RTS' : ResultContextSet .
  vars TP TP' : Type .
  vars Ct Ct' CtS CtS' : Context .
  var C : Constant .
  vars F F' : Qid .

  var VTS : VariantFourSet .
  var VT3S : VariantTripleSet .

  op toVariants : Nat ResultContextSet -> VariantFourSet .
  eq toVariants(OldNextVar:Nat,empty)
   = empty .
  eq toVariants(OldNextVar:Nat,{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags} | RTS)
   = {CtTS,S |> OldNextVar:Nat,S' |> OldNextVar:Nat,NextVar}
      | toVariants(OldNextVar:Nat,RTS) .

  op _|>_ : VariantFourSet TermList -> VariantFourSet .
  eq (empty).VariantFourSet |> TL = empty .
  eq ({T,S,S',N} | VTS) |> TL = {T,(S |> TL),(S' |> TL),N} | (VTS |> TL) .

  op getTerms : VariantFourSet -> TermSet .
  eq getTerms({T:Term,S:Substitution,S':Substitution,NextVar:Nat}
              | R:VariantFourSet)
   = T:Term | getTerms(R:VariantFourSet) .
  eq getTerms((empty).VariantFourSet)
   = emptyTermSet .

  op toVariantTripleSet : VariantFourSet -> VariantTripleSet .
  eq toVariantTripleSet(empty)
   = empty .
  eq toVariantTripleSet({T,S,S',NextVar} | VTS)
   = {T,S,NextVar,none,false} | toVariantTripleSet(VTS) .

  op toVariantFourSet : VariantTripleSet -> VariantFourSet .
  eq toVariantFourSet(empty)
   = empty .
  eq toVariantFourSet({T,S,NextVar,none,false} | VT3S)
   = {T,S,none,NextVar} | toVariantFourSet(VT3S) .

endfm

fmod FM-RIGIDIFE is
  protecting FM-UNIFICATIONTRIPLESET .
  protecting FM-MODULE-HANDLING .
  protecting FM-RESULT-CONTEXT-SET .
  protecting FM-VARIANT .

  vars V V' : Variable .
  var C : Constant .
  vars F Q : Qid .
  vars U U' : UnificationTriple .
  vars US US' : UnificationTripleSet .
  vars S S' S1 S1' S2 S2' S* : Substitution .
  vars Ct CtS Ct' CtS' : Context .
  vars TS TS' CtTS CtTS' : Term .
  var SS : SubstitutionSet .
  var SSe : NeSubstitutionSet .
  vars N N' N1 N2 NextVar : Nat .
  vars T T' : Term .
  vars TL TL' : TermList .
  var NeTL : NeTermList .
  var M : Module .
  var RTS : ResultTripleSet .
  var TP : Type .

  sort PairRigidife .
  op {_,_} : Module TermList -> PairRigidife .
  op getM : PairRigidife -> Module .
  eq getM({M,TL}) = M .
  op getTL : PairRigidife -> TermList .
  eq getTL({M,TL}) = TL .

  *** Transform variables in TermList into constants
  op rigidifeList : Module Qid TermList TermList -> PairRigidife .
  eq rigidifeList(M,Q,TL,empty)
   = {M,TL} .
  eq rigidifeList(M,Q,(T,NeTL),TL)
   = { getM(rigidifeList(getM(rigidifeList(M,Q,T,TL)),Q,NeTL,TL)),
       (getTL(rigidifeList(M,Q,T,TL)),
        getTL(rigidifeList(getM(rigidifeList(M,Q,T,TL)),Q,NeTL,TL))) } .
  eq rigidifeList(M,Q,C,TL)
   = {M,C} .
  eq rigidifeList(M,Q,F[NeTL],TL)
   = {getM(rigidifeList(M,Q,NeTL,TL)),
      F[getTL(rigidifeList(M,Q,NeTL,TL))]} .
  eq rigidifeList(M,Q,V,TL)
   = if V in TL then rigidifeVar***(M,Q,V) else {M,V} fi .

  *** Transform all variables into constants
  op rigidifeAllVar : Module Qid TermList -> PairRigidife .
  eq rigidifeAllVar(M,Q,TL)
   = rigidifeNat(M,Q,TL,0) .

  *** Transform variables above Nat into constants
  op rigidifeNat : Module Qid TermList Nat -> PairRigidife .
  eq rigidifeNat(M,Q,(T,NeTL),N)
   = { getM(rigidifeNat(getM(rigidifeNat(M,Q,T,N)),Q,NeTL,N)),
       (getTL(rigidifeNat(M,Q,T,N)),
        getTL(rigidifeNat(getM(rigidifeNat(M,Q,T,N)),Q,NeTL,N))) } .
  eq rigidifeNat(M,Q,C,N)
   = {M,C} .
  eq rigidifeNat(M,Q,F[NeTL],N)
   = {getM(rigidifeNat(M,Q,NeTL,N)),
      F[getTL(rigidifeNat(M,Q,NeTL,N))]} .
  eq rigidifeNat(M,Q,V,N)
   = if highestVar(V) >= N then rigidifeVar***(M,Q,V) else {M,V} fi .

  *** Transform variables with rigid# into constants
  op rigidifeRigid : Module Qid TermList -> PairRigidife .
  eq rigidifeRigid(M,Q,(T,NeTL))
   = { getM(rigidifeRigid(getM(rigidifeRigid(M,Q,T)),Q,NeTL)),
       (getTL(rigidifeRigid(M,Q,T)),
        getTL(rigidifeRigid(getM(rigidifeRigid(M,Q,T)),Q,NeTL))) } .
  eq rigidifeRigid(M,Q,C)
   = {M,C} .
  eq rigidifeRigid(M,Q,F[NeTL])
   = {getM(rigidifeRigid(M,Q,NeTL)),
      F[getTL(rigidifeRigid(M,Q,NeTL))]} .
  eq rigidifeRigid(M,Q,V)
   = if rfind(string(V), "rigid#", length(string(V))) =/= notFound
     then rigidifeVar***(M,Q,V)
     else {M,V}
     fi .

  *** Basic case for transforming variables into constants
  op rigidifeVar*** : Module Qid Variable -> PairRigidife .
  ceq rigidifeVar***(M,Q,V)
    = {addOps((op qid(F:String) : nil -> getType(V) [none].), M),
       qid(F:String + "." + string(getType(V)))}
   if F:String := "rigid@" + string(Q)
                     + "@" + string(getName(V)) + "@" + string(getType(V)) .

  *** Undo the transformation of variables into constants
  op unrigidife : Qid TermList -> TermList .
  eq unrigidife(Q,(T,NeTL))
   = (unrigidife(Q,T),unrigidife(Q,NeTL)) .
  eq unrigidife(Q,V) = V .
  eq unrigidife(Q,F[TL]) = F[unrigidife(Q,TL)] .
  eq unrigidife(Q,C)
   = if rfind(string(C), "rigid@" + string(Q) + "@", length(string(C)))
          =/= notFound
     then qid(
           string(
             qid(
              substr(string(C),
               rfind(string(C), "rigid@" + string(Q) + "@", length(string(C)))
                + 7 + length(string(Q)),
               rfind(
                substr(string(C),
                  rfind(string(C), "rigid@" + string(Q) + "@", length(string(C)))
                   + 7 + length(string(Q)),
                  length(string(C))),
                "@",length(string(C))
               )
              )
             )
           )
           + ":" +
           string(getType(qid(
                   substr(string(C),
                   rfind(string(C), "rigid@" + string(Q) + "@",
                           length(string(C))) + 7 + length(string(Q)),
                   length(string(C)))
           )))
          )
     else C
     fi .

  op unrigidife : Qid Substitution -> Substitution .
  eq unrigidife(Q,(none).Substitution) = none .
  eq unrigidife(Q,V <- T ; S)
   = unrigidife(Q,V) <- unrigidife(Q,T) ; unrigidife(Q,S) .

  op unrigidife : Qid SubstitutionSet -> SubstitutionSet .
  eq unrigidife(Q,(empty).SubstitutionSet) = empty .
  eq unrigidife(Q,S | SSe)
   = unrigidife(Q,S) | unrigidife(Q,SSe) .

  op unrigidife : Qid UnificationTripleSet -> UnificationTripleSet .
  eq unrigidife(Q,(empty).UnificationTripleSet) = empty .
  eq unrigidife(Q,{S1,S2,N'} | US)
   = {unrigidife(Q,S1),unrigidife(Q,S2),N'}
     | unrigidife(Q,US) .

  op unrigidife : Qid ResultTripleSet -> ResultTripleSet .
  eq unrigidife(Q,(empty).ResultTripleSet) = empty .
  eq unrigidife(Q,{T,TP,S} | RTS)
   = {unrigidife(Q,T),TP,unrigidife(Q,S)}
     | unrigidife(Q,RTS) .

  op unrigidife : Qid VariantFourSet -> VariantFourSet  .
  eq unrigidife(Q,(empty).VariantFourSet) = empty .
  eq unrigidife(Q,{T,S,S',N} | R:VariantFourSet)
   = {unrigidife(Q,T),unrigidife(Q,S),unrigidife(Q,S'),N}
     | unrigidife(Q,R:VariantFourSet) .

  *** Label variables with rigid
  op rigidLabel : Module TermList TermList -> TermList .
  eq rigidLabel(M,TL,empty)
   = TL .
  eq rigidLabel(M,(T,NeTL),TL)
   = rigidLabel(M,T,TL), rigidLabel(M,NeTL,TL) .
  eq rigidLabel(M,C,TL)
   = C .
  eq rigidLabel(M,F[NeTL],TL)
   = F[rigidLabel(M,NeTL,TL)] .
  eq rigidLabel(M,V,TL)
   = if V in TL then rigidLabel***(M,V) else V fi .

  op rigidLabel*** : Module Variable -> Variable .
  eq rigidLabel***(M,V)
   = qid("rigid#" + string(getName(V)) + ":" + string(getType(V))) .

  *** Undo the transformation of variables into constants
  op unrigidLabel : TermList -> TermList .
  eq unrigidLabel((T,NeTL))
   = (unrigidLabel(T),unrigidLabel(NeTL)) .
  eq unrigidLabel(C) = C .
  eq unrigidLabel(F[TL]) = F[unrigidLabel(TL)] .
  eq unrigidLabel(V)
   = if rfind(string(V), "rigid#", length(string(V)))
          =/= notFound
     then qid(
          string(getName(qid(
                   substr(string(V),
                   rfind(string(V), "rigid#",
                           length(string(V))) + 6,
                   length(string(V)))
          )))
          + ":" +
          string(getType(qid(
                   substr(string(V),
                   rfind(string(V), "rigid#",
                           length(string(V))) + 6,
                   length(string(V)))
          )))
          )
     else V
     fi .

  op unrigidLabel : Substitution -> Substitution .
  eq unrigidLabel((none).Substitution) = none .
  eq unrigidLabel(V <- T ; S)
   = unrigidLabel(V) <- unrigidLabel(T) ; unrigidLabel(S) .

  op unrigidLabel : SubstitutionSet -> SubstitutionSet .
  eq unrigidLabel((empty).SubstitutionSet) = empty .
  eq unrigidLabel(S | SSe)
   = unrigidLabel(S) | unrigidLabel(SSe) .

  op unrigidLabel : UnificationTripleSet -> UnificationTripleSet .
  eq unrigidLabel((empty).UnificationTripleSet) = empty .
  eq unrigidLabel({S1,S2,N'} | US)
   = {unrigidLabel(S1),unrigidLabel(S2),N'}
     | unrigidLabel(US) .

  op unrigidLabel : ResultTripleSet -> ResultTripleSet .
  eq unrigidLabel((empty).ResultTripleSet) = empty .
  eq unrigidLabel({T,TP,S} | RTS)
   = {unrigidLabel(T),TP,unrigidLabel(S)}
     | unrigidLabel(RTS) .

  op unrigidLabel : ResultContextSet -> ResultContextSet .
  eq unrigidLabel((empty).ResultContextSet) = empty .
  eq unrigidLabel({T,TP,S,S*,Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags} | RTS:ResultContextSet)
   = {unrigidLabel(T),TP,unrigidLabel(S),unrigidLabel(S*),Ct,CtS,unrigidLabel(TS),unrigidLabel(CtTS),NextVar,unrigidLabel(Tr:TraceNarrow),B:Flags}
     | unrigidLabel(RTS:ResultContextSet) .

  op unrigidLabel : TraceNarrow -> TraceNarrow .
  eq unrigidLabel((nil).TraceNarrow) = nil .
  eq unrigidLabel(Tr:TraceNarrow {CtTS:Term,Subst:Substitution,TP:Type,R:Rule})
   = unrigidLabel(Tr:TraceNarrow)
     {unrigidLabel(CtTS:Term),unrigidLabel(Subst:Substitution),TP:Type,R:Rule} .

  op unrigidLabel : VariantFourSet -> VariantFourSet  .
  eq unrigidLabel((empty).VariantFourSet) = empty .
  eq unrigidLabel({T,S,S',N} | R:VariantFourSet)
   = {unrigidLabel(T),unrigidLabel(S),unrigidLabel(S'),N}
     | unrigidLabel(R:VariantFourSet) .

  op qid : Nat -> Qid .
  eq qid(N:Nat) = qid(string(N:Nat,10)) .

endfm

fmod FM-META-E-UNIFICATION is
  pr FM-TYPEOFNARROWING .
  pr FM-EFLAGS .
  pr FM-RESULT-CONTEXT-SET .
  pr FM-SUBSTITUTION-HANDLING .
  pr FM-META-MINIMIZE-BINDINGS .
  pr FM-RESULT-CONTEXT-SET .
  pr FM-MODULE-HANDLING .
  pr FM-META-LEVEL-MNPA .
  pr FM-VARIANT .
  pr FM-RIGIDIFE .

  *** Repeated definitions to avoid cross calls between modules ************
  op normalizedSubstitution? : Module SubstitutionSet -> Bool .
  op metaACUUnify : Module Term Term Nat -> UnificationTripleSet .
  op metaACUUnify? : Module Term Term Nat -> Bool .
  op metaACUUnify* : Module UnificandPair Nat Nat ~> UnificationTriple? .
  op metaCoreUnify : Module Term Term Nat -> UnificationTripleSet .
  op metaCoreUnify? : Module Term Term Nat -> Bool .
  op metaBuiltInUnify : Module TermList Term Term Nat -> UnificationTripleSet .
  op metaBuiltInUnify? : Module TermList Term Term Nat -> Bool .
  op _<=[_]_ : SubstitutionSet Module SubstitutionSet -> Bool .
  op _<=[_]_ : Term Module Term -> Bool .
  *** Repeated definitions to avoid cross calls between modules ************

  var M : Module .
  vars T T' TS TS' CtTS CtTS' Lhs Rhs : Term .
  vars N N' NextVar NextVar' NextVar'' NextVar1 NextVar2 NextVar3 : Nat .
  var B : Bound .
  var TL TL' : TermList .
  var NeTL : NeTermList .
  var EqS : EquationSet .
  var AtS : AttrSet .
  var ON : TypeOfNarrowing .
  var Q : Qid .
  vars US US' US$ : UnificationTripleSet .
  vars U U' : UnificationTriple .
  vars S S' S* S'* S1 S1' S2 S2' S3 S3' : Substitution .
  var V : Variable .
  var R RT : ResultContext .
  vars RTS RTS' : ResultContextSet .
  vars TP TP' : Type .
  vars Ct Ct' CtS CtS' : Context .
  var C : Constant .
  vars F F' : Qid .
  var EF : EFlags .
  vars VT VT' : VariantFour .
  vars VTS VTS' VTS$ : VariantFourSet .
  var IRR : IrrFlags .

  --- metaECoreUnify --------------------------------------------------
  op metaECoreUnify : Module Term Term TermList -> SubstitutionSet .
                     --- Term Lhs
  eq metaECoreUnify(M, T, T',TL)
   = metaEACUUnify(M, T, T',TL) .

  op metaECoreUnify? : Module Term Term TermList -> Bool .
  eq metaECoreUnify?(M, T, T', TL)
   = metaEACUUnify?(M, T, T', TL) .

  --- metaVariantUnify --------------------------------------------------
  op metaVariantUnify : Module Term Term -> SubstitutionSet .
  eq metaVariantUnify(M, T, T') = metaEACUUnify(M, T, T', empty) .

  op metaVariantUnify : Module Term Term TermList -> SubstitutionSet .
  eq metaVariantUnify(M, T, T', TL) = metaEACUUnify(M, T, T', TL) .

  op metaVariantUnify? : Module Term Term TermList -> Bool .
  eq metaVariantUnify?(M, T, T', TL) = metaEACUUnify?(M, T, T', TL) .

  op metaVariantUnify : Module Term Term Nat IrrFlags -> UnificationTripleSet .
  eq metaVariantUnify(M, T, T',NextVar,IRR) = metaEACUUnify(M, T, T',empty,NextVar,IRR) .

  op metaVariantUnify : Module Term Term TermList Nat IrrFlags -> UnificationTripleSet .
  eq metaVariantUnify(M, T, T',TL,NextVar,IRR) = metaEACUUnify(M, T, T',TL,NextVar,IRR) .

  op metaVariantUnify? : Module Term Term TermList Nat IrrFlags -> Bool .
  eq metaVariantUnify?(M, T, T',TL,NextVar,IRR) = metaEACUUnify?(M, T, T',TL,NextVar,IRR) .

  --- metaEACUUnify --------------------------------------------------
  op metaEACUUnify : Module Term Term TermList -> SubstitutionSet .
  eq metaEACUUnify(M, T, T', TL)
   = toSubstitution(metaEACUUnify(M,T,T',TL,highestVar((T,T',TL)) + 1,reducible)) .

  op metaEACUUnify? : Module Term Term TermList -> Bool .
  eq metaEACUUnify?(M, T, T', TL)
   = metaEACUUnify?(M,T,T',TL,highestVar((T,T',TL)) + 1,reducible) .

  op metaEACUUnifyIrr : Module Term Term TermList -> SubstitutionSet .
                    --- T irreducible T' reducible
  eq metaEACUUnifyIrr(M, T, T',TL)
   = toSubstitution(metaEACUUnify(M,T,T',TL,highestVar((T,T',TL)) + 1,irreducible)) .

  op metaEACUUnifyIrr? : Module Term Term TermList -> Bool .
  eq metaEACUUnifyIrr?(M, T, T', TL)
   = metaEACUUnify?(M,T,T',TL,highestVar((T,T',TL)) + 1,irreducible) .

  op metaEACUUnify : Module Term Term TermList Nat IrrFlags -> UnificationTripleSet .
  eq metaEACUUnify(M, T, T',TL,NextVar,IRR)
   = minimizeBindingsTerm(M,Vars(T),NextVar,
          metaEUnify&(M, T, T',TL,NextVar,ACUUnify IRR)
     ) |> (T,T',TL) .

  op metaEACUUnify? : Module Term Term TermList Nat IrrFlags -> Bool .
  eq metaEACUUnify?(M, T, T',TL,NextVar,IRR)
   = metaEUnify&?(M, T, T',TL,NextVar,ACUUnify IRR) .

  --- metaEBuiltInUnify --------------------------------------------------
  op metaEBuiltInUnify : Module Term Term -> SubstitutionSet .
  eq metaEBuiltInUnify(M, T, T') = metaEBuiltInUnify(M, T, T',empty) .

  op metaEBuiltInUnify : Module Term Term TermList -> SubstitutionSet .
  eq metaEBuiltInUnify(M, T, T', TL)
   = toSubstitution(metaEBuiltInUnify(M,T,T',TL,highestVar((T,T',TL)) + 1,reducible)) .

  op metaEBuiltInUnify? : Module Term Term -> Bool .
  eq metaEBuiltInUnify?(M, T, T') = metaEBuiltInUnify?(M, T, T',empty) .

  op metaEBuiltInUnify? : Module Term Term TermList -> Bool .
  eq metaEBuiltInUnify?(M, T, T',TL)
   = metaEBuiltInUnify?(M,T,T',TL,highestVar((T,T',TL)) + 1,reducible) .

  op metaEBuiltInUnifyIrr : Module Term Term -> SubstitutionSet .
  eq metaEBuiltInUnifyIrr(M, T, T') = metaEBuiltInUnifyIrr(M, T, T', empty) .

  op metaEBuiltInUnifyIrr : Module Term Term TermList -> SubstitutionSet .
                          --- T irreducible T' reducible
  eq metaEBuiltInUnifyIrr(M, T, T', TL)
   = toSubstitution(
       metaEBuiltInUnify(M,T,T',TL,highestVar((T,T',TL)) + 1,irreducible)
     ) .

  op metaEBuiltInUnifyIrr? : Module Term Term  -> Bool .
  eq metaEBuiltInUnifyIrr?(M, T, T') = metaEBuiltInUnifyIrr?(M, T, T', empty) .

  op metaEBuiltInUnifyIrr? : Module Term Term TermList -> Bool .
                          --- T irreducible T' reducible
  eq metaEBuiltInUnifyIrr?(M, T, T', TL)
   = metaEBuiltInUnify?(M,T,T',TL,highestVar((T,T',TL)) + 1,irreducible) .

  op metaEBuiltInUnify : Module Term Term TermList Nat IrrFlags
                         -> UnificationTripleSet .
  eq metaEBuiltInUnify(M, T, T',TL,NextVar,IRR)
   = minimizeBindingsTerm(M,Vars(T),NextVar,
        metaEUnify&(M, T, T',TL,NextVar,BuiltInUnify IRR)
     ) |> (T,T') .

  op metaEBuiltInUnify? : Module Term Term TermList Nat IrrFlags -> Bool .
  eq metaEBuiltInUnify?(M, T, T',TL,NextVar,IRR)
   = metaEUnify&?(M, T, T',TL,NextVar,BuiltInUnify IRR) .

  --- metaEUnify --------------------------------------------------
  op metaEUnify& : Module Term Term TermList Nat EFlags -> UnificationTripleSet .
                      --- Term Lhs
  eq metaEUnify&(M,T,T',TL,NextVar,EF)
   = if sameKind(M,leastSort(M,T),leastSort(M,T'))
     then metaEUnify&*(removeBoolEqs(M),T,T',TL,NextVar,EF)
     else empty
     fi .

  op metaEUnify&? : Module Term Term TermList Nat EFlags -> Bool .
                      --- Term Lhs
  eq metaEUnify&?(M,T,T',TL,NextVar,EF)
   = sameKind(M,leastSort(M,T),leastSort(M,T'))
     and-then
     metaEUnify&*?(removeBoolEqs(M),T,T',TL,NextVar,EF) .

  op metaEUnify&* : Module Term Term TermList Nat EFlags -> UnificationTripleSet .
                      --- Term Lhs
  eq metaEUnify&*(M,T,T',TL,NextVar,EF)
   = if metaBuiltInUnify?(M,TL,
          fst(generalize(onlyEqsVariant(M),NextVar,T)),
          fst(generalize(onlyEqsVariant(M),
                         snd(generalize(onlyEqsVariant(M),NextVar,T)),T')),
          snd(generalize(onlyEqsVariant(M),
                         snd(generalize(onlyEqsVariant(M),NextVar,T)),T'))
        )
     then if T == fst(generalize(onlyEqsVariant(M),NextVar,T))
             and
             T' == fst(
                    generalize(onlyEqsVariant(M),
                               snd(generalize(onlyEqsVariant(M),NextVar,T)),T'))
          then --- no narrowing is necessary to unify
               metaBuiltInUnify(M,TL,T,T',NextVar)
          else metaEUnify$(M,T,T',TL,NextVar,EF)
          fi
     else empty
     fi .

  op metaEUnify&*? : Module Term Term TermList Nat EFlags -> Bool .
                      --- Term Lhs
  eq metaEUnify&*?(M,T,T',TL,NextVar,EF)
   = if metaBuiltInUnify?(M,TL,
          fst(generalize(onlyEqsVariant(M),NextVar,T)),
          fst(generalize(onlyEqsVariant(M),
                         snd(generalize(onlyEqsVariant(M),NextVar,T)),T')),
          snd(generalize(onlyEqsVariant(M),
                         snd(generalize(onlyEqsVariant(M),NextVar,T)),T'))
        )
     then if T == fst(generalize(onlyEqsVariant(M),NextVar,T))
             and
             T' == fst(
                    generalize(onlyEqsVariant(M),
                               snd(generalize(onlyEqsVariant(M),NextVar,T)),T'))
          then --- no narrowing is necessary to unify
               metaBuiltInUnify?(M,TL,T,T',NextVar)
          else metaEUnify$?(M,T,T',TL,NextVar,EF)
          fi
     else false
     fi .

  op metaEUnify$ : Module Term Term TermList Nat EFlags -> UnificationTripleSet .
                      --- Term Lhs
  eq metaEUnify$(M,T,T',TL,NextVar,irreducible EF)
   = metaEUnifyCollect(M,T,T',(T,TL),NextVar,0,empty) .
  eq metaEUnify$(M,T,T',TL,NextVar,EF)
   = metaEUnifyCollect(M,T,T',TL,NextVar,0,empty) [owise] .

  op metaEUnify$? : Module Term Term TermList Nat EFlags -> Bool .
                      --- Term Lhs
  eq metaEUnify$?(M,T,T',TL,NextVar,irreducible EF)
   = metaEUnifyCollect?(M,T,T',(T,TL),NextVar,0) .
  eq metaEUnify$?(M,T,T',TL,NextVar,EF)
   = metaEUnifyCollect?(M,T,T',TL,NextVar,0) [owise] .

  op metaEUnifyCollect : Module Term Term TermList Nat Nat
                          UnificationTripleSet
                       -> UnificationTripleSet  .
  eq metaEUnifyCollect(M,T,T',TL,N,N',US)
   = if metaEUnify*(M,T =? T',TL,N,N') :: UnificationTriple?
        and
        metaEUnify*(M,T =? T',TL,N,N') =/= noUnifier
     then metaEUnifyCollect(M,T,T',TL,N,s(N'),
             US | metaEUnify*(M,T =? T',TL,N,N') )
     else US
     fi .

  op metaEUnifyCollect? : Module Term Term TermList Nat Nat
                       -> Bool .
  eq metaEUnifyCollect?(M,T,T',TL,N,N')
   = metaEUnify*(M,T =? T',TL,N,N') :: UnificationTriple?
     and
     metaEUnify*(M,T =? T',TL,N,N') =/= noUnifier .

  *** Code for collection all unifiers
  op metaEUnify* : Module UnificandPair TermList Nat Nat ~> UnificationTriple? .
  eq metaEUnify*(M, T =? T',TL,N,N')
   = metaEUnifyTriple(
       M,
       unflatten(M,T) =? unflatten(M,T'),
       TL,N,N') .

  op metaEUnifyTriple : Module UnificationProblem TermList Nat Nat ~> UnificationTriple? .
  eq metaEUnifyTriple(M,T =? T',TL,N,N')
   = if metaVariantUnify(M,T =? T',TL,N,N') == noUnifier
     then noUnifier
     else {getSubst(metaVariantUnify(M,T =? T',TL,N,N')) |> T,
           getSubst(metaVariantUnify(M,T =? T',TL,N,N')) |> T',
           getNextVar(metaVariantUnify(M,T =? T',TL,N,N'))}
     fi .

  **************************************
  ***** Variant Generation

  op getVariants : Module Term -> VariantFourSet .
  eq getVariants(M,T) = getVariants(M,T,highestVar(T) + 1) .

  op getVariants : Module Term Nat -> VariantFourSet .
  eq getVariants(M,T,NextVar) = getVariants(M,T,NextVar,reducible BuiltInUnify) .

  op getVariants : Module Term Nat TermList -> VariantFourSet .
  eq getVariants(M,T,NextVar,TL) = getVariants(M,T,NextVar,reducible BuiltInUnify,TL) .

  op getVariants : Module Term Nat EFlags -> VariantFourSet .
  eq getVariants(M,T,NextVar,EF) = getVariants(M,T,NextVar,EF,empty) .

  op getVariants : Module Term Nat EFlags TermList -> VariantFourSet .
  eq getVariants(M,T,NextVar,EF,TL)
   = unrigidife(qid(NextVar),
      getVariants*(
          getM(rigidifeRigid(M,qid(NextVar),T)),
          getTL(rigidifeRigid(M,qid(NextVar),T)),
          NextVar + 1,EF,TL
      )
     ) .

  op getVariants* : Module Term Nat EFlags TermList -> VariantFourSet .
  eq getVariants*(M,T,NextVar,EF,TL)
   = if howMany(onlyEqsVariant(M),T) == 0
     then {T,none,none,NextVar}
     else if getVariants**(M,T,NextVar,EF,TL) :: VariantFourSet
             and
             getVariants**(M,T,NextVar,EF,TL) =/= empty
          then getVariants**(M,T,NextVar,EF,TL)
          else {T,none,none,NextVar}
          fi
     fi .

  op getVariants** : Module Term Nat EFlags TermList -> VariantFourSet .
  eq getVariants**(M,T,NextVar,EF,TL)
   = minimizeBindingsTerm(M,Vars(T),NextVar,
            getVariants***(M,T,NextVar,empty,0,TL)
     ) .

  op getVariants*** : Module Term Nat VariantFourSet Nat TermList -> VariantFourSet .
  eq getVariants***(M,T,NextVar,VTS,N,TL)
   = if metaGetVariant(M,T,TL,NextVar,N) == noVariant
     then VTS
     else getVariants***$(M,T,NextVar,VTS,N,
             metaGetVariant(M,T,TL,NextVar,N),TL)
     fi .

  op getVariants***$ : Module Term Nat VariantFourSet Nat Variant TermList -> VariantFourSet .
  eq getVariants***$(M,T,NextVar,VTS,N,{T2:Term,S:Substitution,NV2:Nat,P:Parent,B:Bool},TL)
   = getVariants***$$(M,T,NextVar,VTS,N,{T2:Term,S:Substitution,NV2:Nat,P:Parent,B:Bool},
           split({S:Substitution,NV2:Nat},NextVar),TL) .

  op getVariants***$$ : Module Term Nat VariantFourSet Nat Variant UnificationTriple TermList -> VariantFourSet .
  eq getVariants***$$(M,T,NextVar,VTS,N,
         {T2:Term,S:Substitution,NV2:Nat,P:Parent,B:Bool},
         {S1:Substitution,S2:Substitution,NV2:Nat},TL)
   = getVariants***(M,T,NextVar,
             VTS | {T2:Term,S1:Substitution,S2:Substitution,NV2:Nat},
             N + 1,TL) .

  sort PairGeneralize .
  op {_,_} : TermList Nat -> PairGeneralize .
  op fst : PairGeneralize -> TermList .
  eq fst({X:TermList,Y:Nat}) = X:TermList .
  op snd : PairGeneralize -> Nat .
  eq snd({X:TermList,Y:Nat}) = Y:Nat .

  op generalize : Module Nat NeTermList -> PairGeneralize .
  eq generalize(M,NextVar,NeTL)
   = generalize*(M,NextVar,getEqs(M),NeTL) .

  op generalize* : Module Nat EquationSet TermList -> PairGeneralize .
  eq generalize*(M,NextVar,EqS,empty)
   = {empty,NextVar} .
  eq generalize*(M,NextVar,EqS,(T,TL))
   = {(fst(generalize**(M,NextVar,EqS,T)),
       fst(generalize*(M,snd(generalize**(M,NextVar,EqS,T)),EqS,TL))),
      snd(generalize*(M,snd(generalize**(M,NextVar,EqS,T)),EqS,TL))
     } .

  op generalize** : Module Nat EquationSet Term -> PairGeneralize .
  eq generalize**(M,NextVar,EqS,C)
   = {C,NextVar} .
  eq generalize**(M,NextVar,EqS,V)
   = {V,NextVar} .
  ceq generalize**(M,NextVar,(eq F'[TL'] = Rhs [AtS] .) EqS,F[TL])
    = {newVar(NextVar,getKind(M,leastSort(M,F[TL]))),NextVar + 1}
   if F == F'
      and-then
      glbSorts(M,leastSort(M,TL),leastSort(M,TL')) =/= none .
  eq generalize**(M,NextVar,EqS,F[TL])
   = {F[fst(generalize*(M,NextVar,EqS,TL))],
      snd(generalize*(M,NextVar,EqS,TL))}
  [owise] .

  *** Identify bound for terms
  op howMany : Module NeTermList -> Nat .
  eq howMany(M,NeTL)
   = howMany*(M,getEqs(M),NeTL << 0 < ) .

  op howMany* : Module EquationSet TermList -> Nat .
  eq howMany*(M,EqS,empty)
   = 0 .
  eq howMany*(M,EqS,(T,TL))
   = howMany**(M,EqS,T) + howMany*(M,EqS,TL) .

  op howMany** : Module EquationSet Term -> Nat .
  eq howMany**(M,EqS,C)
   = 0 .
  eq howMany**(M,EqS,V)
   = 0 .
  ceq howMany**(M,(eq F'[TL'] = Rhs [AtS] .) EqS,F[TL])
    = 1 + howMany*(M,(eq F'[TL'] = Rhs [AtS] .) EqS,TL)
   if F == F'
      and-then
      glbSorts(M,leastSort(M,TL),leastSort(M,TL')) =/= none
      and-then not isAssociative(M,F,getTypes(M,TL)) .
  ceq howMany**(M,(eq F'[TL'] = Rhs [AtS] .) EqS,F[TL])
    = sd(length(TL),1) + howMany*(M,(eq F'[TL'] = Rhs [AtS] .) EqS,TL)
   if F == F'
      and-then
      glbSorts(M,leastSort(M,TL),leastSort(M,TL')) =/= none
      and-then isCommutative(M,F,getTypes(M,TL))
      and-then isAssociative(M,F,getTypes(M,TL)) .
  eq howMany**(M,EqS,F[TL])
   = howMany*(M,EqS,TL) [owise] .


  *** Identify whether basic or variant narrowing should be used
  op howManyAC : Module NeTermList -> Nat .
  eq howManyAC(M,NeTL)
   = if howManyAC$(M,getEqs(M)) == 0
     then 0
     else howManyAC*(M,getEqs(M),NeTL << 0 < )
     fi .

  op howManyAC* : Module EquationSet TermList -> Nat .
  eq howManyAC*(M,EqS,empty)
   = 0 .
  eq howManyAC*(M,EqS,(T,TL))
   = howManyAC**(M,EqS,T) + howManyAC*(M,EqS,TL) .

  op howManyAC** : Module EquationSet Term -> Nat .
  eq howManyAC**(M,EqS,C)
   = 0 .
  eq howManyAC**(M,EqS,V)
   = 0 .
  ceq howManyAC**(M,(eq F'[TL'] = Rhs [AtS] .) EqS,F[TL])
    = sd(length(TL),1) + howManyAC*(M,(eq F'[TL'] = Rhs [AtS] .) EqS,TL)
   if F == F'
      and-then
      glbSorts(M,leastSort(M,TL),leastSort(M,TL')) =/= none
      and-then isCommutative(M,F,getTypes(M,TL))
      and-then isAssociative(M,F,getTypes(M,TL)) .
  eq howManyAC**(M,EqS,F[TL])
   = howManyAC*(M,EqS,TL) [owise] .

  op length : TermList -> Nat .
  eq length((empty).TermList) = 0 .
  eq length((T:Term,TL:TermList)) = 1 + length(TL:TermList) .

  op howManyAC$ : Module EquationSet -> Nat [memo] .
  eq howManyAC$(M,EqS)
   = howManyAC$$(M,EqS) .

  op howManyAC$$ : Module EquationSet -> Nat .
  eq howManyAC$$(M,none)
   = 0 .
  eq howManyAC$$(M,(eq F[TL] = Rhs [AtS] .) EqS)
    = if isCommutative(M,F,getTypes(M,TL))
         and isAssociative(M,F,getTypes(M,TL))
      then 1 else 0 fi
      + howManyAC$$(M,EqS) .

endfm

fmod FM-META-ACU-UNIFICATION is
  pr FM-TERM-HANDLING .
  pr FM-SUBSTITUTION-HANDLING .
  pr FM-MODULE-HANDLING .
  pr FM-SUBSTITUTIONSET .
  pr FM-UNIFICATIONPAIRSET .
  pr CONVERSION .
  pr FM-META-LEVEL-MNPA .
  pr FM-META-MINIMIZE-BINDINGS .
  pr FM-META-E-UNIFICATION .

  var M : Module .
  vars T T' : Term .
  vars N N' : Nat .
  vars US : UnificationTripleSet .

  --- metaACUUnify --------------------------------------------------
  op metaACUUnify : Module Term Term -> SubstitutionSet .
  eq metaACUUnify(M, T, T')
   = toSubstitution(metaACUUnify(M, T, T', highestVar((T,T')) + 1)) .

  op metaACUUnify? : Module Term Term -> Bool .
  eq metaACUUnify?(M, T, T')
   = metaACUUnify?(M, T, T', highestVar((T,T')) + 1) .

  *** General Call for UnificationPairSet
  op metaACUUnify : Module Term Term Nat -> UnificationTripleSet .
  eq metaACUUnify(M, T, T', N)
   = metaACUUnify$(M, canonice(M,T), canonice(M,T'), N) .

  op metaACUUnify$ : Module Term Term Nat -> UnificationTripleSet .
                      --- Term Lhs
  eq metaACUUnify$(M, T, T', N)
   = if (root(T) =/= root(T')
         and not (root(T) :: Variable) and not (root(T') :: Variable))
        or-else
        glbSorts(M,leastSort(M,T),leastSort(M,T')) == none
     then empty
     else minimizeBindingsTerm(M,Vars(T),N,
              metaACUUnifyCollect(M, T, T',N,0,empty))
     fi .

  op metaACUUnify? : Module Term Term Nat -> Bool .
  eq metaACUUnify?(M, T, T', N)
   = metaACUUnify?$(M, canonice(M,T), canonice(M,T'), N) .

  op metaACUUnify?$ : Module Term Term Nat -> Bool .
  eq metaACUUnify?$(M, T, T', N)
   = glbSorts(M,leastSort(M,T),leastSort(M,T')) =/= none
     and-then
     (metaACUUnify*(M,T =? T',N,0) :: UnificationTriple?
      and
      metaACUUnify*(M,T =? T',N,0) =/= noUnifier) .

  op metaACUUnifyCollect : Module Term Term Nat Nat
                          UnificationTripleSet
                       -> UnificationTripleSet .
  eq metaACUUnifyCollect(M,T,T',N,N',US)
   = if metaACUUnify*(M,T =? T',N,N') :: UnificationTriple?
        and
        metaACUUnify*(M,T =? T',N,N') =/= noUnifier
     then metaACUUnifyCollect(M,T,T',N,s(N'),
             US | metaACUUnify*(M,T =? T',N,N') )
     else US
     fi .

  *** Code for collection all unifiers
  op metaACUUnify* : Module UnificandPair Nat Nat ~> UnificationTriple? .
  eq metaACUUnify*(M, T =? T',N,N')
   = metaUnifyTriple(
       changeNonSupportedAttr(eraseEqs(eraseRls(M))),
       unflatten(M,T) =? unflatten(M,T'),
       N,N') .

  op metaUnifyTriple : Module UnificationProblem Nat Nat ~> UnificationTriple? .
  eq metaUnifyTriple(M,T =? T',N,N')
   = if metaUnify(M,T =? T',N,N') == noUnifier
     then noUnifier
     else {getSubst(metaUnify(M,T =? T',N,N')) |> T,
           getSubst(metaUnify(M,T =? T',N,N')) |> T',
           getNextVar(metaUnify(M,T =? T',N,N'))}
     fi .
endfm

fmod FM-META-UNIFICATION is
  pr FM-META-ACU-UNIFICATION .

  var M : Module .
  var T T' : Term .
  var N : Nat .

  --- metaUnify --------------------------------------------------
  op metaCoreUnify : Module Term Term -> SubstitutionSet .
  eq metaCoreUnify(M, T, T')
   = toSubstitution(metaCoreUnify(M, T, T', highestVar((T,T')) + 1)) .

  op metaCoreUnify : Module Term Term Nat -> UnificationTripleSet .
                    --- Term Lhs
  eq metaCoreUnify(M, T, T', N)
   = metaACUUnify(M, T, T', N)  .

  op metaCoreUnify? : Module Term Term Nat -> Bool .
                    --- Term Lhs
  eq metaCoreUnify?(M, T, T', N)
   = metaACUUnify?(M, T, T', N)  .

endfm

fmod META-MSG-UNIFICATION is
  pr FM-META-ACU-UNIFICATION .
  pr FM-META-MATCH .

  var M : Module .
  vars T T' T1# T2# T1$ T2$ T1 T2 : Term .
  vars N N' N'' N1# N2# : Nat .
  vars S S' S1# S2# LSubst RSubst : Substitution .
  var UP : UnificationProblem .
  vars UTS UTS' : UnificationTripleSet .
  var C : Constant .
  vars V V' V1 V2 V3 : Variable .
  vars F F1 F2 : Qid .
  vars TL TL1 TL1' TL1'' TL2 TL2' TL2'' : TermList .
  var NeTL : NeTermList .

  var U : UnificationPair .
  vars US US' : UnificationPairSet .
  var SS SS' : SubstitutionSet .
  vars TP TP' : Type .
  var TPS : TypeSet .
  var TPL : TypeList .
  var AtS : AttrSet .
  var OPDS : OpDeclSet .

  ******* metaBuiltInMatch ***********************************************
  op metaBuiltInMatch : Module Term Term -> SubstitutionSet .
                           *** T1 instance of T2
  eq metaBuiltInMatch(M, T1, T2)
   = metaCoreMatch(M, T1, T2) .

  op metaBuiltInMatch? : Module Term Term -> Bool .
                           *** T1 instance of T2
  eq metaBuiltInMatch?(M, T1, T2)
   = metaCoreMatch?(M, T1, T2) .

  ******* metaBuiltInUnify ***********************************************
  op metaBuiltInUnify : Module Term Term -> SubstitutionSet .
  eq metaBuiltInUnify(M, T, T')
   = metaBuiltInUnify(M, empty, T, T') .

  op metaBuiltInUnify : Module TermList Term Term -> SubstitutionSet .
  eq metaBuiltInUnify(M, TL T, T')
   = toSubstitution(metaBuiltInUnify(M, TL, T, T', highestVar((T,T')) + 1)) .

  *** General Call for UnificationPairSet
  op metaBuiltInUnify : Module TermList Term Term Nat -> UnificationTripleSet .
                       --- Term Lhs
  eq metaBuiltInUnify(M, TL, T1, T2, N)
   = metaBuiltInUnify(M, T1, T2, N) .

  op metaBuiltInUnify : Module Term Term Nat -> UnificationTripleSet .
  eq metaBuiltInUnify(M, T1, T2, N)
   = metaCoreUnify(M, T1, T2, N) .

  op metaBuiltInUnify? : Module Term Term -> Bool .
  eq metaBuiltInUnify?(M, T, T')
   = metaBuiltInUnify?(M, empty, T, T') .

  op metaBuiltInUnify? : Module TermList Term Term -> Bool .
  eq metaBuiltInUnify?(M, TL, T, T')
   = metaBuiltInUnify?(M, TL, T, T',highestVar((T,T')) + 1) .

  op metaBuiltInUnify? : Module TermList Term Term Nat -> Bool .
  eq metaBuiltInUnify?(M, TL, T1, T2, N)
   = metaBuiltInUnify?(M, T1, T2, N)  .

  op metaBuiltInUnify? : Module Term Term Nat -> Bool .
  eq metaBuiltInUnify?(M, T1, T2, N)
   = metaCoreUnify?(M, T1, T2, N) .


endfm
fmod FM-ORDERS-TERM-SUBSTITUTION is
  protecting FM-TERM-HANDLING .
  protecting FM-SUBSTITUTION-HANDLING .
  protecting FM-META-MATCH .
  protecting FM-META-LEVEL-MNPA .
  protecting FM-META-UNIFICATION .
  protecting FM-META-E-UNIFICATION .
  protecting FM-RENAMING .
  protecting FM-SUBSTITUTIONSET .
  protecting META-MSG-UNIFICATION .

  vars T T' : Term .
  vars TL TL' TL1 TL2 TL3 : TermList .
  var M : Module .
  vars S S' : Substitution .
  vars SS SS' SS'' : SubstitutionSet .
  vars V V' V1 V2 V3 : Variable .
  vars TPL TPL' : TypeList .
  vars N N' : Nat .
  vars F : Qid .
  var C : Constant .

  --- metaEMatch(M,T,T') implies that T is an instance of T' modulo E + axioms
  op metaEMatch : Module Term Term -> SubstitutionSet .
  eq metaEMatch(M,T,T')
   = if metaCoreMatch(M,T,T') =/= empty
     then metaCoreMatch(M,T,T')
     else if metaEBuiltInUnifyIrr?(M,T,T')
          then metaShared-filter(M,T,T',metaEBuiltInUnifyIrr(M,T,T'))
          else empty
          fi
     fi .

  op metaEMatch? : Module Term Term -> Bool .
  eq metaEMatch?(M,T,T')
   = metaCoreMatch?(M,T,T')
     or-else
     metaEBuiltInUnifyIrr?(M,T,T') .

  --- order between terms ---------------------------
  --- T <=[M] T' implies that T' is an instance of T
  op _<=[_]_ : Term Module Term -> Bool .
  eq T <=[M] T' = (metaCoreMatch(M,T',T) |> T) =/= empty .

  --- order between substitutions ---------------------------
  --- Subst <=[M] Subst' implies that Subst' is an instance of Subst
  op _<=[_]_ : SubstitutionSet Module SubstitutionSet -> Bool [ditto] .
  eq SS <=[M] SS'
   = SS <=[empty,M] SS' .

  op _<=[_`,_]_ : SubstitutionSet TermList Module SubstitutionSet -> Bool .
  eq empty <=[TL,M] SS'
   = false .
  eq SS <=[TL,M] SS'
   = SS <=[TL,M]$ SS' [owise] .

  op _<=[_`,_]$_ : SubstitutionSet TermList Module SubstitutionSet -> Bool .
  eq SS <=[TL,M]$ empty
   = true .
  eq SS <=[TL,M]$ (S' | SS')
   = (SS <=[TL,M]* S') and-then SS <=[TL,M]$ SS' .

  op _<=[_`,_]*_ : SubstitutionSet TermList Module Substitution -> Bool .
  eq empty <=[TL,M]* S'
   = false .
  eq (S | SS) <=[TL,M]* S'
   = S <=[TL,M]** S' or-else SS <=[TL,M]* S' .

  op _<=[_`,_]**_ : Substitution TermList Module Substitution -> Bool .
  eq none <=[TL,M]** S'
   = true .
  eq S <=[TL,M]** S'
   = 'Q[1st(gen(TL,S,S'))]
     *<=[
       addSorts('XXX,
       addOps((op 'Q : 3rd(gen(TL,S,S')) -> 'XXX [none] .),
         M))
     ]*
     'Q[2nd(gen(TL,S,S'))]
  [owise] .

  --- T <=[M] T' implies that T' is an instance of T
  --- T and T' can have shared variables
  op _*<=[_]*_ : Term Module Term -> Bool .
  eq T *<=[M]* T'
   = (if anyVars T inVars T'
      then metaCoreMatchShared(M,T',T)
      else metaCoreMatch(M,T',T)
      fi |> T)
     =/= empty .

  sort Triple .
  op {{_`,_`,_}} : TermList TermList TypeList -> Triple .
  op 1st : Triple -> TermList .
  eq 1st({{TL,TL',TPL}}) = TL .
  op 2nd : Triple -> TermList .
  eq 2nd({{TL,TL',TPL}}) = TL' .
  op 3rd : Triple -> TypeList .
  eq 3rd({{TL,TL',TPL}}) = TPL .

  ops gen : TermList Substitution Substitution -> Triple . ---[memo] .
  eq gen(empty,none,none)
   = {{empty,empty,nil}} .
  eq gen((V,TL),none,none)
   = {{(V,1st(gen(TL,none,none))),
       (V,2nd(gen(TL,none,none))),
       (getType(V) 3rd(gen(TL,none,none)))}} .
  eq gen(TL,none,V <- T ; S')
   = {{(V,1st(gen(TL \\ V,none,S'))),
       (T,2nd(gen(TL \\ V,none,S'))),
       (getType(V) 3rd(gen(TL \\ V,none,S')))}} .
  eq gen(TL,V <- T ; S,V <- T' ; S')
   = {{(T,1st(gen(TL \\ V,S,S'))),
       (T',2nd(gen(TL \\ V,S,S'))),
       (getType(V) 3rd(gen(TL \\ V,S,S')))}} .
  eq gen(TL,V <- T ; S,S')
   = {{(T,1st(gen(TL \\ V,S,S'))),
       (V,2nd(gen(TL \\ V,S,S'))),
       (getType(V) 3rd(gen(TL \\ V,S,S')))}}
   [owise] .

  op _\\_ : TermList Variable -> TermList .
  eq (TL,V,TL') \\ V = (TL,TL') .
  eq TL \\ V = TL [owise] .

  --- renaming -----------------------------------------------
  op _=[_]=_ : TermSet Module TermSet -> Bool .
  eq T1:TermSet =[M]= T2:TermSet
   = metaBuiltInRenaming(M,T1:TermSet,T2:TermSet) .

  *****
  op metaBuiltInRenaming : Module TermSet TermSet -> Bool .
  eq metaBuiltInRenaming(M,emptyTermSet,emptyTermSet)
   = true .
 ceq metaBuiltInRenaming(M,T:Term | T:TermSet,T':Term | T':TermSet)
    = metaBuiltInRenaming(M,T:TermSet,T':TermSet)
   if metaBuiltInRenaming$(M,T:Term,T':Term) .
  eq metaBuiltInRenaming(M,T:TermSet,T':TermSet)
   = false [owise] .

  op metaBuiltInRenaming$ : Module Term Term -> Bool .
  eq metaBuiltInRenaming$(M,T:Term,T':Term)
   = canonice(M,nullVars(T)) == canonice(M,nullVars(T'))
     and-then
     (metaBuiltInRenaming$$1(M,canonice(M,T),canonice(M,T'))
      or-else
      metaBuiltInRenaming$$2(M,canonice(M,T),canonice(M,T'))
      ) .

  op metaBuiltInRenaming$$1 : Module Term Term -> Bool .
  eq metaBuiltInRenaming$$1(M,T:Term,T':Term)
   = metaBuiltInRenaming$$1*(
         canonice(M,totalOrder(M,flatten(M,T:Term)) <<( 0 )<),
         canonice(M,totalOrder(M,flatten(M,T':Term)) <<( 0 )<) ) .

  op metaBuiltInRenaming$$1* : Term Term -> Bool .
  eq metaBuiltInRenaming$$1*(T:Term,T':Term) = T:Term == T':Term .

  op totalOrder : Module Term -> Term .
  eq totalOrder(M,C) = C .
  eq totalOrder(M,V) = V .
  eq totalOrder(M,F[TL])
   = if not isCommutative(M,F[TL])
     then F[totalOrderTL(M,TL)]
     else F[reorderTL(M,F,totalOrderTL(M,TL))]
     fi .

  op totalOrderTL : Module TermList -> TermList .
  eq totalOrderTL(M,empty) = empty .
  eq totalOrderTL(M,(T,TL)) = (totalOrder(M,T),totalOrderTL(M,TL)) .

  op reorderTL : Module Qid TermList -> TermList .
  eq reorderTL(M,F,empty) = empty .
  eq reorderTL(M,F,(T,TL))
   = if insertTL(M,F,T,TL) =/= (T,TL)
     then reorderTL(M,F,insertTL(M,F,T,TL))
     else (T,reorderTL(M,F,TL))
     fi .

  op insertTL : Module Qid Term TermList -> TermList .
  eq insertTL(M,F,T',empty) = T' .
  eq insertTL(M,F,T',(T,TL))
   = if canonice(M,F[nullVars(T'),nullVars(T)]) == F[canonice(M,nullVars(T')),canonice(M,nullVars(T))]
     then (T',T,TL)
     else (T,insertTL(M,F,T',TL))
     fi .

  op nullVars : Term -> Term .
  eq nullVars(C) = C .
  eq nullVars(V) = qid("#0:" + string(getType(V))) .
  eq nullVars(F[TL]) = F[nullVarsTL(TL)] .

  op nullVarsTL : TermList -> TermList .
  eq nullVarsTL(empty) = empty .
  eq nullVarsTL((T,TL)) = (nullVars(T),nullVarsTL(TL)) .

  *****
  op metaBuiltInRenaming$$2 : Module Term Term -> Bool .
  eq metaBuiltInRenaming$$2(M,T:Term,T':Term)
   = T == T'
     or-else
     onlyRenamingAny(M,metaBuiltInMatchShared(M,T',T) |> T) .

  *****
  op onlyRenamingAll : Module SubstitutionSet -> Bool .
  eq onlyRenamingAll(M,empty)
   = true .
  eq onlyRenamingAll(M,S | SS)
   = onlyRenaming*(M,S)
     and-then
     onlyRenamingAll(M,SS) .

  op onlyRenamingAny : Module SubstitutionSet -> Bool .
  eq onlyRenamingAny(M,empty)
   = false .
  eq onlyRenamingAny(M,S | SS)
   = onlyRenaming*(M,S)
     or-else
     onlyRenamingAny(M,SS) .

  op onlyRenaming* : Module Substitution -> Bool .
  eq onlyRenaming*(M,(V <- T) ; (V' <- T) ; S)
   = false .
  eq onlyRenaming*(M,S)
   = onlyRenaming**(M,S) [owise] .

  op onlyRenaming** : Module Substitution -> Bool .
 ceq onlyRenaming**(M,(V <- F[TL]) ; S)
   = onlyRenaming*(M,
        canonice(M, S << (V1 <- getIdSymbol(M,F[TL])))
     )
  if getIdSymbol(M,F[TL]) :: Term
  /\ TL1,V1,TL2,V2,TL3 := TL
  /\ typeLeq(M,getType(getIdSymbol(M,F[TL])),getType(V1))
     and-then
     not (V1 in Vars((TL1,TL2,V2,TL3)))
  /\ typeLeq(M,getType(getIdSymbol(M,F[TL])),getType(V2))
     and-then
     not (V2 in Vars((TL1,V1,TL2,TL3))) .
  eq onlyRenaming**(M,S)
   = onlyRenaming***(S) [owise] .

  op onlyRenaming*** : Substitution -> Bool .
  eq onlyRenaming***(none)
   = true .
  eq onlyRenaming***((V <- T) ; S)
   = T :: Variable
     and-then
     getType(V) == getType(T)
     and-then
     onlyRenaming***(S) .

  --- Standard metaMatch does not deal with shared variables between T and T'
  --- metaCoreMatch(M,T,T') implies that T is an instance of T'

  op metaCoreMatchShared : Module Term Term -> SubstitutionSet .
  eq metaCoreMatchShared(M,T,T')
   = metaShared-filter(M,T,T',metaCoreMatch(M,T,T')) .

  op metaBuiltInMatchShared : Module Term Term -> SubstitutionSet .
  eq metaBuiltInMatchShared(M,T,T')
   = metaShared-filter(M,T,T',metaBuiltInMatch(M,T,T')) .

  *******
  op metaShared-filter : Module Term Term SubstitutionSet
                           -> SubstitutionSet .
  eq metaShared-filter(M,T,T',SS)
   = metaShared-filter*(M,T,T',empty,SS) .

  op metaShared-filter* : Module Term Term SubstitutionSet SubstitutionSet
                           -> SubstitutionSet .
  eq metaShared-filter*(M,T,T',SS',empty)
   = SS' .
  eq metaShared-filter*(M,T,T',SS',S | SS)
   = metaShared-filter*(M,T,T',
        if S |> T == none
        then SS' | S
        else SS'
        fi,
     SS ) .


  *** Normalize Substitutions
  op normalizedSubstitution? : Module SubstitutionSet -> Bool .
  eq normalizedSubstitution?(M, empty)
   = true .
  eq normalizedSubstitution?(M, S | SS)
   = normalizedSubstitution?*(M, S) and-then normalizedSubstitution?(M, SS) .

  op normalizedSubstitution?* : Module Substitution -> Bool . ---[memo] .
  eq normalizedSubstitution?*(M, none)
   = true .
  eq normalizedSubstitution?*(M, V <- T ; S:Substitution)
   = isNF$(clearAllFrozen(M),T)
     and-then
     normalizedSubstitution?*(M, S:Substitution) .

  *** Normalize Substitutions
  op |_|`(_`) : SubstitutionSet Module -> SubstitutionSet .
  eq | S:SubstitutionSet |(M)
   = eqNormalizeSubstitution(M,S:SubstitutionSet) .

  op eqNormalizeSubstitution : Module SubstitutionSet -> SubstitutionSet .
  eq eqNormalizeSubstitution(M, empty)
   = empty .
  eq eqNormalizeSubstitution(M, S | SS)
   = eqNormalizeSubstitution*(M, S) | eqNormalizeSubstitution(M, SS) .

  op eqNormalizeSubstitution* : Module Substitution -> Substitution .
  eq eqNormalizeSubstitution*(M, none)
   = none .
  eq eqNormalizeSubstitution*(M, V <- T ; S:Substitution)
   = V <- getTerm(metaReduce(eraseRls(M),T))
     ; eqNormalizeSubstitution*(M, S:Substitution) .

endfm
fmod META-NORMALIZE is
  protecting META-TERM .
  protecting FM-META-LEVEL-MNPA .
  protecting FM-META-UNIFICATION .
  protecting FM-RESULT-CONTEXT-SET .
  protecting FM-ORDERS-TERM-SUBSTITUTION .
  protecting FM-TYPEOFNARROWING .

  vars T T' TOrig Lhs Rhs TS TS' CtTS CtTS' : Term .
  var V : Variable .
  var C : Constant .
  var F : Qid .
  vars TL TL' : TermList .
  var M : Module .
  vars RTS RTS' RTS$ RTS$' : ResultContextSet .
  vars RT RT' : ResultContext .
  vars TP TP' : Type .
  vars S S' S* S'* Subst : Substitution .
  var RLS : RuleSet .
  var Att : AttrSet .
  vars B BN : Bound .
  vars N NextVar NextVar' : Nat .
  var NL : NatList .
  vars Ct CtS Ct' CtS' : Context .
  var ON : TypeOfNarrowing .
  var QQ : TypeOfRelation .

  op |_| : ResultTripleSet -> Nat .
  eq | (empty).ResultTripleSet | = 0 .
  eq | {T,TP,S} | RTS:ResultTripleSet | = s(| RTS:ResultTripleSet |) .

  *** Shortcut to Normalization by rewriting Search
  op metaNormalizeCollect$ : Module Term ~> ResultTripleSet .
  eq metaNormalizeCollect$(M,T)
   = metaNormalizeCollect$(M,{T,leastSort(M,T),none}) .

  op metaNormalizeCollect$ : Module Term Type ~> ResultTripleSet .
  eq metaNormalizeCollect$(M,T,TP)
   = metaNormalizeCollect$(M,{T,TP,none}) .

  op metaNormalizeCollect$ : Module ResultTriple ~> ResultTripleSet .
  eq metaNormalizeCollect$(M,{T,TP,S})
   = metaSearchCollect(M,
       T, (addType TP ToVar 'XXXXXXX),
       '!,unbounded) .

  op metaSearchCollect$ : Module Term Type ~> ResultTripleSet .
  eq metaSearchCollect$(M,T,TP)
   = metaSearchCollect$(M,{T,TP,none}) .

  op metaSearchCollect$ : Module ResultTriple ~> ResultTripleSet .
  eq metaSearchCollect$(M,{T,TP,S})
   = metaSearchCollect(M,
       T, (addType TP ToVar 'XXXXXXX),
       '+,unbounded) .

  *** Shortcut to One rewriting step
  op metaOneRewriting$ : Module Term ~> ResultTripleSet .
  eq metaOneRewriting$(M,T)
   = metaOneRewriting$(M,{T,leastSort(M,T),none}) .

  op metaOneRewriting$ : Module Term Type -> ResultTripleSet .
  eq metaOneRewriting$(M,T,TP)
   = metaOneRewriting$(M,{T,TP,none}) .

  op metaOneRewriting$ : Module ResultTriple -> ResultTripleSet .

  eq metaOneRewriting$(M,{T,TP,S})
   = metaSearchCollect(M,
       T, (addType TP ToVar 'XXXXXXX),
       '+,1) .

  *** Use Standard Maude metaSearch
  op metaSearchCollect : Module Term Term TypeOfRelation Bound
                      ~> ResultTripleSet .
  eq metaSearchCollect(M,T,T',QQ,B)
   = metaSearchCollect(M,T,T',QQ,B,0) .

  op metaSearchCollect : Module Term Term TypeOfRelation Bound Nat
                      ~> ResultTripleSet .
  eq metaSearchCollect(M,T,T',QQ,B,N:Nat)
   = if metaSearch(M,T,T',nil,[QQ],B,N:Nat) :: ResultTripleSet
        and
        metaSearch(M,T,T',nil,[QQ],B,N:Nat) =/= failure
     then metaSearch(M,T,T',nil,[QQ],B,N:Nat)
          |
          metaSearchCollect(M,T,T',QQ,B,s(N:Nat))
     else empty
     fi .

  *** Shortcut to normal form detection
  op isNF$ : Module Substitution ~> Bool .
  eq isNF$(M, (none).Substitution)
   = true .
  eq isNF$(M, V:Variable <- T:Term ; S:Substitution)
   = isNF$(M,T) and-then isNF$(M, S:Substitution) .

  op isNF$ : Module Term ~> Bool .
  eq isNF$(M,T) = isNF$$(M,T,leastSort(M,T)) .

  op isNF$$ : Module Term Type ~> Bool .
  eq isNF$$(M,T,TP)
   = metaSearch(M,T,(addType TP ToVar 'XXXXXXX),nil,'+,1,0) == failure .

  ***********************************************************************
  --- Not defined in this module-------------
  op metaNarrowSearchAll : Module Term Term SubstitutionCond TypeOfRelation
                            Bound Bound --- number steps / number solutions
                            Bound --- chosen solution
                            TypeOfNarrowing
                            ResultContextSet
			 -> ResultContextSet .
  --- Not defined in this module-------------

  op metaNormalizeCollect : Module Term ~> ResultTripleSet .
  eq metaNormalizeCollect(M,T)
   = if anyNonExec(M)
     then metaNormalizeCollect#(M,T)
     else metaNormalizeCollect$(M,T)
     fi .

  op metaNormalizeCollect : Module Term Type -> ResultTripleSet .
  eq metaNormalizeCollect(M,T,TP)
   = if anyNonExec(M)
     then metaNormalizeCollect#(M,T,TP)
     else metaNormalizeCollect$(M,T,TP)
     fi .

  op metaSearchCollect : Module Term Type -> ResultTripleSet .
  eq metaSearchCollect(M,T,TP)
   = if anyNonExec(M)
     then metaSearchCollect#(M,T,TP)
     else metaSearchCollect$(M,T,TP)
     fi .

  op metaNormalizeCollect : Module ResultTriple -> ResultTripleSet .
  eq metaNormalizeCollect(M,{T,TP,S})
   = if anyNonExec(M)
     then metaNormalizeCollect#(M,{T,TP,S})
     else metaNormalizeCollect$(M,{T,TP,S})
     fi .

  op metaOneRewriting : Module Term ~> ResultTripleSet .
  eq metaOneRewriting(M,T)
   = if anyNonExec(M)
     then metaOneRewriting#(M,T)
     else metaOneRewriting$(M,T)
     fi .

  op metaOneRewriting : Module Term Type -> ResultTripleSet .
  eq metaOneRewriting(M,T,TP)
   = if anyNonExec(M)
     then metaOneRewriting#(M,T,TP)
     else metaOneRewriting$(M,T,TP)
     fi .

  op metaOneRewriting : Module ResultTriple -> ResultTripleSet .
  eq metaOneRewriting(M,{T,TP,S})
   = if anyNonExec(M)
     then metaOneRewriting#(M,{T,TP,S})
     else metaOneRewriting$(M,{T,TP,S})
     fi .

  --- Based on narrowing -----------------------------
  op metaNormalizeCollect# : Module Term ~> ResultTripleSet .
  eq metaNormalizeCollect#(M,T)
   = metaNormalizeCollect#(M,{T,leastSort(M,T),none}) .

  op metaNormalizeCollect# : Module Term Type -> ResultTripleSet .
  eq metaNormalizeCollect#(M,T,TP)
   = metaNormalizeCollect#(M,{T,TP,none}) .

  ---metaSearch of Maude doesn't work for rules with extra vars
  op metaNormalizeCollect# : Module ResultTriple -> ResultTripleSet .
  eq metaNormalizeCollect#(M,{T,TP,S})
   = toTriple(M,
     metaNarrowSearchAll(
       M,
       T, (addType TP ToVar 'XXXXXXX),
       none,'!,unbounded,unbounded,unbounded,E-rewriting noStrategy,
       {T,TP,S,none,[],[],T << S,T << S,
        max(highestVar(S),highestVar((T,T << S))) + 1,
        nil,
        empty}
     )) .

  op metaSearchCollect# : Module Term Type -> ResultTripleSet .
  eq metaSearchCollect#(M,T,TP)
   = metaSearchCollect#(M,{T,TP,none}) .

  ---metaSearch of Maude doesn't work for rules with extra vars
  op metaSearchCollect# : Module ResultTriple -> ResultTripleSet .
  eq metaSearchCollect#(M,{T,TP,S})
   = toTriple(M,
     metaNarrowSearchAll(
       M,
       T, (addType TP ToVar 'XXXXXXX),
       none,'+,unbounded,unbounded,unbounded,E-rewriting noStrategy,
       {T,TP,S,none,[],[],T << S,T << S,
        max(highestVar(S),highestVar((T,T << S))) + 1,
        nil,
        empty}
     )) .

  op metaOneRewriting# : Module Term ~> ResultTripleSet .
  eq metaOneRewriting#(M,T)
   = metaOneRewriting#(M,{T,leastSort(M,T),none}) .

  op metaOneRewriting# : Module Term Type -> ResultTripleSet .
  eq metaOneRewriting#(M,T,TP)
   = metaOneRewriting#(M,{T,TP,none}) .

  op metaOneRewriting# : Module ResultTriple -> ResultTripleSet .
  eq metaOneRewriting#(M,{T,TP,S})
   = toTriple(M,
     metaNarrowSearchAll(
       M,
       T, (addType TP ToVar 'XXXXXXX),
       none,'+,1,unbounded,unbounded,E-rewriting noStrategy,
       {T,TP,S,none,[],[],T << S,T << S,
        max(highestVar(S),highestVar((T,T << S))) + 1,
        nil,
        empty}
     )) .

  *** Remove itself
  op noSelf : ResultContextSet ResultContextSet -> ResultContextSet .
  eq noSelf(empty,RTS')
   = RTS' .
  eq noSelf({T,TP,S,S*,Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags} | RTS,RTS')
   = noSelf(RTS,
      if TS == T and-then CtTS == T and-then Ct == [] and-then CtS == []
      then noSelf*({T,TP,S,S*,Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags}, RTS')
      else RTS'
      fi
     ) .

  op noSelf* : ResultContext ResultContextSet -> ResultContextSet .
  eq noSelf*(RT,empty)
   = empty .
  eq noSelf*({T,TP,S,S*,[],[],T,T,NextVar,Tr:TraceNarrow,B:Flags},
             {T',TP',S',S'*,Ct',CtS',TS',CtTS',NextVar',Tr':TraceNarrow,B':Flags} | RTS)
   = if TS' == T' and-then CtTS' == T' and-then Ct' == [] and-then CtS' == []
        and-then
        T == T' and-then TP == TP'
        and-then
        (S |> T) == (S' |> T)
     then ---remove
          empty
     else ---keep
          {T',TP',S',S'*,Ct',CtS',TS',CtTS',NextVar',Tr:TraceNarrow,B':Flags}
     fi
     | noSelf*({T,TP,S,S*,[],[],T,T,NextVar,Tr':TraceNarrow,B:Flags},RTS) .

endfm

fmod FM-META-E-NARROWING is
  protecting META-TERM .
  protecting FM-META-LEVEL-MNPA .
  protecting FM-META-UNIFICATION .
  protecting META-MSG-UNIFICATION .
  protecting FM-META-E-UNIFICATION .
  protecting FM-RESULT-CONTEXT-SET .
  protecting FM-ORDERS-TERM-SUBSTITUTION .
  protecting FM-TYPEOFNARROWING .
  protecting META-NORMALIZE .
  protecting FM-UNIFICATIONTRIPLESET .
  protecting FM-RIGIDIFE .

  var T T' T'' TOrig Lhs Lhs' Rhs Rhs'  : Term .
  var CT' TS TS' TS'' CtTS CtTS' CtTS'' : Term .
  var V : Variable .
  var C : Constant .
  var F : Qid .
  var M : Module .
  var RTS RTS' RTS$ RTS-Rls RTS-Sub RTSSol : ResultContextSet .
  var RTNeS : ResultContextNeSet .
  var RT RT' : ResultContext .
  vars S S' S'' Subst Subst' S* S'* : Substitution .
  var SS : SubstitutionSet .
  var RLS : RuleSet .
  var RL : Rule .
  vars Att Att' : AttrSet .
  var B BN : Bound .
  vars N N' N1 N2 : Nat .
  var NL : NatList .
  vars Ct CtS Ct' CtS' Ct'' CtS'' : Context .
  var NeTL NeTL' : NeTermList .
  vars TL TL' TL'' TL''' : TermList .
  vars TP TP' TP'' : Type .
  var ON : TypeOfNarrowing .
  vars NextVar NextVar' NextVar'' NVarPrev : Nat .
  var U : UnificationTriple .
  vars US US' : UnificationTripleSet .
  var IRR : IrrFlags .

  --- metaNarrow ---------------------------
  ---( We implement:
       * basic narrowing, where terms introduced
         by unifiers (substitutions) are never
         selected for narrowing, and
       * standard narrowing, where this
         restriction does not apply  )


  *** Shortcuts to Narrowing
  op metaNarrow : Module Term -> ResultTripleSet .
  eq metaNarrow(M,T) = metaNarrow(M,T,1) .

  op metaNarrow : Module Term Bound -> ResultTripleSet .
  eq metaNarrow(M,T,B)
   = toTriple(M,metaENarrowShowAll(M,T,B,full noStrategy BuiltIn-unify)) |> T .

  *** Shortcuts to Basic Narrowing
  op metaBasicNarrow : Module Term -> ResultTripleSet .
  eq metaBasicNarrow(M,T) = metaBasicNarrow(M,T,1) .

  op metaBasicNarrow : Module Term Bound -> ResultTripleSet .
  eq metaBasicNarrow(M,T,B)
   = toTriple(M,metaENarrowShowAll(M,T,B,basic noStrategy BuiltIn-unify)) |> T .

  *** Shortcuts to Narrowing
  op metaENarrow : Module Term -> ResultTripleSet .
  eq metaENarrow(M,T) = metaENarrow(M,T,1) .

  op metaENarrow : Module Term Bound -> ResultTripleSet .
  eq metaENarrow(M,T,B)
   = toTriple(M,metaENarrowShowAll(M,T,B,full noStrategy E-BuiltIn-unify))
     |> T .

  *** Shortcuts to Narrowing
  op metaEBuiltInTopMostNarrow : Module Term Nat -> ResultTripleSet .
  eq metaEBuiltInTopMostNarrow(M,T,N)
   = metaETopMostNarrow(M,T,1,reducible, E-BuiltIn-unify,N) .
  op metaEBuiltInTopMostNarrowIrr : Module Term Nat -> ResultTripleSet .
  eq metaEBuiltInTopMostNarrowIrr(M,T,N)
   = metaETopMostNarrow(M,T,1,irreducible, E-BuiltIn-unify,N) .

  op metaEACUTopMostNarrow : Module Term Nat -> ResultTripleSet .
  eq metaEACUTopMostNarrow(M,T,N)
   = metaETopMostNarrow(M,T,1,reducible, E-ACU-unify,N) .
  op metaEACUTopMostNarrowIrr : Module Term Nat -> ResultTripleSet .
  eq metaEACUTopMostNarrowIrr(M,T,N)
   = metaETopMostNarrow(M,T,1,irreducible, E-ACU-unify,N) .

  op metaETopMostNarrow : Module Term Bound IrrFlags TypeOfNarrowing Nat
                       -> ResultTripleSet .
  eq metaETopMostNarrow(M,T,B,IRR,ON,N)
   = toTriple(M,metaENarrowShowAll(M,T,B,full topmost ON [IRR],N)) |> T .

  op metaEBuiltInTopMostNarrowRC : Module Term TermList Nat -> ResultContextSet .
  eq metaEBuiltInTopMostNarrowRC(M,T,TL,N)
   = metaETopMostNarrowRC(M,T,1,reducible, E-BuiltIn-unify irrTerms(TL),N) .
  op metaEBuiltInTopMostNarrowRCIrr : Module Term TermList Nat -> ResultContextSet .
  eq metaEBuiltInTopMostNarrowRCIrr(M,T,TL,N)
   = metaETopMostNarrowRC(M,T,1,irreducible, E-BuiltIn-unify irrTerms(TL),N) .

  op metaEACUTopMostNarrowRC : Module Term Nat -> ResultContextSet .
  eq metaEACUTopMostNarrowRC(M,T,N)
   = metaETopMostNarrowRC(M,T,1,reducible, E-ACU-unify,N) .
  op metaEACUTopMostNarrowRCIrr : Module Term Nat -> ResultContextSet .
  eq metaEACUTopMostNarrowRCIrr(M,T,N)
   = metaETopMostNarrowRC(M,T,1,irreducible, E-ACU-unify,N) .

  op metaETopMostNarrowRC : Module Term Bound IrrFlags TypeOfNarrowing Nat
                       -> ResultContextSet .
  eq metaETopMostNarrowRC(M,T,B,IRR,ON,N)
   = metaENarrowShowAll(M,T,B,full topmost ON [IRR],N) |> T .

  --- Auxiliary
  op [_,_] : TypeOfNarrowing IrrFlags ~> TypeOfNarrowing .
  eq [ E-ACU-unify, reducible ] = E-ACU-unify .
  eq [ E-ACU-unify, irreducible ] = E-ACU-unify-Irr .
  eq [ E-BuiltIn-unify, reducible ] = E-BuiltIn-unify .
  eq [ E-BuiltIn-unify, irreducible ] = E-BuiltIn-unify-Irr .

  *** Shortcuts to Basic Narrowing
  op metaEBasicNarrow : Module Term -> ResultTripleSet .
  eq metaEBasicNarrow(M,T)
   = metaEBasicNarrow(M,T,1) .

  *** Shortcuts for normalization
  op metaEBasicNarrow : Module Term Bound -> ResultTripleSet .
  eq metaEBasicNarrow(M,T,B)
   = toTriple(M,metaENarrowShowAll(M,T,B,E-BuiltIn-unify noStrategy basic)) |> T .

  op metaBasicNarrowNormalize : Module Term -> ResultTripleSet .
  eq metaBasicNarrowNormalize(M,T)
   = toTriple(M,metaBasicNarrowNormalizeAll(M,T,highestVar(T) + 1)) |> T .

  op metaBasicNarrowNormalizeAll : Module Term Nat -> ResultContextSet .
  eq metaBasicNarrowNormalizeAll(M,T,NextVar)
   = metaENarrowShowAll(M,T,unbounded,
         basic BuiltIn-unify
         computed-normalized-subs applied-normalized-subs
         normalize-terms noStrategy,NextVar) .

  op metaNarrowNormalize : Module Term -> ResultTripleSet .
  eq metaNarrowNormalize(M,T)
   = toTriple(M,metaNarrowNormalizeAll(M,T,highestVar(T) + 1)) |> T .

  op metaNarrowNormalizeAll : Module Term Nat -> ResultContextSet .
  eq metaNarrowNormalizeAll(M,T,NextVar)
   = metaENarrowShowAll(M,T,unbounded,
         full BuiltIn-unify
         computed-normalized-subs applied-normalized-subs
         normalize-terms noStrategy,NextVar) .

  *** General Call
  op metaENarrowShowAll : Module Term Bound TypeOfNarrowing
                       -> ResultContextSet .
  eq metaENarrowShowAll(M,T,B,ON)
   = metaENarrowShowAll(M,T,B,ON,highestVar(T) + 1) .

  op metaENarrowShowAll : Module Term Bound TypeOfNarrowing Nat
                       -> ResultContextSet .
  eq metaENarrowShowAll(M,T,B,ON,N)
   = metaENarrowGen(removeBoolEqs(M),B,ON,
       {T,leastSort(M,T),none,none,[],[],T,T,N,nil,empty}) .

  *** Call for ResultContextSet
  op metaENarrowGen : Module Bound TypeOfNarrowing
                      ResultContextSet
                   -> ResultContextSet .

  eq metaENarrowGen(M,B,ON,RTS)
   = if B == 0
     then RTS
     else metaENarrowGen*(M,B,ON,empty,empty,RTS)
     fi .

  op metaENarrowGen* : Module
                       Bound TypeOfNarrowing
                       ResultContextSet ResultContextSet ResultContextSet
                    -> ResultContextSet .
  eq metaENarrowGen*(M,B,ON,RTSSol,RTS',empty)
   = if RTS' == empty
        or-else
        (B =/= unbounded and-then B <= 1)
     then RTSSol | RTS' --- Stop
     else metaENarrowGen*(M,dec(B),ON,RTSSol,empty,RTS')
     fi .
  eq metaENarrowGen*(M,B,ON,RTSSol,RTS',RT | RTS)
   = if isEND(normalize-terms?(M,ON,RT))
     then metaENarrowGen*(M,B,ON,
          RTSSol | normalize-terms?(M,ON,RT),
          RTS',RTS)
     else metaENarrowGen*(M,B,ON,RTSSol,
          RTS' |
             filter-variant-RT(M,ON,normalize-terms?(M,ON,RT),
                metaENarrowGen**(M,B,ON,normalize-terms?(M,ON,RT))),
          RTS)
     fi .

  op testNonVarRedex : TypeOfNarrowing Term Term -> Bool .
  eq testNonVarRedex(alsoAtVarPosition ON,T,TS) = true .
  eq testNonVarRedex(ON,T,TS) = testNonVarRedex*(ON,T,TS) [owise] .

  op testNonVarRedex* : TypeOfNarrowing Term Term -> Bool .
  eq testNonVarRedex*(basic ON,T,TS) = not(T :: Variable) .
  eq testNonVarRedex*(ON,T,TS)       = not(TS :: Variable) [owise] .

  op metaENarrowGen** : Module
                        Bound TypeOfNarrowing
                        ResultContext
                     -> ResultContextSet .
  eq metaENarrowGen**(M,B,ON,{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
   = if not testNonVarRedex(ON,T,TS) --- T is a variable
     then if CtS == []
          then *** Term CtTS is a normal form so we return it
               {T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags}
	  else *** Term T is a rigid normal form inside a context Ct
	       *** but since no rewrite has been done and
               *** this can be part of a previous metaNarrowSub call,
               *** this path is discarded
               empty
          fi
     else if metaENarrowStra(M,B,ON,{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
	     =/= empty
          then metaENarrowStra(M,B,ON,{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
          else if CtS == []
               then *** Term CtTS is a normal form so we return it
                    {T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,end(true,B:Flags)}
	       else *** Term T is a rigid normal form inside a context Ct
	            *** but since no rewrite has been done and
                    *** this can be part of a previous metaNarrowSub call,
                    *** this path is discarded
                    empty
               fi
          fi
     fi .

  *** Try all rules at top level of term T in context Ct with metaENarrowRls
  *** Try also inner subterms of T with metaENarrowSub
  *** Note that metaENarrowRls and metaENarrowSub
  *** call to metaNarrow recursively
  op metaENarrowStra : Module Bound TypeOfNarrowing ResultContext
                    -> ResultContextSet .
  ---innermost
  eq metaENarrowStra(M,B,innermost ON,RT)
   = if metaENarrowSub(M,B,innermost ON,RT) =/= empty
     then metaENarrowSub(M,B,innermost ON,RT)
     else metaENarrowRls(M,B,innermost ON,getRls(M),RT)
     fi .

  ---outermost
  eq metaENarrowStra(M,B,outermost ON,RT)
   = if metaENarrowRls(M,B,outermost ON,getRls(M),RT) =/= empty
     then metaENarrowRls(M,B,outermost ON,getRls(M),RT)
     else metaENarrowSub(M,B,outermost ON,RT)
     fi .

  ---topmost
  eq metaENarrowStra(M,B,topmost ON,RT)
   = metaENarrowRls(M,B,topmost ON,getRls(M),RT) .

  ---noStrategy
  eq metaENarrowStra(M,B,noStrategy ON,RT)
   = metaENarrowRls(M,B,noStrategy ON,getRls(M),RT)
     |
     metaENarrowSub(M,B,noStrategy ON,RT) .

  op dec : Bound -> Bound .
  eq dec(unbounded) = unbounded .
  eq dec(s(N)) = N .

  *** Generic call to metaUnification with different parameters
  op auxMetaUnify : Module TypeOfNarrowing
                    Term Term Nat ~> UnificationTripleSet .
		--- Term Lhs
  eq auxMetaUnify(M,variant(N') ON,T,T',N)
   = unrigidife(qid(N'),
       auxMetaUnify*(getM(rigidifeNat(M,qid(N'),T,N')),
                     variant(N') ON,
                     getTL(rigidifeNat(M,qid(N'),T,N')),
                     T',
                     N)
     ) .

  eq auxMetaUnify(M,ON,T,T',N)
   = auxMetaUnify*(M,ON,T,T',N) [owise] .

  op auxMetaUnify* : Module TypeOfNarrowing
                    Term Term Nat ~> UnificationTripleSet .
		--- Term Lhs
 ceq auxMetaUnify*(M,rigidife(F:Qid) ON,T,T',N)
   = unrigidife(Q:Qid,
       auxMetaUnify**(M#:Module,rigidife(F:Qid) ON,T#:Term,T',N)
     )
  if F:Qid[TL:TermList] := T
  /\ Q:Qid := 'auxMetaUnify
  /\ X:PairRigidife := rigidifeRigid(M,Q:Qid,T)
  /\ M#:Module := getM(X:PairRigidife)
  /\ T#:Term := getTL(X:PairRigidife) .

  eq auxMetaUnify*(M,ON,T,T',N)
   = auxMetaUnify**(M,ON,T,T',N) [owise] .

  op auxMetaUnify** : Module TypeOfNarrowing
                     Term Term Nat ~> UnificationTripleSet .
		 --- Term Lhs
                 --- [memo] . --- Very useful but huge space use
  eq auxMetaUnify**(M,E-rewriting ON,T,T',N)
   = toUnificationTriple[N](metaCoreMatch(removeBoolEqs(M),T,T')) .
  eq auxMetaUnify**(M,E-ACU-unify ON,T,T',N)
   = metaEACUUnify(removeBoolEqs(M),T,T',getIrrTerms(ON),N,reducible) .
  eq auxMetaUnify**(M,E-ACU-unify-Irr ON,T,T',N)
   = metaEACUUnify(removeBoolEqs(M),T,T',getIrrTerms(ON),N,irreducible) .
  eq auxMetaUnify**(M,E-BuiltIn-unify ON,T,T',N)
   = metaEBuiltInUnify(removeBoolEqs(M),T,T',getIrrTerms(ON),N,reducible) .
  eq auxMetaUnify**(M,E-BuiltIn-unify-Irr ON,T,T',N)
   = metaEBuiltInUnify(removeBoolEqs(M),T,T',getIrrTerms(ON),N,irreducible) .
  eq auxMetaUnify**(M,ACU-unify ON,T,T',N)
   = metaACUUnify(removeBoolEqs(M),T,T',N) .
  eq auxMetaUnify**(M,BuiltIn-unify ON,T,T',N)
   = metaBuiltInUnify(removeBoolEqs(M),getIrrTerms(ON),T,T',N) .

  *** Remove rigid normal forms
  op removeEND : ResultContextSet -> ResultContextSet .
  eq removeEND(RTS)
   = removeEND*(RTS,empty) .

  op removeEND* : ResultContextSet ResultContextSet -> ResultContextSet .
  eq removeEND*(empty,RTS')
   = RTS' .
  eq removeEND*(RT | RTS,RTS')
   = removeEND*(RTS,if isEND(RT) then RTS' else RTS' | RT fi) .

  op remove_From_ : ResultContextSet ResultContextSet -> ResultContextSet .
  eq remove(RT | RTS) From (RT | RTS')
   = remove(RTS) From (RT | RTS') .
  eq remove(RTS) From (RTS')
   = RTS [owise] .

  op isEND : ResultContext -> Bool .
  eq isEND({T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
   = end(B:Flags) .

  *** Call for Rules ---> Returns empty if no rule is applied
  op metaENarrowRls : Module Bound TypeOfNarrowing
                      RuleSet ResultContext
                   -> ResultContextSet .
  eq metaENarrowRls(M,B,ON,RL RLS,RT)
   = metaENarrowRls#(M,B,ON,RL RLS,RT,empty) .
  eq metaENarrowRls(M,B,ON,none,RT)
   = empty .

  op metaENarrowRls# : Module Bound TypeOfNarrowing
                      RuleSet ResultContext ResultContextSet
                   -> ResultContextSet .
  eq metaENarrowRls#(M,B,ON,none,RT,RTS)
   = RTS .
  eq metaENarrowRls#(M,B,ON,RL RLS,RT,RTS)
   = metaENarrowRls#(M,B,ON,RLS,RT,
      RTS |
        filter-variant-RT(M,ON,RT,
           metaENarrowRls*(M,B,ON,RL,RT)
        )
     ) .

  --- General case
  op metaENarrowRls* : Module Bound TypeOfNarrowing
                       Rule ResultContext
                    -> ResultContextSet .
  eq metaENarrowRls*(M,B,ON,
        (rl Lhs => Rhs [Att].),
	{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
   = metaENarrowRls**$(M,B,ON,
        (rl Lhs => Rhs [Att].),
	{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,
           Tr:TraceNarrow {CtTS,none,leastSort(M,CtTS),(rl Lhs => Rhs [Att].)},
                          --- Subst none here is key to write the real stuff
                          --- later in function _<<_
           B:Flags},
        'rl_=>_`[_`].[Lhs,Rhs,'none.AttrSet] <<{none,NextVar}<) .
  eq metaENarrowRls*(M,B,ON, X:Rule, X:ResultContext)
   = empty [owise] .

  op metaENarrowRls**$ : Module Bound TypeOfNarrowing
                         Rule ResultContext
                         UnificationPair
                      -> ResultContextSet .
  eq metaENarrowRls**$(M,B,ON,
        (rl Lhs => Rhs [Att].),
	{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags},
        {Subst,NextVar'})
   = metaENarrowRls**$$(M,B,ON,
	{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags},
        {Subst,NextVar'},
        'rl_=>_`[_`].[Lhs,Rhs,'none.AttrSet] << Subst) .

  op metaENarrowRls**$$ : Module Bound TypeOfNarrowing
                          ResultContext
                          UnificationPair Term
                       -> ResultContextSet .
  eq metaENarrowRls**$$(M,B,ON,
	{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,
          Tr:TraceNarrow {CtTS,none,TP$:Type,(rl Lhs => Rhs [Att].)},
          B:Flags},
        {Subst,NextVar'},
        'rl_=>_`[_`].[Lhs',Rhs','none.AttrSet])
   = metaENarrowRls**$$$(M,B,ON,
	{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,
           Tr:TraceNarrow {CtTS,none,TP$:Type,(rl Lhs' => Rhs' [Att].)},
           B:Flags},
        {Subst,NextVar'},
        'rl_=>_`[_`].[Lhs',Rhs','none.AttrSet],
        auxMetaUnify(M,ON,TS,Lhs',NextVar')) .

  op metaENarrowRls**$$$ : Module Bound TypeOfNarrowing
                           ResultContext
                           UnificationPair Term UnificationTripleSet
                        -> ResultContextSet .
  eq metaENarrowRls**$$$(M,B,ON,
	{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags},
        {Subst,NextVar'},
        'rl_=>_`[_`].[Lhs',Rhs','none.AttrSet],US)
    = if US =/= empty
      then rebuildTypeAndDiscardErroneous(M,ON,
               {Ct[Rhs'],
	        TP,
		S,S',
		[],
		[],
		CtS[Rhs'],
		CtS[Rhs'],
		NextVar',
                Tr:TraceNarrow,
                B:Flags}
               <<(M,ON) US
            )
      else empty
      fi .

  *** rebuild the context of the applied rule **********************
  op rebuildTypeAndDiscardErroneous : Module TypeOfNarrowing
                                      ResultContextSet -> ResultContextSet .
  eq rebuildTypeAndDiscardErroneous(M,ON,empty)
   = empty .
  eq rebuildTypeAndDiscardErroneous(M,ON,RT | RTS)
   = rebuildTypeAndDiscardErroneous*(M,ON,RT)
     | rebuildTypeAndDiscardErroneous(M,ON,RTS) .

  op rebuildTypeAndDiscardErroneous* : Module TypeOfNarrowing
                                       ResultContext -> ResultContextSet .
  eq rebuildTypeAndDiscardErroneous*(M,ON,
       {T,TP,S,S',[],[],TS,TS,NextVar,Tr:TraceNarrow,B:Flags})
   = if	leastSort(M,TS) :: Type
     then normalize-terms?(M,ON,
             {canonice(M,T),leastSort(M,TS),
              canonice(M,S),canonice(M,S'),
              [],[],canonice(M,TS),canonice(M,TS),
              NextVar,
              canonice(M,Tr:TraceNarrow),B:Flags})
     else empty
     fi .

  *** auxiliary for variant narrowing **********************
  op _<<`(_`,_`)_ : ResultContext
                    Module TypeOfNarrowing
                    UnificationTripleSet -> ResultContextSet .

  eq RT <<(M,ON) (empty).UnificationTripleSet
   = (empty).ResultContextSet .

  eq {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
     <<(M,ON) ({Subst,Subst',N} | SS:UnificationTripleSet)
   = {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
     <<((M,ON)) {Subst,Subst',N}
     |
     {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
     <<(M,ON) SS:UnificationTripleSet .

  op _<<`(`(_`,_`)`)_ : ResultContext
                        Module TypeOfNarrowing
                        UnificationTriple -> ResultContextSet .

  eq {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
     <<((M,ON)) {Subst,Subst',N}
   = if (variant in ON
         and-then
         (Subst == none
          or-else
          (not anyIdSymbol(M,Subst ; Subst')
           and-then
           normalizedSubstitution?(M,Subst ; Subst'))
          or-else
          anyIdSymbol(M,Subst ; Subst')
         )
        )
        or-else
        (computed-normalized-subs in ON
         and-then normalizedSubstitution?(M,Subst))
        or-else
        (applied-normalized-subs in ON
         and-then normalizedSubstitution?(M,Subst'))
        or-else
        (not variant in ON
         and-then
         not applied-normalized-subs in ON
         and-then
         not computed-normalized-subs in ON)
     then {T,TP,S,S',Ct:Context,CtS:Context,TS:Term,CtTS:Term,NextVar,Tr:TraceNarrow,B:Flags}
           << if anyIdSymbol(M,Subst ; Subst')
              ---then {normalizeRls(M,Subst),normalizeRls(M,Subst'),N}
              then {canonice(M,Subst),canonice(M,Subst'),N}
              else {Subst,Subst',N}
              fi
     else (empty).ResultContextSet
     fi .

  *** test flag normalize-terms and normalize **********************
  *** !!!! This mustn't be combined with basic -> strange behavior
  op normalize-terms? : Module TypeOfNarrowing ResultContext
                     -> ResultContext .
  eq normalize-terms?(M,E-normalize-terms ON,
     {T,TP,S,S',[],[],TS,TS,NextVar,Tr:TraceNarrow,B:Flags})
   = {getTerm(metaReduce(M,T)),
      getType(metaReduce(M,T)),
      S,S',[],[],
      getTerm(metaReduce(M,TS)),
      getTerm(metaReduce(M,TS)),
      NextVar,Tr:TraceNarrow,B:Flags} .
  eq normalize-terms?(M,normalize-terms ON,
     {T,TP,S,S',[],[],TS,TS,NextVar,Tr:TraceNarrow,B:Flags})
   = {getTerm(metaNormalizeCollect(M,T)),
      getType(metaNormalizeCollect(M,T)),
      S,S',[],[],
      getTerm(metaNormalizeCollect(M,TS)),
      getTerm(metaNormalizeCollect(M,TS)),
      NextVar,Tr:TraceNarrow,B:Flags} .
  eq normalize-terms?(M,ON,RT)
   = RT [owise] .

  *** Call at inner subterms
  op metaENarrowSub : Module Bound TypeOfNarrowing ResultContext
                      -> ResultContextSet .
  eq metaENarrowSub(M,B,ON,{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
   = metaENarrowSub#(M,B,ON,flatten(M,auxSplitTerm(ON,T,TS)),
            {T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags}) .

  op auxSplitTerm : TypeOfNarrowing Term Term -> Term .
  eq auxSplitTerm(basic ON,T,TS) = T .
  eq auxSplitTerm(ON,T,TS) = TS [owise] .

  op metaENarrowSub# : Module Bound TypeOfNarrowing Term ResultContext
                      -> ResultContextSet .
  eq metaENarrowSub#(M,B,ON,C,RT) = empty .
  eq metaENarrowSub#(M,B,ON,V,RT) = empty .
  eq metaENarrowSub#(M,B,ON,F[NeTL],RT)
   = metaENarrowSub#Gen(M,B,ON,
       splitTerm(M,F,
                 1,getFrozen(M,F,getTypes(M,NeTL)),
                 isAssociative(M,F,getTypes(M,NeTL))
                 or isCommutative(M,F,getTypes(M,NeTL)),
                 empty,NeTL,RT)) .

  op splitTerm : Module Qid
                 Nat NeNatList Bool
                 TermList TermList
                 ResultContext -> ResultContextSet .

  eq splitTerm(M,F,
               N,NL,AC?:Bool,
               TL',empty,
               RT)
   = empty .

  eq splitTerm(M,F,
               N,NL,AC?:Bool,
               TL',(T,TL),
               {T'',TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
   = if ((not AC?:Bool) and-then N inNatList NL)
        or-else
        (AC?:Bool and-then NL =/= 0)
     then empty
     else {T,leastSort(M,T),S,S',
           Ct[F[TL',[],TL]],
           CtS[F[TL' << (S ; S'),[],TL << (S ; S')]],T << (S ; S'),
           CtTS,NextVar,Tr:TraceNarrow,B:Flags}
     fi
     | splitTerm(M,F,
                 s(N),NL,AC?:Bool,
                 (TL',T),TL,
                 {T'',TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags}) .

  op metaENarrowSub#Gen : Module Bound TypeOfNarrowing ResultContextSet
                       -> ResultContextSet .
  eq metaENarrowSub#Gen(M,B,ON,empty)
   = empty .
  eq metaENarrowSub#Gen(M,B,ON,RT | RTS)
   = metaENarrowGen**(M,B,ON,RT) | metaENarrowSub#Gen(M,B,ON,RTS) .

  op filter-variant-RT : Module TypeOfNarrowing ResultContext
                      ResultContextSet -> ResultContextSet .
  eq filter-variant-RT(M,ON,
          {T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags},RTS)
   = if variant in ON and testUnifier !in ON
     then filter-variant-RT*(M,Vars(TS),empty,RTS)
     else RTS
     fi .

  op filter-variant-RT* :
       Module TermList ResultContextSet ResultContextSet -> ResultContextSet .
  eq filter-variant-RT*(M,TL,RTS$,empty)
   = RTS$ .
  eq filter-variant-RT*(M,TL,RTS$,RT | RTS)
   = filter-variant-RT**(M,TL,RTS$,RTS,RT,RTS) .

  op filter-variant-RT** :
        Module TermList ResultContextSet ResultContextSet
                        ResultContext ResultContextSet -> ResultContextSet .
  eq filter-variant-RT**(M,TL,RTS$,RTS',RT,empty)
   = --- RT is not implied by any in RTS'
     filter-variant-RT*(M,TL,RTS$ | RT,RTS') .
  eq filter-variant-RT**(M,TL,RTS$,RT | RTS',RT',RT | RTS)
   = if test-variant-RT(M,TL,RT,RT')
     then --- RT' is implied by RT in RTS'
          filter-variant-RT*(M,TL,RTS$,RT | RTS')
     else if test-variant-RT(M,TL,RT',RT)
          then --- remove RT from the set RTS'
               filter-variant-RT**(M,TL,RTS$,RTS',RT',RTS)
          else --- continue searching in RTS
               filter-variant-RT**(M,TL,RTS$,RT | RTS',RT',RTS)
          fi
     fi .

  op test-variant-RT : Module TermList ResultContext ResultContext
                    -> Bool .
  eq test-variant-RT(M,TL,
         {T,TP,S,S*,Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags},
         {T',TP',S',S'*,Ct',CtS',TS',CtTS',NextVar',Tr':TraceNarrow,B':Flags})
   = test-variant-RT*(M,TL,S |> TL,S' |> TL) .

  op test-variant-RT* : Module TermList Substitution Substitution -> Bool .
  eq test-variant-RT*(M,TL,S,S')
   = | S | <= | S' |
     and-then
     S <=[TL,M] S' . --- keep T & remove T'

  op |_| : Substitution -> Nat .
  eq | (none).Substitution | = 0 .
  eq | V <- T ; S | = s(| S |) .

endfm

fmod FM-META-NARROWING-SEARCH is
  protecting FM-META-E-NARROWING .
  protecting META-TERM .
  protecting FM-META-LEVEL-MNPA .
  protecting FM-META-UNIFICATION .
  protecting FM-RESULT-CONTEXT-SET .
  protecting FM-ORDERS-TERM-SUBSTITUTION .

  var T T' TOrig Lhs Rhs TS TS' CtTS CtTS' : Term .
  var V : Variable .
  var C : Constant .
  var F Q Q' : Qid .
  vars TL TL' : TermList .
  var M : Module .
  var RTS RTS' RTSSol : ResultContextSet .
  var RT RT' : ResultContext .
  vars TP TP' Ty : Type .
  vars S S' Subst S* S'* Sb Sb' : Substitution .
  var RLS : RuleSet .
  var Att : AttrSet .
  var B BN Sol : Bound .
  var N : Nat .
  var NL : NatList .
  vars Ct Ct' CtS CtS' : Context .
  var ON : TypeOfNarrowing .
  vars QQ QQ' : TypeOfRelation .
  var QI : Qid .
  vars NextVar NextVar' : Nat .

  var SCond : SubstitutionCond .

  --- metaNarrowSearch --------------------------------------------------------

  *** Shortcuts to Narrowing Search
  op metaNarrowSearch : Module Term Term SubstitutionCond
                        TypeOfRelation Bound Bound Bound
                        -> ResultTripleSet .
  eq metaNarrowSearch(M,T,T',SCond,QQ,BN,B,Sol)
   = if (BN == unbounded and-then Sol =/= unbounded)
        or-else
        (BN =/= unbounded and-then Sol =/= unbounded and-then BN < Sol)
     then metaNarrowSearch*(M,T,T',SCond,QQ,Sol,B,Sol)
     else metaNarrowSearch*(M,T,T',SCond,QQ,BN,B,Sol)
     fi .

  op metaVUNarrow : Module Term Term SubstitutionCond
                    Qid Bound Bound Bound
                 -> ResultTripleSet .
  eq metaVUNarrow(M, T, T', Sb, QI, BN, B, Sol)
    = metaVUNarrow(M, T, T', Sb, QI, BN, B, Sol, 0) .

  op metaVUNarrow : Module Term Term SubstitutionCond
                        Qid Bound Bound Bound Nat
                        -> ResultTripleSet .
  eq metaVUNarrow(M, T, T', Sb, QI, BN, B, Sol, N)
    = if metaNarrowingSearch(M, T, T', QI, BN, 'none, N) == failure
      then empty
      else narrowingSearchResult2ResultTriple(metaNarrowingSearch(M, T, T', QI, BN, 'none, N)) |
           metaVUNarrow(M, T, T', Sb, QI, BN, B, Sol, s N)
      fi .

  op narrowingSearchResult2ResultTriple : NarrowingSearchResult -> ResultTriple .
  eq narrowingSearchResult2ResultTriple({T,Ty,Sb,Q,Sb',Q'}) = {T, Ty, Sb} .

  op metaNarrowSearch* : Module Term Term SubstitutionCond
                         TypeOfRelation Bound Bound Bound
                         -> ResultTripleSet .
  eq metaNarrowSearch*(M,T,T',SCond,QQ,BN,B,Sol)
   = metaNarrowSearchGen(M,T,T',SCond,QQ,BN,B,Sol,
         full E-BuiltIn-unify noStrategy E-normalize-terms) .

  *** Shortcuts to Paramodulation Search
  op metaParamodulationSearch : Module Term Term SubstitutionCond
                                TypeOfRelation Bound Bound Bound
                             -> ResultTripleSet .
  eq metaParamodulationSearch(M,T,T',SCond,QQ,BN,B,Sol)
   = if (BN == unbounded and-then Sol =/= unbounded)
        or-else
        (BN =/= unbounded and-then Sol =/= unbounded and-then BN < Sol)
     then metaParamodulationSearch*(M,T,T',SCond,QQ,Sol,B,Sol)
     else metaParamodulationSearch*(M,T,T',SCond,QQ,BN,B,Sol)
     fi .

  op metaParamodulationSearch* : Module Term Term SubstitutionCond
                         TypeOfRelation Bound Bound Bound
                         -> ResultTripleSet .
  eq metaParamodulationSearch*(M,T,T',SCond,QQ,BN,B,Sol)
   = metaNarrowSearchGen(M,T,T',SCond,QQ,BN,B,Sol,
         full E-BuiltIn-unify noStrategy E-normalize-terms alsoAtVarPosition) .

  *** General Call
  op metaNarrowSearchGen : Module Term Term SubstitutionCond
                           TypeOfRelation
                           Bound --- number of steps
                           Bound --- number of solutions
                           Bound --- chosen solution
                           TypeOfNarrowing
			-> ResultTripleSet .
  eq metaNarrowSearchGen(M,T,T',SCond,QQ,B,BN,Sol,ON)
   = toTriple(M,metaNarrowSearchGenAll(M,T,T',SCond,QQ,B,BN,Sol,ON)) .

  *** Shortcuts to Narrowing Search Path
  op metaNarrowSearchPath : Module Term Term SubstitutionCond
                            TypeOfRelation Bound Bound Bound
                         -> TraceNarrowSet .
  eq metaNarrowSearchPath(M,T,T',SCond,QQ,B,BN,Sol)
   = if (BN == unbounded and-then Sol =/= unbounded)
        or-else
        (BN =/= unbounded and-then Sol =/= unbounded and-then BN < Sol)
     then metaNarrowSearchPath*(M,T,T',SCond,QQ,Sol,B,Sol)
     else metaNarrowSearchPath*(M,T,T',SCond,QQ,BN,B,Sol)
     fi .

  op metaNarrowSearchPath* : Module Term Term SubstitutionCond
                             TypeOfRelation Bound Bound Bound
                          -> TraceNarrowSet .
  eq metaNarrowSearchPath*(M,T,T',SCond,QQ,BN,B,Sol)
   = extractTraces(
       metaNarrowSearchGenAll(M,T,T',SCond,QQ,B,BN,Sol,
         full E-BuiltIn-unify noStrategy E-normalize-terms)) .

  op extractTraces : ResultContextSet -> TraceNarrowSet .
  eq extractTraces(empty) = empty .
  eq extractTraces({T,TP,S,S*,Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags} | RTS)
   = if Tr:TraceNarrow == nil then empty else Tr:TraceNarrow fi
     | extractTraces(RTS) .

  *** Starting Call
  op metaNarrowSearchGenAll : Module Term Term SubstitutionCond
                              TypeOfRelation Bound Bound Bound TypeOfNarrowing
                           -> ResultContextSet .
  eq metaNarrowSearchGenAll(M,T,T',SCond,QQ,B,BN,Sol,ON)
   = metaNarrowSearchGenAll(M,T,T',SCond,QQ,B,BN,Sol,ON,highestVar((T,T')) + 1) .

  op metaNarrowSearchGenAll : Module Term Term SubstitutionCond
                            TypeOfRelation Bound Bound Bound TypeOfNarrowing Nat
                         -> ResultContextSet .
  eq metaNarrowSearchGenAll(M,T,T',SCond,QQ,B,BN,Sol,ON,N)
   = metaNarrowSearchAll(addSorts('Universal,M),
            T,T',SCond,QQ,B,BN,Sol,ON,
            {T,leastSort(M,T),none,none,[],[],T,T,N,nil,empty}) .

  *** One Narrowing step in the search process (including possible filters)
  op metaNarrowStep : Module SubstitutionCond
                      ResultContextSet TypeOfNarrowing
		   -> ResultContextSet .
  eq metaNarrowStep(M,SCond,RTS,ON)
   = filterSCond(M,SCond,metaENarrowGen(M,1,ON,RTS)) .

  *** Filter and normal forms
  op filterSCond : Module SubstitutionCond ResultContextSet
                   -> ResultContextSet .
  eq filterSCond(M,none,RTS)
   = RTS .
  eq filterSCond(M,SCond,RTS)
   = filterSCond*(M,SCond,RTS) [owise] .

  op filterSCond* : Module SubstitutionCond ResultContextSet
                   -> ResultContextSet .
  eq filterSCond*(M,SCond,empty)
   = empty .
  eq filterSCond*(M,SCond,RT | RTS)
   = filterSCond**(M,SCond,RT) | filterSCond*(M,SCond,RTS) .

  op filterSCond** : Module SubstitutionCond ResultContext
                   -> ResultContextSet .
  eq filterSCond**(M,SCond,{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
   = if SCond <=[M] S
     then {T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags}
     else empty
     fi .

  *** Generate next successors in a breadth way
  --- We reuse the metaNarrowSearchAll function
  op metaNarrowSearchAll : Module Term Term SubstitutionCond TypeOfRelation
                            Bound --- number steps
                            Bound --- number solutions
                            Bound --- chosen solution
                            TypeOfNarrowing
                            ResultContextSet
			 -> ResultContextSet .
  eq metaNarrowSearchAll(M,TOrig,T',SCond,QQ,B,BN,Sol,ON,RTS)
   = if QQ == '+
     then noSelf(RTS,
          metaNarrowSearchCheck(M,TOrig,T',SCond,'*,B,BN,Sol,ON,empty,RTS,empty)
          )
     else metaNarrowSearchCheck(M,TOrig,T',SCond,QQ,B,BN,Sol,ON,empty,RTS,RTS)
     fi .

  *** Take only normal forms
  op isNF : Module ResultContext -> Bool .
  eq isNF(M,{T,TP,S,S',Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
   = end(B:Flags) or-else metaOneRewriting(M,CtTS) == empty .

  *** Take only normal forms
  op isVariant : Module Nat ResultContextSet ResultContext -> Bool .
  eq isVariant(M,N,
        {T',TP',S',S'*,Ct',CtS',TS',CtTS',NextVar',Tr':TraceNarrow,B':Flags} | RTS,
        {T,TP,S,S*,Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags})
    = not (
       (S' |> N ; (newVar(N + 1,TP') <- CtTS'))
           <=[M]
       (S |> N ; (newVar(N + 1,TP) <- CtTS))
      )
      and-then
      isVariant(M,N,RTS,{T,TP,S,S*,Ct,CtS,TS,CtTS,NextVar,Tr:TraceNarrow,B:Flags}) .
  eq isVariant(M,N,RTS,RT)
   = true [owise] .


  *** Generate successors
  op oneMoreStep : Module SubstitutionCond TypeOfNarrowing
                   ResultContextSet -> ResultContextSet [memo] .
  eq oneMoreStep(M,SCond,ON,RTS)
   = remove metaNarrowStep(M,SCond,removeEND(RTS),ON) From RTS .

  *** Check each next successor for conditions
  op metaNarrowSearchCheck : Module Term Term SubstitutionCond
                             TypeOfRelation Bound Bound Bound TypeOfNarrowing
                             ResultContextSet ResultContextSet ResultContextSet
			     -> ResultContextSet .

  eq metaNarrowSearchCheck(M,TOrig,T',SCond,QQ,B,BN,Sol,ON,RTSSol,RTS',empty)
   = if B == 0 or-else BN == 0 or-else Sol == 0 or-else RTS' == empty
     then *** Stop the search
          RTSSol
     else *** Compute Next successors of RTS' with oneMoreStep
          metaNarrowSearchCheck(M,
            TOrig,T',SCond,
            QQ,
            dec(B),BN,Sol,
            ON,
            RTSSol,
            oneMoreStep(M,SCond,ON,RTS'),
            oneMoreStep(M,SCond,ON,RTS')
          )
     fi .

  eq metaNarrowSearchCheck(M,TOrig,T',SCond,QQ,B,BN,Sol,ON,RTSSol,RTS',
         RT | RTS)
   = if isSolution?(M,TOrig,T',QQ,BN,Sol,ON,RTSSol,RT)
        and-then
        auxMetaUnifyCheck(M,ON,getCTTerm(RT),T',getNextVar(RT)) =/= empty *** Is actual term an instance of T'?
     then *** This is a solution
          metaNarrowSearchCheck(M,TOrig,T',SCond,QQ,
                  B,dec(BN),dec(Sol),
                  ON,
                  if Sol == unbounded or-else Sol == 1
                  then rebuildTypeAndDiscardErroneousCheck(M,ON,
                          RT <<(M,ON) auxMetaUnifyCheck(M,ON,getCTTerm(RT),T',getNextVar(RT)))
                  else empty
                  fi
                  | RTSSol,
                  RTS',RTS)
     else *** Continue with the remaining
	  metaNarrowSearchCheck(M,TOrig,T',SCond,QQ,
             B,BN,Sol,ON,RTSSol,RTS',RTS)
     fi .

  op auxMetaUnifyCheck : Module TypeOfNarrowing Term Term Nat ~> UnificationTripleSet .
  eq auxMetaUnifyCheck(M,ON,T,T',N) = auxMetaUnify(M,ON,T,T',N) .

  op rebuildTypeAndDiscardErroneousCheck : Module TypeOfNarrowing ResultContextSet -> ResultContextSet .
  eq rebuildTypeAndDiscardErroneousCheck(M,ON,RTS) = rebuildTypeAndDiscardErroneous(M,ON,RTS) .

  op isSolution? : Module Term Term
                   TypeOfRelation Bound Bound TypeOfNarrowing
                   ResultContextSet ResultContext
	        -> Bool .
  eq isSolution?(M,TOrig,T',QQ,BN,Sol,ON,RTSSol,RT)
   = *** Is this the chosen solution?
     (BN == unbounded or-else BN > 0)
     and-then
     *** Is this step correct wrt relations <'!,'*,'+> ?
     ( QQ == '* or-else (QQ == '! and-then isEND(RT)) )
     and-then
     *** Is this a valid variant solution?
     (not (variant in ON) or-else
      (isNF(M,RT) and-then isVariant(M,highestVar(TOrig) + 1,RTSSol,RT))) .

  op upDown : Module ResultTripleSet -> ResultTripleSet .
  eq upDown(M,RTS:ResultTripleSet)
   = upDown#(M,empty,RTS:ResultTripleSet) .
  op upDown# : Module ResultTripleSet ResultTripleSet -> ResultTripleSet .
  eq upDown#(M,RTS':ResultTripleSet, empty)
   = RTS':ResultTripleSet .
  eq upDown#(M,RTS':ResultTripleSet, {T,TP,S} | RTS:ResultTripleSet)
   = upDown#(M,{getTerm(metaReduce(M,T)),TP,upDown(M,S)}
               | RTS':ResultTripleSet,RTS:ResultTripleSet) .

  op upDown : Module Substitution -> Substitution .
  eq upDown(M,S:Substitution)
   = upDown#(M,none,S:Substitution) .
  op upDown# : Module Substitution Substitution -> Substitution .
  eq upDown#(M,S':Substitution,none)
   = S':Substitution .
  eq upDown#(M,S':Substitution,V <- T ; S:Substitution)
   = upDown#(M,S':Substitution ; V <- getTerm(metaReduce(M,T)),S:Substitution) .

endfm
*************************************
****** End of Santiago Escobar's code
*******************************************************************************
*******************************************************************************

fmod 2TUPLE{X :: TRIV, Y :: TRIV} is
  sorts Tuple{X, Y} .
  op ((_,_)) : X$Elt Y$Elt -> Tuple{X, Y} .
  op p1_ : Tuple{X, Y} -> X$Elt .
  op p2_ : Tuple{X, Y} -> Y$Elt .
  eq p1(V1:[X$Elt],V2:[Y$Elt]) = V1:[X$Elt] .
  eq p2(V1:[X$Elt],V2:[Y$Elt]) = V2:[Y$Elt] .
endfm

fmod FM-3TUPLE{X :: TRIV, Y :: TRIV, Z :: TRIV} is
  sort Tuple{X, Y, Z} .
  op ((_,_,_)) : X$Elt Y$Elt Z$Elt -> Tuple{X, Y, Z} .
  op p1_ : Tuple{X, Y, Z} -> X$Elt .
  op p2_ : Tuple{X, Y, Z} -> Y$Elt .
  op p3_ : Tuple{X, Y, Z} -> Z$Elt .
  eq p1((A:[X$Elt], B:[Y$Elt], C:[Z$Elt])) = A:[X$Elt] .
  eq p2((A:[X$Elt], B:[Y$Elt], C:[Z$Elt])) = B:[Y$Elt] .
  eq p3((A:[X$Elt], B:[Y$Elt], C:[Z$Elt])) = C:[Z$Elt] .
endfm

fmod 4TUPLE{W :: TRIV, X :: TRIV, Y :: TRIV, Z :: TRIV} is
  sort Tuple{W, X, Y, Z} .
  op ((_,_,_,_)) : W$Elt X$Elt Y$Elt Z$Elt -> Tuple{W, X, Y, Z} .
  op p1_ : Tuple{W, X, Y, Z} -> W$Elt .
  op p2_ : Tuple{W, X, Y, Z} -> X$Elt .
  op p3_ : Tuple{W, X, Y, Z} -> Y$Elt .
  op p4_ : Tuple{W, X, Y, Z} -> Z$Elt .
  eq p1((A:[W$Elt], B:[X$Elt], C:[Y$Elt], D:[Z$Elt])) = A:[W$Elt] .
  eq p2((A:[W$Elt], B:[X$Elt], C:[Y$Elt], D:[Z$Elt])) = B:[X$Elt] .
  eq p3((A:[W$Elt], B:[X$Elt], C:[Y$Elt], D:[Z$Elt])) = C:[Y$Elt] .
  eq p4((A:[W$Elt], B:[X$Elt], C:[Y$Elt], D:[Z$Elt])) = D:[Z$Elt] .
endfm

fmod 5TUPLE{V :: TRIV, W :: TRIV, X :: TRIV, Y :: TRIV, Z :: TRIV} is
  sort Tuple{V, W, X, Y, Z} .
  op ((_,_,_,_,_)) : V$Elt W$Elt X$Elt Y$Elt Z$Elt -> Tuple{V, W, X, Y, Z} .
  op p1_ : Tuple{V, W, X, Y, Z} -> V$Elt .
  op p2_ : Tuple{V, W, X, Y, Z} -> W$Elt .
  op p3_ : Tuple{V, W, X, Y, Z} -> X$Elt .
  op p4_ : Tuple{V, W, X, Y, Z} -> Y$Elt .
  op p5_ : Tuple{V, W, X, Y, Z} -> Z$Elt .
  eq p1((A:[V$Elt], B:[W$Elt], C:[X$Elt], D:[Y$Elt], E:[Z$Elt])) = A:[V$Elt] .
  eq p2((A:[V$Elt], B:[W$Elt], C:[X$Elt], D:[Y$Elt], E:[Z$Elt])) = B:[W$Elt] .
  eq p3((A:[V$Elt], B:[W$Elt], C:[X$Elt], D:[Y$Elt], E:[Z$Elt])) = C:[X$Elt] .
  eq p4((A:[V$Elt], B:[W$Elt], C:[X$Elt], D:[Y$Elt], E:[Z$Elt])) = D:[Y$Elt] .
  eq p5((A:[V$Elt], B:[W$Elt], C:[X$Elt], D:[Y$Elt], E:[Z$Elt])) = E:[Z$Elt] .
endfm

fmod 6TUPLE{X1 :: TRIV, X2 :: TRIV, X3 :: TRIV, X4 :: TRIV, X5 :: TRIV, X6 :: TRIV} is
  sort Tuple{X1, X2, X3, X4, X5, X6} .
  op ((_,_,_,_,_,_)) : X1$Elt X2$Elt X3$Elt X4$Elt X5$Elt X6$Elt
       -> Tuple{X1, X2, X3, X4, X5, X6} .
  op p1_ : Tuple{X1, X2, X3, X4, X5, X6} -> X1$Elt .
  op p2_ : Tuple{X1, X2, X3, X4, X5, X6} -> X2$Elt .
  op p3_ : Tuple{X1, X2, X3, X4, X5, X6} -> X3$Elt .
  op p4_ : Tuple{X1, X2, X3, X4, X5, X6} -> X4$Elt .
  op p5_ : Tuple{X1, X2, X3, X4, X5, X6} -> X5$Elt .
  op p6_ : Tuple{X1, X2, X3, X4, X5, X6} -> X6$Elt .
  eq p1((V1:[X1$Elt],V2:[X2$Elt],V3:[X3$Elt],V4:[X4$Elt],V5:[X5$Elt],V6:[X6$Elt]))
    = V1:[X1$Elt] .
  eq p2((V1:[X1$Elt],V2:[X2$Elt],V3:[X3$Elt],V4:[X4$Elt],V5:[X5$Elt],V6:[X6$Elt]))
    = V2:[X2$Elt] .
  eq p3((V1:[X1$Elt],V2:[X2$Elt],V3:[X3$Elt],V4:[X4$Elt],V5:[X5$Elt],V6:[X6$Elt]))
    = V3:[X3$Elt] .
  eq p4((V1:[X1$Elt],V2:[X2$Elt],V3:[X3$Elt],V4:[X4$Elt],V5:[X5$Elt],V6:[X6$Elt]))
    = V4:[X4$Elt] .
  eq p5((V1:[X1$Elt],V2:[X2$Elt],V3:[X3$Elt],V4:[X4$Elt],V5:[X5$Elt],V6:[X6$Elt]))
    = V5:[X5$Elt] .
  eq p6((V1:[X1$Elt],V2:[X2$Elt],V3:[X3$Elt],V4:[X4$Elt],V5:[X5$Elt],V6:[X6$Elt]))
    = V6:[X6$Elt] .
endfm

fmod 7TUPLE{X1 :: TRIV, X2 :: TRIV, X3 :: TRIV,
            X4 :: TRIV, X5 :: TRIV, X6 :: TRIV, X7 :: TRIV} is
  ---- define it using 6TUPLE{}
  sort Tuple{X1, X2, X3, X4, X5, X6, X7} .
  op ((_,_,_,_,_,_,_)) : X1$Elt X2$Elt X3$Elt X4$Elt X5$Elt X6$Elt X7$Elt
       -> Tuple{X1, X2, X3, X4, X5, X6, X7} .
  op p1_ : Tuple{X1, X2, X3, X4, X5, X6, X7} -> X1$Elt .
  op p2_ : Tuple{X1, X2, X3, X4, X5, X6, X7} -> X2$Elt .
  op p3_ : Tuple{X1, X2, X3, X4, X5, X6, X7} -> X3$Elt .
  op p4_ : Tuple{X1, X2, X3, X4, X5, X6, X7} -> X4$Elt .
  op p5_ : Tuple{X1, X2, X3, X4, X5, X6, X7} -> X5$Elt .
  op p6_ : Tuple{X1, X2, X3, X4, X5, X6, X7} -> X6$Elt .
  op p7_ : Tuple{X1, X2, X3, X4, X5, X6, X7} -> X7$Elt .
  eq p1((V1:[X1$Elt], V2:[X2$Elt], V3:[X3$Elt], V4:[X4$Elt], V5:[X5$Elt],
         V6:[X6$Elt], V7:[X7$Elt]))
    = V1:[X1$Elt] .
  eq p2((V1:[X1$Elt], V2:[X2$Elt], V3:[X3$Elt], V4:[X4$Elt], V5:[X5$Elt],
        V6:[X6$Elt], V7:[X7$Elt]))
    = V2:[X2$Elt] .
  eq p3((V1:[X1$Elt], V2:[X2$Elt], V3:[X3$Elt], V4:[X4$Elt], V5:[X5$Elt],
         V6:[X6$Elt], V7:[X7$Elt]))
    = V3:[X3$Elt] .
  eq p4((V1:[X1$Elt], V2:[X2$Elt], V3:[X3$Elt], V4:[X4$Elt], V5:[X5$Elt],
         V6:[X6$Elt], V7:[X7$Elt]))
    = V4:[X4$Elt] .
  eq p5((V1:[X1$Elt], V2:[X2$Elt], V3:[X3$Elt], V4:[X4$Elt], V5:[X5$Elt],
         V6:[X6$Elt], V7:[X7$Elt]))
    = V5:[X5$Elt] .
  eq p6((V1:[X1$Elt], V2:[X2$Elt], V3:[X3$Elt], V4:[X4$Elt], V5:[X5$Elt],
         V6:[X6$Elt], V7:[X7$Elt]))
    = V6:[X6$Elt] .
  eq p7((V1:[X1$Elt], V2:[X2$Elt], V3:[X3$Elt], V4:[X4$Elt], V5:[X5$Elt],
         V6:[X6$Elt], V7:[X7$Elt]))
    = V7:[X7$Elt] .
endfm

fmod 8TUPLE{X1 :: TRIV, X2 :: TRIV, X3 :: TRIV, X4 :: TRIV,
            X5 :: TRIV, X6 :: TRIV, X7 :: TRIV, X8 :: TRIV} is
  sort Tuple{X1, X2, X3, X4, X5, X6, X7, X8} .
  op ((_,_,_,_,_,_,_,_)) : X1$Elt X2$Elt X3$Elt X4$Elt X5$Elt X6$Elt X7$Elt X8$Elt
       -> Tuple{X1, X2, X3, X4, X5, X6, X7, X8} .
  op p1_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X1$Elt .
  op p2_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X2$Elt .
  op p3_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X3$Elt .
  op p4_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X4$Elt .
  op p5_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X5$Elt .
  op p6_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X6$Elt .
  op p7_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X7$Elt .
  op p8_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8} -> X8$Elt .
  var V1 : [X1$Elt] . var V2 : [X2$Elt] . var V3 : [X3$Elt] . var V4 : [X4$Elt] .
  var V5 : [X5$Elt] . var V6 : [X6$Elt] . var V7 : [X7$Elt] . var V8 : [X8$Elt] .
  eq p1((V1, V2, V3, V4, V5, V6, V7, V8)) = V1 .
  eq p2((V1, V2, V3, V4, V5, V6, V7, V8)) = V2 .
  eq p3((V1, V2, V3, V4, V5, V6, V7, V8)) = V3 .
  eq p4((V1, V2, V3, V4, V5, V6, V7, V8)) = V4 .
  eq p5((V1, V2, V3, V4, V5, V6, V7, V8)) = V5 .
  eq p6((V1, V2, V3, V4, V5, V6, V7, V8)) = V6 .
  eq p7((V1, V2, V3, V4, V5, V6, V7, V8)) = V7 .
  eq p8((V1, V2, V3, V4, V5, V6, V7, V8)) = V8 .
endfm

fmod 9TUPLE{X1 :: TRIV, X2 :: TRIV, X3 :: TRIV, X4 :: TRIV,
            X5 :: TRIV, X6 :: TRIV, X7 :: TRIV, X8 :: TRIV, X9 :: TRIV} is
  sort Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} .
  op ((_,_,_,_,_,_,_,_,_)) : X1$Elt X2$Elt X3$Elt X4$Elt X5$Elt X6$Elt X7$Elt
       X8$Elt X9$Elt -> Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} .
  op p1_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X1$Elt .
  op p2_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X2$Elt .
  op p3_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X3$Elt .
  op p4_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X4$Elt .
  op p5_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X5$Elt .
  op p6_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X6$Elt .
  op p7_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X7$Elt .
  op p8_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X8$Elt .
  op p9_ : Tuple{X1, X2, X3, X4, X5, X6, X7, X8, X9} -> X9$Elt .
  var V1 : [X1$Elt] . var V2 : [X2$Elt] . var V3 : [X3$Elt] . var V4 : [X4$Elt] .
  var V5 : [X5$Elt] . var V6 : [X6$Elt] . var V7 : [X7$Elt] . var V8 : [X8$Elt] .
  var V9 : [X9$Elt] .
  eq p1((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V1 .
  eq p2((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V2 .
  eq p3((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V3 .
  eq p4((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V4 .
  eq p5((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V5 .
  eq p6((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V6 .
  eq p7((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V7 .
  eq p8((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V8 .
  eq p9((V1, V2, V3, V4, V5, V6, V7, V8, V9)) = V9 .
endfm

view QidList from TRIV to QID-LIST is
  sort Elt to QidList .
endv

view TermList from TRIV to META-MODULE is
  sort Elt to TermList .
endv

view RuleSet from TRIV to META-MODULE is
  sort Elt to RuleSet .
endv

view EquationSet from TRIV to META-MODULE is
  sort Elt to EquationSet .
endv

view VariableSet from TRIV to META-LEVEL is
  sort Elt to VariableSet .
endv

view ImportList from TRIV to META-MODULE is
  sort Elt to ImportList .
endv

view Condition from TRIV to META-MODULE is
  sort Elt to Condition .
endv

view QidSet from TRIV to META-MODULE is
  sort Elt to QidSet .
endv

view Module from TRIV to META-MODULE is
  sort Elt to Module .
endv

view ParameterDeclList from TRIV to META-MODULE is
  sort Elt to ParameterDeclList .
endv

view Bound from TRIV to META-LEVEL is
  sort Elt to Bound .
endv

view Oid from TRIV to FM-CONFIGURATION is
  sort Elt to Oid .
endv

view Sort from TRIV to META-LEVEL is
  sort Elt to Sort .
endv

view SortMappingSet from TRIV to META-LEVEL is
  sort Elt to SortMappingSet .
endv

view OpMappingSet from TRIV to META-LEVEL is
  sort Elt to OpMappingSet .
endv

view StratMappingSet from TRIV to META-LEVEL is
  sort Elt to StratMappingSet .
endv

view Tuple{X1 :: TRIV, X2 :: TRIV} from TRIV to 2TUPLE{X1, X2} is
  sort Elt to Tuple{X1, X2} .
endv

view ViewExpression from TRIV to META-LEVEL is
  sort Elt to ViewExpression .
endv

view Set{X :: TRIV} from TRIV to SET{X} is
  sort Elt to Set{X} .
endv


-------------------------------------------------------------------------------
*******************************************************************************
***
*** 2 The Signature of Full Maude
***
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-EXTENDED-SORTS is
  ---- Any modification in this module must be reflected in the metamodule
  ---- used in eq addInfoConds in module UNIT-BUBBLE-PARSING
  sorts @SortToken@ @ViewToken@ @Sort@ @Kind@ @Type@ @SortList@
        @TypeList@ @ViewExpression@ @ModExp@ .

  subsorts @SortToken@ < @Sort@ < @SortList@ < @TypeList@ .
  subsorts @Sort@ @Kind@ < @Type@ < @TypeList@ .
  subsort @ViewToken@ < @ViewExpression@ .

  op _`{_`} : @Sort@ @ViewExpression@ -> @Sort@ [prec 40] .
  op __ : @SortList@ @SortList@ -> @SortList@ [assoc] .
  op __ : @TypeList@ @TypeList@ -> @TypeList@ [assoc] .
  op `[_`] : @Sort@ -> @Kind@ .

  op _`,_ : @ViewExpression@ @ViewExpression@ -> @ViewExpression@ [assoc] .
  op _`{_`} : @ViewExpression@ @ViewExpression@ -> @ViewExpression@ [prec 40] .
endfm

-------------------------------------------------------------------------------
******************************************************************************
-------------------------------------------------------------------------------

fmod FM-OPERATOR-ATTRIBUTES is
  sorts @Attr@ @AttrList@ @Hook@ @HookList@ @Bubble@ @UBubble@ @StBubble@
         @EqLBubble@ @RlLBubble@ @SdLBubble@ @RCBubble@ @RBubble@ @Token@ @NeTokenList@ .
  subsort @Attr@ < @AttrList@ .
  subsort @Hook@ < @HookList@ .

  op __ : @AttrList@ @AttrList@ -> @AttrList@ [assoc] .
  ops assoc associative : -> @Attr@ .
  ops comm commutative : -> @Attr@ .
  ops idem idempotent : -> @Attr@ .
  ops id:_ identity:_ : @Bubble@ -> @Attr@ .
  ops left`id:_ left`identity:_ : @Bubble@ -> @Attr@ .
  ops right`id:_ right`identity:_ : @Bubble@ -> @Attr@ .
  ops frozen`(_`) poly`(_`) strat`(_`) strategy`(_`) :
        @NeTokenList@ -> @AttrList@ .
  ops memo memoization : -> @Attr@ .
  ops prec_ precedence_ : @Token@ -> @Attr@ .
  ops gather`(_`) gathering`(_`) : @NeTokenList@ -> @Attr@ .
  ops format`(_`) : @NeTokenList@ -> @Attr@ .
  ops ctor constructor : -> @Attr@ .
  ops frozen ditto iter : -> @Attr@ .
  ops object msg message config : -> @Attr@ .
  op metadata_ : @Token@ -> @Attr@ .

  op special`(_`) : @HookList@ -> @Attr@ .
  op __ : @HookList@ @HookList@ -> @HookList@ [assoc] .
  op id-hook_ : @Token@ -> @Hook@ .
  op id-hook_`(_`) : @Token@ @NeTokenList@ -> @Hook@ .
  op op-hook_`(_:_->_`) : @Token@ @Token@ @NeTokenList@ @Token@ -> @Hook@ .
  op op-hook_`(_:`->_`) : @Token@ @Token@ @Token@ -> @Hook@ .
  op op-hook_`(_:_~>_`) : @Token@ @Token@ @NeTokenList@ @Token@ -> @Hook@ .
  op op-hook_`(_:`~>_`) : @Token@ @Token@ @Token@ -> @Hook@ .
  op term-hook_`(_`) : @Token@ @Bubble@ -> @Hook@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-MOD-EXPR is
  including FM-OPERATOR-ATTRIBUTES .
  including FM-EXTENDED-SORTS .

  sorts @Map@ @MapList@ .
  subsort @Map@ < @MapList@ .
  subsorts @Token@ < @ModExp@ .

  *** module expression
  op _*`(_`) : @ModExp@ @MapList@ -> @ModExp@ .
  op _`{_`} : @ModExp@ @ViewExpression@ -> @ModExp@ .
  op TUPLE`[_`] : @Token@ -> @ModExp@ .
  op POWER`[_`] : @Token@ -> @ModExp@ .
  op _+_ : @ModExp@ @ModExp@ -> @ModExp@ [assoc prec 42] .

  *** renaming maps
  op op_to_ : @Token@ @Token@ -> @Map@ .
  op op_:_->_to_ : @Token@ @TypeList@ @Type@ @Token@ -> @Map@ .
  op op_: ->_to_ : @Token@ @Type@ @Token@ -> @Map@ .
  op op_:_~>_to_ : @Token@ @TypeList@ @Type@ @Token@ -> @Map@ .
  op op_: ~>_to_ : @Token@ @Type@ @Token@ -> @Map@ .
  op op_to_`[_`] : @Token@ @Token@ @AttrList@ -> @Map@ .
  op op_:_->_to_`[_`] : @Token@ @TypeList@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op op_:`->_to_`[_`] : @Token@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op op_:_~>_to_`[_`] : @Token@ @TypeList@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op op_:`~>_to_`[_`] : @Token@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op sort_to_ : @Sort@ @Sort@ -> @Map@ .
  op label_to_ : @Token@ @Token@ -> @Map@ .
  op class_to_ : @Sort@ @Sort@ -> @Map@ .
  op attr_._to_ : @Sort@ @Token@ @Token@ -> @Map@ .
  op msg_to_ : @Token@ @Token@ -> @Map@ .
  op msg_:_->_to_ : @Token@ @TypeList@ @Type@ @Token@ -> @Map@ .
  op msg_:`->_to_ : @Token@ @Type@ @Token@ -> @Map@ .
  op strat_to_ : @Token@ @Token@ -> @Map@ .
  op strat_@_to_ : @Token@ @Type@ @Token@ -> @Map@ .
  op strat_:_@_to_ : @Token@ @TypeList@ @Type@ @Token@ -> @Map@ .

  op _`,_ : @MapList@ @MapList@ -> @MapList@ [assoc prec 42] .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-SIGNATURE is
  inc FM-MOD-EXPR .

  sorts @SortDecl@ @SubsortRel@ @SubsortDecl@ @OpDecl@ .
  sorts @ClassDecl@ @AttrDecl@ @AttrDeclList@ @SubclassDecl@ @MsgDecl@
        @ODeclList@ .
  subsort @AttrDecl@ < @AttrDeclList@ .

  op `(_`) : @Token@ -> @Token@ .

  *** sort declaration
  op sorts_. : @SortList@ -> @SortDecl@ .
  op sort_. : @SortList@ -> @SortDecl@ .

  *** subsort declaration
  op subsort_. : @SubsortRel@ -> @SubsortDecl@ .
  op subsorts_. : @SubsortRel@ -> @SubsortDecl@ .
  op _<_ : @SortList@ @SortList@ -> @SubsortRel@ .
  op _<_ : @SortList@ @SubsortRel@ -> @SubsortRel@ .

  *** operator declaration
  op op_:`->_. : @Token@ @Type@ -> @OpDecl@ .
  op op_:`->_`[_`]. : @Token@ @Type@ @AttrList@ -> @OpDecl@ .
  op op_:_->_. : @Token@ @TypeList@ @Type@ -> @OpDecl@ .
  op op_:_->_`[_`]. : @Token@ @TypeList@ @Type@ @AttrList@ -> @OpDecl@ .
  op ops_:`->_. : @NeTokenList@ @Type@ -> @OpDecl@ .
  op ops_:`->_`[_`]. : @NeTokenList@ @Type@ @AttrList@ -> @OpDecl@ .
  op ops_:_->_. : @NeTokenList@ @TypeList@ @Type@ -> @OpDecl@ .
  op ops_:_->_`[_`]. : @NeTokenList@ @TypeList@ @Type@ @AttrList@ -> @OpDecl@ .

  op op_:`~>_. : @Token@ @Sort@ -> @OpDecl@ .
  op op_:`~>_`[_`]. : @Token@ @Sort@ @AttrList@ -> @OpDecl@ .
  op op_:_~>_. : @Token@ @TypeList@ @Sort@ -> @OpDecl@ .
  op op_:_~>_`[_`]. : @Token@ @TypeList@ @Sort@ @AttrList@ -> @OpDecl@ .
  op ops_:`~>_. : @NeTokenList@ @Sort@ -> @OpDecl@ .
  op ops_:`~>_`[_`]. : @NeTokenList@ @Sort@ @AttrList@ -> @OpDecl@ .
  op ops_:_~>_. : @NeTokenList@ @TypeList@ @Sort@ -> @OpDecl@ .
  op ops_:_~>_`[_`]. : @NeTokenList@ @TypeList@ @Sort@ @AttrList@ -> @OpDecl@ .

  *** class declaration
  op class_|_. : @Sort@ @AttrDeclList@ -> @ClassDecl@ .
  op class_|`. : @Sort@ -> @ClassDecl@ .
  op class_. : @Sort@ -> @ClassDecl@ .
  op _`,_ : @AttrDeclList@ @AttrDeclList@ -> @AttrDeclList@ [assoc] .
  op _:_ : @Token@ @Sort@ -> @AttrDecl@ [prec 40] .

  *** subclass declaration
  op subclass_. : @SubsortRel@ -> @SubclassDecl@ .
  op subclasses_. : @SubsortRel@ -> @SubclassDecl@ .

  *** message declaration
  op msg_:_->_. : @Token@ @SortList@ @Sort@ -> @MsgDecl@ .
  op msgs_:_->_. : @NeTokenList@ @SortList@ @Sort@ -> @MsgDecl@ .
  op msg_:`->_. : @Token@ @Sort@ -> @MsgDecl@ .
  op msgs_:`->_. : @NeTokenList@ @Sort@ -> @MsgDecl@ .

  *** strategy declarations
  op strat_@_. : @Token@ @Type@ -> @OpDecl@ .
  op strats_@_. : @NeTokenList@ @Type@ -> @OpDecl@ .
  op strat_@_`[_`]. : @Token@ @Type@ @AttrList@ -> @OpDecl@ .
  op strats_@_`[_`]. : @NeTokenList@ @Type@ @AttrList@ -> @OpDecl@ .
  op strat_:_@_. : @Token@ @TypeList@ @Type@ -> @OpDecl@ .
  op strats_:_@_. : @NeTokenList@ @TypeList@ @Type@ -> @OpDecl@ .
  op strat_:_@_`[_`]. : @Token@ @TypeList@ @Type@ @AttrList@ -> @OpDecl@ .
  op strats_:_@_`[_`]. : @NeTokenList@ @TypeList@ @Type@ @AttrList@ -> @OpDecl@ .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-STATEMENTS is
  including FM-SIGNATURE .
  including QID-LIST .

  sorts @ImportDecl@ @EqDecl@ @RlDecl@ @StDecl@ @MbDecl@ @VarDecl@ .

  *** variable declaration
  op vars_:_. : @NeTokenList@ @Type@ -> @VarDecl@ .
  op var_:_. : @NeTokenList@ @Type@ -> @VarDecl@ .

  *** membership axiom declaration
  op mb_:_. : @RBubble@ @RBubble@ -> @MbDecl@ .
  op cmb_:_if_. : @RBubble@ @Sort@ @RBubble@ -> @MbDecl@ .

  *** equation declaration
  op eq_=_. : @EqLBubble@ @RBubble@ -> @EqDecl@ .
  op ceq_=_if_. : @EqLBubble@ @RCBubble@ @RBubble@ -> @EqDecl@ .
  op cq_=_if_. : @EqLBubble@ @RCBubble@ @RBubble@ -> @EqDecl@ .

  *** rule declaration
  op rl_=>_. : @RlLBubble@ @RBubble@ -> @RlDecl@ .
  op crl_=>_if_. : @RlLBubble@ @RCBubble@ @RBubble@ -> @RlDecl@ .

  *** importation declaration
  ops including_. inc_. : @ModExp@ -> @ImportDecl@ .
  ops extending_. ex_. : @ModExp@ -> @ImportDecl@ .
  ops protecting_. pr_. : @ModExp@ -> @ImportDecl@ .

  *** strat statement
  op sd_:=_. : @SdLBubble@ @RBubble@ -> @StDecl@ .
  op csd_:=_if_. : @SdLBubble@ @RCBubble@ @RBubble@ -> @StDecl@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-MODULES is
  including FM-STATEMENTS .

  sorts @DeclList@ @Module@ @Parameter@ @List<Parameter>@ .
  sorts @Interface@ .
  subsorts @VarDecl@ @ImportDecl@ @SortDecl@ @SubsortDecl@ @OpDecl@ @MbDecl@
           @EqDecl@
           @RlDecl@
           @StDecl@
           @MsgDecl@ @SubclassDecl@ @ClassDecl@ < @DeclList@ .
  subsort @Parameter@ < @List<Parameter>@ .
  subsorts @Token@ < @Interface@ .

  *** declaration list
  op __ : @DeclList@ @DeclList@ -> @DeclList@ [assoc] .
  op __ : @VarDecl@ @VarDecl@ -> @VarDecl@ [assoc] .

  *** parameterized module interface
  op _::_ : @Token@ @ModExp@ -> @Parameter@ [prec 40 gather (e &)] .
  op _::_ : @Token@ @Interface@ -> @Parameter@ [prec 40 gather (e &)] .

  op _`,_ : @List<Parameter>@ @List<Parameter>@ -> @List<Parameter>@ [assoc] .

  op _`{_`} : @ModExp@ @List<Parameter>@ -> @Interface@ .

  *** modules and theories
  op fmod_is_endfm : @Interface@ @DeclList@ -> @Module@ .
  op obj_is_jbo : @Interface@ @DeclList@ -> @Module@ .
  op obj_is_endo : @Interface@ @DeclList@ -> @Module@ .
  op mod_is_endm : @Interface@ @DeclList@ -> @Module@ .
  op omod_is_endom : @Interface@ @DeclList@ -> @Module@ .
  op smod_is_endsm : @Interface@ @DeclList@ -> @Module@ .
  op fth_is_endfth : @Interface@ @DeclList@ -> @Module@ .
  op th_is_endth : @Interface@ @DeclList@ -> @Module@ .
  op oth_is_endoth : @Interface@ @DeclList@ -> @Module@ .
  op sth_is_endsth : @Interface@ @DeclList@ -> @Module@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-VIEWS is
  including FM-MODULES .

  sorts @ViewDecl@ @ViewDeclList@ @View@ .
  subsorts @VarDecl@ < @ViewDecl@ < @ViewDeclList@ .

  *** view maps
  op op_to`term_. : @Bubble@ @Bubble@ -> @ViewDecl@ .
  op op_to_. : @Token@ @Token@ -> @ViewDecl@ .
  op op_:_->_to_. : @Token@ @TypeList@ @Type@ @Token@ -> @ViewDecl@ .
  op op_:`->_to_. : @Token@ @Type@ @Token@ -> @ViewDecl@ .
  op op_:_~>_to_. : @Token@ @TypeList@ @Type@ @Token@ -> @ViewDecl@ .
  op op_:`~>_to_. : @Token@ @Type@ @Token@ -> @ViewDecl@ .
  op sort_to_. : @Sort@ @Sort@ -> @ViewDecl@ .
  op class_to_. : @Sort@ @Sort@ -> @ViewDecl@ .
  op attr_._to_. : @Sort@ @Token@ @Token@ -> @ViewDecl@ .
  op msg_to_. : @Token@ @Token@ -> @ViewDecl@ .
  op msg_:_->_to_. : @Token@ @TypeList@ @Type@ @Token@ -> @ViewDecl@ .
  op msg_:`->_to_. : @Token@ @Type@ @Token@ -> @ViewDecl@ .
  op strat_to_. : @Token@ @Token@ -> @ViewDecl@ .
  op strat_@_to_. : @Token@ @Type@ @Token@ -> @ViewDecl@ .
  op strat_:_@_to_. : @Token@ @TypeList@ @Type@ @Token@ -> @ViewDecl@ .
  op strat_to expr_. : @Bubble@ @Bubble@ -> @ViewDecl@ .

  *** view
  op view_from_to_is_endv : @Interface@ @ModExp@ @ModExp@ @ViewDeclList@ -> @View@ .
  op view_from_to_is endv : @Interface@ @ModExp@ @ModExp@ -> @View@ .
  op __ : @ViewDeclList@ @ViewDeclList@ -> @ViewDeclList@ [assoc] .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-COMMANDS is
  including FM-MOD-EXPR .

  sorts @Command@ .

  *** down function
  op down_:_ : @ModExp@ @Command@ -> @Command@ .

  *** parse commands
  op parse_. : @Bubble@ -> @Command@ .

  *** reduce commands
  op red_. : @UBubble@ -> @Command@ .
  op reduce_. : @UBubble@ -> @Command@ .

  *** rewrite commands
  op rew_. : @UBubble@ -> @Command@ .
  op rewrite_. : @UBubble@ -> @Command@ .

  *** frewrite commands
  op frew_. : @UBubble@ -> @Command@ .
  op frewrite_. : @UBubble@ -> @Command@ .

  *** srewrite commands
  op srew_. : @UBubble@ -> @Command@ .
  op dsrew_. : @UBubble@ -> @Command@ .
  op srewrite_. : @UBubble@ -> @Command@ .
  op dsrewrite_. : @UBubble@ -> @Command@ .

  *** search commands
  op search_=>1_. : @UBubble@ @UBubble@ -> @Command@ .
  op search_=>*_. : @UBubble@ @UBubble@ -> @Command@ .
  op search_=>+_. : @UBubble@ @UBubble@ -> @Command@ .
  op search_=>!_. : @UBubble@ @UBubble@ -> @Command@ .

  *** narrowing search commands
  op vu-narrow_=>1_. : @UBubble@ @UBubble@ -> @Command@ .
  op vu-narrow_=>*_. : @UBubble@ @UBubble@ -> @Command@ .
  op vu-narrow_=>+_. : @UBubble@ @UBubble@ -> @Command@ .
  op vu-narrow_=>!_. : @UBubble@ @UBubble@ -> @Command@ .

  op fvu-narrow_=>1_. : @UBubble@ @UBubble@ -> @Command@ .
  op fvu-narrow_=>*_. : @UBubble@ @UBubble@ -> @Command@ .
  op fvu-narrow_=>+_. : @UBubble@ @UBubble@ -> @Command@ .
  op fvu-narrow_=>!_. : @UBubble@ @UBubble@ -> @Command@ .

  op search_~>1_. : @UBubble@ @UBubble@ -> @Command@ .
  op search_~>*_. : @UBubble@ @UBubble@ -> @Command@ .
  op search_~>+_. : @UBubble@ @UBubble@ -> @Command@ .
  op search_~>!_. : @UBubble@ @UBubble@ -> @Command@ .

  *** matching commands
  op match_<=?_. : @UBubble@ @UBubble@ -> @Command@ .
  op xmatch_<=?_. : @UBubble@ @UBubble@ -> @Command@ .

  *** unifying command
  op unify_. : @UBubble@ -> @Command@ .

  *** unifying command
  op id-unify_. : @UBubble@ -> @Command@ .

  *** unifying command
  op variant`unify_. : @UBubble@ -> @Command@ .

  *** unifying command
  op asymmetric`variant`unify_. : @UBubble@ -> @Command@ .

  *** unifying command
  op get`variants_. : @UBubble@ -> @Command@ .

  *** select command
  op select_. : @ModExp@ -> @Command@ .

  *** show commands
  op show`module`. : -> @Command@ .
  op show`module_. : @ModExp@ -> @Command@ .
  op show`all`. : -> @Command@ .
  op show`all_. : @ModExp@ -> @Command@ .
  op show`vars`. : -> @Command@ .
  op show`vars_. : @ModExp@ -> @Command@ .
  op show`sorts`. : -> @Command@ .
  op show`sorts_. : @ModExp@ -> @Command@ .
  op show`ops`. : -> @Command@ .
  op show`ops_. : @ModExp@ -> @Command@ .
  op show`mbs`. : -> @Command@ .
  op show`mbs_. : @ModExp@ -> @Command@ .
  op show`eqs`. : -> @Command@ .
  op show`eqs_. : @ModExp@ -> @Command@ .
  op show`rls`. : -> @Command@ .
  op show`rls_. : @ModExp@ -> @Command@ .
  op show`view_. : @ViewExpression@ -> @Command@ .
  op show`modules`. : -> @Command@ .
  op show`views`. : -> @Command@ .

  *** set commands
  op set`protect_on`. : @ModExp@ -> @Command@ .
  op set`protect_off`. : @ModExp@ -> @Command@ .
  op set`include_on`. : @ModExp@ -> @Command@ .
  op set`include_off`. : @ModExp@ -> @Command@ .
  op set`extend_on`. : @ModExp@ -> @Command@ .
  op set`extend_off`. : @ModExp@ -> @Command@ .

  *** miscellaneous
  op load_. : @UBubble@ -> @Command@ .
  ops remove`identity`attributes`. rm`ids`. : -> @Command@ .
  ops remove`identity`attributes_. rm`ids_. : @ModExp@ -> @Command@ .
  op remove`assoc`attributes`. : -> @Command@ .
  op remove`assoc`attributes_. : @ModExp@ -> @Command@ .
  op ax`coherence`completion`. : -> @Command@ .
  op ax`coherence`completion_. : @ModExp@ -> @Command@ .
  op help`. : -> @Command@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FULL-MAUDE-SIGN is
  including FM-VIEWS .
  including FM-COMMANDS .

  sort @Input@ .
  subsorts @Command@ @Module@ @View@ < @Input@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-STRATEGY-GRAMMAR is
  *** strategies
    sorts @Strategy@ @UsingPair@ @UsingPairSet@ @StBubble@ @StCondBubble@
          @Token@ @TermList@ @CallStrategy@ .
    subsort @UsingPair@ < @UsingPairSet@ .
----    sorts RuleApplication CallStrategy @Strategy@ StrategyList .
----    subsort RuleApplication CallStrategy < Strategy < StrategyList .

  *** basic operators
    ops fail idle all : -> @Strategy@ .
----    op _[_]{_} : Qid Substitution StrategyList -> RuleApplication [ctor prec 21] .
----    op top : RuleApplication -> Strategy [ctor] .
    op match_s.t._ : @StBubble@ @StCondBubble@ -> @Strategy@ [prec 21] .
    op xmatch_s.t._ : @StBubble@ @StCondBubble@ -> @Strategy@ [prec 21] .
    op amatch_s.t._ : @StBubble@ @StCondBubble@ -> @Strategy@ [prec 21] .
----    op _|_ : Strategy Strategy -> Strategy [ctor assoc comm id: fail prec 41 gather (e E)] .
----    op _;_ : Strategy Strategy -> Strategy [ctor assoc id: idle prec 39 gather (e E)] .
----    op _or-else_ : Strategy Strategy -> Strategy [ctor assoc prec 43 gather (e E)] .
----    op _+ : Strategy -> Strategy [ctor] .
----    op _?_:_ : Strategy Strategy Strategy -> Strategy [ctor prec 55] .
----    op matchrew_s.t._by_ : @StBubble@ EqCondition UsingPairSet -> Strategy [ctor] .
----    op xmatchrew_s.t._by_ : @StBubble@ EqCondition UsingPairSet -> Strategy [ctor] .
----    op amatchrew_s.t._by_ : @StBubble@ EqCondition UsingPairSet -> Strategy [ctor] .
    op _[[_]] : @Token@ @TermList@ -> @CallStrategy@ [ctor prec 21] .
----    op one : Strategy -> Strategy [ctor] .

  *** derived operators (defined as constructors)
----    op _* : Strategy -> Strategy [ctor] .
----    op _! : Strategy -> Strategy [ctor] .
----    op not : Strategy -> Strategy [ctor] .
----    op test : Strategy -> Strategy [ctor] .
----    op try : Strategy -> Strategy [ctor] .

  *** lists
----    op empty : -> StrategyList [ctor] .
----    op _,_ : StrategyList StrategyList -> StrategyList [ctor assoc id: empty] .
    op _using_ : @Token@ @Strategy@ -> @UsingPair@ [ctor prec 21] .
    op _,_ : @UsingPair@ @UsingPairSet@ -> @UsingPairSet@ [ctor assoc comm prec 61] .
----    eq U:UsingPair, U:UsingPair = U:UsingPair .
endfm


*******
******* ERROR HANDLING, by Peter Olveczky
*******

*** The following module defines a function which prints up to n characters
*** of a bubble, followed by the usual arrow <---*HERE* which points to the
*** erroneous token:

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-PRINT-SYNTAX-ERROR is
---  protecting META-LEVEL + PRE-VARIANT .
  protecting META-LEVEL .
  protecting INT .

  var  QIL : QidList .
  var  Q : Qid .
  var  N : Nat .
  vars RP RP' : ResultPair .
  var  RP? : [ResultPair?] .
  vars Strat Strat' : Strategy .
  var  Strat? : [Strategy?] .

  op printN : Nat QidList -> QidList .  *** first N qid's in a qidList
  eq printN(N, nil) = nil .
  eq printN(0, QIL) = nil .
  eq printN(s N, Q QIL) = Q printN(N, QIL) .

  op removeFront : Nat QidList -> QidList .  *** removes first N qid's
  eq removeFront(N, nil) = nil .
  eq removeFront(0, QIL) = QIL .
  eq removeFront(s N, Q QIL) = removeFront(N, QIL) .

  op printSyntaxError : [ResultPair?] QidList -> QidList .
  eq printSyntaxError(noParse(N), QIL)
    = '\r 'Parse 'error 'in '\o '\s printN(N + 1, QIL) '\r '<---*HERE* '\o .
  eq printSyntaxError(ambiguity(RP, RP'), QIL)
    = '\r 'Ambiguous 'parsing 'for '\o '\s QIL '\o .
  eq printSyntaxError(RP?, QIL) = QIL [owise] .

  op printSyntaxError : [Strategy?] QidList -> QidList .
  eq printSyntaxError(noStratParse(N), QIL)
    = '\r 'Parse 'error 'in '\o '\s printN(N + 1, QIL) '\r '<---*HERE* '\o .
  eq printSyntaxError(ambiguity(Strat, Strat'), QIL)
    = '\r 'Ambiguous 'parsing 'for '\o '\s QIL '\o .
  eq printSyntaxError(Strat?, QIL) = QIL [owise] .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------
***
*** The Abstract Data Type \texttt{Module}
***
-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** In this section we present the abstract data type \texttt{Module}, which
*** can be seen as an extension of the predefined sort \texttt{Module} in
*** several ways. There are constructors for functional, system, and object-
*** oriented modules and theories, which can be parameterized and can import
*** module expressions. There can also be parameterized sorts in Full Maude
*** modules, and therefore, the constructors for the different declarations
*** that can appear in a module have to be appropriately extended.

*** The section is structured as follows. After introducing some modules
*** defining some functions on the predefined sorts \texttt{Bool} and
*** \texttt{QidList} in Section~\ref{BOOL-QID-LIST}, we present in
*** Sections~\ref{EXT-SORT} and~\ref{EXT-DECL} the data types for extended
*** sorts and extended declarations. In Section~\ref{mod-exp-mod-id} we
*** introduce module expressions and module names, and in
*** Section~\ref{unitADT} the abstract data type \texttt{Module} itself.

***
*** Extension \texttt{QID-LIST}
***

*** The conversion of lists of quoted identifiers into single quoted
*** identifiers by concatenating them is heavily used in the coming modules.
*** This is the task of the \texttt{} function, which is
*** introduced in the following module \texttt{EXT-QID-LIST} extending the
*** predefined module \texttt{QID-LIST}.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-EXT-QID-LIST is
  pr QID-LIST .

  op qidList2Qid : QidList -> Qid .

  vars QI QI' QI'' : Qid .
  var  QIL : QidList .
  vars St St' : String .
  var  N : Nat .
  var  F : FindResult .

  eq qidList2Qid(('\s QIL)) = qid(" " + string(qidList2Qid(QIL))) .
  eq qidList2Qid((QI QIL))
    = qid(string(QI) + " " + string(qidList2Qid(QIL)))
    [owise] .
  eq qidList2Qid(nil) = qid("") .

  op trimQidList : QidList -> QidList .
  eq trimQidList(' QIL) = trimQidList(QIL) .
  eq trimQidList(QI QIL) = QI trimQidList(QIL) [owise] .
  eq trimQidList(nil) = nil .

  op qidList2string : QidList -> String .
  eq qidList2string('`( QIL) = "(" + " " + qidList2string(QIL) .
  eq qidList2string('`) QIL) = ")" + " " + qidList2string(QIL) .
  eq qidList2string('`{ QIL) = "{" + " " + qidList2string(QIL) .
  eq qidList2string('`} QIL) = "}" + " " + qidList2string(QIL) .
  eq qidList2string('`[ QIL) = "[" + " " + qidList2string(QIL) .
  eq qidList2string('`] QIL) = "]" + " " + qidList2string(QIL) .
  eq qidList2string('`, QIL) = "," + " " + qidList2string(QIL) .
  eq qidList2string(QI QIL) = string(QI) + " " + qidList2string(QIL) [owise] .
  eq qidList2string(nil) = "" .

  op string2qidList : String -> QidList .
  op string2qidListAux : String -> QidList .

  eq string2qidList(St) = trimQidList(string2qidListAux(St)) .

  eq string2qidListAux("") = nil .
  ceq string2qidListAux(St)
    = if F == notFound
      then qid(substr(St, findNonSpace(St), length(St)))
      else qid(substr(St, findNonSpace(St), F))
           if substr(St, findNonSpace(St) + F, 1) =/= " "
           then qid(substr(St, findNonSpace(St) + F, 1))
           else nil
           fi
           string2qidListAux(substr(St, findNonSpace(St) + F + 1, length(St)))
      fi
    if F := myfind(substr(St, findNonSpace(St), length(St)), " (){}[],", 0)
    [owise] .

  op findNonSpace : String -> Nat .
  op findNonSpace : String Nat -> Nat .
  ---- returns the length of the string if not found
  eq findNonSpace(St) = findNonSpace(St, 0) .

  eq findNonSpace(St, N)
    = if N < length(St)
      then if substr(St, N, 1) == " "
           then findNonSpace(St, N + 1)
           else N
           fi
      else length(St)
      fi .

  op myfind : String String Nat -> FindResult .
  eq myfind(St, St', N)
    = if N < length(St)
      then if find(St', substr(St, N, 1), 0) =/= notFound
           then N
           else myfind(St, St', N + 1)
           fi
      else notFound
      fi .

  op replace : QidList Qid Qid -> QidList .
  eq replace(QI QIL, QI', QI'')
    = if QI == QI'
      then QI'' replace(QIL, QI', QI'')
      else QI replace(QIL, QI', QI'')
      fi .
  eq replace(nil, QI, QI') = nil .
endfm

fmod FM-HELP is
  pr FM-EXT-QID-LIST .
  op fm-help : -> QidList .
  eq fm-help
    = string2qidList("Additional commands available:") '\n
      '\t string2qidList("(load <meta-module> .)") '\n
      '\t '\t string2qidList("Takes as argument a term of sort Module,") '\s string2qidList("i.e.,") '\s string2qidList("a metaterm.") '\n
      '\t '`( 'remove 'identity 'attributes '\s '`[ '<module-expr.> '`] '\s  '. '`) '\s  '| '\s '`( 'rm 'ids '\s '`[ '<module-expr.> '`] '\s  '. '`) '\n
      '\t '\t string2qidList("Shows the module with the id attributes removed using a variant-based transformation.") '\n
      '\t string2qidList("(remove assoc attributes") '\s string2qidList("[<module-expr.>]") '\s string2qidList(".)") '\n
      '\t '\t string2qidList("Shows the module with the assoc (if not with comm) attributes removed using a variant-based transformation.") '\n
      '\t string2qidList("(ax coherence completion") '\s string2qidList("[<module-expr.>]") '\s string2qidList(".)") '\n
      '\t '\t string2qidList("Shows the module resulting from completing for coherence for the different combinations of axioms.") '\n .
endfm


-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** 3.2 View Expressions and Extended Sorts

*** To allow the use of parameterized sorts, or sorts qualified by the view
*** expression with which the parameterized module in which the given sorts
*** appear is instantiated, we add the sort Sort of ``extended sorts'' as a
*** supersort of the predefined sort Sort.  View expressions and extended
*** sorts are introduced in the following modules.

*** 3.2.1 View Expressions

*** A view expression is given by a single quoted identifier, by a sequence of
*** view expressions (at the user level, separated by commas), or by the
*** composition of view expressions. In the current version, the composition
*** of view expressions is only used internally; we plan to make it available
*** to the user with syntax \verb~_;_~ in the future. View expressions are
*** used in the instantiation of parameterized modules and in parameterized
*** sorts.  We plan to support parameterized views in the future as well. We
*** use operators \verb~_|_~ and \verb~_;;_~ to represent, respectively,
*** sequences and composition of view expressions.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-VIEW-EXPR is
  pr META-MODULE .

----@  sort ViewExpression .
----@  subsorts Sort < ViewExpression < ModuleExpression NeParameterList .

  op mtViewExpression : -> ViewExpression .
----@  op _{_} : Sort ParameterList -> ViewExpression [ctor prec 37].
  op _;;_ : ViewExpression ViewExpression -> ViewExpression
       [assoc id: mtViewExpression] .     *** view composition  _;_

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** Since the Core Maude engine does not know about view expressions, or, as
*** we shall see, about extended sorts, extended module expressions, extended
*** modules, and other declarations that we introduce, to be able to use them
*** with built-in functions such as \texttt{sameComponent},
*** \texttt{leastSort}, \texttt{metaReduce}, etc., we shall have to convert
*** them into terms which only use the built-in constructors.  Thus, for
*** example, view expressions in sort \texttt{ViewExpression} will be converted
*** into quoted identifiers of sort \texttt{Qid} by means of function
*** \texttt{parameter2Qid}, or, similarly, elements of sorts \texttt{Sort},
*** \texttt{SortList}, and \texttt{SortSet} are transformed into elements
*** of sorts \texttt{Qid}, \texttt{QidList}, and  \texttt{QidSet},
*** respectively, with functions \texttt{eSortToQid} defined  on the
*** appropriate sorts.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-VIEW-EXPR-TO-QID is
  pr FM-VIEW-EXPR .
  pr FM-EXT-QID-LIST .

  op viewExp2Qid : ViewExpression -> Qid .
  op parameterList2Qid : ParameterList -> Qid .
  op viewExp2QidList : ViewExpression -> QidList .
  op parameterList2QidList : ParameterList -> QidList .

  op eMetaPrettyPrint : ViewExpression -> QidList .
  ceq eMetaPrettyPrint(VE) = viewExp2QidList(VE) if not VE :: TypeList .

  var  V : Sort .
  var  QI : Qid .
  var  QIL : QidList .
  var  P : ViewExpression .
  var  PL : NeParameterList .
  vars VE VE' : ViewExpression .

  eq parameterList2QidList(P) = viewExp2QidList(P) .
  ceq parameterList2QidList((P, PL))
    = (if QI == '`) then QIL QI '\s else QIL QI fi)
      '`, parameterList2QidList(PL)
    if QIL QI := viewExp2QidList(P).

  eq viewExp2QidList(V{PL})
    = (viewExp2QidList(V) '`{ parameterList2QidList(PL) '`}) .
  ceq viewExp2QidList(VE ;; VE')
    = (viewExp2QidList(VE) '; viewExp2QidList(VE'))
    if VE =/= mtViewExpression /\ VE' =/= mtViewExpression .
  eq viewExp2QidList(V) = V .

  eq parameterList2Qid(P) = viewExp2Qid(P) .
  eq parameterList2Qid((P, PL))
    = qid(string(viewExp2Qid(P)) + ", " + string(parameterList2Qid(PL))) .

  eq viewExp2Qid(VE) = qidList2Qid(viewExp2QidList(VE)) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Parameterized Sorts
***

*** In addition to the \texttt{Sort} sort, in the following module
*** \texttt{EXT-SORT} we also define sorts \texttt{SortList} and
*** \texttt{SortSet}.

*** The operator \texttt{eSort} is declared to be a constructor for extended
*** sorts.

*** As for lists and sTS of quoted identifiers, we declare \verb~__~ and
*** \verb~_;_~ as constructors for sorts \texttt{SortList} and
*** \texttt{SortList}, and \texttt{SortSet}, respectively.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-EXT-SORT is
---  pr META-LEVEL + PRE-VARIANT .
  pr META-LEVEL .
  pr EXT-BOOL .
  pr FM-VIEW-EXPR-TO-QID .
  pr FM-EXT-QID-LIST .
  pr FM-TERMSET .

*** We define operations extending the built-in functions \texttt{sameKind}
*** and \texttt{leastSort}, respectively, to lists of sorts and
*** to lists of extended terms. The function \texttt{sameKind} takes
*** a module and two lists of extended sorts as arguments, and returns
*** \texttt{true} if the $i$-th elements of both lists are in the same
*** connected component of sorts. This function will be used, for example, to
*** check whether two operators are in the same family of subsort overloaded
*** operators. \texttt{leastSort} returns a list of sorts where the $i$-th
*** element of the list is the least sort, computed by the homonymous built-in
*** function, of the $i$-th term in the list of terms given as argument.
*** Moreover, we define a function \verb~_in_~ to check whether an
*** extended sort is in a given set of extended sorts.  Note that before
*** calling the built-in function \texttt{sameComponent}, extended sorts of
*** sort \texttt{Sort} have to be `desugared' into sorts of sort
*** \texttt{Sort} as defined in the predefined \texttt{META-LEVEL} module.
*** This conversion is done by the \texttt{eTypeToType} function. Basically,
*** user-defined sorts are converted into quoted identifiers by concatenating
*** the list of identifiers composing the name of the sort. For example, sorts
*** \texttt{'Nat} and \texttt{'List['Nat]} are converted, respectively, into
*** \texttt{'Nat} and \texttt{'List`[Nat`]}. Error
*** sorts~\cite{ClavelDuranEkerLincolnMarti-OlietMeseguerQuesada99} are left
*** as such.

  vars Tp Tp' Tp'' Tp''' : Type .
  vars TpL TpL' : TypeList .
  var  M : Module .

  op sameKind : Module TypeList TypeList -> Bool [ditto] .
  eq sameKind(M, (Tp Tp' TpL), (Tp'' Tp''' TpL'))
    = sameKind(M, Tp, Tp'')
      and-then sameKind(M, Tp' TpL, Tp''' TpL') .
  eq sameKind(M, nil, nil) = true .
  eq sameKind(M, TpL, TpL') = false [owise] .

  eq sameKind(M, cc(S:Sort ; SS:SortSet), Tp)
    = sameKind(M, S:Sort, Tp) .
  eq sameKind(M, Tp, cc(S:Sort ; SS:SortSet))
    = sameKind(M, Tp, S:Sort) .
  eq sameKind(M, cc(S:Sort ; SS:SortSet), cc(S':Sort ; SS':SortSet))
    = sameKind(M, S:Sort, S':Sort) .

  op sameKindAll : Module Type TypeList -> Bool .
  eq sameKindAll(M, Tp, Tp' TpL) = sameKind(M, Tp, Tp') and-then sameKindAll(M, Tp, TpL) .
  eq sameKindAll(M, Tp, nil) = true .

  op eLeastSort : Module TermList ~> TypeList .
  eq eLeastSort(M, (T:Term, TL:TermList))
    = (leastSort(M, T:Term) eLeastSort(M, TL:TermList)) .
  eq eLeastSort(M, empty) = nil .
  eq eLeastSort(M, qidError(QIL)) = qidError(QIL) .

  op eLeastSort : Module TermSet ~> TypeSet .
  eq eLeastSort(M, (T:Term | TS:TermSet))
    = (leastSort(M, T:Term) ; eLeastSort(M, TS:TermSet)) .
  eq eLeastSort(M, emptyTermSet) = none .
  eq eLeastSort(M, qidError(QIL)) = qidError(QIL) .

  op qidError : QidList -> [Sort] .
  op stringError : QidList -> [String] .
  eq string(qidError(QIL)) = stringError(QIL) .
  eq qid(stringError(QIL)) = qidError(QIL) .
  eq stringError(QIL) + St:String = stringError(QIL) .

  op getMsg : [Sort] -> QidList .
  eq getMsg(qidError(QIL:QidList)) = QIL:QidList .

  op kind : TypeList -> Type .

  eq kind(S:Sort TL:TypeList)
    = qid("[" + string(S:Sort) + "]") kind(TL:TypeList) .
  eq kind(K:Kind TL:TypeList) = K:Kind kind(TL:TypeList) .
  eq kind(nil) = nil .

  op kind : SortSet -> Type .
  eq kind(S:Sort ; SS:SortSet) = qid("[" + string(S:Sort) + "]") .

  op cc : SortSet -> Type .

  op getSort : Kind -> Sort .
  eq getSort(K:Kind)
    = if findOut(string(K:Kind), "`,", "{", "}", 0) == notFound
      then qid(substr(string(K:Kind),
                      2,
                      sd(length(string(K:Kind)), 4)))
      else qid(substr(string(K:Kind),
                      2,
                      sd(findOut(string(K:Kind), "`,", "{", "}", 0), 2)))
      fi .

  op getSorts : Kind -> SortSet .
  eq getSorts(K:Kind)
    = if findOut(string(K:Kind), "`,", "{", "}", 0) == notFound
      then qid(substr(string(K:Kind),
                      2,
                      sd(length(string(K:Kind)), 4)))
      else qid(substr(string(K:Kind),
                      2,
                      sd(findOut(string(K:Kind), "`,", "{", "}", 0), 2)))
           ;
           getSorts(qid("[" + substr(string(K:Kind),
                                     sd(findOut(string(K:Kind), "`,", "{", "}", 0), 1),
                                     length(string(K:Kind)))))
      fi .

----  op qid2Sort : Sort -> Sort .
----  eq qid2Sort(S:Sort) = getName{S:Sort} { getPars(S:Sort) } .

  ---- name of a sort (the name of S{P1, ..., Pn} is S)
  op getName : Sort -> Qid .
  eq getName(S:Sort)
    = if findOpening(string(S:Sort), "{", "}", sd(length(string(S:Sort)), 2))
           == notFound
      then S:Sort
      else qid(substr(string(S:Sort),
                      0,
                      findOpening(string(S:Sort),
                        "{", "}",
                        sd(length(string(S:Sort)), 2))))
      fi .

  ---- parameters of a sort (the parameters of S{P1, ..., Pn} are P1 ... Pn)
  op getPars : Sort -> ParameterList [memo] .
  op getParsAux : String Nat Nat -> ParameterList .

  eq getPars(S:Sort)
    = if findOpening(string(S:Sort), "{", "}", sd(length(string(S:Sort)), 2))
           == notFound
      then empty
      else getParsAux(string(S:Sort),
             findOpening(string(S:Sort),
               "{", "}", sd(length(string(S:Sort)), 2)) + 1,
             length(string(S:Sort)))
      fi .

  var  St Pattern OpenPar ClosingPar : String .
  vars L R N OpenPars ClosingPars : Nat .

  eq getParsAux(St, L, R)
    = if findOut(St, ",", "{", "}", L) == notFound
      then qid(substr(St, L, sd(findClosing(St, "{", "}", L), L)))
      else (qid(substr(St, L, sd(findOut(St, ",", "{", "}", L), L))),
            getParsAux(St, findOut(St, ",", "{", "}", L) + 1, R))
      fi .

  ---- finds a pattern out of balanced parentheses
  ---- findOut("S{P1, P2{P21, P22}, P3}", ",", "{", "}", 6) returns 18, not 12
  op findOut : String String String String Nat -> FindResult .
  op findOut : String String String String Nat Nat -> FindResult .

  eq findOut(St, Pattern, OpenPar, ClosingPar, N)
    = findOut(St, Pattern, OpenPar, ClosingPar, 0, N) .

  eq findOut(St, Pattern, OpenPar, ClosingPar, OpenPars, N)
    = if N >= length(St)
      then notFound
      else if OpenPars == 0 and-then substr(St, N, length(Pattern)) == Pattern
           then N
           else if substr(St, N, length(OpenPar)) == OpenPar
                then findOut(St, Pattern, OpenPar, ClosingPar,
                       OpenPars + 1, N + 1)
                else if substr(St, N, length(ClosingPar)) == ClosingPar
                     then findOut(St, Pattern, OpenPar, ClosingPar,
                            sd(OpenPars, 1), N + 1)
                     else findOut(St, Pattern, OpenPar, ClosingPar,
                            OpenPars, N + 1)
                     fi
                fi
           fi
      fi .

  ---- finds the first closing unbalanced parenthesis
  ---- findOut("P1, P2{P21, P22}, P3}", "{", "}", 6) returns 21, not 16
  op findClosing : String String String Nat -> FindResult .
  op findClosing : String String String Nat Nat -> FindResult .

  eq findClosing(St, OpenPar, ClosingPar, N)
    = findClosing(St, OpenPar, ClosingPar, 0, N) .

  eq findClosing(St, OpenPar, ClosingPar, OpenPars, N)
    = if N >= length(St)
      then notFound
      else if OpenPars == 0
              and-then substr(St, N, length(ClosingPar)) == ClosingPar
           then N
           else if substr(St, N, length(OpenPar)) == OpenPar
                then findClosing(St, OpenPar, ClosingPar,
                       OpenPars + 1, N + 1)
                else if substr(St, N, length(ClosingPar)) == ClosingPar
                     then findClosing(St, OpenPar, ClosingPar,
                            sd(OpenPars, 1), N + 1)
                     else findClosing(St, OpenPar, ClosingPar,
                            OpenPars, N + 1)
                     fi
                fi
           fi
      fi .

  ---- finds the last opening unbalanced parenthesis
  ---- findOpening("S{P1, P2{P21, P22}, P3}", "{", "}", 21) returns 1, not 8
  op findOpening : String String String Nat -> FindResult .
  op findOpening : String String String Nat Nat -> FindResult .

  eq findOpening(St, OpenPar, ClosingPar, N)
    = findOpening(St, OpenPar, ClosingPar, 0, N) .

  eq findOpening(St, OpenPar, ClosingPar, ClosingPars, N)
    = if N == 0
      then notFound
      else if ClosingPars == 0
              and-then substr(St, N, length(ClosingPar)) == OpenPar
           then N
           else if substr(St, N, length(OpenPar)) == ClosingPar
                then findOpening(St, OpenPar, ClosingPar,
                       ClosingPars + 1, sd(N, 1))
                else if substr(St, N, length(ClosingPar)) == OpenPar
                     then findOpening(St, OpenPar, ClosingPar,
                            sd(ClosingPars, 1), sd(N, 1))
                     else findOpening(St, OpenPar, ClosingPar,
                            ClosingPars, sd(N, 1))
                     fi
                fi
           fi
      fi .

  op makeSort : Sort ParameterList -> Sort .
  op makeSort : Sort ParameterList ParameterList ParameterList -> Sort .
  op makeSort2 : Sort ParameterList -> Sort .
  op makePars : ParameterList -> String .

  vars S P : Sort .
  vars PL PL' PL'' PL3 : ParameterList .
  var  VE : ViewExpression .
  var  QIL : QidList .
  var  K : Kind .

  eq makeSort(S, PL)
    = if PL == empty
      then S
      else makeSort(S, PL, empty, empty)
      fi .

  ----eq makeSort(S, P, PL, PL') = makeSort(S, empty, (PL, P), PL') .
  eq makeSort(S, (P, PL), PL', PL'') = makeSort(S, PL, (PL', P), PL'') .
  eq makeSort(S, (P{PL}, PL'), PL'', PL3)
    = makeSort(S, PL', (PL'', makeSort(P, PL)), PL3) .
  ----eq makeSort(S, (P ;; VE), PL, PL')
  ----  = makeSort(S, empty, (PL, P), (PL', VE))
  ----  [owise] .
  eq makeSort(S, ((P ;; VE), PL), PL', PL'')
    = makeSort(S, PL, (PL', P), (PL'', VE))
    [owise] .
  eq makeSort(S, empty, PL, PL')
    = if PL' == empty
      then makeSort2(S, PL)
      else makeSort(makeSort2(S, PL), PL')
      fi .

  eq makeSort2(S, empty) = S:Sort .
  eq makeSort2(S, P) = qid(string(S) + "{" + string(P) + "}") .
  eq makeSort2(S, (P, PL))
    = qid(string(S) + "{" + string(P) + makePars(PL))
    [owise] .

  eq makePars((P, PL)) = "," + string(P) + makePars(PL) .
  eq makePars(P) = "," + string(P) + "}" .
  eq makePars(empty) = "}" .

  op list2set : TypeList -> TypeSet .
  eq list2set(Tp TpL) = Tp ; list2set(TpL) .
  eq list2set(nil) = none .

  op type2qid : Type -> Qid .
  eq type2qid(S)
    = if getPars(S) == empty
      then S
      else qid(string(getName(S)) + "{" + string(qidList2Qid(parameterList2QidList(getPars(S)))) + "}")
      fi .
  eq type2qid(K) = qid("[" + string(type2qid(getSort(K))) + "]") .

  op size : TypeList -> Nat .
  eq size(Tp TpL) = 1 + size(TpL) .
  eq size((nil).TypeList) = 0 .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod DEFAULT-VALUE{X :: TRIV} is
  sort Default{X} .
  subsort X$Elt < Default{X} .
  op null : -> Default{X} .
endfm

view Term from TRIV to META-TERM is
  sort Elt to Term .
endv

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Extended Declarations
***

*** In this section we discuss modules \texttt{EXT-DECL} and \texttt{O-O-DECL}
*** which introduce, respectively, the declarations extending the sorts and
*** constructors for declarations of the predefined data type \texttt{Module}
*** in the \texttt{META-LEVEL} module to allow the use of extended sorts in
*** them, and the declarations appearing in object-oriented units, namely
*** class declarations, subclass relation declarations, and message
*** declarations.

***
*** Declarations of Functional and System Modules
***

*** In the following module \texttt{EXT-DECL}, we introduce the declarations
*** extending those in \texttt{META-LEVEL} to allow the use of extended sorts
*** in declarations of sorts, subsort relations, operators, variables, and
*** membership axioms.

*** \begin{comment}
*** \footnote{In the future, the declarations for operators,
*** membership axioms, equations, and rules will be extended to allow
*** the use of extended sorts in sort tests, that is, terms of the
*** form \mbox{\verb~T : S~} and \mbox{\verb~T :: S~}.}
*** \end{comment}

*** The extension is accomplished by adding new supersorts for each of the
*** sorts in \texttt{META-LEVEL} involved, and by adding new constructors for
*** these new sorts.

*** We start introducing the declarations for the supersorts and their
*** corresponding constructors. The \texttt{EXT-DECL} module also contains the
*** declarations for sTS of such declarations.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-INT-LIST is
  pr META-MODULE .
  pr INT .
  sort IntList .
  subsort Int NatList < IntList .
  op __ : IntList IntList -> IntList [ctor ditto] .

  op numberError : QidList -> [Nat] .

  vars N M : Nat .

  op from_to_list : Nat Nat ~> NatList .
  ceq from N to M list
    = if N == M
      then N
      else N from N + 1 to M list
      fi
    if N <= M .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-EXT-DECL is
  pr FM-EXT-SORT .
  pr FM-INT-LIST .

  var  QI : Qid .
  vars QIL QIL' : QidList .
  var  At : Attr .
  var  AtS : AttrSet .
  var  OPD OPD' : OpDecl .
  var  OPDS : OpDeclSet .
  vars LHS RHS T T' : Term .
  var  S : Sort .
  var  Cond : Condition .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  MbS : MembAxSet .
  var  M : Module .

  op variant : -> Attr [ctor] .

*** subsort declarations error
  op subsortDeclError : QidList -> [SubsortDeclSet] [ctor format (r o)] .
  eq subsortDeclError(QIL) subsortDeclError(QIL')
    = subsortDeclError(QIL QIL') .

*** extended attribute declarations
  op strat : IntList -> Attr [ditto] .   *** to handle on-demand strategies
  op ditto : -> Attr [ctor] .

  op _in_ : Attr AttrSet -> Bool .
  eq At in At AtS = true .
  eq At in AtS = false [owise] .

*** extended operation declarations
  op opDeclError : QidList -> [OpDeclSet] [ctor format (r o)] .
  eq opDeclError(QIL) opDeclError(QIL') = opDeclError(QIL QIL') .

*** extended membership axioms
  op membAxError : QidList -> [MembAxSet] [ctor format (r o)] .
  eq membAxError(QIL) membAxError(QIL') = membAxError(QIL QIL') .

*** extended equations
  op equationError : QidList -> [EquationSet] [ctor format (r o)] .
  eq equationError(QIL) equationError(QIL') = equationError(QIL QIL') .

*** extended rules
  op ruleError : QidList -> [RuleSet] [ctor format (r o)] .
  eq ruleError(QIL) ruleError(QIL') = ruleError(QIL QIL') .

*** extended strategy definitions
  op stratDefError : QidList -> [StratDefSet] [ctor format (r o)] .
  eq stratDefError(QIL) stratDefError(QIL') = stratDefError(QIL QIL') .

*** The function \verb~_in_~ checks whether a given operator
*** declaration is in a set of operator declarations.

  op _in_ : OpDecl OpDeclSet -> Bool .

  eq OPD in (OPD OPDS) = true .
  eq OPD in OPDS = false [owise] .

  ops lhs rhs : Rule -> Term .
  op cond : Rule -> Condition .
  op atts : Rule -> AttrSet .
  op label : Rule -> [Qid] .
  eq lhs(rl LHS => RHS [AtS] .) = LHS .
  eq lhs(crl LHS => RHS if Cond [AtS] .) = LHS .
  eq rhs(rl LHS => RHS [AtS] .) = RHS .
  eq rhs(crl LHS => RHS if Cond [AtS] .) = RHS .
  eq cond(rl LHS => RHS [AtS] .) = nil .
  eq cond(crl LHS => RHS if Cond [AtS] .) = Cond .
  eq atts(rl LHS => RHS [AtS] .) = AtS .
  eq atts(crl LHS => RHS if Cond [AtS] .) = AtS .
  eq label(rl LHS => RHS [label(QI) AtS] .) = QI .
  eq label(crl LHS => RHS if Cond [label(QI) AtS] .) = QI .

  ops lhs rhs : Equation -> Term .
  op cond : Equation -> Condition .
  op atts : Equation -> AttrSet .
  op label : Equation -> [Qid] .
  eq lhs(eq LHS = RHS [AtS] .) = LHS .
  eq lhs(ceq LHS = RHS if Cond [AtS] .) = LHS .
  eq rhs(eq LHS = RHS [AtS] .) = RHS .
  eq rhs(ceq LHS = RHS if Cond [AtS] .) = RHS .
  eq cond(eq LHS = RHS [AtS] .) = nil .
  eq cond(ceq LHS = RHS if Cond [AtS] .) = Cond .
  eq atts(eq LHS = RHS [AtS] .) = AtS .
  eq atts(ceq LHS = RHS if Cond [AtS] .) = AtS .
  eq label(eq LHS = RHS [label(QI) AtS] .) = QI .
  eq label(ceq LHS = RHS if Cond [label(QI) AtS] .) = QI .

  op cond : MembAx -> Condition .
  op atts : MembAx -> AttrSet .
  eq cond(mb T : S [AtS] .) = nil .
  eq cond(cmb T : S if Cond [AtS] .) = Cond .
  eq atts(mb T : S [AtS] .) = AtS .
  eq atts(cmb T : S if Cond [AtS] .) = AtS .

  op rulify : EquationSet -> RuleSet .
  ---- takes a set of equations and turn them into rules
  eq rulify(eq LHS = RHS [AtS] . EqS) = (rl LHS => RHS [AtS] .) rulify(EqS) .
  eq rulify(ceq LHS = RHS if Cond [AtS] . EqS) = (crl LHS => RHS if Cond [AtS] .) rulify(EqS) .
  eq rulify((none).EquationSet) = none .
endfm

**** The module FM-EXT-TERM extends META-LEVEL with definitions of several
**** operations that manipulate terms: definitions for positions and operations
**** to get the subterm of a given term at a given position, to replace the
**** subterm of a term at a given position by another term, to get all the
**** nonvariable positions in a term, to apply a substitution to a term, and to
**** get a copy of a term in which all the variables in it have been renamed.

fmod FM-EXT-TERM is
---  pr META-LEVEL + PRE-VARIANT .
  pr META-LEVEL .
  pr EXT-BOOL .
  pr FM-EXT-DECL .

  vars T T' : Term .
  vars F X : Qid .
  var  TL : TermList .
  var  N : Nat .
  vars NL NL' : NatList .
  vars V V' W : Variable .
  var  Subst : Substitution .
  vars C Ct : Constant .
  var  NTL : NeTermList .
  var  M : Module .
  var  Tp : Type .
  vars TpL TpL' : TypeList .
  vars AtS AtS' : AttrSet .
  var  ODS : OpDeclSet .
  var  Cd : Condition .
  var  S : Sort .

  **** vars returns the set of variables in a term
  op vars : Term -> QidSet .
  op vars : TermList -> QidSet .

  eq vars(V) = V .
  eq vars(C) = none .
  eq vars(F[TL]) = vars(TL) .
  eq vars(empty) = none .
  eq vars((T, TL)) = (vars(T) ; vars(TL)) .

  **** varlist returns the list of variables in a term
  op varlist : Term -> QidList .
  op varlist : TermList -> QidList .

  eq varlist(V) = V .
  eq varlist(C) = nil .
  eq varlist(F[TL]) = varlist(TL) .
  eq varlist(empty) = nil .
  eq varlist((T, TL)) = varlist(T) varlist(TL) .

  **** occurs? checks whether a variable name occurs in a term or not.
  op occurs? : Variable Term -> Bool .
  op occurs? : Variable TermList -> Bool .
  eq occurs?(V, V') = V == V' .
  eq occurs?(V, C) = false .
  eq occurs?(V, F[TL]) = occurs?(V, TL) .
  eq occurs?(V, (T, TL)) = occurs?(V, T) or-else  occurs?(V, TL) .

  **** occurrences checks whether a variable name occurs in a term or not.
  op occurrences : Variable Term -> Nat .
  op occurrences : Variable TermList -> Nat .
  eq occurrences(V, V') = if V == V' then 1 else 0 fi .
  eq occurrences(V, C) = 0 .
  eq occurrences(V, F[TL]) = occurrences(V, TL) .
  eq occurrences(V, (T, TL)) = occurrences(V, T) + occurrences(V, TL) .

  op frozen : Module Term Nat -> Bool .
  op frozen : Module OpDeclSet Qid TypeList Nat -> Bool .
  eq frozen(M, F[TL], N)
    = frozen(M, getOps(M), F, eLeastSort(M, TL), N) .

  ceq frozen(M, op F : TpL -> Tp [AtS] . ODS, F, TpL', N)
    = true
    if sameKind(M, TpL, TpL')
       /\ not ctor(M, op F : TpL -> Tp [AtS] . ODS, F, TpL') .
  ceq frozen(M, op F : TpL -> Tp [AtS] . ODS, F, TpL', N)
    = true
    if sameKind(M, TpL, TpL')
       /\ ctor(M, op F : TpL -> Tp [AtS] . ODS, F, TpL')
       /\ frozen(NL N NL') AtS' := AtS .
  eq frozen(M, ODS, F, TpL, N) = false [owise] .

  ---- ctor check whether the operator at the top is a constructor
  ---- in any of its overloadings
  op ctor : Module OpDeclSet Term -> Bool .
  op ctor : Module OpDeclSet Qid TypeList -> Bool .

  eq ctor(M, ODS, Ct) = ctor(M, ODS, Ct, nil) .
  eq ctor(M, ODS, F[TL]) = ctor(M, ODS, F, eLeastSort(M, TL)) .
  eq ctor(M, ODS, T) = false [owise] .

  ceq ctor(M, op F : TpL -> Tp [AtS] . ODS, F, TpL')
    = ctor in AtS or-else ctor(M, ODS, F, TpL')
    if sameKind(M, TpL, TpL') .
  eq ctor(M, ODS, F, TpL) = false [owise] .

**** The function \texttt{substitute} takes a term $t$ and a substitution
**** $\sigma$ and returns the term $t\sigma$.

  op substitute : Module Term Substitution -> Term .
  op substitute : Module TermList Substitution -> TermList .

  eq substitute(M, T, none) = T .
  eq substitute(M, V, ((W <- T) ; Subst))
    = if getName(V) == getName(W) and-then sameKind(M, getType(V), getType(W))
      then T
      else substitute(M, V, Subst)
      fi .
  eq substitute(M, C, ((W <- T); Subst)) = C .
  eq substitute(M, F[TL], Subst) = F[substitute(M, TL, Subst)] .
  eq substitute(M, (T, TL), Subst)
    = (substitute(M, T, Subst), substitute(M, TL, Subst)) .

  op substitute : Module EqCondition Substitution -> EqCondition .
  eq substitute(M, T = T' /\ Cd, Subst)
    = substitute(M, T, Subst) = substitute(M, T', Subst) /\ substitute(M, Cd, Subst) .
  eq substitute(M, T := T' /\ Cd, Subst)
    = substitute(M, T, Subst) := substitute(M, T', Subst) /\ substitute(M, Cd, Subst) .
  eq substitute(M, T : S /\ Cd, Subst)
    = substitute(M, T, Subst) : S /\ substitute(M, Cd, Subst) .
  eq substitute(M, (nil).EqCondition, Subst) = nil .
endfm

***(
red substitute('f['X:Foo, 'g['Y:Foo, 'Z:Foo]], ('Y:Foo <- 'h['W:Foo])) .
red rename('f['X:Foo, 'g['Y:Foo, 'Z:Foo]]) .
red allNonVarPos(
      substitute('f['X:Foo, 'g['Y:Foo, 'Z:Foo]], ('Y:Foo <- 'h['W:Foo]))) .
)

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Declarations for Object-Oriented Modules
***

*** In the \texttt{O-O-DECL} module we introduce the sorts and constructors
*** for declarations of classes, subclass relations, and messages in
*** object-oriented units.

*** Note that we follow the same naming conventions for classes as for
*** extended sorts (see Section~\ref{parameterized-modules}), and therefore
*** we use the sort \texttt{Sort} for class identifiers, and
*** \texttt{TypeList} and \texttt{SortSet} for lists and sTS of class
*** identifiers, respectively.  We use the operator \verb~attr_:_~ as a
*** constructor for declarations of attributes. Since the operator name
*** \texttt{\_\,:\_\,} is used for sort  tests in the \texttt{META-LEVEL}
*** module, we use \texttt{attr\_\,:\_\,} as  constructor for declarations of
*** attributes to satisfy the preregularity  condition.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-O-O-DECL is
  pr FM-EXT-SORT .

  vars QIL QIL' : QidList .

  sorts AttrDecl AttrDeclSet .
  subsort AttrDecl < AttrDeclSet .
  op attr_:_ : Qid Sort -> AttrDecl .
  op none : -> AttrDeclSet .
  op _`,_ : AttrDeclSet AttrDeclSet -> AttrDeclSet [assoc comm id: none] .

  eq AD:AttrDecl, AD:AttrDecl = AD:AttrDecl .

  sorts ClassDecl ClassDeclSet .
  subsort ClassDecl < ClassDeclSet .
  op class_|_. : Sort AttrDeclSet -> ClassDecl .
  op none : -> ClassDeclSet .
  op __ : ClassDeclSet ClassDeclSet -> ClassDeclSet [assoc comm id: none] .

  op classDeclError : QidList -> [ClassDeclSet] [ctor format (r o)] .
  eq classDeclError(QIL) classDeclError(QIL') = classDeclError(QIL QIL') .

  eq CD:ClassDecl CD:ClassDecl = CD:ClassDecl .

  sorts SubclassDecl SubclassDeclSet .
  subsort SubclassDecl < SubclassDeclSet .
  op subclass_<_. : Sort Sort -> SubclassDecl .
  op none : -> SubclassDeclSet .
  op __ : SubclassDeclSet SubclassDeclSet -> SubclassDeclSet
     [assoc comm id: none] .

  eq SCD:SubclassDecl SCD:SubclassDecl = SCD:SubclassDecl .

  op subclassDeclError : QidList -> [SubclassDeclSet] [ctor format (r o)] .
  eq subclassDeclError(QIL) subclassDeclError(QIL')
    = subclassDeclError(QIL QIL') .

  sorts MsgDecl MsgDeclSet .
  subsort MsgDecl < MsgDeclSet .
  op msg_:_->_. : Qid TypeList Sort -> MsgDecl .
  op none : -> MsgDeclSet .
  op __ : MsgDeclSet MsgDeclSet -> MsgDeclSet [assoc comm id: none] .

  eq MD:MsgDecl MD:MsgDecl = MD:MsgDecl .

  op msgDeclError : QidList -> [MsgDeclSet] [ctor format (r o)] .
  eq msgDeclError(QIL) msgDeclError(QIL') = msgDeclError(QIL QIL') .

*** The function \texttt{classSet} returns the set of class identifiers in
*** the set of class declarations given as argument.

  op classSet : ClassDeclSet -> SortSet .

  eq classSet((class S:Sort | ADS:AttrDeclSet .) CDS:ClassDeclSet)
    = (S:Sort ; classSet(CDS:ClassDeclSet)) .
  eq classSet(none) = none .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Renaming Maps
***

*** We introduce the different types of renaming maps in the module
*** \texttt{FMAP} below. A sort is introduced for each of these types of maps,
*** with the appropriate constructors for each sort (see
*** Section~\ref{module-expressions}). All these sorts are declared to be
*** subsorts of the sort \texttt{Map}. A sort for sTS of
*** maps (\texttt{RenamingSet}) is then declared as supersort of \texttt{Map}
*** with constructors \texttt{none} and \verb~_,_~.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-FMAP is
  inc META-MODULE .
  pr FM-EXT-SORT .

  *** renamings
  op class_to_ : Sort Sort -> Renaming .
  op attr_._to_ : Qid Sort Qid -> Renaming .
  op msg_to_ : Qid Qid -> Renaming .
  op msg_:_->_to_ : Qid TypeList Sort Qid -> Renaming .
  op op_to term_ : Term Term -> Renaming .
  op strat_to expr_ : CallStrategy Strategy -> Renaming .

  op none : -> RenamingSet .
  eq (MAP, MAP) = MAP .
  eq (MAPS, none) = MAPS .

----  eq attr A . qidError(QIL) to A' = none .

*** Given a set of maps, the function \texttt{sortMaps} returns the
*** subset of sort maps in it.

  var  MAP : Renaming .
  var  MAPS : RenamingSet .
  vars S S' A A' : Sort .
  var  QIL : QidList .

  op sortMaps : RenamingSet -> RenamingSet .

  eq sortMaps(sort S to S') = sort S to S' .
  eq sortMaps(((sort S to S'), MAPS))
    = ((sort S to S'), sortMaps(MAPS)) .
  eq sortMaps(MAP) = none [owise] .
  eq sortMaps((MAP, MAPS)) = sortMaps(MAPS) [owise] .
  eq sortMaps(none) = none .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Module Expressions and Module Names
***

*** The abstract syntax for writing specifications in Maude can be seen as
*** given by module expressions, where the notion of module expression is
*** understood as an expression that defines a new module out of previously
*** defined modules by combining and/or modifying them according to a specific
*** set of operations.  All module expressions will be evaluated generating
*** modules with such module expressions as names. In the case of parameterized
*** modules, each of the parameters in an interface will be used as the name
*** of a new module created as a renamed copy of the parameter theory.

***
*** Module Expressions
***

*** The \texttt{TUPLE} and \texttt{POWER} are declared to be new types of
*** \texttt{ModuleExpression}s.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-EXPR is
  inc META-MODULE .
  pr FM-FMAP .

  op TUPLE`[_`] : NzNat -> ModuleExpression .
  op POWER`[_`] : NzNat -> ModuleExpression .

  eq ME:ModuleExpression * ( none ) = ME:ModuleExpression .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Module Names
***

*** As we shall see in the coming sections, the evaluation of module
*** expressions may produce the creation of new modules, whose \emph{names}
*** are given by the module expressions themselves. If there is already a
*** module in the database with the module expression being evaluated as name,
*** the evaluation of such module expression does not produce any change in
*** the database. However, the evaluation of a module expression may involve
*** the evaluation of some other module expressions contained in the modules
*** involved, which in turn may generate new modules.

*** Given a parameterized module $\texttt{N\{L}_1\texttt{\ ::\ T}_1
*** \texttt{\ ,\ }\ldots\texttt{\ ,\ L}_n\texttt{\ ::\ T}_n\texttt{\}}$, with
*** $\texttt{L}_1\ldots\texttt{L}_n$ labels and
*** $\texttt{T}_1\ldots\texttt{T}_n$ theory identifiers, we say that
*** \texttt{N} is the name of the module and that
*** $\texttt{\{L}_1\texttt{\ ::\ T}_1\texttt{\ ,\ }
*** \ldots\texttt{\ ,\ L}_n\texttt{\ ::\ T}_n\texttt{\}}$
*** is its \emph{interface}.
*** As we shall see in Sections~\ref{instantiation} and~\ref{unit-processing},
*** for each parameter $\texttt{L}_i\texttt{\ ::\ T}_i$ in the interface of a
*** module, a new module is generated with such a parameter expression as its
*** name, and a declaration importing it in the parameterized module is added.
***  We regard the relationship between the body of a parameterized module and
*** the parameters in its interface, not as an inclusion, but as mediated by
*** a module constructor that generates renamed copies of the parameters,
*** which are then included. Therefore, the sort \texttt{ViewExpression} is
*** declared as a subsort of \texttt{Header}, that is, terms of sort
*** \texttt{ViewExpression} are considered to be module names. The constructor
*** operator for the sort \texttt{ViewExpression} is \verb~par_::_~.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-NAME is
  inc MOD-EXPR .
  pr EXT-BOOL .
  op parameterError : QidList -> [ParameterDecl] .

  sort ModuleName .
  subsorts ModuleExpression < ModuleName < Header .
  op _{_}  : ModuleExpression ParameterDeclList -> Header [ctor] .
  op pd : ParameterDecl -> ModuleName .
  op nullHeader : -> Header .

----  op getName : Header -> ModuleExpression .
  op getParDecls : Header -> ParameterDeclList .

  vars QI QI' : Qid .
  var  ME : ModuleExpression .
  vars PDL PDL' : ParameterDeclList .
  var  PL : NeParameterList .
  var  MN : ModuleName .

----  eq getName(ME{PDL}) = ME .
----  eq getName(MN) = MN .
  eq getParDecls(ME{PDL}) = PDL .
  eq getParDecls(MN) = nil .

  op including_. : ModuleName -> Import [ctor] .
  op extending_. : ModuleName -> Import [ctor] .
  op protecting_. : ModuleName -> Import [ctor] .

  op fth_is_sorts_.____endfth : Header ImportList SortSet SubsortDeclSet
    OpDeclSet MembAxSet EquationSet -> FTheory [ctor gather (& & & & & & &)
     format (d d d n++i ni d d ni ni ni ni n--i d)] .
  op th_is_sorts_._____endth : Header ImportList SortSet SubsortDeclSet
    OpDeclSet MembAxSet EquationSet RuleSet -> STheory
    [ctor gather (& & & & & & & &)
     format (d d d n++i ni d d ni ni ni ni ni n--i d)] .

*** The function \texttt{labelInParameterDeclList} checks whether the quoted
*** identifier given as first argument is used as a label in the list of
*** parameters given as second argument.

  op labelInParameterDeclList : Sort ParameterDeclList -> Bool .
  eq labelInParameterDeclList(QI, (PDL, (QI :: ME), PDL')) = true .
  eq labelInParameterDeclList(QI, PDL) = false [owise] .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** Since the Core Maude engine assumes that module names are identifiers and
*** does not know about term-structured module names (such as parameterized
*** module interfaces or module expressions), for evaluation purposes we need
*** to transform them into quoted identifiers. The functions
*** \texttt{header2Qid} and \texttt{header2QidList} in the module
*** \texttt{MOD-NAME-TO-QID} below accomplish this transformation. In any
*** language extensions, new equations for the function
*** \texttt{header2QidList} should be added for each new module expression
*** constructor introduced. In Sections~\ref{renaming} and~\ref{instantiation}
*** we shall see how the corresponding equalities are added for renaming and
*** instantiation expressions, and in Section~\ref{extension} for other new
*** module expressions in extensions of Full Maude.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-NAME-TO-QID is
  pr MOD-NAME .
  pr FM-EXT-QID-LIST .

  op header2Qid : Header -> Qid .
  op header2QidList : Header -> QidList .
  op parameterDecl2Qid : ParameterDecl -> Qid .
  op parameterDecl2QidList : ParameterDecl -> QidList .
  op parameterDeclList2Qid : ParameterDeclList -> Qid .
  op parameterDeclList2QidList : ParameterDeclList -> QidList .

  vars QI X : Qid .
  var  QIL : QidList .
  vars ME ME' : ModuleExpression .
  var  PDL : ParameterDeclList .
  var  PD : ParameterDecl .

  eq header2Qid(QI) = QI .
  eq header2Qid(nullHeader) = ' .
  eq header2Qid(pd(X :: ME)) = qidList2Qid(header2QidList(pd(X :: ME))) .
  eq header2QidList(pd(X :: ME)) = X ':: header2QidList(ME) .

  eq header2QidList(QI) = QI .
  eq header2QidList(nullHeader) = ' .

  eq header2Qid((ME { PDL })) = qidList2Qid(header2QidList((ME { PDL }))) .
  ceq header2QidList((ME { PDL }))
    = (if QI == '\s then QIL else QIL QI fi
       '`{ parameterDecl2QidList(PDL) '`} '\s)
    if QIL QI := header2QidList(ME) .

  eq parameterDecl2Qid(X :: ME) = qidList2Qid(X ':: header2Qid(ME)) .

  eq parameterDeclList2Qid(PDL)
    = qidList2Qid(parameterDeclList2QidList(PDL)) .

  eq parameterDeclList2QidList(X :: ME) = X ':: header2QidList(ME) .
  eq parameterDeclList2QidList((X :: ME, PDL))
    = parameterDeclList2QidList(X :: ME) '`, parameterDeclList2QidList(PDL)
    [owise] .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Modules
***

*** We handle six different types of units: functional, system, and
*** object-oriented modules, and functional, system, and object-oriented
*** theories.  Modules and theories of any kind are considered to be elements
*** in specific subsorts of the sort \texttt{Module}. A constructor
*** \texttt{error} is also included to represent incorrect units.
*** \texttt{error} has a list of quoted identifiers as argument, which is
*** used to report the error. Besides considering functional and system
*** theories and object-oriented theories and modules, the declarations
*** presented in the following module extend the declarations for sort
*** \texttt{Module} in the \texttt{META-LEVEL} module in three different ways:

*** \begin{itemize}
*** \item the name of a module can be any term of sort \texttt{Header},
*** \item parameterized modules are handled, for which a list of
***       parameters is added to the constructors of modules,
*** \item the importation declaration is extended to module names, and
*** \item parameterized sorts are supported.
*** \end{itemize}

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FM-UNIT is
  pr FM-EXT-DECL .
  pr FM-O-O-DECL .
  pr MOD-NAME-TO-QID .
---  inc META-LEVEL + PRE-VARIANT .
  inc META-LEVEL .

  ---- pre-parsing declarations
  op sd_:=_[_]. : Term Term AttrSet -> StratDefinition .
  op csd_:=_if_[_]. : Term Term EqCondition AttrSet -> StratDefinition .

  op moduleName : Import -> ModuleName .
  eq moduleName(protecting MN .) = MN .
  eq moduleName(protecting ME{PL} .) = ME .
  eq moduleName(extending MN .) = MN .
  eq moduleName(extending ME{PL} .) = ME .
  eq moduleName(including MN .) = MN .
  eq moduleName(including ME{PL} .) = ME .

  op importError : QidList -> [ImportList] [ctor format (r o)] .
  eq importError(QIL) importError(QIL') = importError(QIL QIL') .

  sorts OModule OTheory Theory .
  subsorts SModule < OModule < Module .
  subsorts STheory < OTheory StratTheory < Theory < Module .

  op noModule : -> Module .   *** Module
  op unitError : QidList -> [Module] [ctor format (r o)] .
  op getMsg : [Module] -> QidList .
  eq getMsg(unitError(QIL)) = QIL .

  op omod_is_sorts_.________endom : Header ImportList
        SortSet SubsortDeclSet ClassDeclSet SubclassDeclSet OpDeclSet
        MsgDeclSet MembAxSet EquationSet RuleSet -> OModule
        [ctor
         gather (& & & & & & & & & & &)
         format (r! o r! n++io ni d d ni ni ni ni ni ni ni ni n--ir! o)] .
  op oth_is_sorts_.________endoth : Header ImportList
        SortSet SubsortDeclSet ClassDeclSet SubclassDeclSet OpDeclSet
        MsgDeclSet MembAxSet EquationSet RuleSet -> OTheory
        [ctor
         gather (& & & & & & & & & & &)
         format (r! o r! n++io ni d d ni ni ni ni ni ni ni ni n--ir! o)] .

*** In addition to the constructor operators, the following functions are
*** introduced in the \texttt{UNIT} module:
*** \begin{itemize}
*** \item A function \verb~_in_~ to check whether a given importation
***       declaration is in a set of importation declarations or not.

  op _in_ : Import ImportList -> Bool .

*** \item Selector functions for the different components of a Module.

  op getHeader : Module -> Header .
  op getPars : Module -> ParameterDeclList .
  op getClasses : Module -> ClassDeclSet .
  op getSubclasses : Module -> SubclassDeclSet .
  op getMsgs : Module -> MsgDeclSet .
  op getStratDcls : Module -> StratDeclSet .
  op getStratDefs : Module -> StratDefSet .

*** \item Functions to change the value of each of the components of a Module.

  op setName : Module ModuleExpression -> Module .
  op setName : Module ParameterDecl -> Module .
  op setPars : Module ParameterDeclList -> Module .
  op setImports : Module ImportList -> Module .
  op setSorts : Module SortSet -> Module .
  op setSubsorts : Module SubsortDeclSet -> Module .
  op setOps : Module OpDeclSet -> Module .
  op setMbs : Module MembAxSet -> Module .
  op setEqs : Module EquationSet -> Module .
  op setRls : Module RuleSet ~> Module .
  op setClasses : Module ClassDeclSet -> Module .
  op setSubclasses : Module SubclassDeclSet -> Module .
  op setMsgs : Module MsgDeclSet -> Module .
  op setStratDefs : Module StratDefSet -> Module .
  op setStratDcls : Module StratDeclSet -> Module .

*** \item Functions to add new declarations to the set of declarations
*** already in a unit.

  op addImports : ImportList Module -> Module .
  op addSorts : SortSet Module -> Module .
  op addSubsorts : [SubsortDeclSet] Module -> Module .
  op addOps : [OpDeclSet] Module -> Module .
  op addMbs : MembAxSet Module -> Module .
  op addEqs : EquationSet Module -> Module .
  op addRls : RuleSet Module -> Module .
  op addClasses : ClassDeclSet Module -> Module .
  op addSubclasses : SubclassDeclSet Module -> Module .
  op addMsgs : MsgDeclSet Module -> Module .
  op addStratDefs : StratDefSet Module -> Module .
  op addStratDcls : StratDeclSet Module -> Module .

*** \item There are functions and constants to create empty modules of the
***       different types. For example, the function \texttt{emptyFTheory}
***       returns an empty functional theory. There is also a
***       function \texttt{empty} which takes a module as argument and returns
***       an empty module of the same type.

  op emptyFModule : Header -> FModule .
  op emptyFModule : -> FModule .
  op emptySModule : -> SModule .
  op emptyOModule : -> OModule .
  op emptyStratModule : -> StratModule .
  op emptyFTheory : -> FModule .
  op emptySTheory : -> SModule .
  op emptyOTheory : -> OModule .
  op emptyStratTheory : -> StratModule .
  op empty : Module -> Module .

*** \item A function \texttt{addDecls} which returns the module resulting from
***       adding all the declarations in the module passed as second argument
***       to the module passed as first argument.

  op addDecls : Module Module -> Module .

*** \end{itemize}

*** Note that some of the `set' and `add' functions are partial functions.

  vars M M' M'' : Module .
  vars QI V : Qid .
  var  S : Sort .
  vars SSDS SSDS' SSDS'' : SubsortDeclSet .
  vars OPD OPD' : OpDecl .
  vars OPDS OPDS' : OpDeclSet .
  var  OPDS? : [OpDeclSet] .
  var  At : Attr .
  var  AtS : AttrSet .
  vars MAS MAS' MbS : MembAxSet .
  vars Eq Eq' : Equation .
  vars EqS EqS' : EquationSet .
  vars Rl Rl' : Rule .
  vars RlS RlS' : RuleSet .
  vars SS SS' : SortSet .
  vars IL IL' : ImportList .
  vars QIL QIL' : QidList .
  vars PL PL' : ParameterList .
  vars CDS CDS' : ClassDeclSet .
  vars SCD SCD' : SubclassDecl .
  vars SCDS SCDS' : SubclassDeclSet .
  vars U U' : Module .
  vars MDS MDS' : MsgDeclSet .
  vars I I' : Import .
  vars T T' T1 T1' T2 T2' : Term .
  vars ME ME' : ModuleExpression .
  vars PD PD' : ParameterDecl .
  vars PDL PDL' : ParameterDeclList .
  var  H : Header .
  vars MN MN' : ModuleName .
  var  Cd Cond Cond1 Cond2 : Condition .
  vars StratDcls StratDcls' : StratDeclSet .
  vars StratDefs StratDefs' : StratDefSet .
  var  StratDcls? : [StratDeclSet] .
  var  StratDefs? : [StratDefSet] .

  eq I in (IL I IL') = true .
  eq I in IL = false [owise] .

  op theory : Module -> Bool .
  eq theory(unitError(QIL)) = false .
  eq theory(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = false .
  eq theory(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = true .
  eq theory(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = false .
  eq theory(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth) = true .
  eq theory(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = false .
  eq theory(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = true .
  eq theory(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = false .
  eq theory(sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = true .

*** Selection functions for units

  eq getHeader(unitError(QIL)) = ' .
  eq getHeader(noModule) = ' .
  eq getHeader(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = ME .
  eq getHeader(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = ME .
  eq getHeader(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = MN .
  eq getHeader(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm) = ME .
  eq getHeader(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm) = ME .
  eq getHeader(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth) = MN .
  eq getHeader(
       omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = ME .
  eq getHeader(
       omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = ME .
  eq getHeader(
       oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = MN .
  eq getHeader(smod ME is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = ME .
  eq getHeader(smod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = ME .
  eq getHeader(sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = MN .

  eq getImports(unitError(QIL)) = nil .
  eq getImports(noModule) = nil .
  eq getImports(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = IL .
  eq getImports(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = IL .
  eq getImports(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = IL .
  eq getImports(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = IL .
  eq getImports(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = IL .
  eq getImports(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = IL .
  eq getImports(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = IL .
  eq getImports(sth H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = IL .

  eq getPars(unitError(QIL)) = nil .
  eq getPars(noModule) = nil .
  eq getPars(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = nil .
  eq getPars(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = PDL .
  eq getPars(mod nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = nil .
  eq getPars(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = nil .
  eq getPars(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = nil .
  eq getPars(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm) = nil .
  eq getPars(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm) = PDL .
  eq getPars(fmod nullHeader is IL sorts SS . SSDS OPDS MAS EqS endfm) = nil .
  eq getPars(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth) = nil .
  eq getPars(
       omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = nil .
  eq getPars(
        omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS
        endom)
    = PDL .
  eq getPars(
        omod nullHeader is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS
        endom)
    = nil .
  eq getPars(
       oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = nil .
  eq getPars(smod ME is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = nil .
  eq getPars(smod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = PDL .
  eq getPars(smod nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm)
    = nil .
  eq getPars(sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = nil .
  eq getPars(sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = nil .

  eq getSorts(unitError(QIL)) = none .
  eq getSorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = SS .
  eq getSorts(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = SS .
  eq getSorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = SS .
  eq getSorts(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = SS .
  eq getSorts(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = SS .
  eq getSorts(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = SS .
  eq getSorts(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = SS .
  eq getSorts(sth H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = SS .

  op getAllSorts : Module -> SortSet .
  eq getAllSorts(M) = getSorts(M) .

  eq getSubsorts(unitError(QIL)) = none .
  eq getSubsorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = SSDS .
  eq getSubsorts(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = SSDS .
  eq getSubsorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = SSDS .
  eq getSubsorts(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = SSDS .
  eq getSubsorts(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = SSDS .
  eq getSubsorts(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = SSDS .
  eq getSubsorts(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = SSDS .
  eq getSubsorts(sth H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = SSDS .

  eq getOps(unitError(QIL)) = none .
  eq getOps(noModule) = none .
  eq getOps(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = OPDS .
  eq getOps(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = OPDS .
  eq getOps(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = OPDS .
  eq getOps(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = OPDS .
  eq getOps(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = OPDS .
  eq getOps(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = OPDS .
  eq getOps(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = OPDS .
  eq getOps(sth H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = OPDS .

  eq getMbs(unitError(QIL)) = none .
  eq getMbs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = MAS .
  eq getMbs(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = MAS .
  eq getMbs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = MAS .
  eq getMbs(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = MAS .
  eq getMbs(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = MAS .
  eq getMbs(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = MAS .
  eq getMbs(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = MAS .
  eq getMbs(sth H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = MAS .

  eq getEqs(unitError(QIL)) = none .
  eq getEqs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = EqS .
  eq getEqs(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = EqS .
  eq getEqs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = EqS .
  eq getEqs(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = EqS .
  eq getEqs(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = EqS .
  eq getEqs(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = EqS .
  eq getEqs(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = EqS .
  eq getEqs(sth H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = EqS .

  eq getRls(unitError(QIL)) = none .
  eq getRls(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = RlS .
  eq getRls(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = RlS .
  eq getRls(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getRls(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getRls(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = RlS .
  eq getRls(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = RlS .
  eq getRls(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = RlS .
  eq getRls(sth H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = RlS .

  eq getClasses(unitError(QIL)) = none .
  eq getClasses(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getClasses(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getClasses(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getClasses(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getClasses(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = CDS .
  eq getClasses(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = CDS .
  eq getClasses(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = none .
  eq getClasses(sth H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = none .

  eq getSubclasses(unitError(QIL)) = none .
  eq getSubclasses(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getSubclasses(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getSubclasses(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getSubclasses(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getSubclasses(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = SCDS .
  eq getSubclasses(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = SCDS .
  eq getSubclasses(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = none .
  eq getSubclasses(sth H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = none .

  eq getMsgs(unitError(QIL)) = none .
  eq getMsgs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getMsgs(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getMsgs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getMsgs(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getMsgs(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = MDS .
  eq getMsgs(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = MDS .
  eq getMsgs(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = none .
  eq getMsgs(sth H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = none .

  eq getStratDcls(unitError(QIL)) = none .
  eq getStratDcls(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getStratDcls(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getStratDcls(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getStratDcls(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getStratDcls(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom) = none .
  eq getStratDcls(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth) = none .
  eq getStratDcls(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = StratDcls .
  eq getStratDcls(sth H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = StratDcls .

  eq getStratDefs(unitError(QIL)) = none .
  eq getStratDefs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getStratDefs(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getStratDefs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getStratDefs(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getStratDefs(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom) = none .
  eq getStratDefs(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth) = none .
  eq getStratDefs(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm) = StratDefs .
  eq getStratDefs(sth H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth) = StratDefs .

*** Set functions

  eq setImports(unitError(QIL), IL) = unitError(QIL) .
  eq setImports(noModule, IL) = noModule .
  eq setImports(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, IL')
    = mod H is IL' sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setImports(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, IL')
    = th H is IL' sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setImports(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, IL')
    = fmod H is IL' sorts SS . SSDS OPDS MAS EqS endfm .
  eq setImports(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, IL')
    = fth H is IL' sorts SS . SSDS OPDS MAS EqS endfth .
  eq setImports(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, IL')
    = omod H is IL' sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setImports(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, IL')
    = oth H is IL' sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .
  eq setImports(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, IL')
    = smod H is IL' sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm .
  eq setImports(sth H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth, IL')
    = sth H is IL' sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth .

  eq setOps(unitError(QIL), OPDS) = unitError(QIL) .
  eq setOps(noModule, OPDS) = noModule .
  eq setOps(U, opDeclError(QIL) OPDS) = unitError(QIL) .
  eq setOps(unitError(QIL), opDeclError(QIL') OPDS) = unitError(QIL QIL') .
  eq setOps(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, OPDS')
    = mod H is IL sorts SS . SSDS OPDS' MAS EqS RlS endm .
  eq setOps(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, OPDS')
    = th MN is IL sorts SS . SSDS OPDS' MAS EqS RlS endth .
  eq setOps(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, OPDS')
    = fmod H is IL sorts SS . SSDS OPDS' MAS EqS endfm .
  eq setOps(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, OPDS')
    = fth MN is IL sorts SS . SSDS OPDS' MAS EqS endfth .
  eq setOps(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
       OPDS')
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS' MDS MAS EqS RlS endom .
  eq setOps(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
       OPDS')
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS' MDS MAS EqS RlS endoth .
  eq setOps(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, OPDS')
    = smod H is IL sorts SS . SSDS OPDS' MAS EqS RlS StratDcls StratDefs endsm .
  eq setOps(sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth, OPDS')
    = sth MN is IL sorts SS . SSDS OPDS' MAS EqS RlS StratDcls StratDefs endsth .

  eq setSubsorts(unitError(QIL), SSDS) = unitError(QIL) .
  eq setSubsorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, SSDS')
    = mod H is IL sorts SS . SSDS' OPDS MAS EqS RlS endm .
  eq setSubsorts(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, SSDS')
    = th MN is IL sorts SS . SSDS' OPDS MAS EqS RlS endth .
  eq setSubsorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, SSDS')
    = fmod H is IL sorts SS . SSDS' OPDS MAS EqS endfm .
  eq setSubsorts(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, SSDS')
    = fth MN is IL sorts SS . SSDS' OPDS MAS EqS endfth .
  eq setSubsorts(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
       SSDS')
    = omod H is IL sorts SS . SSDS' CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setSubsorts(
       oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
       SSDS')
    = oth MN is IL sorts SS . SSDS' CDS SCDS OPDS MDS MAS EqS RlS endoth .
  eq setSubsorts(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, SSDS')
    = smod H is IL sorts SS . SSDS' OPDS MAS EqS RlS StratDcls StratDefs endsm .
  eq setSubsorts(sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth, SSDS')
    = sth MN is IL sorts SS . SSDS' OPDS MAS EqS RlS StratDcls StratDefs endsth .

  eq setMbs(unitError(QIL), membAxError(QIL') MAS) = unitError(QIL QIL') .
  eq setMbs(unitError(QIL), MAS) = unitError(QIL) .
  eq setMbs(U, membAxError(QIL) MAS) = unitError(QIL) .
  eq setMbs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, MAS')
    = mod H is IL sorts SS . SSDS OPDS MAS' EqS RlS endm .
  eq setMbs(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MAS')
    = th MN is IL sorts SS . SSDS OPDS MAS' EqS RlS endth .
  eq setMbs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, MAS')
    = fmod H is IL sorts SS . SSDS OPDS MAS' EqS endfm .
  eq setMbs(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, MAS')
    = fth MN is IL sorts SS . SSDS OPDS MAS' EqS endfth .
  eq setMbs(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, MAS')
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS' EqS RlS endom .
  eq setMbs(
       oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, MAS')
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS' EqS RlS endoth .
  eq setMbs(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, MAS')
    = smod H is IL sorts SS . SSDS OPDS MAS' EqS RlS StratDcls StratDefs endsm .
  eq setMbs(sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth, MAS')
    = sth MN is IL sorts SS . SSDS OPDS MAS' EqS RlS StratDcls StratDefs endsth .

  eq setEqs(unitError(QIL), EqS) = unitError(QIL) .
  eq setEqs(U, equationError(QIL) EqS?:[EquationSet]) = unitError(QIL) .
  eq setEqs(unitError(QIL), equationError(QIL') EqS?:[EquationSet])
    = unitError(QIL QIL') .
  eq setEqs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, EqS')
    = mod H is IL sorts SS . SSDS OPDS MAS EqS' RlS endm .
  eq setEqs(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, EqS')
    = th MN is IL sorts SS . SSDS OPDS MAS EqS' RlS endth .
  eq setEqs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, EqS')
    = fmod H is IL sorts SS . SSDS OPDS MAS EqS' endfm .
  eq setEqs(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, EqS')
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS' endfth .
  eq setEqs(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, EqS')
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS' RlS endom .
  eq setEqs(
       oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, EqS')
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS' RlS endoth .
  eq setEqs(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, EqS')
    = smod H is IL sorts SS . SSDS OPDS MAS EqS' RlS StratDcls StratDefs endsm .
  eq setEqs(sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth, EqS')
    = sth MN is IL sorts SS . SSDS OPDS MAS EqS' RlS StratDcls StratDefs endsth .

  var U? : [Module] .
  var RlS? : [RuleSet] .

  eq setRls(unitError(QIL), RlS?) = unitError(QIL) .
  eq setRls(U?, ruleError(QIL) RlS?) = unitError(QIL) .
  eq setRls(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, RlS')
    = mod H is IL sorts SS . SSDS OPDS MAS EqS RlS' endm .
  eq setRls(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, RlS')
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS' endth .
  eq setRls(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, RlS)
    = if RlS == none
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      fi .
  eq setRls(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, RlS)
    = if RlS == none
      then fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth
      else th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      fi .
  eq setRls(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, RlS')
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS' endom .
  eq setRls(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, RlS')
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS' endoth .
  eq setRls(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, RlS')
    = smod H is IL sorts SS . SSDS OPDS MAS EqS RlS' StratDcls StratDefs endsm .
  eq setRls(sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth, RlS')
    = sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS' StratDcls StratDefs endsth .

  eq setSorts(unitError(QIL), SS) = unitError(QIL) .
  eq setSorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, SS')
    = mod H is IL sorts SS' . SSDS OPDS MAS EqS RlS endm .
  eq setSorts(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, SS')
    = th MN is IL sorts SS' . SSDS OPDS MAS EqS RlS endth .
  eq setSorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, SS')
    = fmod H is IL sorts SS' . SSDS OPDS MAS EqS endfm .
  eq setSorts(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, SS')
    = fth MN is IL sorts SS' . SSDS OPDS MAS EqS endfth .
  eq setSorts(
        omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, SS')
    = omod H is IL sorts SS' . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setSorts(
        oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, SS')
    = oth MN is IL sorts SS' . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .
  eq setSorts(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, SS')
    = smod H is IL sorts SS' . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm .
  eq setSorts(sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth, SS')
    = sth MN is IL sorts SS' . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth .

  eq setPars(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm, PDL)
    = if PDL == nil
      then mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      fi .
  eq setPars(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm, PDL')
    = if PDL' == nil
      then mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else mod ME{PDL'} is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      fi .
  eq setPars(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, PDL)
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setPars(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm, PDL)
    = if PDL == nil
      then fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm
      else fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm
      fi .
  eq setPars(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm, PDL')
    = if PDL' == nil
      then fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm
      else fmod ME{PDL'} is IL sorts SS . SSDS OPDS MAS EqS endfm
      fi .
  eq setPars(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, PDL)
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setPars(
        omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
        PDL)
    = if PDL == nil
      then omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom
      else omod ME{PDL} is
             IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS
           endom
      fi .
  eq setPars(
       omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
       PDL')
    = if PDL' == nil
      then omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom
      else omod ME{PDL'} is
             IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS
           endom
      fi .
  eq setPars(
        oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
        PDL)
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .
  eq setPars(smod ME is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, PDL)
    = if PDL == nil
      then smod ME is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm
      else smod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm
      fi .
  eq setPars(smod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, PDL')
    = if PDL' == nil
      then smod ME is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm
      else smod ME{PDL'} is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm
      fi .
  eq setPars(sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth, PDL)
    = sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth .

  eq setClasses(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, CDS)
    = if CDS == none
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else omod H is IL sorts SS . SSDS CDS none OPDS none MAS EqS none endom
      fi .
  eq setClasses(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, CDS)
    = if CDS == none
      then fth H is IL sorts SS . SSDS OPDS MAS EqS endfth
      else oth H is IL sorts SS . SSDS CDS none OPDS none MAS EqS none endoth
      fi .
  eq setClasses(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, CDS)
    = if CDS == none
      then mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else omod H is IL sorts SS . SSDS CDS none OPDS none MAS EqS RlS endom
      fi .
  eq setClasses(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, CDS)
    = if CDS == none
      then th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      else oth H is IL sorts SS . SSDS CDS none OPDS none MAS EqS RlS endoth
      fi .
  eq setClasses(
        omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
        CDS')
    = omod H is IL sorts SS . SSDS CDS' SCDS OPDS MDS MAS EqS RlS endom .
  eq setClasses(
        oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
        CDS')
    = oth H is IL sorts SS . SSDS CDS' SCDS OPDS MDS MAS EqS RlS endoth .
  eq setClasses(M, CDS)
    = unitError(header2QidList(getHeader(M)) 'not 'an 'object-oriented 'module)
    [owise] .

  eq setSubclasses(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, SCDS)
    = if SCDS == none
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else omod H is IL sorts SS . SSDS none SCDS OPDS none MAS EqS none endom
      fi .
  eq setSubclasses(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, SCDS)
    = if SCDS == none
      then fth H is IL sorts SS . SSDS OPDS MAS EqS endfth
      else oth H is IL sorts SS . SSDS none SCDS OPDS none MAS EqS none endoth
      fi .
  eq setSubclasses(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, SCDS)
    = if SCDS == none
      then mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else omod H is IL sorts SS . SSDS none SCDS OPDS none MAS EqS RlS endom
      fi .
  eq setSubclasses(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, SCDS)
    = if SCDS == none
      then th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      else oth H is IL sorts SS . SSDS none SCDS OPDS none MAS EqS RlS endoth
      fi .
  eq setSubclasses(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, SCDS')
    = omod H is IL sorts SS . SSDS CDS SCDS' OPDS MDS MAS EqS RlS endom .
  eq setSubclasses(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
       SCDS')
    = oth H is IL sorts SS . SSDS CDS SCDS' OPDS MDS MAS EqS RlS endoth .
  eq setSubclasses(M, SCDS)
    = unitError(header2QidList(getHeader(M)) 'not 'an 'object-oriented 'module)
    [owise] .

  eq setMsgs(
       fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, MDS)
    = if MDS == none
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else omod H is IL sorts SS . SSDS none none OPDS MDS MAS EqS none endom
      fi .
  eq setMsgs(
       fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, MDS)
    = if MDS == none
      then fth H is IL sorts SS . SSDS OPDS MAS EqS endfth
      else oth H is IL sorts SS . SSDS none none OPDS MDS MAS EqS none endoth
      fi .
  eq setMsgs(
       mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, MDS)
    = if MDS == none
      then mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else omod H is IL sorts SS . SSDS none none OPDS MDS MAS EqS RlS endom
      fi .
  eq setMsgs(
       th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MDS)
    = if MDS == none
      then th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      else oth H is IL sorts SS . SSDS none none OPDS MDS MAS EqS RlS endoth
      fi .
  eq setMsgs(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, MDS')
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS' MAS EqS RlS endom .
  eq setMsgs(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, MDS')
    = oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS' MAS EqS RlS endoth .
  eq setMsgs(M, MDS)
    = unitError(header2QidList(getHeader(M)) 'not 'an 'object-oriented 'module)
    [owise] .

  eq setName(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm, ME')
    = mod ME' is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setName(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm, ME')
    = mod ME'{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setName(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm, ME')
    = fmod ME' is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setName(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm, ME')
    = fmod ME'{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setName(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, MN')
    = fth MN' is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setName(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MN')
    = th MN' is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setName(omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, ME')
    = omod ME' is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setName(omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, ME')
    = omod ME'{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setName(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, MN')
    = oth MN' is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .
  eq setName(smod ME is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, ME')
    = smod ME' is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm .
  eq setName(smod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, ME')
    = smod ME'{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm .
  eq setName(sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth, MN')
    = sth MN' is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth .
  eq setName(noModule, ME) = noModule .
  eq setName(unitError(QIL), ME) = unitError(QIL) .

  eq setName(mod nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS endm, ME')
    = mod ME' is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setName(fmod nullHeader is IL sorts SS . SSDS OPDS MAS EqS endfm, ME')
    = fmod ME' is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setName(fth nullHeader is IL sorts SS . SSDS OPDS MAS EqS endfth, MN)
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setName(th nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MN)
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setName(
       omod nullHeader is
         IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS
       endom,
       ME')
    = omod ME' is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setName(
       oth nullHeader is
         IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
       MN)
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .
  eq setName(smod nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, ME')
    = smod ME' is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm .
  eq setName(sth nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth, MN)
    = sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth .
  eq setName(noModule, ME) = noModule .
  eq setName(unitError(QIL), ME) = unitError(QIL) .

  eq setStratDcls(unitError(QIL), StratDcls?) = unitError(QIL) .
----  eq setStratDcls(U?, ruleError(QIL) StratDcls?) = unitError(QIL) .
  eq setStratDcls(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, StratDcls)
    = if StratDcls == none
      then mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls none endsm
      fi .
  eq setStratDcls(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, StratDcls)
    = if StratDcls == none
      then th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      else sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls none endsth
      fi .
  eq setStratDcls(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, StratDcls)
    = if StratDcls == none
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else smod H is IL sorts SS . SSDS OPDS MAS EqS none StratDcls none endsm
      fi .
  eq setStratDcls(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, StratDcls)
    = if StratDcls == none
      then fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth
      else sth MN is IL sorts SS . SSDS OPDS MAS EqS none StratDcls none endsth
      fi .
  eq setStratDcls(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, StratDcls)
    = if StratDcls == none
      then omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom
      else unitError(header2QidList(H) 'not 'a 'strat 'module)
      fi .
  eq setStratDcls(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, StratDcls)
    = if StratDcls == none
      then oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth
      else unitError(header2QidList(MN) 'not 'a 'strat 'module)
      fi .
  eq setStratDcls(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, StratDcls')
    = smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls' StratDefs endsm .
  eq setStratDcls(sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth, StratDcls')
    = sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls' StratDefs endsth .

  eq setStratDefs(unitError(QIL), StratDefs?) = unitError(QIL) .
  eq setStratDefs(U?, stratDefError(QIL) StratDefs?) = unitError(QIL) .
  eq setStratDefs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, StratDefs)
    = if StratDefs == none
      then mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else smod H is IL sorts SS . SSDS OPDS MAS EqS RlS none StratDefs endsm
      fi .
  eq setStratDefs(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, StratDefs)
    = if StratDefs == none
      then th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      else sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS none StratDefs endsth
      fi .
  eq setStratDefs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, StratDefs)
    = if StratDefs == none
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else smod H is IL sorts SS . SSDS OPDS MAS EqS none none StratDefs endsm
      fi .
  eq setStratDefs(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, StratDefs)
    = if StratDefs == none
      then fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth
      else sth MN is IL sorts SS . SSDS OPDS MAS EqS none none StratDefs endsth
      fi .
  eq setStratDefs(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, StratDefs)
    = if StratDefs == none
      then omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom
      else unitError(header2QidList(H) 'not 'a 'strat 'module)
      fi .
  eq setStratDefs(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, StratDefs)
    = if StratDefs == none
      then oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth
      else unitError(header2QidList(MN) 'not 'a 'strat 'module)
      fi .
  eq setStratDefs(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm, StratDefs')
    = smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs' endsm .
  eq setStratDefs(sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth, StratDefs')
    = sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs' endsth .

*** Add functions

  eq addSorts(SS, U) = setSorts(U, (SS ; getSorts(U))) .
  eq addSorts(SS, unitError(QIL)) = unitError(QIL) .

  eq addSubsorts(SSDS, U) = setSubsorts(U, (SSDS getSubsorts(U))) .
  eq addSubsorts(subsortDeclError(QIL), U) = unitError(QIL) .
  eq addSubsorts(SSDS, unitError(QIL)) = unitError(QIL) .

  eq addOps(OPDS, U) = setOps(U, (OPDS getOps(U))) .
  eq addOps(OPDS?, unitError(QIL)) = unitError(QIL) .
  eq addOps(OPDS?, U) = U [owise] .

  eq addMbs(MAS, U) = setMbs(U, (MAS getMbs(U))) .
  eq addMbs(MAS, unitError(QIL)) = unitError(QIL) .
  eq addEqs(EqS, U) = setEqs(U, (EqS getEqs(U))) .
  eq addEqs(EqS, unitError(QIL)) = unitError(QIL) .
  eq addRls(RlS, U) = setRls(U, (RlS getRls(U))) .
  eq addRls(RlS, unitError(QIL)) = unitError(QIL) .
  eq addRls(ruleError(QIL), U) = unitError(QIL) .
  eq addImports(IL, U) = setImports(U, (getImports(U) IL)) .
  eq addImports(IL, unitError(QIL)) = unitError(QIL) .
  eq addClasses(CDS, U) = setClasses(U, (getClasses(U) CDS)) .
  eq addClasses(CDS, unitError(QIL)) = unitError(QIL) .
  eq addSubclasses(SCDS, U) = setSubclasses(U, (getSubclasses(U) SCDS)) .
  eq addSubclasses(SCDS, unitError(QIL)) = unitError(QIL) .
  eq addMsgs(MDS, U) = setMsgs(U, getMsgs(U) MDS) .
  eq addMsgs(MDS, unitError(QIL)) = unitError(QIL) .
  eq addStratDefs(StratDefs, U) = setStratDefs(U, StratDefs getStratDefs(U)) .
  eq addStratDcls(StratDcls, U) = setStratDcls(U, StratDcls getStratDcls(U)) .

*** Creation of empty units

  eq emptyFModule(ME)
    = fmod header2Qid(ME) is nil sorts none . none none none none endfm .
  eq emptyFModule
    = fmod nullHeader is nil sorts none . none none none none endfm .
  eq emptySModule
    = mod nullHeader is nil sorts none . none none none none none endm .
  eq emptyOModule
    = omod nullHeader is
        nil sorts none . none none none none none none none none
      endom .
  eq emptyStratModule
    = smod nullHeader is nil sorts none . none none none none none none none endsm .
  eq emptyFTheory
    = fth nullHeader is nil sorts none . none none none none endfth .
  eq emptySTheory
    = th nullHeader is nil sorts none . none none none none none endth .
  eq emptyOTheory
    = oth nullHeader is
         nil sorts none . none none none none none none none none
      endoth .
  eq emptyStratTheory
    = sth nullHeader is nil sorts none . none none none none none none none endsth .

*** \texttt{empty} returns an empty unit of the same type of the one given as
*** argument.

  eq empty(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = (mod H is nil sorts none . none none none none none endm) .
  eq empty(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth)
    = (th MN is nil sorts none . none none none none none endth) .
  eq empty(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = (fmod H is nil sorts none . none none none none endfm) .
  eq empty(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth)
    = (fth MN is nil sorts none . none none none none endfth) .
  eq empty(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = (omod H is
         nil sorts none . none none none none none none none none
       endom) .
  eq empty(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = (oth MN is
         nil sorts none . none none none none none none none none
       endoth) .
  eq empty(smod H is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsm)
   = (smod H is nil sorts none . none none none none none none none endsm) .
  eq empty(sth MN is IL sorts SS . SSDS OPDS MAS EqS RlS StratDcls StratDefs endsth)
   = (sth MN is nil sorts none . none none none none none none none endsth) .

*** In the following \texttt{addDecls} function, the declarations of the unit
*** given as second argument are added to the unit given as first argument.

  eq addDecls(noModule, U) = U .
  eq addDecls(U, noModule) = U .
  eq addDecls(unitError(QIL), U) = unitError(QIL) .
  eq addDecls(U, unitError(QIL)) = unitError(QIL) .
  eq addDecls(U, U')
    = addImports(getImports(U'),
        addSorts(getSorts(U'),
          addSubsorts(getSubsorts(U'),
            addOps(getOps(U'),
              addMbs(getMbs(U'),
                addEqs(getEqs(U'),
                  (if U' :: FModule or U' :: FTheory
                   then U
                   else addRls(getRls(U'),
                          (if U' :: SModule or U' :: STheory
                           then U
                           else (if U' :: StratModule or U' :: StratTheory
                                 then addStratDefs(getStratDefs(U'),
                                        addStratDcls(getStratDcls(U'), U))
                                 else addClasses(getClasses(U'),
                                        addSubclasses(getSubclasses(U'),
                                          addMsgs(getMsgs(U'), U)))
                                fi)
                           fi))
                   fi)))))))
    [owise] .

  op removeNonExecs : Module -> Module .
  op removeNonExecs : MembAxSet -> MembAxSet .
  op removeNonExecs : EquationSet -> EquationSet .
  op removeNonExecs : RuleSet -> RuleSet .

  ceq removeNonExecs(M)
    = setRls(M'', removeNonExecs(getRls(M)))
    if M' := setMbs(M, removeNonExecs(getMbs(M)))
    /\ M'' := setEqs(M', removeNonExecs(getEqs(M))) .
  eq removeNonExecs(unitError(QIL)) = unitError(QIL) .

  eq removeNonExecs(mb T : S [nonexec AtS] . MbS) = removeNonExecs(MbS) .
  eq removeNonExecs(cmb T : S if Cd [nonexec AtS] . MbS) = removeNonExecs(MbS) .
  eq removeNonExecs(MbS) = MbS [owise] .

  eq removeNonExecs(eq T = T' [nonexec AtS] . EqS) = removeNonExecs(EqS) .
  eq removeNonExecs(ceq T = T' if Cd [nonexec AtS] . EqS) = removeNonExecs(EqS) .
  eq removeNonExecs(EqS) = EqS [owise] .

  eq removeNonExecs(rl T => T' [nonexec AtS] . RlS) = removeNonExecs(RlS) .
  eq removeNonExecs(crl T => T' if Cd [nonexec AtS] . RlS) = removeNonExecs(RlS) .
  eq removeNonExecs(RlS) = RlS [owise] .

  *** moreGeneralEqs  ******************************
  ---- An equation is more general than other if there is a substitution such that
  ---- the more general equation with such a substitution applied is equal to the
  ---- less general one.
  op moreGeneralEqs : Module -> Module .
  op moreGeneralRls : Module -> Module .
  op $moreGeneralEqs : Module Module EquationSet EquationSet -> Module .
  op $moreGeneralRls : Module Module RuleSet RuleSet -> Module .
  op $moreGeneral : Module Equation Equation -> Bool .
  op $moreGeneral : Module Rule Rule -> Bool .
  op $moreGeneral : Module Condition Condition Term Term -> Bool .

  eq moreGeneralEqs(M)
    = $moreGeneralEqs(
        M,
        addOps((op '@/\@ : '@@@ '@@@ -> '@@@ [assoc] .
                op '@--@ : 'Universal -> '@@@ [poly(1)] .
                op '@--@ : 'Universal 'Universal -> '@@@ [poly(1 2)] .),
               addSorts('@@@, M)),
        getEqs(M), getEqs(M)) .
  eq moreGeneralRls(M)
    = $moreGeneralRls(
        M,
        addOps((op '@/\@ : '@@@ '@@@ -> '@@@ [assoc] .
                op '@--@ : 'Universal -> '@@@ [poly(1)] .
                op '@--@ : 'Universal 'Universal -> '@@@ [poly(1 2)] .),
               addSorts('@@@, M)),
        getRls(M), getRls(M)) .

 ceq $moreGeneralEqs(M, M', Eq EqS, Eq Eq' EqS')
    = $moreGeneralEqs(M, M', EqS, Eq' EqS')
    if $moreGeneral(M', Eq', Eq) .
  eq $moreGeneralEqs(M, M', EqS, EqS') = setEqs(M, EqS') [owise] .

 ceq $moreGeneralRls(M, M', Rl RlS, Rl Rl' RlS')
    = $moreGeneralRls(M, M', RlS, Rl' RlS')
    if $moreGeneral(M', Rl', Rl) .
  eq $moreGeneralRls(M, M', RlS, RlS') = setRls(M, RlS') [owise] .

  eq $moreGeneral(M, Eq, Eq')
    = sameKind(M, leastSort(M, lhs(Eq)), leastSort(M, lhs(Eq')))
      and-then
      $moreGeneral(M, cond(Eq), cond(Eq'), '@--@[lhs(Eq), rhs(Eq)], '@--@[lhs(Eq'), rhs(Eq')]) .

  eq $moreGeneral(M, Rl, Rl')
    = sameKind(M, leastSort(M, lhs(Rl)), leastSort(M, lhs(Rl')))
      and-then
      $moreGeneral(M, cond(Rl), cond(Rl'), '@--@[lhs(Rl), rhs(Rl)], '@--@[lhs(Rl'), rhs(Rl')]) .

  eq $moreGeneral(M, T1 = T1' /\ Cond1, T2 = T2' /\ Cond2, T, T')
    = sameKind(M, leastSort(M, T1), leastSort(M, T2))
      and-then
      $moreGeneral(M, Cond1, Cond2, '@/\@['@--@[T1, T1'], T], '@/\@['@--@[T2, T2'], T']) .
  eq $moreGeneral(M, T1 := T1' /\ Cond1, T2 := T2' /\ Cond2, T, T')
    = sameKind(M, leastSort(M, T1), leastSort(M, T2))
      and-then
      $moreGeneral(M, Cond1, Cond2, '@/\@['@--@[T1, T1'], T], '@/\@['@--@[T2, T2'], T']) .
  eq $moreGeneral(M, T1 => T1' /\ Cond1, T2 => T2' /\ Cond2, T, T')
    = sameKind(M, leastSort(M, T1), leastSort(M, T2))
      and-then
      $moreGeneral(M, Cond1, Cond2, '@/\@['@--@[T1, T1'], T], '@/\@['@--@[T2, T2'], T']) .
  eq $moreGeneral(M, T1 : S /\ Cond1, T2 : S /\ Cond2, T, T')
    = $moreGeneral(M, Cond1, Cond2, '@/\@['@--@[T1], T], '@/\@['@--@[T2], T']) .

  eq $moreGeneral(M, nil, nil, T, T') = metaMatch(M, T, T', nil, 0) =/= noMatch .
  eq $moreGeneral(M, Cond1, Cond2, T, T') = false [owise] .

  op rmVariantAttrs : Module -> Module .
  op $rmVariants : EquationSet -> EquationSet .
  op $rmVariants : RuleSet -> RuleSet .
  op $rmVariants : MembAxSet -> MembAxSet .
  eq rmVariantAttrs(M) = setRls(setEqs(setMbs(M, $rmVariants(getMbs(M))), $rmVariants(getEqs(M))), $rmVariants(getRls(M))) .
  eq rmVariantAttrs(unitError(QIL)) = unitError(QIL) .

  eq $rmVariants(eq T = T' [variant AtS] . EqS) = (eq T = T' [variant AtS] .) $rmVariants(EqS) .
  eq $rmVariants(ceq T = T' if Cond [variant AtS] . EqS) = (ceq T = T' if Cond [variant AtS] .) $rmVariants(EqS) .
  eq $rmVariants(EqS) = EqS [owise] .

  eq $rmVariants(rl T => T' [variant AtS] . RlS) = (rl T => T' [variant AtS] .) $rmVariants(RlS) .
  eq $rmVariants(crl T => T' if Cond [variant AtS] . RlS) = (crl T => T' if Cond [variant AtS] .) $rmVariants(RlS) .
  eq $rmVariants(RlS) = RlS [owise] .

  eq $rmVariants(mb T : S [variant AtS] . MbS) = (mb T : S [variant AtS] .) $rmVariants(MbS) .
  eq $rmVariants(cmb T : S if Cond [variant AtS] . MbS) = (cmb T : S if Cond [variant AtS] .) $rmVariants(MbS) .
  eq $rmVariants(MbS) = MbS [owise] .
endfm

fmod FM-PARSE-STRATEGY is
---  including META-LEVEL + PRE-VARIANT .
  including META-LEVEL .
  including FM-UNIT .

  op STRAT-BUBBLES : -> FModule .
  op STRAT-GRAMMAR : -> FModule [memo] .

  eq STRAT-BUBBLES
    = (fmod 'GRAMMAR is
        including 'QID-LIST .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'stbubble : 'QidList -> '@StBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 's.t.)))] .
        none
        none
     endfm) .

  eq STRAT-GRAMMAR = addImports((including 'FULL-MAUDE-SIGN .), STRAT-BUBBLES) .

----  op metaParseStrategy : Module QidSet QidList ~> Strategy? .
----  op metaPrettyPrintStrategy : Module Strategy PrintOptionSet ~> QidList .

endfm

-------------------------------------------------------------------------------

fmod AX-COHERENCE-COMPLETION is
  inc FM-UNIT .
----  inc FM-MODULE-HANDLING * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) .

  vars V W : Variable .
  var  C : Constant .
  var  FM : FModule .
  var  SM : SModule .
  var  M : Module .
  var  N : Nat .
  vars T T' T'' LHS RHS : Term .
  vars Subst Subst' : Substitution .
  var  F : Qid .
  var  TL : TermList .
  vars AtS AtS' : AttrSet .
----  var  VFS : VariantFourSet .
  vars Tp Tp' Tp'' : Type .
  var  TpL : TypeList .
  var  Rl : Rule .
  var  RlS : RuleSet .
  var  Eq : Equation .
  var  EqS : EquationSet .
  var  ODS : OpDeclSet .
  var  Cond : Condition .
  var  QIL : QidList .

  ------------------------------------------------------------------------------
  ---- coherence completion
  ------------------------------------------------------------------------------

  op axCohComplete : SModule -> SModule .
  op axCohComplete : SModule OpDeclSet RuleSet -> RuleSet .
  op axCohCompleteAux : SModule OpDeclSet RuleSet -> RuleSet .
  op axCohComplete : SModule Type AttrSet Rule -> RuleSet .
  op axCohComplete : SModule OpDeclSet EquationSet -> EquationSet .
  op axCohCompleteAux : SModule OpDeclSet EquationSet -> EquationSet .
  op axCohComplete : SModule Type AttrSet Equation -> EquationSet .

  eq axCohComplete(FM)
    = moreGeneralEqs(setEqs(FM, axCohComplete(FM, getOps(FM), getEqs(FM)))) .
  eq axCohComplete(SM)
    = moreGeneralEqs(
        moreGeneralRls(
          setRls(
            setEqs(SM,
              axCohComplete(SM, getOps(SM), getEqs(SM))),
            axCohComplete(SM, getOps(SM), getRls(SM)))))
    [owise] .
  eq axCohComplete(unitError(QIL)) = unitError(QIL) .

  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, rl F[TL] => RHS [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc AtS, rl F[TL] => RHS [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, RlS)
    if sameKindAll(M, Tp, eLeastSort(M, TL)) .
  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, crl F[TL] => RHS if Cond [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc AtS, crl F[TL] => RHS if Cond [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, RlS)
    if sameKindAll(M, Tp, eLeastSort(M, TL)) .
  eq axCohComplete(M, ODS, RlS) = axCohCompleteAux(M, ODS, RlS) [owise] .

  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, rl LHS => RHS [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc id(T) AtS, rl F[LHS] => RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, crl LHS => RHS if Cond [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc id(T) AtS, crl F[LHS] => RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, rl LHS => RHS [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc left-id(T) AtS, rl F[LHS] => RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, crl LHS => RHS if Cond [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc left-id(T) AtS, crl F[LHS] => RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, rl LHS => RHS [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc right-id(T) AtS, rl F[LHS] => RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, crl LHS => RHS if Cond [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc right-id(T) AtS, crl F[LHS] => RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  eq axCohCompleteAux(M, ODS, RlS) = RlS [owise] .

  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, eq F[TL] = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc AtS, eq F[TL] = RHS [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, EqS)
    if sameKindAll(M, Tp, eLeastSort(M, TL)) .
  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, ceq F[TL] = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc AtS, ceq F[TL] = RHS if Cond [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, EqS)
    if sameKindAll(M, Tp, eLeastSort(M, TL)) .
  eq axCohComplete(M, ODS, EqS) = axCohCompleteAux(M, ODS, EqS) [owise] .

  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, eq LHS = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc id(T) AtS, eq F[LHS] = RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, ceq LHS = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc id(T) AtS, ceq F[LHS] = RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, eq LHS = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc left-id(T) AtS, eq F[LHS] = RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, ceq LHS = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc left-id(T) AtS, ceq F[LHS] = RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, eq LHS = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc right-id(T) AtS, eq F[LHS] = RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, ceq LHS = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc right-id(T) AtS, ceq F[LHS] = RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  eq axCohCompleteAux(M, ODS, EqS) = EqS [owise] .

  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, eq F[TL] = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc AtS, eq F[TL] = RHS [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, EqS)
    if sameKind(M, Tp, Tp')
    /\ sameKind(M, Tp', Tp'')
    /\ sameKindAll(M, Tp, eLeastSort(M, TL)) .
  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, ceq F[TL] = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc AtS, ceq F[TL] = RHS if Cond [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, EqS)
    if sameKind(M, Tp, Tp')
    /\ sameKind(M, Tp', Tp'')
    /\ sameKindAll(M, Tp, eLeastSort(M, TL)) .
  eq axCohComplete(M, ODS, eq LHS = RHS [AtS] . EqS)
    = eq LHS = RHS [AtS] . axCohComplete(M, ODS, EqS)
    [owise] .
  eq axCohComplete(M, ODS, ceq LHS = RHS if Cond [AtS] . EqS)
    = ceq LHS = RHS if Cond [AtS] . axCohComplete(M, ODS, EqS)
    [owise] .
  eq axCohComplete(M, ODS, (none).EquationSet) = none .

  ---- Given f(t1,...,tn) -> r if C
  ---- if f AC add f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[TL] => RHS [AtS'] .)
      (rl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
    [owise] .
  eq axCohComplete(M, Tp, assoc comm AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[TL] => RHS if Cond [AtS'] .)
      (crl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
    [owise] .
  ---- if f ACU replace by f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) [AtS'] .) .
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) .
  ---- if f AU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
    if not comm in AtS .
  ceq axCohComplete(M, Tp, assoc id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
    if not comm in AtS .
  ---- if f ALU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) [AtS'] .)  .
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) if Cond [AtS'] .)  .
  ---- if f ARU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (rl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .) .
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (crl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) .
  ---- if f A add f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----            f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  ----            f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[TL] => RHS [AtS'] .)
      (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) [AtS'] .)
      (rl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
    if not comm in AtS
    [owise] .
  ceq axCohComplete(M, Tp, assoc AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[TL] => RHS if Cond [AtS'] .)
      (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) if Cond [AtS'] .)
      (crl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         => getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
    if not comm in AtS
    [owise] .

  ---- Given f(t1,...,tn) -> r if C
  ---- if f AC add f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[TL] = RHS [AtS'] .)
      (eq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
    [owise] .
  eq axCohComplete(M, Tp, assoc comm AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[TL] = RHS if Cond [AtS'] .)
      (ceq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
    [owise] .
  ---- if f ACU replace by f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) [AtS'] .) .
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) .
  ---- if f AU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
    if not comm in AtS .
  ceq axCohComplete(M, Tp, assoc id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
    if not comm in AtS .
  ---- if f ALU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) [AtS'] .)  .
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) if Cond [AtS'] .)  .
  ---- if f ARU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (eq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .) .
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (ceq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) .
  ---- if f A add f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----            f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  ----            f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[TL] = RHS [AtS'] .)
      (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) [AtS'] .)
      (eq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
    if not comm in AtS
    [owise] .
  ceq axCohComplete(M, Tp, assoc AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[TL] = RHS if Cond [AtS'] .)
      (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL]
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) if Cond [AtS'] .)
      (ceq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))]
         = getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
    if not comm in AtS
    [owise] .
endfm

*** To parse some input using the built-in function \texttt{metaParse}, we
*** need to give the metarepresentation of the signature in which the input is
*** going to be parsed.

*** But we do not need to give the complete metarepresentation of such a
*** module. In modules including \texttt{META-LEVEL} it is possible to define
*** terms of sort \texttt{Module} that import built-in modules or any module
*** introduced at the ``object level'' of Core Maude. In this way, it is
*** possible to get the equivalent effect of having the explicit
*** metarepresentation of a module by declaring a constant and adding an
*** equation identifying such a constant with the metarepresentation of an
*** extended module that imports the original module at the object level.

*** The declaration of constructors for bubble sorts at the object level is
*** not supported in the current version of Core Maude. The \texttt{special}
*** attributes linking the constructors for the bubble sorts to the built-in
*** ones are only supported at the metalevel, that is, the declarations of the
*** constructor operators for bubble sorts have to be given in the
*** metarepresentation of a module.

*** To allow the greatest generality and flexibility in future extensions of
*** Full Maude, we have declared its signature as a module
*** \texttt{FULL-MAUDE-SIGN}. Then, in the following module
*** \texttt{META-FULL-MAUDE-SIGN} we declare a constant \texttt{GRAMMAR} of
*** sort \texttt{FModule}, and we give an equation identifying such constant
*** with the metarepresentation of a module \texttt{GRAMMAR} in which there is
*** a declaration importing \texttt{FULL-MAUDE-SIGN}. Declarations for the
*** constructors of the bubble sorts are also included in this module. Note
*** that the bubble sorts \texttt{@Token@}, \texttt{@Bubble@},
*** \texttt{@SortToken@}, and \texttt{@NeTokenList@} are declared in the
*** module \texttt{SIGN\&VIEW-EXPR}, which is imported by
*** \texttt{FULL-MAUDE-SIGN}. These sorts are used in the declarations
*** describing the syntax of the system.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod META-FULL-MAUDE-SIGN is
---  including META-LEVEL + PRE-VARIANT .
  including META-LEVEL .
  including FM-UNIT .

  op BUBBLES : -> FModule .
  op GRAMMAR : -> FModule [memo] .

  eq BUBBLES
    = (fmod 'GRAMMAR is
        including 'QID-LIST .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'viewToken : 'Qid -> '@ViewToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'sortToken : 'Qid -> '@SortToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '`[ '`] '< 'to '`, '. '`( '`) '`{ '`} ': '|
                                  'ditto 'precedence 'prec 'gather
                                  'assoc 'associative 'comm 'commutative
                                  'ctor 'constructor 'id: 'strat 'strategy
                                  'poly 'memo 'memoization 'iter 'frozen
                                  'config 'object 'msg 'metadata 'nonexec 'variant)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '. ':)))] .
        op 'bubble : 'QidList -> '@Bubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'eq 'ceq 'rl 'crl 'mb 'cmb 'sd 'csd
                                  'var 'vars 'strat 'endm
                                  'endfm 'endsm 'sorts 'subsort 'subsorts
                                  'subclass 'subclasses 'op 'ops
                                  'protecting 'pr 'including 'inc 'extending
                                  'ctor 'assoc 'comm '==)))] .
        op 'ububble : 'QidList -> '@UBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'stbubble : 'QidList -> '@StBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'using)))] .
        op 'eqlbubble : 'QidList -> '@EqLBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '=)))] .
        op 'rllbubble : 'QidList -> '@RlLBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '=>)))] .
        op 'sdlbubble : 'QidList -> '@SdLBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, ':=)))] .
        op 'rcbubble : 'QidList -> '@RCBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'if)))] .
        op 'rbubble : 'QidList -> '@RBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '.)))] .
        none
        none
     endfm) .

  eq GRAMMAR = addImports((including 'FULL-MAUDE-SIGN .), BUBBLES) .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------


*** The \texttt{GRAMMAR} module will be used in calls to the \texttt{metaParse}
*** function in order to get the input parsed in this signature. Note that
*** this module is not the data type in which we shall represent the inputs.
*** From the call to \texttt{metaParse} we shall get a term representing the
*** parse tree of the input. This term will then be transformed into terms of
*** other appropriate data types if necessary.

*** Future extensions to Full Maude will require extending the signature as
*** well. The addition of new commands, new module expressions, or additions
*** of any other kind will require adding new declarations to the present Full
*** Maude signature and defining the corresponding extensions to the data
*** types and functions to deal with the new cases introduced by the
*** extensions.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Abstract Data Type \texttt{View}
***

*** In this section we present the data type \texttt{View} for views.
*** Basically, the data elements of sort \texttt{View} are composed by the
*** name of the view, the names of the source and target units, and a set of
*** maps representing the maps asserting how the given target unit is claimed
*** to satisfy the source theory (see Section~\ref{Views}).

*** Internally, renaming maps are considered to be a particular case of view
*** maps. The sort \texttt{ViewMap} is declared as a supersort of
*** \texttt{Map}. The only kind of maps in sort \texttt{ViewMap} not in sort
*** \texttt{Map} are maps of operators going to derived operators. We start
*** introducing the declarations for renaming maps and sTS of renaming maps
*** in Section~\ref{renaming-maps}, we then introduce view maps and sTS of
*** view maps in Section~\ref{view-maps}, and finally we introduce the sort
*** \texttt{View}, its constructor, and some operations on it in
*** Section~\ref{viewADT}.

***
*** View Maps
***

*** In addition to the maps of sort \texttt{Renaming},
*** in views there can also be maps from operators to derived
*** operators, that is, terms with variables (see Section~\ref{Views}). Maps
*** of this kind are given with the constructor \texttt{op_to`term_}, which, in
*** addition to the source and target terms, takes the set of variable
*** declarations for the variables used in the map. The source term must be of
*** the form $\texttt{F(X}_1\texttt{,}\ldots,\texttt{X}_n\texttt{)}$, where
*** \texttt{F} is an operator name declared with $n$ arguments of sorts in the
*** connected components of the variables $\texttt{X}_1\ldots\texttt{X}_n$,
*** respectively. We will see in Section~\ref{view-processing} how in the
*** initial processing of a view the variables declared in it are associated
*** to each of the maps in which they are used.


***
*** Views
***

*** The \texttt{View} sort is introduced in the following module
*** \texttt{VIEW}.  In addition to the constructor for views (\texttt{view}),
*** selector functions are added for each of the components of a
*** view (\texttt{name}, \texttt{source}, \texttt{target}, and
*** \texttt{mapSet}), and a constant \texttt{emptyView}, which is identified
*** in an equation with the empty view, is defined.

*** Although the declaration of the constructor for views includes an argument
*** for the list of parameters, parameterized views are not handled yet, so at
*** present this argument must be set to the \texttt{nil}.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod EXT-RENAMING is
  pr META-MODULE .

  op op_to term_ : Term Term -> Renaming .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod VIEW is
  ex META-VIEW .
  pr FM-VIEW-EXPR .
  inc FM-FMAP .

  *** mappings
  op class_to_. : Sort Sort -> SortMapping .
  op attr_._to_. : Qid Sort Qid -> OpMapping .
  op msg_to_. : Qid Qid -> OpMapping .
  op msg_:_->_to_. : Qid TypeList Sort Qid -> OpMapping .

  op strat_to`expr_. : Term Term -> StratMapping . ---- PreMapping

  subsort ViewExpression < Header .

  op null : -> View [ctor] .
  op viewError : QidList -> [View] [ctor format (r o)] .

  eq VE{(nil).ParameterDeclList} = VE .

  vars A A' F F' Q Q' : Qid .
  var QIL : QidList .
  var VH : Header .
  var VE : ViewExpression .
  vars PDL PDL' : ParameterDeclList .
  vars ME ME' ME'' : ModuleExpression .
  vars SMS SMS' : SortMappingSet .
  vars OMS OMS' : OpMappingSet .
  vars TMS TMS' : StratMappingSet .
  vars S S' C : Sort .
  var  Ty : Type .
  var  TyL : TypeList .
  vars T T' : Term .
  var  CS : CallStrategy .
  var  Strat : Strategy .

  op maps2rens : SortMappingSet -> RenamingSet .
  op maps2rens : OpMappingSet -> RenamingSet .
  op maps2rens : StratMappingSet -> RenamingSet .

  eq maps2rens(sort S to S' . SMS) = sort S to S', maps2rens(SMS) .
  eq maps2rens(class S to S' . SMS) = class S to S', maps2rens(SMS) .
  eq maps2rens((none).SortMappingSet) = none .

  eq maps2rens(op F to F' . OMS) = op F to F' [none], maps2rens(OMS) .
  eq maps2rens(op F : TyL -> Ty to F' . OMS) = op F : TyL -> Ty to F' [none], maps2rens(OMS) .
  eq maps2rens(op T to term T' . OMS) = op T to term T', maps2rens(OMS) .
  eq maps2rens(msg F to F' . OMS) = msg F to F' [none], maps2rens(OMS) .
  eq maps2rens(msg F : TyL -> Ty to F' . OMS) = msg F : TyL -> Ty to F' [none], maps2rens(OMS) .
  eq maps2rens(attr A . C to A' . OMS) = attr A . C to A', maps2rens(OMS) .
  eq maps2rens((none).OpMappingSet) = none .

  eq maps2rens(strat F to F' . TMS) = strat F to F', maps2rens(TMS) .
  eq maps2rens(strat F : TyL @ Ty to F' . TMS) = strat F : TyL @ Ty to F', maps2rens(TMS) .
  eq maps2rens(strat CS to expr Strat . TMS) = strat CS to expr Strat, maps2rens(TMS) .
  eq maps2rens((none).StratMappingSet) = none .

*** projection functions
----  op getName : View -> Qid .
----  eq getName(view VE from ME to ME' is SMS OMS TMS endv) = VE [owise] .
----  eq getName(view VE{PDL} from ME to ME' is SMS OMS TMS endv) = VE .

  op getPars : [View] -> ParameterDeclList .
  eq getPars(view VE from ME to ME' is SMS OMS TMS endv) = nil [owise] .
  eq getPars(view VE{PDL} from ME to ME' is SMS OMS TMS endv) = PDL .
  eq getPars(viewError(QIL)) = nil .

  eq getFrom(view VH from ME to ME' is SMS OMS TMS endv) = ME .
  eq getTo(view VH from ME to ME' is SMS OMS TMS endv) = ME' .
  eq getSortMappings(view VH from ME to ME' is SMS OMS TMS endv) = SMS .
  eq getOpMappings(view VH from ME to ME' is SMS OMS TMS endv) = OMS .

*** injection functions
  op setName : View Qid -> View .
  eq setName(view Q from ME to ME' is SMS OMS TMS endv, Q')
    = view Q' from ME to ME' is SMS OMS TMS endv .
  eq setName(view Q{PDL} from ME to ME' is SMS OMS TMS endv, VH) = view VH{PDL} from ME to ME' is SMS OMS TMS endv .
  eq setName(viewError(QIL), VE) = viewError(QIL) .

  op setPars : [View] ParameterDeclList -> [View] .
  eq setPars(view VH from ME to ME' is SMS OMS TMS endv, PDL)
    = view VH{PDL} from ME to ME' is SMS OMS TMS endv [owise] .
  eq setPars(view VH{PDL} from ME to ME' is SMS OMS TMS endv, PDL') = view VH{PDL'} from ME to ME' is SMS OMS TMS endv .
  eq setPars(viewError(QIL), PDL) = viewError(QIL) .

  op setFrom : View ModuleExpression -> View .
  eq setFrom(view VH from ME to ME' is SMS OMS TMS endv, ME'')
    = view VH from ME'' to ME' is SMS OMS TMS endv .
  eq setFrom(viewError(QIL), ME) = viewError(QIL) .

  op setTo : View ModuleExpression -> View .
  eq setTo(view VH from ME to ME' is SMS OMS TMS endv, ME'')
    = view VH from ME to ME'' is SMS OMS TMS endv .
  eq setTo(viewError(QIL), ME) = viewError(QIL) .

  op setSortMappings : View SortMappingSet -> View .
  eq setSortMappings(view VH from ME to ME' is SMS OMS TMS endv, SMS')
    = view VH from ME to ME' is SMS' OMS TMS endv .
  eq setSortMappings(viewError(QIL), SMS') = viewError(QIL) .

  op setOpMappings : View OpMappingSet -> View .
  eq setOpMappings(view VH from ME to ME' is SMS OMS TMS endv, OMS')
    = view VH from ME to ME' is SMS OMS' TMS endv .
  eq setOpMappings(viewError(QIL), OMS') = viewError(QIL) .

  op emptyView : Qid ModuleExpression ModuleExpression -> View .
  eq emptyView(VH, ME, ME') = view VH from ME to ME' is none none none endv .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Abstract Data Type \texttt{Database}
***

*** In this section we present the data type \texttt{Database}, which will be
*** used to store information about the units and views in the system. Before
*** discussing this data type in Section~\ref{databaseADT}, we present the
*** predefined units added in Full Maude to those already available in Core
*** Maude.

***
*** Non-Built-In Predefined Modules
***

*** As we shall see in the following section, except for the
*** \texttt{LOOP-MODE} module, all the predefined modules that are available
*** in Core Maude are also available in Full Maude. In addition to these Core
*** Maude predefined modules, in Full Maude there are some additional
*** predefined units. In the present system, the only units with which the
*** database is initialized are the functional theory \texttt{TRIV}, the
*** module \texttt{CONFIGURATION}, and the module \texttt{UP}, which will be
*** used to evaluate the \texttt{up} functions. We shall see in
*** Section~\ref{main-module} how new predefined modules can be added to the
*** initial database.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod PREDEF-UNITS is
  pr FM-UNIT .

*** The following module \texttt{UP} contains the necessary declarations to
*** be able to parse the \texttt{up} functions presented in
*** Section~\ref{structured-specifications}. We shall see in
*** Section~\ref{evaluation} how a declaration importing the following module
*** \texttt{UP} is added to all the modules importing the predefined module
*** \texttt{META-LEVEL}. With this declaration, it is possible to parse the
*** \texttt{up} commands in the bubbles of such modules or in commands being
*** evaluated in such modules. We shall see in Section~\ref{bubble-parsing}
*** how these commands are then evaluated.

  op #UP# : -> FModule [memo] .
  eq #UP#
    = (fmod '#UP# is
        including 'QID-LIST .
        including 'FM-MOD-EXPR .
        sorts none .
        none
        op 'upTerm : '@ModExp@ '@Bubble@ -> 'Term [none] .
        op 'upModule : '@ModExp@ -> 'Module [none] .
        op '`[_`] : '@Token@ -> 'Module [none] .
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'viewToken : 'Qid -> '@ViewToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'sortToken : 'Qid -> '@SortToken@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '`[ '`] '< 'to '`, '. '`( '`) '`{ '`} ':
                                  'ditto 'precedence 'prec 'gather
                                  'assoc 'associative 'comm 'commutative
                                  'ctor 'constructor 'id: 'strat 'strategy
                                  'poly 'memo 'memoization 'iter 'frozen
                                  'config 'object 'msg 'metadata 'nonexec 'variant)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '. ':)))] .
        op 'bubble : 'QidList -> '@Bubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'eq 'ceq 'rl 'crl 'mb 'cmb 'sd 'csd
                                  'var 'vars 'strat 'endm
                                  'endfm 'endsm 'sorts 'subsort 'subsorts
                                  'subclass 'subclasses 'op 'ops
                                  'protecting 'pr 'including 'inc 'extending
                                  'ctor 'assoc 'comm '==)))] .
        op 'ububble : 'QidList -> '@UBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'stbubble : 'QidList -> '@StBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'using)))] .
        op 'eqlbubble : 'QidList -> '@EqLBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '=)))] .
        op 'rllbubble : 'QidList -> '@RlLBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '=>)))] .
        op 'sdlbubble : 'QidList -> '@SdLBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, ':=)))] .
        op 'rcbubble : 'QidList -> '@RCBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'if)))] .
        op 'rbubble : 'QidList -> '@RBubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '.)))] .
        none
        none
     endfm) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** 7 The Evaluation of Views
***

*** Before being entered into the database, besides containing bubbles, views
*** have a somewhat different structure from that of the views given in
*** Section~\ref{viewADT}. We introduce in the following module a sort
*** \texttt{PreView} with constructor \texttt{view}, which is declared as the
*** constructor for views of sort \texttt{View}, but with an additional
*** argument, namely, a set of variable declarations to hold the declarations
*** of variables in the view. During the processing of views (see
*** Section~\ref{view-processing}), which takes place once the parsing process
*** has concluded, these variables are associated with the corresponding maps
*** where they are used, generating a term of sort \texttt{View}.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod PRE-VIEW is
  pr VIEW .

  sort PreView .
  op preview_from_to_is____endpv : Header ModuleExpression ModuleExpression
       VariableSet SortMappingSet OpMappingSet StratMappingSet -> PreView
       [ctor format (nir! o r! o r! o r! o o o o r! o)] .
  op null : -> PreView .

  op getName : PreView -> ViewExpression .
  op getPars : PreView -> ParameterDeclList .
  op getFrom : PreView -> ModuleExpression .
  op getTo : PreView -> ModuleExpression .
  op getVars : PreView -> VariableSet .
  op getSortMappings : PreView -> SortMappingSet .
  op getOpMappings : PreView -> OpMappingSet .
  op getStratMappings : PreView -> StratMappingSet .

  var  QI : Qid .
  vars ME ME' : ModuleExpression .
  var  VE : ViewExpression .
  var  VH : Header .
  vars PDL PDL' : ParameterDeclList .
  vars VDS VDS' : VariableSet .
  vars SMS SMS' : SortMappingSet .
  vars OMS OMS' : OpMappingSet .
  vars TMS TMS' : StratMappingSet .

  eq getName(preview VE from ME to ME' is VDS SMS OMS TMS endpv) = VE .
  eq getName(preview VE{PDL} from ME to ME' is VDS SMS OMS TMS endpv) = VE .
  eq getPars(preview VE from ME to ME' is VDS SMS OMS TMS endpv) = nil .
  eq getPars(preview VE{PDL} from ME to ME' is VDS SMS OMS TMS endpv) = PDL .
  eq getFrom(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = ME .
  eq getTo(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = ME' .
  eq getVars(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = VDS .
  eq getSortMappings(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = SMS .
  eq getOpMappings(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = OMS .
  eq getStratMappings(preview VH from ME to ME' is VDS SMS OMS TMS endpv) = TMS .

*** The following functions can be used to add new declarations to the set of
*** declarations already in a preview.

  op addMaps : SortMappingSet PreView -> PreView .
  op addMaps : OpMappingSet PreView -> PreView .
  op addMaps : StratMappingSet PreView -> PreView .
  op addVars : VariableSet PreView -> PreView .

  eq addMaps(SMS, preview VH from ME to ME' is VDS SMS' OMS TMS endpv)
    = preview VH from ME to ME' is VDS (SMS SMS') OMS TMS endpv .
  eq addMaps(OMS, preview VH from ME to ME' is VDS SMS OMS' TMS endpv)
    = preview VH from ME to ME' is VDS SMS (OMS OMS') TMS endpv .
  eq addMaps(TMS, preview VH from ME to ME' is VDS SMS OMS TMS' endpv)
    = preview VH from ME to ME' is VDS SMS OMS (TMS TMS') endpv .

  eq addVars(VDS, preview VH from ME to ME' is VDS' SMS OMS TMS endpv)
    = preview VH from ME to ME' is (VDS ; VDS') SMS OMS TMS endpv .

  op setPars : PreView ParameterDeclList -> PreView .
  eq setPars(preview VE from ME to ME' is VDS SMS OMS TMS endpv, PDL)
    = preview VE{PDL} from ME to ME' is VDS SMS OMS TMS endpv
    [owise] .
  eq setPars(preview VE{PDL} from ME to ME' is VDS SMS OMS TMS endpv, PDL')
    = preview VE{PDL'} from ME to ME' is VDS SMS OMS TMS endpv .

  op emptyPreView : Qid ModuleExpression ModuleExpression -> PreView .
  eq emptyPreView(QI, ME, ME')
    = preview QI from ME to ME' is none none none none endpv .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Database
***

*** In order to be able to refer to modules by name, which is extremely useful
*** for module definition purposes at the user level, the evaluation of module
*** expressions takes place in the context of a database, in which we keep
*** information about the modules already introduced in the system, and also
*** about those modules generated internally.  This information is stored as
*** a set of elements of sort \texttt{ModuleInfo} and \texttt{ViewInfo}, in
*** which we hold, respectively, the information concerning units and views.
*** For each unit we save:
*** \begin{itemize}
*** \item Its original form, as introduced by the user, or, in case of an
***       internally generated unit, as generated from the original form of
***       some other unit.
*** \item Its internal representation, in which variables have been renamed
***       to avoid collisions with the names of variables in other units in
***       the same hierarchy.  In the case of object-oriented units, we store
***       its equivalent system module, that is, the result of transforming
***       it into a system module.
*** \item Its signature, which is given as a functional module of sort
***       \texttt{FModule} with no axioms, ready to be used in calls to
***       \texttt{metaParse}. There can only be importation declarations
***       including built-in modules in this module. These are the only
***       inclusions handled by the Core Maude engine.
*** \item Its flattened version, for which, as for signatures, only the
***       importation of built-in modules is left unevaluated.
*** \end{itemize}
*** For each view we keep its name and the view itself.

*** As a simple mechanism to keep the database consistent, for each unit we
*** maintain the list of names of all the units and views ``depending'' on it.
*** Similarly, for each view we maintain the list of names of all the units
*** ``depending'' on it. The idea is that if a unit or view is redefined or
*** removed, all those units and/or views depending on it will also be
*** removed. This dependency does not only mean direct importation. For
*** example, the module resulting from the renaming of some module also
*** depends on the module being renamed; the instantiation of a parameterized
*** module also depends on the parameterized module and on all the views used
*** in its instantiation; a view depends on its source and target units, etc.
*** This dependency is transitive: if a module, theory, or view has to be
*** removed, all the units and/or views depending on them will be removed as
*** well. The dependencies derived from the module expressions themselves are
*** established by the function \texttt{setUpModExpDeps}. The function
*** \texttt{setUpModuleDeps} calls \texttt{setUpModExpDeps},
*** and then \texttt{setUpImportSetDeps} to add the \emph{back
*** references} in the modules being imported. The function
*** \texttt{setUpViewDeps} sTS up the back references for the views
*** being introduced.

*** In addition to this set of information cells for units and views, we also
*** keep lists with the names of all the units and views in the database, and
*** a list of quoted identifiers in which we store the messages generated
*** during the process of treatment of the inputs in order to simplify the
*** communication with the read-eval-print loop process.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

view ModuleName from TRIV to MOD-NAME is
  sort Elt to ModuleName .
endv

view ViewExpression from TRIV to FM-VIEW-EXPR is
  sort Elt to ViewExpression .
endv

view ParameterDecl from TRIV to META-MODULE is
  sort Elt to ParameterDecl .
endv

fmod INFO is
  pr VIEW .
  pr DEFAULT-VALUE{Term} .
  pr (SET * (op _`,_ to _._,
             op empty to emptyModuleNameSet,
             op insert to insertModuleNameSet,
             op delete to deleteModuleNameSet,
             op _in_ to _inModuleNameSet_,
             op |_| to |_|ModuleNameSet,
             op $card to $cardModuleNameSet,
             op union to unionModuleNameSet,
             op intersection to intersectionModuleNameSet,
             op $intersect to $intersectModuleNameSet,
             op _\_ to _\ModuleNameSet_,
             op $diff to $diffModuleNameSet,
             op _subset_ to _subsetModuleNameSet_,
             op _psubset_ to _psubsetModuleNameSet_)){ModuleName} .
  pr (SET * (op _`,_ to _#_,
             op empty to emptyViewExpressionSet,
             op insert to insertViewExpressionSet,
             op delete to deleteViewExpressionSet,
             op _in_ to _inViewExpressionSet_,
             op |_| to |_|ViewExpressionrSet,
             op $card to $cardViewExpressionrSet,
             op union to unionViewExpressionrSet,
             op intersection to intersectionViewExpressionrSet,
             op $intersect to $intersectViewExpressionrSet,
             op _\_ to _\ViewExpressionrSet_,
             op $diff to $diffViewExpressionrSet,
             op _subset_ to _subsetViewExpressionrSet_,
             op _psubset_ to _psubsetViewExpressionrSet_)){ViewExpression} .
  pr (SET * (op _`,_ to _._)){ParameterDecl} .

  var  MN : ModuleName .
  var  MNS : Set{ModuleName} .

  op remove : Set{ModuleName} ModuleName -> Set{ModuleName} .
  eq remove(MN . MNS, MN) = remove(MNS, MN) .
  eq remove(MNS, MN) = MNS [owise] .

  sort ModuleInfo .
  op <_;_;_;_;_;_;_;_> : ModuleName Default{Term} Module Module Module
       VariableSet Set{ModuleName} Set{ViewExpression} -> ModuleInfo
     [ctor
      format
        (nig o g n+++io g nio g nio g nio g nio g nio g nio n---ig o)] .
  op <_;_;_;_;_;_;_;_> : ModuleName Module Module Module Module
       VariableSet Set{ModuleName} Set{ViewExpression} -> ModuleInfo
     [ctor
      format
      (nig ur! g n+++io g nio g nio g nio g nio g nio g nio n---ig o)] .

  *** - Modules can be introduced by the user or can be generated internally.
  ***   When introduced by the user the 2nd arg. keeps the term representation
  ***   of the module as given, so that it can be recompiled later. If the
  ***   module is generated internally as the result of the evaluation of a
  ***   module expression, then this second arg. will be null, the default
  ***   term value. The user can also enter modules with the procModule
  ***   function, providing then the metarepresentation of a module, which
  ***   is directly stored in the database as the 2nd arg. of one of these
  ***   ModuleInfo units of the second kind. This is useful for the ITP for
  ***   example, where the interaction with the database takes place at the
  ***   metalevel and the modules given by the "user" are already at the
  ***   metalevel but still wants the same treatment.
  *** - The sixth arg. stores the variables (corresponding ops.) in the top
  ***   module.

  sort ViewInfo .
  op <_;_;_;_;_> : ViewExpression Default{Term} View Set{ModuleName}
       Set{ViewExpression} -> ViewInfo
       [ctor format (nig o g n+++io g nio g nio g nio n---ig o)] .
  op <_;_;_;_;_> :
       ViewExpression View View Set{ModuleName} Set{ViewExpression} -> ViewInfo
       [ctor format (nig o g n+++io g nio g nio g nio n---ig o)] .

endfm

view ModuleInfo from TRIV to INFO is
  sort Elt to ModuleInfo .
endv

view ViewInfo from TRIV to INFO is
  sort Elt to ViewInfo .
endv

fmod DATABASE-DECLS is
  pr (SET * (op _`,_ to __, op empty to emptyInfoSet)){ModuleInfo} .
  pr (SET * (op _`,_ to __, op empty to emptyInfoSet)){ViewInfo} .

  sort Database .
  op db :
     Set{ModuleInfo}  *** module info tuples
     Set{ModuleName}  *** names of the modules in the database
     Set{ViewInfo}    *** view info tuples
     Set{ViewExpression}     *** names of the views in the db
     Set{ModuleName}  *** modules with set protect on (by default empty)
     Set{ModuleName}  *** modules with set extend on (by default empty)
     Set{ModuleName}  *** modules with set include on (by default empty)
     QidList
       -> Database
     [ctor
      format (nib i++o)] .

  ops getDefPrs getDefExs getDefIncs : Database -> Set{ModuleName} .
  eq getDefPrs(
        db(MIS:Set{ModuleInfo}, MNS:Set{ModuleName}, VIS:Set{ViewInfo},
           VES:Set{ViewExpression}, MNS':Set{ModuleName}, MNS'':Set{ModuleName},
           MNS3:Set{ModuleName}, QIL:QidList))
    = MNS':Set{ModuleName} .
  eq getDefExs(
        db(MIS:Set{ModuleInfo}, MNS:Set{ModuleName}, VIS:Set{ViewInfo},
           VES:Set{ViewExpression}, MNS':Set{ModuleName}, MNS'':Set{ModuleName},
           MNS3:Set{ModuleName}, QIL:QidList))
    = MNS'':Set{ModuleName} .
  eq getDefIncs(
        db(MIS:Set{ModuleInfo}, MNS:Set{ModuleName}, VIS:Set{ViewInfo},
           VES:Set{ViewExpression}, MNS':Set{ModuleName}, MNS'':Set{ModuleName},
           MNS3:Set{ModuleName}, QIL:QidList))
    = MNS3:Set{ModuleName} .
endfm

view Database from TRIV to DATABASE-DECLS is
  sort Elt to Database .
endv

view ModuleExpression from TRIV to META-MODULE is
  sort Elt to ModuleExpression .
endv

fmod DATABASE is
  pr (2TUPLE * (op `(_`,_`) to <_;_>,
                op p1_ to database,
                op p2_ to modExp)) {Database, ModuleExpression} .
  pr PRE-VIEW .
  pr FM-UNIT .
  pr FM-VIEW-EXPR-TO-QID .

  op evalModule : Module VariableSet Database -> Database .
  *** its definition is in the module FM-EVALUATION

  op procModule : Qid Database -> Database .
  op procView : Qid Database -> Database .
  op procView : View Database -> Database .
  *** their definitions are in the modules UNIT-PROCESSING and VIEW-PROCESSING

  op evalModExp : ModuleExpression Database -> Tuple{Database, ModuleExpression} .
  *** its definition is in the module MOD-EXPR-EVAL

  vars QI X Y F : Qid .
  vars QIL QIL' : QidList .
  vars NQIL NQIL' : NeQidList .
  vars VE VE' VE'' : ViewExpression .
  vars VES VES' VES'' VES3 : Set{ViewExpression} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars MNS MNS' MNS'' MNS3 MNS4 MNS5 MNS6 : Set{ModuleName} .
  vars PL PL' : ParameterList .
  vars PDS PDS' PDS'' : Set{ParameterDecl} .
  var  PDL : ParameterDeclList .
  var  PD : ParameterDecl .
  vars ME ME' : ModuleExpression .
  vars VI VI' : View .
  var  SMS : SortMappingSet .
  var  OMS : OpMappingSet .
  var  TMS : StratMappingSet .
  vars PU PU' U U' U'' U3 U4 : Module .
  var  M : Module .
  var  DB : Database .
  vars IL IL' : ImportList .
  var  VIf : ViewInfo .
  var  UIf : ModuleInfo .
  vars OPDS : OpDeclSet .
  vars VDS VDS' : VariableSet .
  var  PV : PreView .
  vars T T' : Term .
  var  DT : Default{Term} .
  var  NL : IntList .
  var  TyL : TypeList .
  var  Ty : Type .
  var  AtS : AttrSet .
  var  B : Bool .
  var  I : Import .
  var  MN MN' : ModuleName .

  ops dincluded : ModuleExpression ImportList -> Bool .

  eq dincluded(ME, IL (protecting ME .) IL') = true .
  eq dincluded(ME, IL (extending ME .) IL') = true .
  eq dincluded(ME, IL (including ME .) IL') = true .
  eq dincluded(ME, IL) = false [owise] .

  ops included includedAux : ModuleExpression ImportList Database -> Bool .

  eq included(ME, IL (protecting ME .) IL', DB) = true .
  eq included(ME, IL (extending ME .) IL', DB) = true .
  eq included(ME, IL (including ME .) IL', DB) = true .
  eq included(ME, nil, DB) = false .
  eq included(ME, IL, DB) = includedAux(ME, IL, DB) [owise] .

  eq includedAux(ME, I IL, DB)
    = included(ME, getImports(getTopModule(moduleName(I), DB)), DB)
      or-else includedAux(ME, IL, DB) .
  eq includedAux(ME, nil, DB) = false .

  op defImports : Module Database -> ImportList .
  op defImports : ImportList ImportList Set{ModuleName} Set{ModuleName}
       Set{ModuleName} -> ImportList .

  eq defImports(M, DB)
    = if theory(M)
      then nil
      else defImports(getImports(M), nil,
             getDefPrs(DB), getDefExs(DB), getDefIncs(DB))
      fi .

  eq defImports(IL, IL', MN . MNS, MNS', MNS'')
    = if dincluded(MN, IL IL')
      then defImports(IL, IL', MNS, MNS', MNS'')
      else defImports(IL, IL' (protecting MN .), MNS, MNS', MNS'')
      fi .
  eq defImports(IL, IL', MNS, MN . MNS', MNS'')
    = if dincluded(MN, IL IL')
      then defImports(IL, IL', MNS, MNS', MNS'')
      else defImports(IL, IL' (extending MN .), MNS, MNS', MNS'')
      fi .
  eq defImports(IL, IL', MNS, MNS', MN . MNS'')
    = if dincluded(MN, IL IL')
      then defImports(IL, IL', MNS, MNS', MNS'')
      else defImports(IL, IL' (including MN .), MNS, MNS', MNS'')
      fi .
  eq defImports(IL, IL',
       emptyModuleNameSet, emptyModuleNameSet, emptyModuleNameSet)
    = IL' .

*** The constant \texttt{emptyDatabase} denotes the empty database, and there
*** are predicates \texttt{viewInDatabase} and \texttt{unitInDb} to check,
*** respectively, whether a view and a unit are in a database or not.

  op emptyDatabase : -> Database .
  eq emptyDatabase
    = db(emptyInfoSet, emptyModuleNameSet, emptyInfoSet, emptyViewExpressionSet,
         emptyModuleNameSet, emptyModuleNameSet, 'BOOL, nil) .

  op unitInDb : ModuleName Database -> Bool .
  eq unitInDb(MN, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = MN inModuleNameSet MNS .

  op viewInDb : ViewExpression Database -> Bool .
  eq viewInDb(VE, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = VE inViewExpressionSet VES .

  op includeBOOL : Database -> Bool .
  eq includeBOOL(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = 'BOOL inModuleNameSet MNS' .

*** If a module, theory, or view is being redefined, that is, if there was
*** already in the database a module, theory, or view with the same name,
*** then all the units and/or views depending on it are removed using the
*** functions \texttt{delModules} and \texttt{delViews}. Removing a view
*** or a unit from the database means removing its info cell from the set of
*** cells in the database. Those entered by the user are not completely
*** removed, their term form is saved so that it can be recompiled later.

  op delModules : Set{ModuleName} Database -> Database .
  op delViews : Set{ViewExpression} Database -> Database .

  eq delModules((MN . MNS),
       db(< MN ; T ; U ; U' ; U'' ; VDS ; MNS' ; VES > MIS,
          MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))
    = delModules((MNS . MNS'),
          delViews(VES,
            db(< MN ; T ; noModule ; noModule ; noModule ; VDS ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))) .
  eq delModules((MN . MNS),
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS' ; VES > MIS,
          MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))
    = delModules((MNS . MNS'),
          delViews(VES,
            db(< MN ; U ; noModule ; noModule ; noModule ; VDS ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))) .
  eq delModules((MN . MNS),
       db(< MN ; null ; U ; U' ; U'' ; VDS ; MNS' ; VES > MIS,
          MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))
    = delModules((MNS . MNS'),
        delViews(VES,
            db(MIS, MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))) .
  eq delModules(emptyModuleNameSet, DB) = DB .
  eq delModules((MN . MNS), DB) = delModules(MNS, DB) [owise] .

  eq delViews(VE # VES,
       db(MIS, MNS, < VE ; T ; VI ; MNS' ; VES' > VIS, VE # VES'',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES # VES',
        delModules(MNS',
          db(MIS, MNS,
             < VE ; T ; null ; emptyModuleNameSet ; emptyViewExpressionSet > VIS,
             VE # VES'', MNS'', MNS3, MNS4, QIL))) .
  eq delViews(VE # VES,
       db(MIS, MNS,
          < VE ; (null).Default{Term} ; VI ; MNS' ; VES' > VIS, VE # VES'',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES # VES',
        delModules(MNS',
          db(MIS, MNS, VIS, VES'', MNS'', MNS3, MNS4, QIL))) .
  eq delViews(VE # VES,
       db(MIS, MNS, < VE ; VI ; VI' ; MNS' ; VES' > VIS, VE # VES'',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES # VES',
        delModules(MNS',
          db(MIS, MNS,
             < VE ; VI ; null ; emptyModuleNameSet ; emptyViewExpressionSet > VIS,
             VE # VES'', MNS'', MNS3, MNS4, QIL))) .
  eq delViews(emptyViewExpressionSet, DB) = DB .
  eq delViews(VE # VES, DB) = delViews(VES, DB) [owise] .

*** The \texttt{warning} function allows us to place messages (warning, error,
*** or any other kind of messages) in the last argument of the database
*** constructor. These messages are given in the form of quoted identifier
*** lists, and will be passed to the third argument of the read-eval-print
*** loop, to be printed in the terminal.

  op warning : Database QidList -> Database .
  eq warning(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, nil), QIL)
    = db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL) .
  eq warning(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, NQIL), QIL)
    = db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, NQIL QIL) .

  op getMsg : Database -> QidList .
  eq getMsg(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL)) = QIL .

*** Core Maude built-in modules are handled in a special way in the current
*** version of the system. They are not explicitly defined in the Full Maude
*** database; their importation is directly handled by Core Maude. This has
*** some drawbacks: Core Maude built-in modules cannot be renamed; they cannot
*** be directly used with built-in functions, such as \texttt{metaReduce} or
*** \texttt{sameComponent}, although they can be imported in modules being
*** used in the calls to these functions; and, in general, any function taking
*** as argument or returning as result the metarepresentation of a module
*** cannot take one of these built-in modules as argument. This is the case,
*** for example, for the \texttt{up} function presented in
*** Section~\ref{changing-levels}, or for functions or commands in which the
*** name of a module has to be specified, as the \texttt{select} or
*** \texttt{down} commands, or the \texttt{up} function presented in
*** Section~\ref{structured-specifications}. Nevertheless, there are also
*** some advantages: The flattening of the built-in part of the structure is
*** accomplished more efficiently, and, since these modules do not have to be
*** stored in the database of Full Maude, the size of the database is reduced.

*** Our plan is to have in the future a hybrid solution. Once we have some way
*** of storing the modules entered to Full Maude in Core Maude's database, it
*** will be enough to keep in the Full Maude database just the original form
*** of the top of all the modules, including built-ins, leaving all the
*** importation declarations to be resolved by the engine. The structures will
*** be normalized as they are now, so that the engine will have to deal just
*** with inclusions, but it will be possible to use the predefined modules as
*** any other module. Moreover, the Full Maude database will be relatively
*** smaller and the flattening will be computed more efficiently.

*** When a new module or theory is entered, the names of all the modules,
*** theories, and views depending on it are included in its lists of
*** dependencies with functions \texttt{setUpModuleDeps} and
*** \texttt{setUpViewDeps}. Notice that if new module expressions are
*** defined, the function \texttt{setUpModExpDeps} will have to be
*** extended accordingly.

  op setUpModuleDeps : Module Database -> Database .
  op setUpModExpDeps : ModuleName Database -> Database .
  op setUpModExpDeps : ModuleName Header Database -> Database .
  op setUpModExpDeps : ModuleName ViewExpression Database -> Database .
  op setUpImportDeps : ModuleName ImportList Database -> Database .

  eq setUpModuleDeps(U, DB)
    = setUpImportDeps(getHeader(U), getImports(U),
        setUpModExpDeps(getHeader(U), DB)) .

  eq setUpModExpDeps(QI, DB) = DB .

  eq setUpModExpDeps(pd(X :: ME),
       db(< ME ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; DT ; U ; U' ; U'' ; VDS ; (MNS . pd(X :: ME)) ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps(pd(X :: ME),
       db(< ME ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; U ; U' ; U'' ; U3 ; VDS ; (MNS . pd(X :: ME)) ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps(pd(X :: ME), DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n))
    [owise] .

---- This could be a bug in Core Maude.
---- It should work if the next 6 equations are replaced by this single equation.
----  ceq setUpImportDeps(MN, (I IL),
----       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS),
----          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
----    = setUpImportDeps(MN, IL,
----        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS),
----           MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
----    if MN' := moduleName(I) .
  eq setUpImportDeps(MN, ((including MN' .) IL),
       db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((including MN' .) IL),
       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((extending MN' .) IL),
       db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((extending MN' .) IL),
       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((protecting MN' .) IL),
       db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((protecting MN' .) IL),
       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL,
        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, I IL, DB)
    = warning(DB, '\r 'Error: '\o 'Module header2QidList(moduleName(I)) 'not 'in 'database. '\n)
    [owise] .
  eq setUpImportDeps(MN, nil, DB) = DB .

  op setUpViewDeps : ModuleExpression ViewExpression Database -> Database .
  op setUpViewExpressionDeps : ViewExpression Database -> Database .
  op setUpViewExpressionDeps : ViewExpression ParameterList Database -> Database .

  eq setUpViewDeps(ME, VE,
       db((< ME ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db((< ME ; DT ; U ; U' ; U'' ; VDS ; MNS ; VE # VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpViewDeps(ME, VE,
       db((< ME ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db((< ME ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VE # VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpViewDeps(ME, VE, DB)
    = warning(DB, '\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n)
    [owise] .

  eq setUpViewExpressionDeps(QI, DB) = DB .
  eq setUpViewExpressionDeps(QI{PL}, DB) = setUpViewExpressionDeps(QI{PL}, PL, DB) .

  eq setUpViewExpressionDeps(VE, (QI, PL),
       db(MIS, MNS, < QI ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE, PL,
        db(MIS, MNS, < QI ; DT ; VI ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpressionDeps(VE, (QI, PL),
       db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE, PL,
        db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpressionDeps(QI{PL}, PL',
       db(MIS, MNS, < QI ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(MIS, MNS, < QI ; DT ; VI ; MNS' ; QI{PL} # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)
    [owise] .
  eq setUpViewExpressionDeps(QI{PL}, PL',
       db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; QI{PL} # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)
    [owise] .

  eq setUpViewExpressionDeps(VE, (QI{PL}, PL'),
       db(MIS, MNS, < QI{PL} ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE, PL',
        db(MIS, MNS, < QI{PL} ; DT ; VI ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpressionDeps(VE, (QI{PL}, PL'),
       db(MIS, MNS, < QI{PL} ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE, PL',
        db(MIS, MNS, < QI{PL} ; VI ; VI' ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpressionDeps(VE, (QI{PL}, PL'), DB)
    = setUpViewExpressionDeps(VE, PL', DB)
    [owise] .
  eq setUpViewExpressionDeps(VE, empty, DB) = DB .

  op compiledModule : ModuleExpression Database -> Bool .
  op compiledModule : ParameterDecl Database -> Bool .
  op compiledView : ViewExpression Database -> Bool .

  eq compiledView(VE,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VI =/= null .
  eq compiledView(ME, DB) = false [owise] .

  eq compiledModule(MN,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U'' =/= noModule .
  eq compiledModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U3 =/= noModule .
  eq compiledModule(MN, DB) = false [owise] .

  op insertTermView : ViewExpression Term Database -> Database .
  op insertView : View Database -> Database .
  op getTermView : ViewExpression Database -> Default{Term} .
  op getView : ViewExpression Database -> View .

  eq insertTermView(VE, T,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES,
        delModules(MNS',
          db(MIS, MNS,
            < VE ; T ; null ; emptyModuleNameSet ; emptyViewExpressionSet > VIS, VES',
            MNS'', MNS3, MNS4,
            QIL
            '\g 'Advisory: '\o 'View viewExp2QidList(VE) 'redefined. '\n))) .
  eq insertTermView(VE, T,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = db(MIS, MNS,
         < VE ; T ; null ; emptyModuleNameSet ; emptyViewExpressionSet > VIS,
         (VE # VES), MNS', MNS'', MNS3, QIL)
    [owise] .

  eq insertView(view VE from ME to ME' is SMS OMS TMS endv,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; DT ;
                 view VE from ME to ME' is SMS OMS TMS endv ;
                 MNS' ; VES > VIS,
                 VES', MNS'', MNS3, MNS4, QIL)))) .
  eq insertView(view VE{PDL} from ME to ME' is SMS OMS TMS endv,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; DT ;
                 view VE{PDL} from ME to ME' is SMS OMS TMS endv ;
                 MNS' ; VES > VIS,
                 VES', MNS'', MNS3, MNS4, QIL)))) .
  eq insertView(view VE from ME to ME' is SMS OMS TMS endv,
       db(MIS, MNS, VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; (null).Default{Term} ;
                 view VE from ME to ME' is SMS OMS TMS endv ;
                 emptyModuleNameSet ; emptyViewExpressionSet > VIS,
                 VE # VES', MNS'', MNS3, MNS4, QIL))))
    [owise] .
  eq insertView(view VE{PDL} from ME to ME' is SMS OMS TMS endv, db(MIS, MNS, VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpressionDeps(VE,
        setUpViewDeps(ME, VE,
          setUpViewDeps(ME', VE,
            db(MIS, MNS,
               < VE ; (null).Default{Term} ;
                 view VE{PDL} from ME to ME' is SMS OMS TMS endv ;
                 emptyModuleNameSet ; emptyViewExpressionSet > VIS,
                 VE # VES', MNS'', MNS3, MNS4, QIL))))
    [owise] .
  eq insertView(viewError(QIL), DB) = warning(DB, QIL) .
  ceq insertView(view VE:[ViewExpression] from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] TMS:[StratMappingSet] endv, DB)
    = warning(DB, 'The 'view QIL QI if QI == '`) then '\s else nil fi 'contains 'errors.)
    if not view VE:[ViewExpression] from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] TMS:[StratMappingSet] endv :: View
    /\ QIL QI := eMetaPrettyPrint(VE:[ViewExpression])
    [owise] .
  ceq insertView(view VE:[ViewExpression]{PDL:[ParameterDeclList]} from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] TMS:[StratMappingSet] endv, DB)
    = warning(DB, 'The 'view QIL QI if QI == '`) then '\s else nil fi 'contains 'errors.)
    if not view VE:[ViewExpression]{PDL:[ParameterDeclList]} from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] TMS:[StratMappingSet] endv :: View
    /\ QIL QI := eMetaPrettyPrint(VE:[ViewExpression])
    [owise] .

  eq getTermView(VE,
       db(MIS, MNS, (< VE ; DT ; VI ; MNS' ; VES > VIS), VES', MNS'', MNS3, MNS4, QIL))
    = DT .
  eq getTermView(VE, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = qidError('\r 'Error: '\o 'View viewExp2QidList(VE) 'not 'in 'database. '\n)
    [owise] .

  eq getView(VE,
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VI .
  eq getView(VE,
       db(MIS, MNS, < VE ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VI' .
  eq getView(VE, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = viewError('\r 'Error: '\o 'View viewExp2QidList(VE) 'not 'in 'database. '\n)
    [owise] .

*** There are functions to insert the different versions of a unit, and to
*** extract them.  We only give here the equations for the insertion of top
*** units to illustrate the way in which the consistency of the database is
*** maintained.  We assume that when the internal version, the signature, or
*** the flat version of a module is entered in the database, its corresponding
*** top module is already present in it.

  pr FM-3TUPLE{Term,VariableSet,Module} * (op ((_,_,_)) to <_;_;_>) .

*** extended variable set
  op variableSetError : QidList -> [VariableSet] [ctor format (r o)] .
  eq variableSetError(QIL) variableSetError(QIL') = variableSetError(QIL QIL') .


----  sort Tuple{Term,OpDeclSet,Module} .
----  op <_;_;_> : Default{Term} OpDeclSet Module -> Tuple{Term,OpDeclSet,Module} .
  op error : QidList -> [Tuple{Term,VariableSet,Module}] .

  op insTermModule : ModuleName Module Database -> Database .
  op insTermModule : ModuleName Term Database -> Database .
  op insertTopModule : ModuleExpression [Module] Database -> Database .
  op insertInternalModule : ModuleExpression [Module] Database -> Database .
  op insertFlatModule : ModuleExpression [Module] Database -> Database .
  op insertVars : ModuleExpression [VariableSet] Database -> Database .
  op getTermModule : ModuleExpression Database -> [Tuple{Term,VariableSet,Module}] .
  op getTopModule : ModuleExpression Database -> [Module] .
  op getInternalModule : ModuleExpression Database -> [Module] .
  op getFlatModule : ModuleExpression Database -> [Module] .
  op getFlatModuleNeg : ModuleExpression Database -> [Module] .
  op getVars : ModuleExpression Database -> [VariableSet] .
  op insertTopModule : ParameterDecl [Module] Database -> Database .
  op insertInternalModule : ParameterDecl [Module] Database -> Database .
  op insertFlatModule : ParameterDecl [Module] Database -> Database .
  op insertVars : ParameterDecl [OpDeclSet] Database -> Database .
  op getTermModule : ParameterDecl Database -> [Tuple{Term,VariableSet,Module}] .
  op getTopModule : ParameterDecl Database -> [Module] .
  op getInternalModule : ParameterDecl Database -> [Module] .
  op getFlatModule : ParameterDecl Database -> [Module] .
  op getFlatModuleNeg : ParameterDecl Database -> [Module] .
  op getVars : ParameterDecl Database -> [VariableSet] .

  eq insTermModule(MN, T,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; T ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory: '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, T,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; T ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory: '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, T,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = db(< MN ; T ; noModule ; noModule ; noModule ; none ;
           emptyModuleNameSet ; emptyViewExpressionSet > MIS,
         MN . MNS, VIS, VES, MNS', MNS'', MNS3, QIL)
    [owise] .
  eq insTermModule(MN, qidError(QIL), DB) = warning(DB, QIL) .
  eq insTermModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insTermModule(MN, U,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; U ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory:
               '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS, MNS',
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS,
          delViews(VES,
            db(< MN ; U ; noModule ; noModule ; noModule ; none ;
                 emptyModuleNameSet ; emptyViewExpressionSet > MIS,
               MNS', VIS, VES', MNS'', MNS3, MNS4,
               QIL
               '\g 'Advisory:
               '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, U,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = db(< MN ; U ; noModule ; noModule ; noModule ; none ;
           emptyModuleNameSet ; emptyViewExpressionSet > MIS,
         MN . MNS, VIS, VES, MNS', MNS'', MNS3, QIL)
    [owise] .
  eq insTermModule(MN, qidError(QIL), DB) = warning(DB, QIL) .
  eq insTermModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertTopModule(MN, U,
       db(< MN ; null ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; null ; U ; noModule ; noModule ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4,
         QIL
         '\r 'Advisory: '\o
         'Internally 'generated 'module header2QidList(MN) 'redefined. '\n) .
  eq insertTopModule(MN, U,
       db(< MN ; T ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModuleDeps(U,
        db(< MN ; T ; U ; noModule ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq insertTopModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModuleDeps(U,
        db(< MN ; U' ; U ; noModule ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq insertTopModule(MN, U,
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = setUpModuleDeps(U,
        db(< MN ; null ; U ; noModule ; noModule ;
              none ; emptyModuleNameSet ; emptyViewExpressionSet > MIS,
           MN . MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    [owise] .
  eq insertTopModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertInternalModule(MN, U,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; DT ; U' ; U ; U3 ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertInternalModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; U' ; U'' ; U ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertInternalModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertFlatModule(MN, U,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; DT ; U' ; U'' ; U ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertFlatModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; U' ; U'' ; U3 ; U ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertFlatModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertVars(MN, VDS,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS' ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertVars(MN, VDS,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS' ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS,
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertVars(MN, variableSetError(QIL), DB) = warning(DB, QIL) .

  eq getTermModule(MN,
       db(< MN ; null ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = error('\r 'Error: '\o header2QidList(MN) 'is 'an 'internal 'module. '\n) .
  eq getTermModule(MN,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = < DT ; none ; noModule > .
  eq getTermModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = < null ; VDS ; U > .
  eq getTermModule(MN, DB)
    = error('\r 'Error: '\o 'Module header2QidList(MN)  '\n)
    [owise] .

  eq getTopModule(MN,
      db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U .
  eq getTopModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U' .
  eq getTopModule(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  eq getInternalModule(MN,
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U' .
  eq getInternalModule(MN,
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U'' .
  eq getInternalModule(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  eq getVars(MN,
       db(< MN ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VDS .
  eq getVars(MN,
       db(< MN ; U ; U' ; U'' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VDS .
  eq getVars(MN, DB) = none [owise] .

*** The name of the signature and the flattened module is not the
*** module expression used as the name of the module but the result of
*** converting it into a quoted identifier.

  eq getFlatModule(MN,
       db(< MN ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = if M == noModule
      then unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'compiled. '\n)
      else remNegAnns(M)
      fi .
  eq getFlatModule(MN,
       db(< MN ; U ; U' ; U'' ; M ; VDS ; MNS ; VES > MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = if M == noModule
      then unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'compiled. '\n)
      else remNegAnns(M)
      fi .
  eq getFlatModule(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  *** Handling of negative annotations (by Santiago Escobar)

  eq getFlatModuleNeg(MN,
       db(< MN ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = M .
  eq getFlatModuleNeg(MN,
       db(< MN ; U ; U' ; U'' ; M ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = M .
  eq getFlatModuleNeg(MN,
       db(< MN ; DT ; U ; U' ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = unitError('\r 'Error: '\o
                'Module header2QidList(MN) 'not 'compiled. '\n) .
  eq getFlatModuleNeg(MN,
      db(< MN ; U ; U' ; U'' ; noModule ; VDS ; MNS ; VES > MIS,
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = unitError('\r 'Error: '\o
                'Module header2QidList(MN) 'not 'compiled. '\n) .
  eq getFlatModuleNeg(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  *** removeNegAnnotations
  op remNegAnns : Module -> Module .
  op remNegAnns : OpDeclSet -> OpDeclSet .
  op remNegAnns : AttrSet -> AttrSet .
  op remNegAnns : IntList -> IntList .

  eq remNegAnns(M) = setOps(M, remNegAnns(getOps(M))) .

  eq remNegAnns(op F : TyL -> Ty [AtS] . OPDS)
    = op F : TyL -> Ty [remNegAnns(AtS)] . remNegAnns(OPDS) .
  eq remNegAnns((none).OpDeclSet) = (none).OpDeclSet .

  eq remNegAnns(strat(NL:NatList) AtS) = strat(NL:NatList) AtS .
  eq remNegAnns(strat(IL:IntList) AtS) = AtS [owise] .
  eq remNegAnns(AtS) = AtS [owise] .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Evaluation of Modules
***

*** The general principle for the evaluation of units in our design consists in
*** first evaluating any module expression, reducing it to a canonical form in
*** which only unit inclusions appear, that is, to a unit hierarchy, which can
*** be seen as a partial order of unit inclusions. The design of the Full Maude
*** system has been based upon the principle of evaluating all module
*** expressions to irreducible structured units, and on using the flat version
*** of the units only for execution purposes. We have then two different
*** processes clearly distinguished: a first step in which the structured unit
*** is evaluated and reduced to its normal form, and a second step in which
*** this normal form is flattened.

*** As explained in Section~\ref{execution-environment}, the process of
*** evaluation to normal form is also responsible for the parsing of the
*** bubbles in the premodules, which is accomplished once the signature has
*** been built. The parsing of bubbles is discussed in
*** Section~\ref{bubble-parsing}. To be able to handle the \texttt{up}
*** function and the \texttt{down} command presented in
*** Section~\ref{structured-specifications}, it is necessary to be able to
*** move terms and modules from one level of reflection to another. The
*** functionality to move between levels is presented in
*** Section~\ref{changing-levels}, where functions \texttt{up} and
*** \texttt{down} on sorts \texttt{Module} and \texttt{Term} are defined. The
*** transformation of object-oriented modules into system modules in discussed
*** in Section~\ref{omod2modfunction}. The evaluation of module expressions is
*** discussed in Sections~\ref{evalModExp}, \ref{application-of-maps},
*** \ref{instantiation}, and~\ref{renaming}.

***
*** Changing Levels
***

*** Moving terms of sorts \texttt{Term} and \texttt{Module} from one
*** level of reflection to another is possible thanks to the
*** \texttt{up} and \texttt{down} functions, which are defined,
*** respectively, in the following modules \texttt{MOVE-UP} and
*** \texttt{MOVE-DOWN}.

***
*** The \texttt{up} Function
***

*** Given a term of sort \texttt{Module} or \texttt{Term}, the
*** \texttt{up} function, defined in the following module
*** \texttt{MOVE-UP}, returns the term metarepresenting it. The
*** function is just call the \texttt{upTerm} predefined function.

*** We shall see in Section~\ref{bubble-parsing} how the \texttt{up} function
*** is used to evaluate the homonymous function discussed in
*** Section~\ref{structured-specifications}. In Section~\ref{instantiation} we
*** shall discuss how the \texttt{up} function is used to evaluate the
*** \texttt{META-LEVEL} module expression (see
*** Section~\ref{structured-specifications}).

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOVE-UP is
---  pr META-LEVEL + PRE-VARIANT .
  pr META-LEVEL .
  pr CONVERSION .
  op up : Module -> Term .
  op up : Term -> Term .
  op up : EquationSet -> Term .

  eq up(M:Module) = upTerm(M:Module) .
  eq up(T:Term) = upTerm(T:Term) .
  eq up(EqS:EquationSet) = upTerm(EqS:EquationSet) .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The \texttt{down} Function
***

*** Given a term of sort \texttt{Term} metarepresenting a term of sort
*** \texttt{Term} or \texttt{Module}, the \texttt{down} function can be seen
*** as the inverse of the \texttt{up} function discussed in the previous
*** section, that is, it returns the original term that had been
*** metarepresented. There are also \texttt{down} functions for terms
*** metarepresenting terms in other sorts. We present here only some of them.

*** We assume that the \texttt{down} functions are called with valid
*** metarepresentations. In fact, these functions should be declared as
*** partial functions going to error sorts when their arguments are invalid.

*** The main application of the \texttt{down} functions is in the evaluation
*** of the \texttt{down} command (see
*** Section~\ref{structured-specifications}).  However, they are also used in
*** other tasks, as for example in the parsing of some inputs.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOVE-DOWN is
  pr FM-UNIT .
  pr CONVERSION .
  pr FM-INT-LIST .

  op downTerm : Term -> [Term] .
  op downModule : Term -> [Module] .
  op downQid : Term -> [Qid] [memo] .
  op downQidList : Term -> [QidList] .
  op downTypes : Term -> [TypeList] .
  op downSorts : Term -> [SortSet] .
  op downSort : Term -> [Sort] .
  op downModExp : Constant -> [Header] .
  op downNat : Term -> [Int] .
  op downString : Term -> [String] .

  op downResultPair : Term -> [ResultPair] .
  op downTerm : TermList -> [Term] .
  op downImports : TermList -> [ImportList] .
  op downSubsorts : TermList -> [SubsortDeclSet] .
  op downOps : TermList -> [OpDeclSet] .
  op downEqCond : TermList -> [EqCondition] .
  op downCond : TermList -> [Condition] .
  op downMbs : TermList -> [MembAxSet] .
  op downEqs : TermList -> [EquationSet] .
  op downRls : TermList -> [RuleSet] .
  op downAttrs : TermList -> [AttrSet] .
  op downAttr : Term -> [Attr] .
  op downHooks : TermList -> [HookList] .
  op downMetaNat : Term -> [Term] .
  op downNat : TermList -> [IntList] .

  op downClasses : TermList -> [ClassDeclSet] .
  op downMsgs : TermList -> [MsgDeclSet] .
  op downSubclasses : TermList -> [SubclassDeclSet] .
  op downClassAttrs : TermList -> [AttrDeclSet] .

  op downStratDcls : TermList -> [StratDeclSet] .
  op downStratDefs : TermList -> [StratDefSet] .

  vars T T' T'' T''' T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Term .
  vars TL TL' : TermList .
  vars NTL NTL' : NeTermList .
  vars QI QI' F V L : Qid .
  var  Ct : Constant .
  var  M : Module .
  var  Tp : Type .

  eq downResultPair('`{_`,_`}[T, T']) = {downTerm(T), downTerm(T')} .

  eq downModule('fmod_is_sorts_.____endfm[T1, T2, T3, T4, T5, T6, T7])
    = (fmod downModExp(T1) is
         downImports(T2)
         sorts downSorts(T3) .
         downSubsorts(T4)
         downOps(T5)
         downMbs(T6)
         downEqs(T7)
       endfm) .
  eq downModule('mod_is_sorts_._____endm[T1, T2, T3, T4, T5, T6, T7, T8])
    = (mod downModExp(T1) is
         downImports(T2)
         sorts downSorts(T3) .
         downSubsorts(T4)
         downOps(T5)
         downMbs(T6)
         downEqs(T7)
         downRls(T8)
       endm) .
  eq downModule('omod_is_sorts_.________endom[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11])
    = (omod downModExp(T1) is
         downImports(T2)
         sorts downSorts(T3) .
         downSubsorts(T4)
         downClasses(T5)
         downSubclasses(T6)
         downOps(T7)
         downMsgs(T8)
         downMbs(T9)
         downEqs(T10)
         downRls(T11)
       endom) .
   eq downModule('smod_is_sorts_._____endm[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10])
     = (smod downModExp(T1) is
          downImports(T2)
          sorts downSorts(T3) .
          downSubsorts(T4)
          downOps(T5)
          downMbs(T6)
          downEqs(T7)
          downRls(T8)
          downStratDcls(T9)
          downStratDefs(T10)
        endsm) .

  eq downModExp(Ct) = downQid(Ct) .

  eq downImports('nil.ImportList) = nil .
  eq downImports('__[TL]) = downImports(TL) .
  eq downImports('including_.[T]) = (including downModExp(T) .) .
  eq downImports('extending_.[T]) = (extending downModExp(T) .) .
  eq downImports('protecting_.[T]) = (protecting downModExp(T) .) .
  eq downImports((NTL, NTL')) = (downImports(NTL) downImports(NTL')) .

  eq downSubsorts('none.SubsortDeclSet) = none .
  eq downSubsorts('__[TL]) = downSubsorts(TL) .
  eq downSubsorts('subsort_<_.[T, T']) = (subsort downQid(T) < downQid(T') .) .
  eq downSubsorts((NTL, NTL')) = (downSubsorts(NTL) downSubsorts(NTL')) .

  eq downOps('none.OpDeclSet) = none .
  eq downOps('__[TL]) = downOps(TL) .
  eq downOps('op_:_->_`[_`].[Ct, T, T', T''])
    = (op downQid(Ct) : downTypes(T) -> downQid(T') [downAttrs(T'')] .) .
  eq downOps((NTL, NTL')) = (downOps(NTL) downOps(NTL')) .

  eq downAttrs('none.AttrSet) = none .
  eq downAttrs('__[TL]) = downAttrs(TL) .
  ceq downAttrs((TL, TL')) = (downAttr(TL) downAttrs(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downAttrs(T) = downAttr(T) [owise].

  eq downAttr('assoc.Attr) = assoc .
  eq downAttr('comm.Attr) = comm .
  eq downAttr('idem.Attr) = idem .
  eq downAttr('id[T]) = id(downTerm(T)) .
  eq downAttr('left-id[T]) = left-id(downTerm(T)) .
  eq downAttr('right-id[T]) = right-id(downTerm(T)) .
  eq downAttr('poly[T]) = poly(downNat(T)) .
  eq downAttr('strat[T]) = strat(downNat(T)) .
  eq downAttr('memo.Attr) = memo .
  eq downAttr('prec[T]) = prec(downNat(T)) .
  eq downAttr('gather[T]) = gather(downQidList(T)) .
  eq downAttr('ctor.Attr) = ctor .
  eq downAttr('special[T]) = special(downHooks(T)) .
  eq downAttr('iter.Attr) = iter .
  eq downAttr('frozen[T]) = frozen(downNat(T)) .
  eq downAttr('label[T]) = label(downQid(T)) .
  eq downAttr('config.Attr) = config .
  eq downAttr('object.Attr) = object .
  eq downAttr('msg.Attr) = msg .
  eq downAttr('nonexec.Attr) = nonexec .
  eq downAttr('variant.Attr) = variant .
----  eq downAttr('metadata`(_`)['token[T]]) = metadata(downString(downQid(T))) .
  eq downAttr('owise.Attr) = owise .
  eq downAttr('metadata[T]) = metadata(substr(string(T), 1, find(string(T), "\".String", 0) + (- 1))) .
  eq downAttr('format[T]) = format(downQidList(T)) .

  eq downHooks('__[TL]) = downHooks(TL) .
  eq downHooks('id-hook[T, T']) = id-hook(downQid(T), downQidList(T')) .
  eq downHooks('op-hook[T, T', T'', T3])
    = op-hook(downQid(T), downQid(T'), downQidList(T''), downQid(T3)) .
  eq downHooks('term-hook[T, T']) = term-hook(downQid(T), downTerm(T')) .
  eq downHooks((NTL, NTL')) = downHooks(NTL) downHooks(NTL') .

----  eq downTerm(T) = downTerm(T, qidError('\r 'Error: '\o 'Incorrect 'term. '\n)) .
  eq downTerm(QI) = downQid(QI) .
  eq downTerm('_`[_`][T, T']) = downQid(T)[downTerm(T')] .
  eq downTerm('_`,_[T, TL]) = (downTerm(T), downTerm(TL)) .
  eq downTerm((T, NTL)) = (downTerm(T), downTerm(NTL)) .
  eq downTerm(F[TL])
    = qidError('\r 'Error: '\o 'Incorrect 'term. '\n) [owise] .

  eq downEqCond('_/\_[TL]) = downEqCond(TL) .
  eq downEqCond('_=_[T, T']) = downTerm(T) = downTerm(T') .
  eq downEqCond('_:_[T, T']) = downTerm(T) : downSort(T') .
  eq downEqCond('_:=_[T, T']) = downTerm(T) := downTerm(T') .
  eq downEqCond((NTL, NTL')) = downEqCond(NTL) /\ downEqCond(NTL') .

  eq downCond('_/\_[TL]) = downCond(TL) .
  eq downCond('_=_[T, T']) = downEqCond('_=_[T, T']) .
  eq downCond('_:_[T, T']) = downEqCond('_:_[T, T']) .
  eq downCond('_:=_[T, T']) = downEqCond('_:=_[T, T']) .
  eq downCond('_=>_[T, T']) = downTerm(T) => downTerm(T') .
  eq downCond((NTL, NTL')) = downCond(NTL) /\ downCond(NTL') .

  eq downMbs('none.MembAxSet) = none .
  eq downMbs('__[TL]) = downMbs(TL) .
  eq downMbs('mb_:_`[_`].[T, T', T''])
    = (mb downTerm(T) : downSort(T') [downAttrs(T'')] .) .
  eq downMbs('cmb_:_if_`[_`].[T, T', T'', T3])
    = (cmb downTerm(T) : downSort(T') if downEqCond(T'') [downAttrs(T3)] .) .
  eq downMbs((NTL, NTL')) = (downMbs(NTL) downMbs(NTL')) .

  eq downEqs('none.EquationSet) = none .
  eq downEqs('__[TL]) = downEqs(TL) .
  eq downEqs('eq_=_`[_`].[T, T', T''])
    = (eq downTerm(T) = downTerm(T') [downAttrs(T'')] .) .
  eq downEqs('ceq_=_if_`[_`].[T, T', T'', T3])
    = (ceq downTerm(T) = downTerm(T') if downEqCond(T'') [downAttrs(T3)] .) .
  eq downEqs((NTL, NTL')) = (downEqs(NTL) downEqs(NTL')) .

  eq downRls('none.RuleSet) = none .
  eq downRls('__[TL]) = downRls(TL) .
  eq downRls('rl_=>_`[_`].[T, T', T''])
    = (rl downTerm(T) => downTerm(T') [downAttrs(T'')] .) .
  eq downRls('crl_=>_if_`[_`].[T, T', T'', T3])
    = (crl downTerm(T) => downTerm(T') if downCond(T'') [downAttrs(T3)] .) .
  eq downRls((NTL, NTL')) = (downRls(NTL) downRls(NTL')) .

  eq downSorts('none.EmptyTypeSet) = none .
  eq downSorts(('_;_[TL], TL')) = (downSorts(TL) ; downSorts(TL')) .
  eq downSorts((QI, TL)) = (downSort(QI) ; downSorts(TL)) .
  eq downSorts(empty) = none .

  eq downSort(Ct) = downQid(Ct) .

  eq downTypes('nil.TypeList) = nil .
  eq downTypes(('__[TL], TL')) = (downTypes(TL) downTypes(TL')) .
  eq downTypes((QI, TL)) = (downSort(QI) downTypes(TL)) .
  eq downTypes(empty) = nil .

  eq downQidList('nil.TypeList) = nil .
  eq downQidList(('__[TL], TL')) = (downQidList(TL) downQidList(TL')) .
  eq downQidList((QI, TL)) = (downQid(QI) downQidList(TL)) .
  eq downQidList(empty) = nil .

  eq downQid(Ct)
    = qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))) .

  eq downMetaNat(QI)
    = qid(substr(string(getName(QI)), 1, length(string(getName(QI))))
          + ".Nat") .

----  eq downNat(T) = downTerm(T, numberError('Error: 'non 'valid 'metaterm)) .
  ceq downNat(QI)
    = trunc(rat(string(getName(QI)), 10))
    if getType(QI) == 'Nat or getType(QI) == 'NzNat .
  ceq downNat(QI)
    = if substr(string(getName(QI)), 0 ,1) == "-"
      then - trunc(rat(substr(string(getName(QI)), 1,
                            length(string(getName(QI)))), 10))
      else trunc(rat(string(getName(QI)), 10))
      fi
    if getType(QI) == 'Int or getType(QI) == 'NzInt .
  eq downNat('0.Zero) = 0 .
  eq downNat('s_['0.Zero]) = 1 .
  ceq downNat(F['0.Zero])
    = trunc(rat(substr(string(F), 3, 2), 10))
    if substr(string(F), 0, 3) = "s_^" .

  eq downString(QI) = substr(string(QI), 1, _-_(length(string(QI)), 2)) .

  eq downNat('__[TL]) = downNat(TL) .
  ceq downNat((TL, TL')) = (downNat(TL) downNat(TL')) if TL =/= empty /\ TL' =/= empty .

  eq downClasses('none.ClassDeclSet) = none .
  eq downClasses('__[TL]) = downClasses(TL) .
  ceq downClasses((TL, TL')) = (downClasses(TL) downClasses(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downClasses('class_|_.[T, T']) = (class downSort(T) | downClassAttrs(T') .) .

  eq downClassAttrs('none.AttrDeclSet) = none .
  eq downClassAttrs('_`,_[TL]) = downClassAttrs(TL) .
  ceq downClassAttrs((TL, TL')) = (downClassAttrs(TL), downClassAttrs(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downClassAttrs('attr_:_[T, T']) = (attr downQid(T) : downSort(T')) .

  eq downSubclasses('none.SubclassDeclSet) = none .
  eq downSubclasses('__[TL]) = downSubclasses(TL) .
  ceq downSubclasses((TL, TL')) = (downSubclasses(TL) downSubclasses(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downSubclasses('subclass_<_.[T, T']) = (subclass downQid(T) < downQid(T') .) .

  eq downMsgs('none.MsgDeclSet) = none .
  eq downMsgs('__[TL]) = downMsgs(TL) .
 ceq downMsgs((TL, TL')) = (downMsgs(TL) downMsgs(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downMsgs('msg_:_->_.[Ct, T, T'])
    = (msg downQid(Ct) : downTypes(T) -> downQid(T') .) .

  eq downStratDcls('none.StratDeclSet) = none .
  eq downStratDcls('__[TL]) = downStratDcls(TL) .
 ceq downStratDcls((TL, TL')) = (downStratDcls(TL) downStratDcls(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downStratDcls('strat_:_@_`[_`].[Ct, T, T', T''])
    = (strat downQid(Ct) : downTypes(T) @ downQid(T') [downAttrs(T'')] .) .

  eq downStratDefs('none.StratDefSet) = none .
  eq downStratDefs('__[TL]) = downStratDefs(TL) .
 ceq downStratDefs((TL, TL')) = (downStratDefs(TL) downStratDefs(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downStratDefs('sd_:=_`[_`].[T, T', T''])
   = (sd downStrategy(T) := downStrategy(T') [downAttrs(T'')] .) .
  eq downStratDefs('csd_:=_if_`[_`].[T, T', T'', T'''])
   = (csd downStrategy(T) := downStrategy(T') if downCond(T'') [downAttrs(T''')] .) .

  op downStrategy : TermList -> Strategy .
  eq downStrategy('empty.StrategyList) = empty .
  eq downStrategy('_`,_[T, T']) = downStrategy(T'), downStrategy(T') .
 ceq downStrategy((TL, TL')) = (downStrategy(TL), downStrategy(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downStrategy('fail.Strategy) = fail .
  eq downStrategy('idle.Strategy) = idle .
  eq downStrategy('all.Strategy) = all .
  eq downStrategy('_`[_`]`{_`}[T, T', T''])
    = downQid(T) [ downSubstitution(T') ]{ downStrategy(T'') } .
  eq downStrategy('top[T]) = top( downStrategy(T) ) .
  eq downStrategy('match_s.t._[T, T']) = match downTerm(T) s.t. downCond(T') .
  eq downStrategy('xmatch_s.t._[T, T']) = xmatch downTerm(T) s.t. downCond(T') .
  eq downStrategy('amatch_s.t._[T, T']) = amatch downTerm(T) s.t. downCond(T') .
  eq downStrategy('_|_[T, T']) = downStrategy(T) | downStrategy(T') .
  eq downStrategy('_;_[T, T']) = downStrategy(T) ; downStrategy(T') .
  eq downStrategy('_or-else_[T, T']) = downStrategy(T) or-else downStrategy(T') .
  eq downStrategy('_+[T]) = downStrategy(T) + .
  eq downStrategy('_?_:_[T, T', T'']) = downStrategy(T) ? downStrategy(T') : downStrategy(T'') .
  eq downStrategy('matchrew_s.t._by_[T, T', T''])
    = matchrew downTerm(T) s.t. downCond(T') by downUsingPairSet(T'') .
  eq downStrategy('xmatchrew_s.t._by_[T, T', T''])
    = matchrew downTerm(T) s.t. downCond(T') by downUsingPairSet(T'') .
  eq downStrategy('amatchrew_s.t._by_[T, T', T''])
    = matchrew downTerm(T) s.t. downCond(T') by downUsingPairSet(T'') .
  eq downStrategy('one[T]) = one( downStrategy(T) ) .
  eq downStrategy('_*[T]) = downStrategy(T) * .
  eq downStrategy('_![T]) = downStrategy(T) ! .
  eq downStrategy('not[T]) = not(downStrategy(T)) .
  eq downStrategy('test[T]) = test(downStrategy(T)) .
  eq downStrategy('try[T]) = try(downStrategy(T)) .

  op downCallStrategy : TermList -> CallStrategy .
  eq downCallStrategy('_`[`[_`]`][T, T']) = downQid(T) [[ downTerm(T') ]] .

  op downUsingPairSet : TermList -> UsingPairSet .
  eq downUsingPairSet('_`,_[TL]) = downUsingPairSet(TL) .
 ceq downUsingPairSet((TL, TL'))
    = (downUsingPairSet(TL), downUsingPairSet(TL'))
    if TL =/= empty /\ TL' =/= empty .
  eq downUsingPairSet('_using_[T, T']) = downQid(T) using downStrategy(T') .

  op downSubstitution : TermList -> Substitution .
  eq downSubstitution('none.Substitution) = none .
  eq downSubstitution('_;_[T, T']) = downSubstitution(T) ; downSubstitution(T') .
 ceq downSubstitution((TL, TL'))
    = (downSubstitution(TL) ; downSubstitution(TL'))
    if TL =/= empty /\ TL' =/= empty .
  eq downSubstitution('_<-_[T, T']) = downQid(T) <- downTerm(T') .
endfm
